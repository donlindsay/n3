* startup

#+startup:  overview hideblocks

** drawers

#+drawer:   hidden state properties owl2-rdfs org-n3 n3

** tags 

#+tags:     { @file @buffer @window @frame } 
#+tags:     { @doc @src @lob } 
#+tags:     { @import @export @org-n3 }
#+tags:     org elisp n3 owl2 rdfs prolog lisp shell axiom

** header-args

#+property: header-args         :export results
#+property: header-args:org-n3  :session *org-n3*

** properties 
   :properties:
   :see-also org-property-allowed-value-functions
   :end:

*** TODO do i want a #+property: list of all owl2 and rdfs? 
    
**** or elisp via org-global-properties

     "List of property/value pairs that can be inherited by any entry.
     This list will be combined with the constant
     `org-global-properties-fixed'.  The entries in this list are cons
     cells where the car is a property name and cdr is a string with the
     value."
 
**** org-global-properties format

   '(("org-n3-triple-part" . "subject predicate object"))

   it might make sense to make a separate file for holding the list
   since it might be somewhat long and can be imported.

   a related question is if i want to define all the owl2 and rdfs as
   tags.

   this may be where drawers will be appropriate as they are easily
   handled, are custom definable, and have good code support.

   also, the syntax of drawers is similar to n3 syntax, making the
   production of n3 strings easier, if, for instance, i want to do
   string replacement and filtering functions, or want to do things
   with agenda and column views

#+BEGIN_EXAMPLE owl2-rdfs property drawer
  :owl2-rdfs:
  :doc-string "owl2 and rdfs markup element drawer"
  :type drawer
  :end:
#+END_EXAMPLE

#+property: org-n3_all          org-n3-rdfs-type

#+property: org-n3+             org-n3-predicate
#+property: org-n3-predicate    rdfs-type

**** or elisp via org-file-properties
   
     "You can set buffer-local values for the same purpose in the variable
     `org-file-properties' this by adding lines like
   
     #+PROPERTY: NAME VALUE"


** calls 
  
   "#+call [<inside header arguments>] (<arguments>) <end header arguments>"

#+call: org-n3-imenu-add-to-menubar
#+call: org-n3-button-panel
#+call: org-n3-ac-predictive
#+CALL: factorial(n=5)
#+CALL: factorial[:session special](n=5)
#+CALL: org-n3-todo-keywords (<arguments>)


* functions
** org-n3-org-ac
#+name: org-n3-org-ac
#+BEGIN_SRC emacs-lisp
  (defun org-n3-ac-predictive ()
    "Enable org-ac and predictive mode. Warning: resource intensive."
    (interactive)
    (progn
      (predictive-mode)             
      (org-ac/setup-current-buffer))
    )
#+END_SRC

** org-n3-todo
#+name:     org-n3-todo-keywords
#+headers:  :var data1=1
#+begin_src emacs-lisp          :var data2=2
(progn 
;; buttonize
(org-babel-execute-src-block)

(setq org-todo-keywords
       '((sequence "TODO" "|" "DONE")
         (sequence "REPORT" "BUG" "KNOWNCAUSE" "|" "FIXED")
         (sequence "|" "CANCELED")))

(message "data1:%S, data2:%S" data1 data2))
#+end_src
#+results:
: data1:1, data2:2

#+name: named-block
#+header: :var data=2
#+begin_src emacs-lisp
(message "data:%S" data)
#+end_src
#+results: named-block
: data:2

** org-n3-button-panel
   :properties:
   :doc-string  "A panel window with a set of custom buttons for common tasks."
   :import      buffer-buttons.el
   :end:

   Buffer buttons placed at the bottom or top of this file. So that
   they can be used in a two window frame, when the buttons are ready,
   code the frame window geometry setup. See buffer-buttons.el for more.

   Another feature is inline buttons for source blocks. Buttons
   provide quick access to executions and editing functions. Source
   blocks, like repls, with buttons.

*** org-n3-button-definitions
#+name: org-n3-button-definitions
#+BEGIN_SRC emacs-lisp
  ; eval-last-sexp
  (define-buffer-button (elisp-eval b
                                    :label "<- Eval"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (eval-last-sexp nil)))
  ; org-edit-src-code
  (define-buffer-button (elisp-eval b
                                    :label "Edit Src"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (org-edit-src-code nil)))
  ; org-execute-source-block
  (define-buffer-button (elisp-eval b
                                    :label "Exec Src"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (org-execute-source-block nil)))
#+end_src

***  define the buttons in source blocks

** org-n3-yas 
#+name: yasnippet-functions
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
                      (lambda ()
                        (org-set-local 'yas/trigger-key [tab])
                        (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
  


 (add-hook 'org-mode-hook
                      (lambda ()
                        (make-variable-buffer-local 'yas/trigger-key)
                        (setq yas/trigger-key [tab])
                        (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                        (define-key yas/keymap [tab]
                      'yas/next-field)))

(defun yas/org-very-safe-expand ()
              (let ((yas/fallback-behavior 'return-nil))
              (yas/expand)))

#+END_SRC
** org-n3-imenu
** org-n3-predictive-mode
** org-n3-lob-ingest
 :properties:
 :org-n3-lob-file ~/src/lisp/org-n3/org-n3-library-of-babel.org
 :end:

#+name: org-n3-lob-ingest
#+BEGIN_SRC emacs-lisp
; (org-babel-lob-ingest)

#+END_SRC


* tasks
** determine the significance of (:how) (:what) and (seq (:how :much))
** TODO do i want a #+property: list of all owl2 and rdfs? 

#+property: org-n3_all          org-n3-rdfs-type
#+property: org-n3+             org-n3-predicate
#+property: org-n3-predicate    rdfs-type

*** drawers
#+drawer:   hidden state

** TODO edit for org-n3-lob-file
*** utilities							      :shell:
**** raptor							 :rdf:parser:
***** TODO define functions to run rapper
****** this is a start
#+NAME: raptor
#+BEGIN_SRC sh :var filename=(buffer-file-name) :exports both
       rapper -i turtle -o ntriples $filename
#+END_SRC
***** man raptor
****** Raptor RDF Syntax Library - Raptor RDF parser utility	 :rdf:raptor:
******* NAME
       	rapper − Raptor RDF parsing and serializing utility

******* SYNOPSIS
       	rapper [OPTIONS] INPUT-URI [INPUT-BASE-URI]

******* EXAMPLE
       	rapper -o ntriples http://planetrdf.com/guide/rss.rdf
       	rapper -i rss-tag-soup -o rss-1.0 pile-of-rss.xml
	     http://example.org/base/ 
       	rapper --count http://example.org/index.rdf

******* DESCRIPTION
       	The rapper utility allows parsing of RDF content by the
       	Raptor RDF parser toolkit emitting the results as RDF
       	triples in a choice of syntaxes. The INPUT-URI can be a
       	file name, ’-’ for standard input or if Raptor is built
       	with a WWW retrieval library, a general URI. The optional
       	INPUT-BASE-URI is used as the document parser base URI if
       	present otherwise defaults to the INPUT-URI. A value of
       	’-’ means no base URI.

******* OPTIONS
       	rapper uses the usual GNU command line syntax, with long
       	options starting with two dashes (’-’) if supported by
       	the getopt_long function. Otherwise the short options are
       	only available.

       	−h, −−help

       	Show a summary of the options.

       	−i, −−input FORMAT

       	Set the input FORMAT to one of ’rdfxml’ (RDF/XML,
       	default), ’ntriples’ (N-Triples, see below), ’turtle’
       	(Turtle, see below) or ’rss-tag-soup’ (RSS Tag Soup). The
       	RSS Tag Soup parser can turn the many XML RSS formats and
       	Atom 0.3 into RDF triples.

       	The list of parsers depends on how libraptor(3) was
       	built. The list of supported parsers is given in the help
       	summary given by −h.

       	−I, −−input-uri URI

       	Set the input/parser base URI or use value ’-’ for no
       	base. The default is the INPUT-URI argument value.

       	−o, −−output FORMAT

       	Set the output FORMAT to ’ntriples’ (N-Triples, default),
       	’rdfxml’ (RDF/XML), ’rdfxml-abbrev’ (RDF/XML with
       	abbreviations) or ’rss-1.0’ (RSS 1.0, also an RDF/XML
       	syntax).

       	The list of serializers depends on how libraptor(3) was
       	built. The list of supported serializers is given in the
       	help summary given by −h.

       	−O, −−output-uri URI

       	Set the output/serializer base URI or use value ’-’ for
       	no base. The default is the input base uri, either set by
       	the argument INPUT-BASE-URI or via options −I,
       	−−input-uri URI

       	−c, −−count

       	Only count the triples and produce no other output.

       	−e, −−ignore-errors

       	Ignore errors, do not emit the messages and try to
       	continue parsing.

       	−f, −−feature FEATURE[=VALUE]

       	Set a parser or serializer feature FEATURE to a value, or
       	to 1 if VALUE is omitted, Use −f help to get lists of
       	valid parser and serializer features.

       	If the form −f ’xmlns:prefix="uri"’ is used, the prefix
       	and namespace uri given will be set for serializing. The
       	syntax matches XML in that either or both of prefix or
       	uri can be omitted.

       	−g, −−guess

       	Guess the parser to use from the source-URI rather than
       	use the −i FORMAT.

       	−q, −−quiet

       	No extra information messages.

       	−r, −−replace-newlines

       	Replace newlines in multi-line literals with spaces.

       	−−show-graphs

       	Print graph names (URIs) as they are seen in the input. This only has
       	a meaning for parsers that support graph names such as the TRiG
       	parser.

       	−−show-namespaces

       	Print namespaces as they are seen in the input.

       	−t, −−trace

       	Print URIs retrieved during parsing. Especially useful
       	for monitoring what the guess and GRDDL parsers are
       	doing.

       	−w, −−ignore-warnings

       	Ignore warnings, do not emit the messages.

       	−v, −−version

       	Print the raptor version and exit.  

******* EXAMPLES

       	rapper -q -i ntriples -o rdfxml 
       	-f ’xmlns:rss="http://purl.org/rss/1.0/"’ 
       	-f ’xmlns:ex="http://example.org/"’ 
       	   tests/test.nt

       	rapper -q -o rdfxml 
       	-f ’xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"’ 
       	   tests/rdf-schema.rdf 
       	   ’http://www.w3.org/2000/01/rdf-schema#’

******* Examples
     rapper -q -i ntriples -o rdfxml 
	    -f ’xmlns:rss="http://purl.org/rss/1.0/"’
	    -f ’xmlns:ex="http://example.org/"’ tests/test.nt

     rapper -q -o rdfxml 
	    -f ’xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"’ tests/rdf-schema.rdf 
	       ’http://www.w3.org/2000/01/rdf-schema#’

#+begin_src elisp
(defun rapper)
(interactive)
(shell-command rapper)
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
**** ebnf2ps							   :meta:rdf:
       	 `ebnf'	ebnf2ps recognizes the syntax described in ebnf2ps
   		   documentation.
   		   The following variables *ONLY* have effect with this
   		   setting:
   		   `ebnf-terminal-regexp', `ebnf-case-fold-search',
   		   `ebnf-lex-comment-char' and `ebnf-lex-eop-char'.
      
       	 `abnf'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.ietf.org/rfc/rfc2234.txt'
   		   ("Augmented BNF for Syntax Specifications: ABNF").
      
       	 `iso-ebnf'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html'
   		   ("International Standard of the ISO EBNF Notation").
   		   The following variables *ONLY* have effect with this
   		   setting:
   		   `ebnf-iso-alternative-p' and `ebnf-iso-normalize-p'.
      
       	 `yacc'	ebnf2ps recognizes the Yacc/Bison syntax.
   		   The following variable *ONLY* has effect with this
   		   setting:
   		   `ebnf-yac-ignore-error-recovery'.
      
       	 `ebnfx'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.w3.org/TR/2004/REC-xml-20040204/#sec-notation'
   		   ("Extensible Markup Language (XML) 1.0 (Third Edition)")
      
       	 `dtd'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.w3.org/TR/2004/REC-xml-20040204/'
   		   ("Extensible Markup Language (XML) 1.0 (Third Edition)")
      
      Any other value is treated as `ebnf'.
**** bnf2xml							:ebnf:parser:
#+begin_src elisp
(defun bnf2xml)
(interactive)
(on-region (shell-command bnf2xml))
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
***** BNF parser:
	recursively does lookups from L to R
	that stops (returns) if terminals are found.
	for each LHS item
	1) search for each RHS, or failing that, ...
	2) try to match it (a terminal) against input
	If all LHS items on a line finally get matched to terminals: done.

LHS : RHS
<a> : <b>
<b> : <c> <b>
<b> : <d> <b>
<d> : <e>

	Any RHS with no LHS in a bnf table is terminal.
	c and d are terminal (no c and d on LHS)
	d isn't ever found so e is questionable

What that does is group how terminals are matched, and so one can,
with a full bnf file, have a language specified (ie, C) is one use.


===============================
this was the initial design
before functions were 
#+begin_src language

#+end_src
hardly writen yet
===============================


	this implementation was mostly written in early to early '90s when you
	couldn't hardly find / download such things (before XML, mid-90's)
	development was halted by 1) college  2) health emergencies 3) money
	too bad.  not that xml isn't nice.

	This parser byte compiles (makes op codes) of the BNF table.
	It's a multi-line table.  NOTE: input string is seen as flat
	there's no "lines of input of file" - none

					// ---- BnfSym ----
	WHAT IS last ?  		// LogLHS uses it to tell FindRHS "fake logical match
					// ignore / don't do any action (record, pop, any)
	word4symbol, symbol4word	// dictionary lookup / uncrack op code table
	SVec3 ssBNFv3 ; 		// BNF text file v3{string, line, word in line}
	DVec1<long, uint> slRHSv1 ;	// RHS symbols for a line (after byte compiles bnf table)
	SVec2 ssTRMv2 ; 		// list of terminal strings (last symbol+1 = termbase, 
					// ssTRMv2[symb-termbase]=terminal string)
					// (for indexing each input char to bnf terminal char table)
	DVec2<long, uint> slLHSv2 ; 	// LHS symbols for a line
					// ---- Parse ----
        // all four pushed after each successful search
	// and _found (ones pushed in search) is remarked depending on ret_val
        DVec1<long, uint> lresv1_found ; // T/F per group
        DVec1<long, uint> lresv1_found_item ; // T/F  per item
	DVec1<long, uint> lresv1_rec_lvl ; // how deep
					// so print can know if repeat push due to recursive search
					// no of the other pushes can be used to show repeasts
					// possible to not push if not necessary?  but using logic for when
					// to push removes what happened (if you did want to trace failed
	// matches) and could get complicated
        DVec1<long, uint> lresv1_line ;  // current atline of
        DVec1<long, uint> lresv1_n ;     // n of line[n] == symb if any
        DVec1<long, uint> lresv1_symb ;  // symbol if any

		// these support a "quick find" only of top of search
		// and report is only input and line # really
	DVec1<long, uint> slResV1 ;	// Results vec, pushed, List of symbols for input.
	DVec1<long, uint> slSymbLineV1 ; // list of lines numbers matched, pushed
	DVec1<long, uint> slSymbV1 ;	// Index for ea. symbol in ssTRMv2 for input.
					// A convenience since option based.
					// list made just before exit by listing slResV1

	SVec2 ssStrV2 ;			// List of matched words in input from BNF file
					// (no caps for common, etc).
					// list made just before exit by listing slResV1
					// ---- Program codes for matches ----
	DVec1<long, uint> slMapedTrmV1 ; // prog id for terminal strings
					// ss, "str / str" table
					// sl, "str / long" (string / number)
					// (has nothing to do with parsing)


    ret_val  is 0 False no !retval, 1 true yes ret_val
            (unsigned int) -1 is a special yes check for in one place


	"this is a FIRST LEVEL parse; this rule file can (in turn)
	 define more complicated rule files which can then in
	 turn be used to parse more complicated files"

		Sat Jul  2 21:50:26 EDT 2011

	HOW?? (took me an hour to remmeber)
		* each parsed input can be a new bnf line
		  (instead of getting input from FileArr, recycled)
		* after being parsed it needs end up being
		  the form this parser reads (basic bnf)
	INTERNALS
		* FileArr(filename)->BnfSym(file)->BnfParse(txt)->FindRHS(txt, syms)
			c++ Parse:BnfParse:BnfSym:FileArr
		* BnfSym has no specification of what terminals are
		  any RHS with no LHS is mapped as 'terminal'
		* the built in terminators {=,<,>,\t,:,|, ,',"} seem limiting
		  on a 1st parse but if bnf is recyled they are the target format
		  (are muted, bnf terminators used to read final input).
		* but what IS limiting is built-in operators (&,|,=,~)
		  These reduce size of final RHS LHS table provide search rules.
		  A 2nd level bnf can combine ot act like new ones.
			  * I'm unsure if that has the same cost.
	WHAT IS VARIABLE 'last' ?
		LogLHS uses it to tell FindRHS "fake logical match - ignore"
		LogLHS -> MatchLHS -> FindRHS (which must know it's fake)

orig. bnf features
	& is implied always by bnf form and
		<ab> : <a> <b>
	bnf parser can list recursive matches (a recursive searcher)
		<white> : <whitechar> <white>

3 enhacements, meant to be strong yet still basic

	1) | logical search operator - for tech. reasons

	2) ==  is for simpler callers to limit matching to a dictionary
	   (otherwise a simple caller couldn't read report: too comlicated)
	   (also a bnf shortcut: "find these [terminal] or quit")
		with <repl> and <sys> (see features)

	3) 3 REPORT : 
		a) simple reflection of input matched
		b) a quick report showing top line, symbols, and words
		   matched (highest line fully matched)
		   NOTE: based on report a, not report c
		c) extended report dump of all non-failed searches
		   trace what you need

	FindRHS can be invoke to begin at whatever line for which symb.

todo, if ever: search enhancements

	ex. to specify groups <being> <end> that "fail one skip the rest of group"
	search enhancements, operators, anything to reduce table, extend searching,
	or reduce needless searching smartly / by standards

	support for OPS was added later and (I hope) is completely
	separable from the basic code (don't use them in bnf
	and the more complex yet separate code is never used)

*/
/*
	TODOS
		* simple reflexion requires more though to print
			<w> : <wc> <w> 
			<w> : w <wc> <w> /w /w
			-->	W " " W " " /W /W
			<a> <a> <b> is inf rec
		* the fact that ie, 9 30 W 9 30 W repeated pushes
			likely means something (ie, logLHS last 0)
			maybe never needs to push or pop
				though easily skipped

	// Sat Oct 13 17:05:58 EDT 2012

	// printing results better...

	two basic ways:

		 1)  some complicated way that pushes only "wanted info"
		*2)  push all that didn't fail, extra data, and you can
		    trace into what you want l8tr

    done
*/


===============================
this was the initial design
before functions were 
hardly writen yet
===============================

/*
Report generation for parser:
	Lvec2 ComTab () const ;
	Svec2 ComStr () const ;
ex. "look at room"
ComTab:
	3			10		9		4			8
	3			200		300		400			500
ComSym:
	<com>		<verb>	<prep>	<article>	<noun>
	command		look	at		the			room
*/

// ------------------------------------------------------------------------
/*
Contents of Symbol table:

	- The recursive algorithm only needs unique symbols
	in place of long form, thus:
		char *strtok( char *string1, const char *string2 );
	can be (is) used to identify tokens to symbolize.

	- Symbols have to express whether their token is terminal (T/F &mask).

	- The table must contain references to use to match tokens
	(note that most terminals are not characters).
*/
// ------------------------------------------------------------------------
/*

**	Note that the below ignores the difficulty in actually providing the 
correct solution when substitution, identity, and other such features exist.
	Symbols for partial matches musted be pushed as found and poped
if a full statement can't be matched.  Some statements will not need to be
matched.  Complete information on all previous operations would be 
hard to maintain and hard to analyze.
	The sol. is notated somewhat in the source code.  A parameter is used
to keep track of whether the current frame is a frame which will cause all
of the input to be matched.  Frames which aren't responsible in this manner
do not cause the solutions stack to be poped.

1. find a matching RHS element (noting first is on line 0)
1. STARTS on same line as LHS
1.1R if exits
	2 determin lhs elements
	2.1 if <>== found, do 2.2 else 3.1
	2.2 * matches aggregates to pre-defined terminals
		1. feed <> to rhs MUST return 1 (or return char *)
			if ( !(FindRHS(match, atline)) ) // note: we don't want atline changed now...
		2. match <> to terminal and return result
		3. lhs should be listed to rhs
		3.1 if () found: () here groups logics
			- start from inner most () (& recurse ?)
		3.2 first | found
			- feed left and right to this function return |
		* this is where to add other logicals
		3.3 feed remaining to rhs, return with && logic
			a. if T return T
			b. if symlst () (the set?) F, match terminal(s)
				1. match downward only
				2. match () RHS
				3. ' ','\t','\r','\n' are term separators, ret T?
				4. if F and ! end line, keep checking
1.2E if not exits LHS item was terminal, ret T
*/
// ------------------------------------------------------------------------


// ------------------------------------------------------------------------
/*
	Notes in source specify a difference from the process below.
	The aim of the notes is to define avail. syntax
*/
/*
1. find a matching RHS element (noting first is on line 0)
1. STARTS on same line as LHS
1.1R if exits
	2 determin lhs elements
	2.1 if <>== found, do 2.2 else 3.1
	2.2 * matches aggregates to pre-defined terminals
		1. feed <> to rhs MUST return 1 (or return char *)
			if ( !(FindRHS(match, atline)) ) // note: we don't want atline changed now...
		2. match <> to terminal and return result
		3. lhs should be listed to rhs
		3.1 if () found: () here groups logics
		() never found in first level parse - see PROC: list symbols
		3.2 an | found
			- feed left and right to this function return |
		* this is where to add other logicals
		3.3 feed remaining to rhs, return with && logic
			a. if T return T
			b. if symlst () (the set?) F, match terminal(s)
				1. match downward only
				2. match () RHS
				3. r','\n' are term separators, ret T?
				4. if F and ! end line, keep checking
1.2E if not exits LHS item was terminal, ret T

  PROC: list symbols:
	- use start, end idecies
	- =
		(if symb exits after =)
		AndLhs(st, end(OP=)) || AndLhs(OP=+1, end)
	- |
		do
		find end
		AndLhs(st, end(OP|))
		st = OP+1 end = st
		until finished
		| return logic
	- ~ not
		same as | except !(...) in symbol table 
		is in form ~...~ 
	- &
		do
		AndLhs(st) to findrhs
		++st 
		until st==end
		& return logic
*/
// ------------------------------------------------------------------------
/*
Table Build Format:
	note that: 6|>5rhs and 8t>5rhs; 
				1|2= allows term determination: (!RHS>lhs)
start	guess		guess			finish
rlll	1 2|143		1 26143			3 4165		
rlllll	2 23|342	2 236342		4 451564
rllll	3 4=s|s+s	3 47868??		5 6218
rltt	4 tttt		4 9??			6 9
rttt	5 t		5 (10)			7 (10...)

NOTE: 8,9,>10 are terminal that are stored for matching
PROCESS: rhs and lhs are stored seperately
	rhs is a 1 to ... count
	lhs is the same - but terminals must have a symbol
		differing from bnf identifiers - so they have a 
		number higher than any of those...
	termbase is the lowest non bnf identifier in table
	termstr[lhs[i]-termbase] is a terminal to match

Q: sym for ea. term in rhs or one for ea. rhs ?
A: 1 uniq. for ea. + lookup allows efficient storage...
	   --> AND easy lookup

OOPS: or (|) begins at 1 - 0 will be the unassigned constant

ANTIQUITY:
	- no assignment for operators; they are assumed first (1,2,...)
	- this is a FIRST LEVEL parse; this rule file can (in turn)
    define more complicated rule files which can then in
	turn be used to parse more complicated files
*/	
// ------------------------------------------------------------------------



***** bnf2xml
FEATURES:
	fully reflexive (don't need *, automatic)
	OR, AND, == (bnf bnf a maybe, see below)

	REPLACE / DO something hack , 2 ways to match
		form   <a> : <repl> "" ""
		repl <a_r> : <foo> "" ""
			if <a> take parallel <a_r>
			replaces in output: REPORT c (not report a or b)
			does not change input
		form   <a> : <subst> "" ""
		repl <a_s> : <foo> "" ""
			if <a> take parallel <a_r>
			replace input during search
			restars search on that line and continues
			downward (do not start at line 0)
			replaces in all REPORT a,b,c
		form   <a> : <sys> "" ""
		repl <a_S> : <foo> "" ""
			if <a> system(<a_r>)
		NOTES:
		* lines must be one after the other, _r is
		  actuall <a_foo> (use positionally)
		* #define SYS_FOO_PRINTONLY is default
		* Note input subst remains once done, so
		  plan ahead not to depend on whether the
		  line where <a> is found wholey matches)
TODOS
	this looks easiest, or getop if must
		cat opts bnf1 bnf2 | parse

	input is one line only (can't parse input file)

	cannot yet use input to use 1st bnf to read in a 2nd bnf
		which would then read input
		point being to allow varied bnf syntax support

	output is not very useable yet but mostly complete

	WARNING: having read Ale I guaruntee the naming is confusing
	and not good enough.  see parse.discussion about many parsers /
	analyzers
**** rdf2rdf							 :rdf:parser:
#+begin_src elisp
(defun rdf2rdf)
(interactive)
(shell-command bnf2xml)
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
**** rdf.sh (perl)						   :rdf:perl:
#+begin_src elisp
(defun rdf.sh)
(interactive)
(shell-command rdf.sh)
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
#+begin_src turtle
<http://sebastian.tramp.name/Projects/rdf.sh> a :Project;
    <http://purl.org/dc/terms/updated> "2013-05-05T17:52:26Z"^^xsd:dateTime;
         :description "A multi-tool shell script for doing Semantic Web jobs on the command line.";
         :developer <http://sebastian.tramp.name>;
         :download-page <https://github.com/seebi/rdf.sh/archives/master>;
         :homepage <https://github.com/seebi/rdf.sh/>;
         :programming-language "Shell";
         :name "rdf.sh".
#+end_src
**** pellet.sh
     file:///home/xk05/apps/pellet-2.3.1


*** exclusive-or
#+name: exclusive-or
#+begin_src emacs-lisp
       (defun org-xor (a b)
          "Exclusive or."
          (if a (not b) b))
#+end_src

*** XPath							     :rdf:fn:

    [Definition: XPath operates on the abstract, logical structure of an
    XML document, rather than its surface syntax. This logical
    structure, known as the data model, is defined in [XQuery 1.0 and
    XPath 2.0 Data Model (Second Edition)].]

    XPath is designed to be embedded in a host language such as [XSL
    Transformations (XSLT) Version 2.0 (Second Edition)] or [XQuery 1.0:
    An XML Query Language (Second Edition)]. XPath has a natural subset
    that can be used for matching (testing whether or not a node matches
    a pattern); this use of XPath is described in [XSL Transformations
    (XSLT) Version 2.0 (Second Edition)].

    XQuery Version 1.0 is an extension of XPath Version 2.0. Any
    expression that is syntactically valid and executes successfully in
    both XPath 2.0 and XQuery 1.0 will return the same result in both
    languages. Since these languages are so closely related, their
    grammars and language descriptions are generated from a common
    source to ensure consistency, and the editors of these
    specifications work together closely.

**** IRI is an extention of URI.					:rdf:
  URI is still used in documentation for backward compatibility
  with the larger corpus of specifications.

[Definition: Within this specification, the term
URI refers to a Universal Resource Identifier as
defined in [RFC3986] and extended in [RFC3987]
with the new name IRI.] The term URI has been
retained in preference to IRI to avoid introducing
new names for concepts such as "Base URI" that are
defined or referenced across the whole family of
XML specifications.



[Definition: Statically known documents. This is a
mapping from strings onto types. The string
represents the absolute URI of a resource that is
potentially available using the fn:doc
function. The type is the static type of a call to
fn:doc with the given URI as its literal
argument. ] If the argument to fn:doc is a string
literal that is not present in statically known
documents, then the static type of fn:doc is
document-node()?.

Note:

The purpose of the statically known documents is
to provide static type information, not to
determine which documents are available. A URI
need not be found in the statically known
documents to be accessed using fn:doc.

**** xmlpatterns -- A tool for running XQuery queries.			:rdf:

     -                          When appearing, any following options are not 
			       	interpreted as switches.
     -help                      Displays this help.
     -initial-template <string> The name of the initial template to call as a 
			       	Clark Name.
     -is-uri                    If specified, all filenames on the command line 
			       	are interpreted as URIs instead of a local
			       	filenames.
     -no-format                 By default output is formatted for readability. 
			       	When specified, strict serialization is
			       	performed.
     -output <local file>       A local file to which the output should be 
			       	written. The file is overwritten, or if not
			       	exist, created. If absent, stdout is used.
     -param <name=value>        Binds an external variable. The value is 
			       	directly available using the variable
			       	reference: $name.
     -version                   Displays version information.
     focus <string>             The document to use as focus. Mandatory in case 
			       	a stylesheet is used. This option is also
			       	affected by the is-uris option.
     query/stylesheet <string>  A local filename pointing to the query to run. 
			       	If the name ends with .xsl it's assumed to be
			       	an XSL-T stylesheet. If it ends with .xq, it's
			       	assumed to be an XQuery query. (In other cases
			       	it's also assumed to be an XQuery query, but
			       	that interpretation may change in a future
			       	release of Qt.)

**** XPath is defined 
     in terms of the data model and the expression context.
**** XPath defines						  :rdf:debug:
     two phases of processing called the static
     analysis phase and the dynamic evaluation phase
***** thus
      (((data-model) (expression-context)) 
      (xpath) 
      ((static-analysis-phase) (dynamic-evalution-phase)))
**** rdf							  :rdf:debug:
**** owl							    :rdf:owl:
***** owl2 in triples						    :rdf:owl:
****** DONE load these triples into the ts triple-store
****** Annotations

       "... the OWL 2 RDF-Based Semantics includes many semantic
       conditions that can in a sense be regarded as being
       "axiomatic", and thus can be considered a replacement for
       the missing axiomatic triples."
       [[file:///usr/share/doc/w3-recs/html/www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/index.html#Appendix:_Axiomatic_Triples_.28Informative.29]]

****** owl2 in turtle

owl:AllDifferent rdf:type rdfs:Class .

owl:AllDifferent rdfs:subClassOf rdfs:Resource .

owl:AllDisjointClasses rdf:type rdfs:Class .

owl:AllDisjointClasses rdfs:subClassOf rdfs:Resource .

owl:AllDisjointProperties rdf:type rdfs:Class .

owl:AllDisjointProperties rdfs:subClassOf rdfs:Resource .

owl:Annotation rdf:type rdfs:Class .

owl:Annotation rdfs:subClassOf rdfs:Resource .

owl:AnnotationProperty rdf:type rdfs:Class .

owl:AnnotationProperty rdfs:subClassOf rdf:Property .

owl:AsymmetricProperty rdf:type rdfs:Class .

owl:AsymmetricProperty rdfs:subClassOf owl:ObjectProperty .

owl:Axiom rdf:type rdfs:Class .

owl:Axiom rdfs:subClassOf rdfs:Resource .

owl:Class rdf:type rdfs:Class .

owl:Class rdfs:subClassOf rdfs:Class .

owl:DataRange rdf:type rdfs:Class .

owl:DataRange rdfs:subClassOf rdfs:Datatype .

owl:DatatypeProperty rdf:type rdfs:Class .

owl:DatatypeProperty rdfs:subClassOf rdf:Property .

owl:DeprecatedClass rdf:type rdfs:Class .

owl:DeprecatedClass rdfs:subClassOf rdfs:Class .

owl:DeprecatedProperty rdf:type rdfs:Class .

owl:DeprecatedProperty rdfs:subClassOf rdf:Property .

owl:FunctionalProperty rdf:type rdfs:Class .

owl:FunctionalProperty rdfs:subClassOf rdf:Property .

owl:InverseFunctionalProperty rdf:type rdfs:Class .

owl:InverseFunctionalProperty rdfs:subClassOf owl:ObjectProperty .

owl:IrreflexiveProperty rdf:type rdfs:Class .

owl:IrreflexiveProperty rdfs:subClassOf owl:ObjectProperty .

owl:NamedIndividual rdf:type rdfs:Class .

owl:NamedIndividual rdfs:subClassOf owl:Thing .

owl:NegativePropertyAssertion rdf:type rdfs:Class .

owl:NegativePropertyAssertion rdfs:subClassOf rdfs:Resource .

owl:Nothing rdf:type owl:Class .

owl:Nothing rdfs:subClassOf owl:Thing .

owl:ObjectProperty rdf:type rdfs:Class .

owl:ObjectProperty rdfs:subClassOf rdf:Property .

owl:Ontology rdf:type rdfs:Class .

owl:Ontology rdfs:subClassOf rdfs:Resource .

owl:OntologyProperty rdf:type rdfs:Class .

owl:OntologyProperty rdfs:subClassOf rdf:Property .

owl:ReflexiveProperty rdf:type rdfs:Class .

owl:ReflexiveProperty rdfs:subClassOf owl:ObjectProperty .

owl:Restriction rdf:type rdfs:Class .

owl:Restriction rdfs:subClassOf owl:Class .

owl:SymmetricProperty rdf:type rdfs:Class .

owl:SymmetricProperty rdfs:subClassOf owl:ObjectProperty .

owl:Thing rdf:type owl:Class .

owl:TransitiveProperty rdf:type rdfs:Class .

owl:TransitiveProperty rdfs:subClassOf owl:ObjectProperty .

******* Axiomatic Triples for the Properties

owl:allValuesFrom rdf:type rdf:Property .

owl:allValuesFrom rdfs:domain owl:Restriction .

owl:allValuesFrom rdfs:range rdfs:Class .

owl:annotatedProperty rdf:type rdf:Property .

owl:annotatedProperty rdfs:domain rdfs:Resource .

owl:annotatedProperty rdfs:range rdfs:Resource .

owl:annotatedSource rdf:type rdf:Property .

owl:annotatedSource rdfs:domain rdfs:Resource .

owl:annotatedSource rdfs:range rdfs:Resource .

owl:annotatedTarget rdf:type rdf:Property .

owl:annotatedTarget rdfs:domain rdfs:Resource .

owl:annotatedTarget rdfs:range rdfs:Resource .

owl:assertionProperty rdf:type rdf:Property .

owl:assertionProperty rdfs:domain owl:NegativePropertyAssertion .

owl:assertionProperty rdfs:range rdf:Property .

owl:backwardCompatibleWith rdf:type owl:AnnotationProperty .

owl:backwardCompatibleWith rdf:type owl:OntologyProperty .

owl:backwardCompatibleWith rdfs:domain owl:Ontology .

owl:backwardCompatibleWith rdfs:range owl:Ontology .

owl:bottomDataProperty rdf:type owl:DatatypeProperty .

owl:bottomDataProperty rdfs:domain owl:Thing .

owl:bottomDataProperty rdfs:range rdfs:Literal .

owl:bottomObjectProperty rdf:type owl:ObjectProperty .

owl:bottomObjectProperty rdfs:domain owl:Thing .

owl:bottomObjectProperty rdfs:range owl:Thing .

owl:cardinality rdf:type rdf:Property .

owl:cardinality rdfs:domain owl:Restriction .

owl:cardinality rdfs:range xsd:nonNegativeInteger .

owl:complementOf rdf:type rdf:Property .

owl:complementOf rdfs:domain owl:Class .

owl:complementOf rdfs:range owl:Class .

owl:datatypeComplementOf rdf:type rdf:Property .

owl:datatypeComplementOf rdfs:domain rdfs:Datatype .

owl:datatypeComplementOf rdfs:range rdfs:Datatype .

owl:deprecated rdf:type owl:AnnotationProperty .

owl:deprecated rdfs:domain rdfs:Resource .

owl:deprecated rdfs:range rdfs:Resource .

owl:differentFrom rdf:type rdf:Property .

owl:differentFrom rdfs:domain owl:Thing .

owl:differentFrom rdfs:range owl:Thing .

owl:disjointUnionOf rdf:type rdf:Property .

owl:disjointUnionOf rdfs:domain owl:Class .

owl:disjointUnionOf rdfs:range rdf:List .

owl:disjointWith rdf:type rdf:Property .

owl:disjointWith rdfs:domain owl:Class .

owl:disjointWith rdfs:range owl:Class .

owl:distinctMembers rdf:type rdf:Property .

owl:distinctMembers rdfs:domain owl:AllDifferent .

owl:distinctMembers rdfs:range rdf:List .

owl:equivalentClass rdf:type rdf:Property .

owl:equivalentClass rdfs:domain rdfs:Class .

owl:equivalentClass rdfs:range rdfs:Class .

owl:equivalentProperty rdf:type rdf:Property .

owl:equivalentProperty rdfs:domain rdf:Property .

owl:equivalentProperty rdfs:range rdf:Property .

owl:hasKey rdf:type rdf:Property .

owl:hasKey rdfs:domain owl:Class .

owl:hasKey rdfs:range rdf:List .

owl:hasSelf rdf:type rdf:Property .

owl:hasSelf rdfs:domain owl:Restriction .

owl:hasSelf rdfs:range rdfs:Resource .

owl:hasValue rdf:type rdf:Property .

owl:hasValue rdfs:domain owl:Restriction .

owl:hasValue rdfs:range rdfs:Resource .

owl:imports rdf:type owl:OntologyProperty .

owl:imports rdfs:domain owl:Ontology .

owl:imports rdfs:range owl:Ontology .

owl:incompatibleWith rdf:type owl:AnnotationProperty .

owl:incompatibleWith rdf:type owl:OntologyProperty .

owl:incompatibleWith rdfs:domain owl:Ontology .

owl:incompatibleWith rdfs:range owl:Ontology .

owl:intersectionOf rdf:type rdf:Property .

owl:intersectionOf rdfs:domain rdfs:Class .

owl:intersectionOf rdfs:range rdf:List .

owl:inverseOf rdf:type rdf:Property .

owl:inverseOf rdfs:domain owl:ObjectProperty .

owl:inverseOf rdfs:range owl:ObjectProperty .

owl:maxCardinality rdf:type rdf:Property .

owl:maxCardinality rdfs:domain owl:Restriction .

owl:maxCardinality rdfs:range xsd:nonNegativeInteger .

owl:maxQualifiedCardinality rdf:type rdf:Property .

owl:maxQualifiedCardinality rdfs:domain owl:Restriction .

owl:maxQualifiedCardinality rdfs:range xsd:nonNegativeInteger .

owl:members rdf:type rdf:Property .

owl:members rdfs:domain rdfs:Resource .

owl:members rdfs:range rdf:List .

owl:minCardinality rdf:type rdf:Property .

owl:minCardinality rdfs:domain owl:Restriction .

owl:minCardinality rdfs:range xsd:nonNegativeInteger .

owl:minQualifiedCardinality rdf:type rdf:Property .

owl:minQualifiedCardinality rdfs:domain owl:Restriction .

owl:minQualifiedCardinality rdfs:range xsd:nonNegativeInteger .

owl:onClass rdf:type rdf:Property .

owl:onClass rdfs:domain owl:Restriction .

owl:onClass rdfs:range owl:Class .

owl:onDataRange rdf:type rdf:Property .

owl:onDataRange rdfs:domain owl:Restriction .

owl:onDataRange rdfs:range rdfs:Datatype .

owl:onDatatype rdf:type rdf:Property .

owl:onDatatype rdfs:domain rdfs:Datatype .

owl:onDatatype rdfs:range rdfs:Datatype .

owl:oneOf rdf:type rdf:Property .

owl:oneOf rdfs:domain rdfs:Class .

owl:oneOf rdfs:range rdf:List .

owl:onProperty rdf:type rdf:Property .

owl:onProperty rdfs:domain owl:Restriction .

owl:onProperty rdfs:range rdf:Property .

owl:onProperties rdf:type rdf:Property .

owl:onProperties rdfs:domain owl:Restriction .

owl:onProperties rdfs:range rdf:List .

owl:priorVersion rdf:type owl:AnnotationProperty .

owl:priorVersion rdf:type owl:OntologyProperty .

owl:priorVersion rdfs:domain owl:Ontology .

owl:priorVersion rdfs:range owl:Ontology .

owl:propertyChainAxiom rdf:type rdf:Property .

owl:propertyChainAxiom rdfs:domain owl:ObjectProperty .

owl:propertyChainAxiom rdfs:range rdf:List .

owl:propertyDisjointWith rdf:type rdf:Property .

owl:propertyDisjointWith rdfs:domain rdf:Property .

owl:propertyDisjointWith rdfs:range rdf:Property .

owl:qualifiedCardinality rdf:type rdf:Property .

owl:qualifiedCardinality rdfs:domain owl:Restriction .

owl:qualifiedCardinality rdfs:range xsd:nonNegativeInteger .

owl:sameAs rdf:type rdf:Property .

owl:sameAs rdfs:domain owl:Thing .

owl:sameAs rdfs:range owl:Thing .

owl:someValuesFrom rdf:type rdf:Property .

owl:someValuesFrom rdfs:domain owl:Restriction .

owl:someValuesFrom rdfs:range rdfs:Class .

owl:sourceIndividual rdf:type rdf:Property .

owl:sourceIndividual rdfs:domain owl:NegativePropertyAssertion .

owl:sourceIndividual rdfs:range owl:Thing .

owl:targetIndividual rdf:type rdf:Property .

owl:targetIndividual rdfs:domain owl:NegativePropertyAssertion .

owl:targetIndividual rdfs:range owl:Thing .

owl:targetValue rdf:type rdf:Property .

owl:targetValue rdfs:domain owl:NegativePropertyAssertion .

owl:targetValue rdfs:range rdfs:Literal .

owl:topDataProperty rdf:type owl:DatatypeProperty .

owl:topDataProperty rdfs:domain owl:Thing .

owl:topDataProperty rdfs:range rdfs:Literal .

owl:topObjectProperty rdf:type rdf:ObjectProperty .

owl:topObjectProperty rdfs:domain owl:Thing .

owl:topObjectProperty rdfs:range owl:Thing .

owl:unionOf rdf:type rdf:Property .

owl:unionOf rdfs:domain rdfs:Class .

owl:unionOf rdfs:range rdf:List .

owl:versionInfo rdf:type owl:AnnotationProperty .

owl:versionInfo rdfs:domain rdfs:Resource .

owl:versionInfo rdfs:range rdfs:Resource .

owl:versionIRI rdf:type owl:OntologyProperty .

owl:versionIRI rdfs:domain owl:Ontology .

owl:versionIRI rdfs:range owl:Ontology .

owl:withRestrictions rdf:type rdf:Property .

owl:withRestrictions rdfs:domain rdfs:Datatype .

owl:withRestrictions rdfs:range rdf:List .
	
******* Axiomatic Triples for the Datatypes

xsd:anyURI rdf:type rdfs:Datatype .

xsd:anyURI rdfs:subClassOf rdfs:Literal .

xsd:base64Binary rdf:type rdfs:Datatype .

xsd:base64Binary rdfs:subClassOf rdfs:Literal .

xsd:boolean rdf:type rdfs:Datatype .

xsd:boolean rdfs:subClassOf rdfs:Literal .

xsd:byte rdf:type rdfs:Datatype .

xsd:byte rdfs:subClassOf rdfs:Literal .

xsd:dateTime rdf:type rdfs:Datatype .

xsd:dateTime rdfs:subClassOf rdfs:Literal .

xsd:dateTimeStamp rdf:type rdfs:Datatype .

xsd:dateTimeStamp rdfs:subClassOf rdfs:Literal .

xsd:decimal rdf:type rdfs:Datatype .

xsd:decimal rdfs:subClassOf rdfs:Literal .

xsd:double rdf:type rdfs:Datatype .

xsd:double rdfs:subClassOf rdfs:Literal .

xsd:float rdf:type rdfs:Datatype .

xsd:float rdfs:subClassOf rdfs:Literal .

xsd:hexBinary rdf:type rdfs:Datatype .

xsd:hexBinary rdfs:subClassOf rdfs:Literal .

xsd:int rdf:type rdfs:Datatype .

xsd:int rdfs:subClassOf rdfs:Literal .

xsd:integer rdf:type rdfs:Datatype .

xsd:integer rdfs:subClassOf rdfs:Literal .

xsd:language rdf:type rdfs:Datatype .

xsd:language rdfs:subClassOf rdfs:Literal .

xsd:long rdf:type rdfs:Datatype .

xsd:long rdfs:subClassOf rdfs:Literal .

xsd:Name rdf:type rdfs:Datatype .

xsd:Name rdfs:subClassOf rdfs:Literal .

xsd:NCName rdf:type rdfs:Datatype .

xsd:NCName rdfs:subClassOf rdfs:Literal .

xsd:negativeInteger rdf:type rdfs:Datatype .

xsd:negativeInteger rdfs:subClassOf rdfs:Literal .

xsd:NMTOKEN rdf:type rdfs:Datatype .

xsd:NMTOKEN rdfs:subClassOf rdfs:Literal .

xsd:nonNegativeInteger rdf:type rdfs:Datatype .

xsd:nonNegativeInteger rdfs:subClassOf rdfs:Literal .

xsd:nonPositiveInteger rdf:type rdfs:Datatype .

xsd:nonPositiveInteger rdfs:subClassOf rdfs:Literal .

xsd:normalizedString rdf:type rdfs:Datatype .

xsd:normalizedString rdfs:subClassOf rdfs:Literal .

rdf:PlainLiteral rdf:type rdfs:Datatype .

rdf:PlainLiteral rdfs:subClassOf rdfs:Literal .

xsd:positiveInteger rdf:type rdfs:Datatype .

xsd:positiveInteger rdfs:subClassOf rdfs:Literal .

owl:rational rdf:type rdfs:Datatype .

owl:rational rdfs:subClassOf rdfs:Literal .

owl:real rdf:type rdfs:Datatype .

owl:real rdfs:subClassOf rdfs:Literal .

xsd:short rdf:type rdfs:Datatype .

xsd:short rdfs:subClassOf rdfs:Literal .

xsd:string rdf:type rdfs:Datatype .

xsd:string rdfs:subClassOf rdfs:Literal .

xsd:token rdf:type rdfs:Datatype .

xsd:token rdfs:subClassOf rdfs:Literal .

xsd:unsignedByte rdf:type rdfs:Datatype .

xsd:unsignedByte rdfs:subClassOf rdfs:Literal .

xsd:unsignedInt rdf:type rdfs:Datatype .

xsd:unsignedInt rdfs:subClassOf rdfs:Literal .

xsd:unsignedLong rdf:type rdfs:Datatype .

xsd:unsignedLong rdfs:subClassOf rdfs:Literal .

xsd:unsignedShort rdf:type rdfs:Datatype .

xsd:unsignedShort rdfs:subClassOf rdfs:Literal .

rdf:XMLLiteral rdf:type rdfs:Datatype .

rdf:XMLLiteral rdfs:subClassOf rdfs:Literal .
	
******* Axiomatic Triples for the Facets

<rdf:langRange> <rdf:type> <owl:DatatypeProperty> .

<rdf:langRange> <rdfs:domain> <rdfs:Resource> .

<rdf:langRange> <rdfs:range> <rdfs:Literal> .

<xsd:length> <rdf:type> <owl:DatatypeProperty> .

<xsd:length> <rdfs:domain> <rdfs:Resource> .

<xsd:length> <rdfs:range> <rdfs:Literal> .

<xsd:maxExclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:maxExclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:maxExclusive> <rdfs:range> <rdfs:Literal> .

<xsd:maxInclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:maxInclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:maxInclusive> <rdfs:range> <rdfs:Literal> .

<xsd:maxLength> <rdf:type> <owl:DatatypeProperty> .

<xsd:maxLength> <rdfs:domain> <rdfs:Resource> .

<xsd:maxLength> <rdfs:range> <rdfs:Literal> .

<xsd:minExclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:minExclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:minExclusive> <rdfs:range> <rdfs:Literal> .

<xsd:minInclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:minInclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:minInclusive> <rdfs:range> <rdfs:Literal> .

<xsd:minLength> <rdf:type> <owl:DatatypeProperty> .

xsd:minLength rdfs:domain rdfs:Resource .

xsd:minLength rdfs:range rdfs:Literal .

xsd:pattern rdf:type owl:DatatypeProperty .

xsd:pattern rdfs:domain rdfs:Resource .

xsd:pattern rdfs:range rdfs:Literal .
	
******* Additional Axiomatic Triples for Classes and Properties

<rdfs:Class> <rdfs:subClassOf> <owl:Class> .

<rdfs:comment> <rdf:type> <owl:AnnotationProperty> .

<rdfs:comment> <rdfs:domain> <rdfs:Resource> .

<rdfs:comment> <rdfs:range> <rdfs:Literal> .

<rdfs:Datatype> <rdfs:subClassOf> <owl:DataRange> .

<rdfs:isDefinedBy> <rdf:type> <owl:AnnotationProperty> .

<rdfs:isDefinedBy> <rdfs:domain> <rdfs:Resource> .

<rdfs:isDefinedBy> <rdfs:range> <rdfs:Resource> .

<rdfs:label> <rdf:type> <owl:AnnotationProperty> .

<rdfs:label> <rdfs:domain> <rdfs:Resource> .

<rdfs:label> <rdfs:range> <rdfs:Literal> .

<rdfs:Literal> <rdf:type> <rdfs:Datatype> .

<rdf:Property> <rdfs:subClassOf> <owl:ObjectProperty> .

<rdfs:Resource> <rdfs:subClassOf> <owl:Thing> .

<rdfs:seeAlso> <rdf:type> <owl:AnnotationProperty> .

<rdfs:seeAlso> <rdfs:domain> <rdfs:Resource> .

<rdfs:seeAlso> <rdfs:range> <rdfs:Resource> .
***** misc owl2								:rdf:
      ICEXT(I(ex:c1)) ⊆ ICEXT(I(ex:c2)) ∪ ICEXT(I(ex:c3)) . 
***** owl2 basic gloss

      owl:AllDifferent 

      owl:AllDisjointClasses 

      owl:AllDisjointProperties 

      owl:allValuesFrom 

      owl:annotatedProperty 

      owl:annotatedSource 

      owl:annotatedTarget 

      owl:Annotation 

      owl:AnnotationProperty 

      owl:assertionProperty 

      owl:AsymmetricProperty 

      owl:Axiom 

      owl:backwardCompatibleWith 

      owl:bottomDataProperty 

      owl:bottomObjectProperty 

      owl:cardinality 

      owl:Class 

      owl:complementOf 

      owl:DataRange 

      owl:datatypeComplementOf 

      owl:DatatypeProperty 

      owl:deprecated 

      owl:DeprecatedClass 

      owl:DeprecatedProperty 

      owl:differentFrom 

      owl:disjointUnionOf 

      owl:disjointWith 

      owl:distinctMembers 

      owl:equivalentClass 

      owl:equivalentProperty 

      owl:FunctionalProperty 

      owl:hasKey 

      owl:hasSelf 

      owl:hasValue 

      owl:imports 

      owl:incompatibleWith 

      owl:intersectionOf 

      owl:InverseFunctionalProperty 

      owl:inverseOf 

      owl:IrreflexiveProperty 

      owl:maxCardinality 

      owl:maxQualifiedCardinality 

      owl:members 

      owl:minCardinality 

      owl:minQualifiedCardinality 

      owl:NamedIndividual 

      owl:NegativePropertyAssertion 

      owl:Nothing 

      owl:ObjectProperty 

      owl:onClass 

      owl:onDataRange 

      owl:onDatatype 

      owl:oneOf 

      owl:onProperty 

      owl:onProperties 

      owl:Ontology 

      owl:OntologyProperty 

      owl:priorVersion 

      owl:propertyChainAxiom 

      owl:propertyDisjointWith 

      owl:qualifiedCardinality 

      owl:ReflexiveProperty 

      owl:Restriction 

      owl:sameAs 

      owl:someValuesFrom 

      owl:sourceIndividual 

      owl:SymmetricProperty 

      owl:targetIndividual 

      owl:targetValue 

      owl:Thing 

      owl:topDataProperty 

      owl:topObjectProperty 

      owl:TransitiveProperty 

      owl:unionOf 

      owl:versionInfo 

      owl:versionIRI 

      owl:withRestrictions 

***** About owl2 and axiomatic triples

_:x rdf:type owl:Class.

_:x owl:intersectionOf ( C1 … Cn ). 

_:x rdf:type owl:Class.

_:x owl:unionOf ( C1 … Cn ). 

_:x rdf:type owl:Class.

_:x owl:complementOf C. 

_:x rdf:type owl:Class.

_:x owl:oneOf ( a1 … an ). 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:allValuesFrom C .

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:someValuesFrom C .

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:hasValue a. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:hasSelf "true"^^xsd:boolean. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:cardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:qualifiedCardinality n.

_:x owl:onClass C. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:maxCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:maxQualifiedCardinality n.

_:x owl:onClass C. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:minCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:minQualifiedCardinality n.

_:x owl:onClass C. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:allValuesFrom D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:someValuesFrom D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:hasValue v. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:cardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:qualifiedCardinality n.

_:x owl:onDataRange D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:maxCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:maxQualifiedCardinality n.

_:x owl:onDataRange D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:minCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:minQualifiedCardinality n.

_:x owl:onDataRange D. 

_:x rdf:type rdfs:Datatype.

_:x owl:datatypeComplementOf D. 

_:x rdf:type rdfs:Datatype.

_:x owl:intersectionOf (D1…Dn). 

_:x rdf:type rdfs:Datatype.

_:x owl:unionOf (D1…Dn). 

_:x rdf:type rdfs:Datatype.

_:x owl:oneOf ( v1 … vn ). 

_:x rdf:type rdfs:Datatype.

_:x owl:onDatatype DN.

_:x owl:withRestrictions (_:x1 ... _:xn).

_:xj fj vj.      j=1…n 

C1 rdfs:subClassOf C2. 

Cj owl:equivalentClass Cj+1. j=1…n-1 

C1 owl:disjointWith C2. 

_:x rdf:type owl:AllDisjointClasses.

_:x owl:members ( C1 … Cn ). 

P1 rdfs:subPropertyOf P2. 

P owl:propertyChainAxiom (P1 … Pn). 

P rdfs:domain C. 

P rdfs:range C. 

Pj owl:equivalentProperty Pj+1. j=1…n-1 

P1 owl:propertyDisjointWith P2. 

_:x rdf:type owl:AllDisjointProperties.

_:x owl:members ( P1 … Pn ). 

CN owl:disjointUnionOf ( C1 … Cn ).

P1 owl:inverseOf P2. 

P rdf:type owl:FunctionalProperty. 

P rdf:type owl:InverseFunctionalProperty. 

P rdf:type owl:ReflexiveProperty. 

P rdf:type owl:IrreflexiveProperty. 

P rdf:type owl:SymmetricProperty. 

P rdf:type owl:AsymmetricProperty. 

P rdf:type owl:TransitiveProperty. 

DN owl:equivalentClass D. 

aj owl:sameAs aj+1. j=1…n-1 

a1 owl:differentFrom a2. 

_:x rdf:type owl:AllDifferent.

_:x owl:members (a1 … an). 

a rdf:type C. 

a1 PN a2. 

a R v. 

_:x rdf:type owl:NegativePropertyAssertion.

_:x owl:sourceIndividual a1.

_:x owl:assertionProperty P.

_:x owl:targetIndividual a2. 

_:x rdf:type owl:NegativePropertyAssertion.

_:x owl:sourceIndividual a.

_:x owl:assertionProperty R.

_:x owl:targetValue v. 

C owl:hasKey (P1 … Pm R1 … Rn).

m+n>0 

CN rdf:type owl:Class. 

DN rdf:type rdfs:Datatype. 

PN rdf:type owl:ObjectProperty. 

R rdf:type owl:DatatypeProperty. 

A rdf:type owl:AnnotationProperty. 

aN rdf:type owl:NamedIndividual. 

@prefix p U. 

rdf:type rdf:type rdf:Property .

rdf:type rdfs:domain rdfs:Resource .

rdf:type rdfs:range rdfs:Class .

rdfs:Datatype rdfs:subClassOf rdfs:Class .

rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso .

I(rdf:type) ∈ ICEXT(I(rdf:Property)) ,

IEXT(I(rdf:type)) ⊆ ICEXT(I(rdfs:Resource)) × ICEXT(I(rdfs:Class)) ,

ICEXT(I(rdfs:Datatype)) ⊆ ICEXT(I(rdfs:Class)) ,

IEXT(I(rdfs:isDefinedBy)) ⊆ IEXT(I(rdfs:seeAlso)) . 

I(owl:FunctionalProperty) ∈ IC 

owl:FunctionalProperty rdf:type rdfs:Class .

ICEXT(I(owl:FunctionalProperty)) ⊆ IP 

owl:FunctionalProperty rdfs:subClassOf rdf:Property .

E rdf:type rdfs:Datatype .

E rdfs:subClassOf rdfs:Literal .

I(owl:disjointWith) ∈ IP 

owl:disjointWith rdf:type rdf:Property .

IEXT(I(owl:disjointWith)) ⊆ IC × IC 

owl:disjointWith rdfs:domain owl:Class .

owl:disjointWith rdfs:range owl:Class .

E rdf:type owl:DatatypeProperty .

E rdfs:domain rdfs:Resource .

E rdfs:range rdfs:Literal .
**** prolog							     :prolog:
***** Allegro Prolog					  :prolog:lisp:gruff:
******* Release 0.98b

Release 0.98b of Allegro Prolog continues a sequence of minor bugfix releases
from 0.98, but 0.98 and its accompanying documentation have significant
changes and enhancements from earlier releases.

The prolog module can be loaded with 
#+begin_lisp
(require :prolog) .
(use-package :prolog)
prolog:==
 options
(shadowing-import '(prolog:==))(use-package :prolog)
#+end_lisp


Symbols are exported from the prolog package. If you intend to use
Prolog interactively you will probably find it convenient to execute
(use-package :prolog) also.

It happens that both the prolog and cg packages export a symbol named ==
which will signal a package conflict if there is an attempt to use both
packages. This will happen, for instance, if you try to use the prolog
package in the cg-user package without first shadowing one or the other
symbol. Usually you want == to refer to prolog:==. You will get that if you
load the prolog module and evaluate (shadowing-import '(prolog:==)) and then
(use-package :prolog).

****** User Documentation

This document is not intended as an introduction to programming in Prolog. It
assumes some programming knowledge of both Prolog and Common Lisp.

Allegro Prolog is an implementation of Prolog in Common Lisp. It is based on
the implementation developed by Peter Norvig in Paradigms of Artificial
Intelligence Programming. The code has been further optimized and useful
extensions provided, making an industrial-strength Prolog programming
environment with a flexible calling interface in both directions between
Common Lisp and Prolog.

Prolog functors are translated to compiled Common Lisp functions. A single
Lisp function combines all rules for each distinct functor/arity. Special
treatment is given for facts, that is, rules with no variables in the head
and no clauses in the body. The Lisp function automatically captures these as
data instead of code. This allows reasonably large collections of data to be
specified as regular Prolog rules. Larger, highly-scalable data sets can be
implemented by extensions outlined below.

Allegro Prolog does not intend to be an ISO-compliant Prolog, nor does it
implement the entire Prolog language. Its purpose is to provide Prolog logic
programming as an integrated extension to Common Lisp for use in Lisp
programs, not as a separate language. Many standard Prolog arithmetic,
predicate operators, and I/O operators are not implemented, as they are a
subset of the standard Common Lisp operators available using lisp/2. There is
also no support for operator syntax (e.g. infix notation), as input notation
is subsumed by sexpr syntax. These choices may be reconsidered in the future
if there is reason to if there is motivation to make Allegro Prolog a
self-standing Prolog implementation. What is provided is the basic Prolog
engine for logic programming.

Prolog source files may be loaded either compiled or interpreted, as Prolog
functors are automatically compiled upon first use. But since Allegro Prolog
programs will typically contain both Lisp and Prolog code intermixed, it is
generally a good idea to compile the files so that the Lisp code is compiled.

All public symbols are exported from the prolog package. The definitions
mostly follow Norvig. Lisp S-expression syntax is used rather than Edinburgh
syntax, although support for Edinburgh input may be provided in the future.
Prolog variables are Lisp symbols that have names that begin with the `?'
character. The anonymous variable is the symbol `?' (that is, `prolog:?').
Some symbols exported from the prolog package are eq to symbols exported from
the common-lisp package, but there is never any ambiguity between use of a
Prolog name and a Lisp name. There is no implementation of the Prolog module
system. Programmers should be aware that there is a danger of collision with
inherited symbols. For example, the symbol cl:list is not defined by Prolog
but would typically be inherited from the common-lisp package by an
application package. An attempt to make a Lisp function definition on cl:list
would be prevented by package locking, but definition as a Prolog functor is
not protected. If multiple application packages attempt to make such
definitions, they would collide on the inherited symbol.

Allegro Prolog has no known dependencies on 8-bit vs. 16-bit character images
or on ANSI vs. Modern mode images.

***** Built-in Prolog Functors

The following Prolog functors are predefined in Allegro Prolog and generally
implement the standard Prolog functionality. The set of defined functors may
be extended in the future. A few functors in this implementation accept
varying arity and are indicated with a *, as in or/*.
***** allegro-prolog functors

       =/2   ==/2   abolish/2   and/*   append/3   arg/3   assert/1   asserta/1
       assertz/1   atom/1   atomic/1   bagof/3   call/1   consult/1   
       copy-term/2   erase/1   fail/0   first/1   functor/3   ground/1   if/2   
       if/3   is/2   last/1   leash/1   length/1   listing/1   member/2   
       memberp/2 (member without backtracking)   not/1   number/1   or/*   princ
       /1   read/1   recorda/1   recordz/1   recorded/2   repeat/0   rest/1   
       retract/1   rev/2   setof/3   true/0   var/1   write/1  
      
***** ! is the Prolog cut. 
      It may written as an atom ! as well as the 1-element list (!). The
      Prolog atom predicate is equivalent to Lisp's symbolp. The Prolog
      atomic predicate is equivalent to Lisp's atom, true for any object
      that is not a cons.

***** The Prolog Top Level

Allegro Prolog does not provide a top level listener loop other than the
regular lisp listener. Prolog computation may be invoked programmatically
from Lisp using the prolog macro described below, or interactively by
executing the ?- macro. Here is a simple example interactive session using ?-
.

cl-user(2): (require :prolog)
nil
cl-user(3): (use-package :prolog)
t
cl-user(4): (?- (append ?x ?y (1 2 3)))
?x = ()
?y = (1 2 3) <ENTER>
?x = (1)
?y = (2 3) <ENTER>
?x = (1 2)
?y = (3) <ENTER>
?x = (1 2 3)
?y = () <ENTER>
No.
cl-user(5): 
***** the ?- macro
The ?- macro operates similarly to the top-level loop in interactive Prologs.
A ?- expression takes zero or more subforms which are clauses and tries to
solve them. When a solution is found, it prints the values of all variables
in the expression then reads a character from *standard-input*. (If there are
no variables it prints "Yes."). If the character is either newline (usually 
enter on a keyboard) or semicolon, Prolog backtracks and attempts to find
another solution. If the character is a period, Prolog prints "No." and
returns.

***** Defined Lisp Operators

         Lisp Operator                                                                                                                                                                                                                                                                                                                                Description                                                                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
<- clause*                      Assert a fact or rule. A macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                As above, but first retracts all rules for the functor with the same arity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                This is similar to the action taken for <- the first time a functor/arity is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                seen within a consult, but <-- is especially useful interactively. By                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                retracting previous clauses it allows predicates to be changed and files to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
<-- clause*                     be loaded more than once. A useful convention (in a file that might be loaded                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                rather than consulted) is to use <-- in the first rule for a particular                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                function/arity. An example of typical usage would be:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                  (<-- (member ?item (?item . ?)))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                  (<-  (member ?item (? . ?rest)) (member ?item ?rest))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
?- clause*                      Interactively try to prove the concatenation of clauses, printing unified                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                variables and then backtracking after each success. A macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                This function calls cl:load on its filename or pathname argument, with the                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                additional functionality that the first time <- is executed for a given                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
consult &rest filename*         predicate/arity, that predicate/arity is cleared before the new definition is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                established. consult/1 is also available as a prolog functor, accepting a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                single filename or a list of filenames.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                A macro analogous to Lisp trace which causes printing at each of the four                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                ports to the functor: call, exit, redo, and fail. This predicate is often                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                called trace in other Prologs, but that name clashes with the standard                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                cl:trace macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Leash output is printed to *trace-output*.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                If leash is called with no arguments it returns a list of the                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                currently-leashed functor/aritys currently being leashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                When a functor/arity is leashed (or unleashed) it is automatically recompiled                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                without (or with) tail-call optimization to make leash output conform to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                Prolog WAM model even for tail-recursive functors. The programmer does not                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                normally need to be concerned with this.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Some built in functors such as if, not, or, and and are normally rewritten by                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                inline macro transformers so will usually not appear in leash output if                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                leashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Here is an example of leash. rev-member is like member but returns results                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                starting from the tail of the list:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
leash {functor arity}*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                cl-user(2): (require :prolog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                cl-user(3): (use-package :prolog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                cl-user(4): (<-- (rev-member ?item (? . ?rest)) (rev-member ?item ?rest)) rev-member cl-user(5): (<- (rev-member ?item (?item . ?))) rev-member cl-user(6): (leash rev-member 2) t cl-user(7): (?- (rev-member ?animal (dog cat fish))) [1] Entering rev-member/2 {Unbound 1000fe7cb1} (dog cat fish) [2] Entering rev-member/2 {Unbound 1000fe7cb1} (cat fish) [3] Entering rev-member/2 {Unbound 1000fe7cb1} (fish) [4] Entering rev-member/2 {Unbound 1000fe7cb1} () [4] Failed rev-member/2 [3] Succeeded rev-member/2 fish (fish) [2] Succeeded rev-member/2 fish (cat fish) [1] Succeeded rev-member/2 fish (dog cat fish) ?animal="fish" <ENTER>
                                [1] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                 [2] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                  [3] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
                                  [3] Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                 [2] Succeeded rev-member/2 cat (cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                [1] Succeeded rev-member/2 cat (dog cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                ?animal = cat <ENTER>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                [1] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                 [2] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                 [2] Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                [1] Succeeded rev-member/2 dog (dog cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                ?animal = dog <ENTER>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                [1] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                [1] Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                No.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                cl-user(8):                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
leash-1 functor arity           Functional version of the above.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
unleash {functor arity}*        Analogous to Lisp untrace. If called with no arguments, every                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                currently-leashed functor/arity is unleashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
unleash-1 functor arity         Functional version of the above                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                If variable this is an integer, the debugger will be entered if leash output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
*leash-limit*                   exceeds the specified depth. This is intended as a convenience when debugging                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                deep recursion. Initially nil.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Leash output indents one space for each level of leashed functor. If leashing                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
*prolog-leash-indent-wrap*      is deeply recursive this indentation may make the leash output unreadable, so                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                the indentation is taken modulo the value of this variable. It must be a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                nonnegative integer, but may be set large. Initially 20.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                This may be called after new rules are asserted before making Prolog queries.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
prolog-compile-symbols functor* Called with no arguments, it compiles all functors needing (re)compilation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                Otherwise, a functor/arity will be compiled automatically the first time it                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                is called.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

Whether a rule is established by <- or assert/2, a Lisp form inside a prolog
rule executed by the lisp/2 and similar functors may not refer to the Lisp
lexical environment outside the rule definition. This restriction is
necessary because the code for the Prolog functor is not compiled until
later, after all functor/arity clauses have been combined to form its
function body.

***** The Programming Interface between Prolog and Common Lisp

In addition to the interactive query and assertion macros (e.g. ?-> and <-)
there are several operators to call in either direction between Prolog code
and Lisp code.

****** Prolog Functor                                Description                              
                                                                                       
                Execute a Lisp form from Prolog. The Lisp form is compiled (at the same
                time the Prolog predicate is compiled) and may refer to variables in   
                the surrounding dynamic Lisp environment. Lexical references cannot go 
                beyond the rule boundary. Prolog variables may be referenced, but only 
lisp arg form   in evaluated positions (i.e. not inside constants). Prolog variables   
                are dereferenced as necessary into non-dynamic-extent copies. The      
                clause fails and no Lisp code is executed if any Prolog variables in   
                the form are unbound. The result of executing the Lisp form second     
                argument is unified with the first argument.                           
                                                                                       
lisp form       As above, but the Lisp form is executed for side effect only. Any value
                returned by the form is ignored.                                       
                                                                                       
                As above, but unbound Prolog variables do not cause the clause to fail.
                If the Prolog variables referenced within the Lisp form are guaranteed 
                to be bound, this functor is more efficient than the                   
lisp* arg form  otherwise-equivalent lisp functor because it does not need to set up   
lisp* form      code to handle the unbound-variable failure case. It is often the case 
                in numeric calculation that the variables are certain to be bound. In  
                such situations it is faster to execute (lisp* ?x (1+ ?x)) than (lisp ?
                x (1+ ?x)).                                                            
                                                                                       
                A convenience functor similar to lisp but runs as a predicate and fails
                if execution of the form returns nil. The familiar Prolog numeric      
lispp form      predicates can be obtained this way:                                   
                                                                                       
                  (lispp (>= ?x 5))                                                    
                                                                                       
                As above, except that unbound Prolog variables do not cause the rule to
lispp* form     fail. lispp* is more efficient than lispp if all referenced Prolog     
                variables are bound.                                                   
                                                                                       
lisp! arg form                                                                         
lisp! form      Similar to the above functors, with the provision that any             
lisp*! arg form dynamic-extent data bound to Prolog variables in the form are consed in
lisp*! form     the heap before being passed to Lisp. See the section below on Prolog  
lispp! form     and Dynamic Extent.                                                    
lispp*! form                                                                           
                                                                                       
                This is an exact equivalent for the 2-argument lisp functor above. is  
                is the traditional name for this functor. The lisp and is in this      
                implementation are slightly more powerful than the Prolog is since they
                are capable of unifying (even destructuring) an arbitrary returned     
                value returned by the Lisp form, while the Prolog functor is intended  
is arg form     only for numerical calculations.                                       
                                                                                       
                  cl-user: (?- (is (?div ?rem) (multiple-value-list (truncate 11 3)))) 
                  ?div = 3                                                             
                  ?rem = 2                                                             
                  No.                                                                  

****** Lisp Operator                           Description                          
                                                                             
               Lisp code running inside a call to one of the the Prolog lisp 
fail           functors can call this Lisp function to cause the clause to   
               fail immediately.                                             
                                                                             
               A Lisp macro that invokes Prolog programmatically to solve the
               conjunction of the clauses. The surrounding Lisp environment  
               (lexical as well as dynamic) can be accessed using the lisp   
               functor. This example refers to the likes data in an example  
               in a later section of this document:                          
                                                                             
                 (defun human-friends-of (person)                            
                   (let ((friends nil))                                      
                     (prolog (lisp ?person person)                           
                             (likes ?person ?x)                              
                             (human ?x)                                      
                             (lisp (pushnew ?x friends)))                    
prolog clause*       friends))                                               
                                                                             
               The expansion of the prolog macro wraps a block named prolog  
               around the body so Lisp forms inside the body can easily      
               return a value:                                               
                                                                             
                 (defun human-friend-of (person)                             
                   (prolog (lisp ?person person)                             
                           (likes ?person ?x)                                
                           (human ?x)                                        
                           (lisp (return-from prolog ?x))))                  
                                                                             
               Unless there is some nonlocal exit, execution of the prolog   
               macro silently finds all solutions to the clauses.            

***** Prolog and Dynamic Extent

Computation in Prolog works by attempting to satisfy a clause and, if
successful, calling a continuation function. If that continuation fails
control may return to any previous choice point, undoing any intervening
unifications, and trying a different solution choice. Prolog unification data
and continuation functions always have dynamic extent. The implementation
exploits this by allocating Prolog variables themselves, cons structure
created by unification, and continuation closure functions on the stack, that
is, with dynamic extent. This allows Prolog code to operate with essentially
zero consing and with a resulting improvement in speed.

There are, however, certain functors that typically cons data with indefinite
extent. Solutions collected by the bagof/3 and setof/3 functors are
automatically heap consed, as are any rules stored by the assert, asserta,
assertz, recorda, and recordz functors.

The family of lisp functors are special cases. When a call to the lisp
functor is performed, the values of any Prolog variables referenced in the
Lisp form are communicated efficiently to the Lisp code using symbol macros.
But those variables may contain nested unification with other Prolog
variables, and the structure created by unification may have been consed with
dynamic extent. This is not normally a concern since the Lisp code is of
course running within the dynamic extent of the surrounding Prolog code, but
it would become an issue if the Lisp code stored the data somewhere with
indefinite extent.

Dynamic extent is only a concern for cons structures. Numeric data is
generally not stack consed.

Some examples will make this clear. Consider the following code:
#+begin_src lisp
(defun ancestors-of (person)
  (let ((ancestors nil))
    (prolog (lisp ?person person)
            (ancestor ?x person)
            (lisp (push ?x ancestors)))
    ancestors))
#+end_src
If the data returned by the ancestor predicate are atoms (e.g. symbols) there
is no problem since they cannot be stack consed. Similarly, there is no
problem with numbers and numeric calculation since the implementation
generally does not stack cons numbers. But suppose Prolog data passed to Lisp
code was created by unification:
#+begin_src lisp
(defun grandfather-pairs ()
  (let ((pairs nil))
    (prolog (grandfather ?gramp ?child)
            (lisp (push (?gramp ?child) pairs)))
    pairs))
#+end_src
... are atoms, but it would not work if the objects being passed back were conses
created by Prolog unification. But structure created by Prolog unification
has only dynamic extent -- that is, it may be consed on the stack.
Stack-consed data must be copied to the heap if it is passed outward to Lisp
or otherwise preserved outside the dynamic contour where it is created. As an
example see the function zebra-benchmark in the zebra example file.

A top-level list created by bagof and setof are automatically given
indefinite extent, as is any substructure created by unification and
collected on these lists. Therefore the programmer should not have to worry
about dynamic extent when using these predicates.

***** Tail Call Elimination

The ISO standard for Prolog apparently does not require tail-call
elimination. However, most implementations provide it to some degree. It is
certainly a valuable feature. Allegro Prolog functors usually do not perform
tail-call elimination. The Prolog compiler tries to stack cons Prolog
variables, data structure, and continuations. Stack allocation of these data
enhances performance, but stack-consed data generally prohibits tail-call
elimination.

Since tail-call elimination can be important for particular functors in
certain styles of coding, a crude control over stack consing has been
implemented at the level of an individual functor/arity. This facility is
experimental and is likely to change in future releases.

The first clause of any rule may be a cl:declare which makes declarations
about the functor. Declarations may appear in any rule for a given functor/
arity -- declarations in later rules (according to the ordering maintained by
assert and friends) override earlier declarations.

The only declarations currently supported are :tail-calls and :no-tail-calls.
The latter is the default.

  (<-- (my-member ?item (?item . ?)) (declare :tail-calls)) (<- (my-member ?item (? . ?rest)) (my-member ?item ?rest))

The (declare :tail-calls) could have been included in either or both of the
two rules.

The built in member/2 and length/2 functors are written in a way that
consumes neither Prolog nor Lisp stack, but if they had not, the version of
my-member shown above implements heap-consing by the functor and allows tail
recursion on the Lisp stack. The functor still requires Prolog stack for the
unifications performed on the ?rest Prolog variable, but this is small (one
word per unified variable) compared to the consumption of Lisp stack that
recursion would require.

Tail call elimination is subject to the normal constraints imposed by the
Lisp compiler. These are platform dependent.The presence in a functor/arity
of calls to the lisp, lispp or lisp! functors will sometimes prevent tail
call elimination. Where possible, use lisp*, lispp* and lisp*! instead.

***** The Prolog Stack

******          Lisp Name                             Description                   
                                                                             
                             Prolog maintains a stack of unifications as it  
                             tries to satisfy clauses recursively. This stack
                             is separate from the regular Lisp execution     
                             stack. The initial stack length is determined by
                             the implementation, but the stack will double in
                             length when the current length is exceeded. This
                             Lisp condition is signalled with cerror when    
                             automatic doubling will exceed the limit        
prolog-stack-overflow        contained in the variable *prolog-stack-limit*. 
                             Continuing (e.g. with the standard Lisp continue
                             function) will continue Prolog computation with 
                             the stack length doubled.                       
                                                                             
                             The only superclass of this condition is        
                             cl:condition itself. In particular, it is not a 
                             subclass of error so extraneous error handlers  
                             don't try to handle it.                         
                                                                             
prolog-stack-overflow-length This reader on the above condition returns the  
                             current stack length.                           
                                                                             
                             A special variable containing a positive integer
*prolog-stack-limit*         that specifies the size above which a           
                             prolog-stack-overflow-length will be signalled. 
                             The initial value is 4096.                      

***** I/O Functors

The set of built-in Prolog I/O functors is intentionally limited because most
input and output would naturally be done by Lisp code. A few functors are
provided for convenience.

******                Lisp Name                             Description             
                                                                             
                                        The value argument is unified with a 
                                        single datum read from               
                                        *standard-input*. This is just a     
                                        simple wrapper for the Lisp read     
                                        function. The input syntax is Lisp   
                                        syntax, not Edinburgh.               
read value [stream [stream [stream] ] ]                                      
                                        The functors read/2, read/3, and read
                                        /4 are also defined, providing the   
                                        stream, eof-error, and eof-value     
                                        optional arguments to read. If       
                                        supplied, the values of these        
                                        arguments must be grounded.          
                                                                             
                                        The value argument is written to     
                                        *standard-output*. This is just a    
                                        simple wrapper for the Lisp write    
                                        function. The output syntax is Lisp  
write value [stream]                    syntax, not Edinburgh.               
                                                                             
                                        The functor write/2 is also defined, 
                                        providing the stream, write. If      
                                        supplied, the value must be grounded.
                                                                             
princ value [stream]                    Like write but uses the Lisp princ   
                                        function.                            
                                                                             
nl [stream]                             A wrapper for the Lisp terpri        
                                        function.                            

****** Unification with standard-objects.

*******            Prolog Functor                                    Description                       
                                                                                               
                                      This Prolog functor unifies the value of a slot of a     
                                      standard instance. The instance and slot-name arguments  
                                      must be bound, otherwise the predicate silently fails.   
                                      The slot-value argument is unified against the content of
                                      the slot. A Lisp error is signalled if the slot does not 
                                      exist or is not bound. The implementation is:            
slot= inst slot-name slot-value                                                                
                                        (<-- (slot= ?instance ?slot-name ?slot-value)          
                                             (lisp ?slot-value                                 
                                                   (slot-value ?instance ?slot-name)))         
                                                                                               
                                      When it is only necessary to read a slot, this functor is
                                      faster than the two that follow.                         
                                                                                               
slot=* inst slot-name slot-value      Like lisp* except that this functor fails silently if the
                                      slot does not exist or is unbound.                       
                                                                                               
                                      As above, this Prolog functor unifies the value of a slot
                                      in a standard instance. However, if the slot is unbound  
                                      it is bound dynamically as if by letf to the value of    
                                      slot-value, and the clause succeeds. (If slot-value is   
                                      unbound or contains any unbound Prolog variables, the    
                                      clause fails.) The slot is again made unbound when       
                                      execution returns out of the continuation (by            
                                      backtracking, or by Lisp nonlocal exit). While the slot  
                                      is bound it is visible to other threads. Example:        
                                                                                               
                                        cl-user(38): (defparameter *inst* (make-instance 'foo))
slot-value inst slot-name slot-value    *inst*                                                 
                                        cl-user(39): (?- (lisp ?i *inst*)                      
                                                         (slot-value ?i a ?sv))                
                                        No.                                                    
                                        cl-user(40): (?- (lisp ?i *inst*)                      
                                                         (slot-value ?i a 123)                 
                                                         (slot-value ?i a ?sv))                
                                        ?i = #<foo>                                            
                                        ?sv = 123                                              
                                        No.                                                    
                                        cl-user(41): (?- (lisp ?i *inst*)                      
                                                         (slot-value ?i a ?sv))                
                                        No.                                                    
                                                                                               
                                      As above, except that if the slot is set it is not made  
                                      unbound when execution backtracks. The side effect of    
                                      setting the slot persists. Example:                      
                                                                                               
                                        cl-user(42): (defparameter *inst* (make-instance 'foo))
                                        *inst*                                                 
                                        cl-user(43): (?- (lisp ?i *inst*)                      
                                                         (slot-value! ?i a ?sv))               
                                        No.                                                    
slot-value! inst slot-name slot-value   cl-user(44): (?- (lisp ?i *inst*)                      
                                                         (slot-value! ?i a 123)                
                                                         (slot-value! ?i a ?sv))               
                                        ?i = #<foo>                                            
                                        ?sv = 123                                              
                                        No.                                                    
                                        cl-user(45): (?- (lisp ?i *inst*)                      
                                                         (slot-value! ?i a ?sv))               
                                        ?i = #<foo>                                            
                                        ?sv = 123                                              
                                        No.                                                    

***** The Prolog `Database' and Generators.

In its simplest model, Prolog needs only to remember rules. (A fact is simply
a rule with no trailing clauses and no variables in its head.) All rules for
a particular functor/arity are remembered in the order they were asserted and
the Prolog implementation somehow references these when that functor/arity is
invoked. Under this simple model, there is no firm distinction between that
portion of a system which the programmer considers program, that part which
he considers internal data and tables, and (sometimes) that part which he
would consider external data.

But the scaling requirements and operating characteristics of Prolog data
sets vary over enormous ranges. Many standard functors have only one or two
rules:

  (<-- (first ?x (?x . ?)))

  (<-- (member ?item (?item . ?)))
  (<-  (member ?item (? . ?rest)) (member ?item ?rest))

Functors like these are naturally represented as compiled code, or may even
be inlined. Rules which are conceptually implemented by compiled program code
are managed by the Prolog assert/abolish mechanism.

Now consider a different example (from Norvig) where a functor is defined
partly by algorithm (nontrivial rules) and partly by data (facts):

  (<-- (likes Kim Robin))
  (<-  (likes Sandy Lee))
  (<-  (likes Sandy Kim))
  (<-  (likes Robin cats))
  (<-  (likes Sandy ?x) (likes ?x cats))
  (<-  (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
  (<-  (likes ?x ?x))

The likes/2 predicate has seven rules, four of which are facts. Despite the
combination of programmatic rules and facts, this combined data is still
small enough to be represented directly by the code implementing the functor/
arity predicate. (This is true especially for Allegro Prolog since compiled
functors capture facts as constant data, rather that expanding them into
volumous Lisp code.) However, this representation would become unwieldy if
the number of individuals represented in the data were a few orders of
magnitude larger, and especially if more of the individuals had idiosyncratic
affinities. The factual data would better be represented in tabular form,
usually called recorded databases in Prolog. These are managed by functors
such as recorda. Prolog stores recorded facts in an equal-key hashtable.

Note that details of the following functors differ in some ways from those of
other Prolog implementations, and the API may change in the future. The
predicates assert/1, asserta/1, assertz/1 and abolish/2 pertain to the
compiled predicate database. The predicates recorda/2, recordz/2, retract/1,
and retractall/1 pertain to the hashtable database of facts. The hashtable
database is not automatically referenced by compiled functors; it is
consulted only by the recorded/2 predicate.

***** AllegroCache Object Database 
There is a separate interface to the AllegroCache object database described 
below.

******    Prolog Functor                           Description                      
                                                                             
                      Asserts a single rule into the database. The new rule  
                      is placed after all existing rules for that functor/   
                      arity.                                                 
                                                                             
                      Note that assert/1 takes a single list of clauses,     
assertz rule          therefore one would write                              
                                                                             
                      ... (assert ((likes ?name Lisp))) ...                  
                                                                             
                      and not                                                
                                                                             
                      ... (assert (likes ?name Lisp)) ...                    
                                                                             
assert rule           Same as assertz.                                       
                                                                             
asserta rule          Like assertz except the new rule is placed before all  
                      existing rules..                                       
                                                                             
abolish functor arity All rules for the functor/arity are removed.           

A typical Prolog application will reason over sets of data. In small
programming examples, the data is simply included as `facts' that are part of
the program source itself. Reading facts from an external source and
asserting them into the program is not much different. While a clever Prolog
implementation can optimize collections of facts, this approach cannot scale
indefinitely. First, it requires the facts be captured as data belonging to
the function. Second, efficient reasoning over large data sets requires
knowledge about how the data will be accessed. Often this is really an
indexing problem, and the application programmer must guide the system by
describing (or implementing) how the data is indexed. It is no coincidence
that this concern is similar to database implementation.

A Prolog functor/arity is compiled automatically the first time it is called.
Any assert or retract to that functor/arity automatically invalidates the
compiled function such that it will be recompiled the next time it is called.
While the Allegro compiler is reasonably fast, performance may be poor if
dynamic fact/rule management is performed using assert and retract with high
bandwidth, interspersed with calls to the functor/arity. In such applications
it would be better to use the recorded interface or some other custom fact
maintenance code, perhaps using generator.

******  Prolog Functor                           Description                        
                                                                             
                  Asserts a single new rule into the recorded database, keyed
                  on the key which is the head of the rule. Only the functor 
recordz rule      and arity are considered in matching the key. The new rule 
                  is placed after all existing rules for that key. See the   
                  example below under generator.                             
                                                                             
recorda rule      Same as recordz except that the new rule is placed before  
                  all current rules for key.                                 
                                                                             
                  Finds the list of rules matching key in the recorded       
recorded key rule database and unifies rule successively to each rule. Only  
                  the functor and arity are considered in matching the key.  
                                                                             
retract key       All rules for the key are removed from the recorded        
                  database. Succeeds only if something is deleted.           

A common idiom for solving the data set issue is to construct a Lisp closure
that iteratively generates the data items to be returned. The following
functors support this use.

******         Prolog Functor                                           Description                                 
                                                                                                             
                                The generator argument should be a Lisp closure that returns an item each    
                                time it is called. When there are no more items, it should return nil. This  
                                protocol cannot be used with generators that may return nil; see generator*  
                                below. The item argument is unified with the returned item.                  
                                                                                                             
                                Example:                                                                     
                                                                                                             
                                  ;; This asserts facts into the record database all the package             
                                  ;; inheritances in the running Lisp.                                       
                                  cl-user(40): (?- (lisp ?gen (let ((packages (list-all-packages)))          
                                                                (lambda () (pop packages))))                 
                                                   (generator ?package ?gen)                                 
                                                   (lisp ?used-list (package-use-list ?package))             
generator item generator                           (member ?used ?used-list)                                 
                                                   (recordz (use ?package ?used))                            
                                                   (fail))                                                   
                                  No.                                                                        
                                  ;; This queries which packages are used by the current package.            
                                  cl-user(41): (?- (lisp ?package *package*)                                 
                                                   (recorded (use ?package ?) (? ? ?used)))                  
                                  ?package = #<The common-lisp-user package>                                 
                                  ?t = #<The prolog package>                                                 
                                  ?package = #<The common-lisp-user package>                                 
                                  ?t = #<The common-lisp package>                                            
                                  ?package = #<The common-lisp-user package>                                 
                                  ?t = #<The excl package>                                                   
                                  No.                                                                        
                                                                                                             
                                Similar to generator but suitable when generated items may include nil. The  
generator* item generator       generator should return two values: the item, and a boolean indicating that  
                                an item was returned. When there are no more items the second value should be
                                nil.                                                                         
                                                                                                             
                                This is a convenience shortcut for typical use of the generator functor. The 
                                second argument is a lisp form that returns the generator closure. The values
                                it generates are unified against the first argument. The example above could 
                                be written more conveniently this way:                                       
                                                                                                             
generating item lisp-generator    cl-user(40): (?- (generating ?package (let ((packages (list-all-packages)))
                                                                          (lambda () (pop packages))))       
                                                   (lisp ?used-list (package-use-list ?package))             
                                                   (member ?used ?used-list)                                 
                                                   (recordz (use ?package ?used))                            
                                                   (fail))                                                   
                                  No.                                                                        
                                                                                                             
generating* item lisp-generator As above for generator*.                                                     
***** prolog lattice
A Prolog program that walks a lattice of linked objects is naturally
implemented using the lisp operator to follow links using standard Lisp
accessors.

  (<-- (class-subclass-gen ?gen ?class)
       (lisp ?gen
             (let ((class-stack (list
                                 (if (symbolp ?class)
                                     (find-class ?class)
                                   ?class))))
               (lambda ()
                 (let ((class (pop class-stack)))
                   (when class
                     (loop for subclass in (clos:class-direct-subclasses class)
                            do (push subclass class-stack))
                     class))))))

  (<-- (has-initarg-p ?class ?slot-name ?initarg)
       (lisp t (typep ?class 'standard-class))
       (lisp ?dslotds (clos:class-direct-slots ?class))
       (member ?dslotd ?dslotds)
       (lisp ?initargs (clos:slot-definition-initargs ?dslotd))
       (member ?initarg ?initargs)
       (lisp ?slot-name (clos:slot-definition-name ?dslotd)))

  (<-- (class-initarg ?root-class ?class ?slot-name ?initarg)
       (class-subclass-gen ?gen ?root-class)
       (generator ?class ?gen)
       (has-initarg-p ?class ?slot-name ?initarg))

  ;; This query will unify to each standard-class and slot that has a
  ;; :documentation initialization argument.
  ;;   (?- (class-initarg t ?class ?slot :documentation))

But querying large collections of relational data may require the programmer
to inform the system how the data should be stored and indexed. Allegro
Prolog has under development some general mechanisms for indexing data sets,
or else an application programmer may implement his own custom mechanisms.
For example, the application programmer might back end the Prolog program
with a full relational or object database. These possibilities are under
active exploration as extensions.

***** The Interface to AllegroCache
****** SeeAlso AllegroGraph, Gruff
Prolog code can reason directly over data stored in an AllegroCache database.
The interface is contained in the pcache module which can be loaded with
(require :pcache). The module is currently distributed as part of the
AllegroCache distribution.

The interface consists of the single prolog:db functor. This functor has
variable arity.

******                Prolog Functor                          Description           
                                                                             
                                             The db functor should only be   
                                             executed in a dynamic (Lisp)    
                                             environment in which the        
                                             *allegrocache* variable is bound
                                             to an open AllegroCache         
                                             database. The class argument    
                                             must be grounded and have the   
                                             value of a persistent-metaclasss
                                             class or the name of such a     
                                             class. ?instance is a variable  
                                             that will be unified with a     
                                             succession of instances of that 
                                             class. If there are no          
                                             additional arguments, the clause
                                             succeeds once for each instance 
                                             of that class in the database.  
                                                                             
                                             If there are additional         
db class ?instance { slot-name slot-value }* arguments, they are pairs of    
                                             slot-names and slot-values. Each
                                             slot-name must be grounded and  
                                             be a symbol naming a slot. If   
                                             ungrounded, the functor silently
                                             fails. The value of that slot is
                                             unified against the slot-value  
                                             which may be grounded or not.   
                                                                             
                                             If the first slot is indexed and
                                             the first value is fully        
                                             grounded, retrieval uses        
                                             AllegroCache's indexing and is  
                                             fast. Otherwise retrieval may   
                                             need to iterate over all        
                                             instances of the class.         
                                             Improvements in this simple     
                                             indexing strategy may be        
                                             explored in future releases.    

This is an example of a Roman numeral database that can do arithmetic by
database lookup. The objects in the database store Roman numeral and English
representations. The example retrieves the integer and English representation
of numbers that are half the value of perfect squares that are multiples of
100.

(defclass roman ()
  ((int     :accessor int     :index :any-unique :initarg :int)
   (roman   :accessor roman   :index :any-unique :initarg :roman)
   (english :accessor english :index :any-unique :initarg :english)
   (0mod100 :accessor 0mod100 :index :any        :initarg :0mod100)
   (square  :accessor square  :initarg :square))
  (:metaclass db.allegrocache:persistent-class))

(defun test-populate ()
  (with-file-database ("roman.db" :if-exists :supersede :if-does-not-exist :create)
    (loop for i from 1 to 500
        do (make-instance 'roman
             :int i
             :roman   (intern (format nil "~@r" i) (load-time-value (find-package :keyword)))
             :english (mapcar (lambda (string)
                                (intern string
                                        (load-time-value (find-package :keyword))))
                              (split-re "[ -]" (format nil "~r" i)))
             :0mod100 (zerop (mod i 100))
             :square (* i i)))))

(defmacro with-file-database ((name
                               &key (if-exists nil if-exists-p)
                                    (if-does-not-exist nil if-does-not-exist-p)
                                    read-only)
                              &body body)
  `(let ((db.allegrocache:*allegrocache* nil))
     (unwind-protect
         (multiple-value-prog1
             (progn
               (db.allegrocache:open-file-database
                ,name
                ,@(and if-exists-p
                       `(:if-exists ,if-exists))
                ,@(and if-does-not-exist-p
                       `(:if-does-not-exist ,if-does-not-exist)))
               ,@body)
           (unless ,read-only
             (db.allegrocache:commit)))
       (when db.allegrocache:*allegrocache*
         (db.allegrocache:close-database db.allegrocache:*allegrocache*)))))

cl-user(15): (test-populate)
nil
cl-user(16): (with-file-database ("roman.db")
               (?- (bagof (?half ?english)
                          (and
                           (db roman ?r 0mod100 t int ?int english ?english square ?square)
                           (lisp ?half (truncate ?int 2))
                           (db roman ?r2 int ?half english ?english-half))
                          ?bag)))
?r = 
?english = 
?square = 
?int = 
?r2 = 
?half = 
?english-half = 
?bag = ((100 (two hundred)) (150 (three hundred)) (200 (four hundred)) (250 (five hundred))
        (50 (one hundred)))
No.

***** Known Issues.

Allegro Prolog is a new product and rough edges can be expected while
experience is gained supporting large programs. More attention is needed on
smooth integration into the Allegro program development and debugging
environment. These are some other known issues:

The interface to and capabilities of leash deserve extension better to
support debugging. A mechanism such as the Allegro CL :inside trace option
would be especially useful, as would the ability to select individually which
of a functor's four WAM ports to leash. In some cases immediately recursive
invocation of a functor will not be intercepted by leash. (The issue is
essentially the same as tracing lisp self calls.)

It might be worthwhile to make public the Prolog compiler-macro interface if
it allows better optimization of user code. However, the API and conventions
for a compiler macro are complex and need review and some convenience macros
before the machinery can be exported.

A more powerful solution to the tail-jump elimination problem is pending.

Performance could be improved in some kinds of programs by a capability to
control indexing of rule terms. This is available as the index/1 in some
Prolog implementations.

Definition of Prolog functors should be integrated into the Allegro CL source
file recording machinery. This would provide warnings about multiple
definitions, particularly in definitions on inherited symbols.

An etags extension for <- and <-- would be helpful.

Franz Inc is interested in bugs and the experience of programmers using 
Allegro Prolog. Contact support@franz.com.

***** Example: the zebra problem

Here is the Lisp code and the Prolog code for the zebra problem, a well known
example of a puzzle with a set of facts about the attributes of people who
live in adjacent houses. First here is the Lisp code:
#+begin_src lisp

;;;========== zebra.cl

;;;; -*- Mode: common-lisp; Syntax: Common-Lisp -*-

(in-package :user)
(eval-when (compile load eval)
  (use-package :prolog))

(eval-when (compile) (setf excl:*load-xref-info* nil))

(<-- (nextto ?x ?y ?list) (iright ?x ?y ?list))
(<-  (nextto ?x ?y ?list) (iright ?y ?x ?list))
(<-- (iright ?left ?right (?left ?right . ?rest)))
(<-  (iright ?left ?right (?x . ?rest))
     (iright ?left ?right ?rest))

(<-- (zebra ?h ?w ?z)
     ;; Each house is of the form:
     ;; (house nationality pet cigarette drink house-color)
     (= ?h ((house norwegian ? ? ? ?)   ;1,10
            ?
            (house ? ? ? milk ?) ? ?))  ; 9
     (member (house englishman ? ? ? red) ?h) ; 2
     (member (house spaniard dog ? ? ?) ?h) ; 3
     (member (house ? ? ? coffee green) ?h) ; 4
     (member (house ukrainian ? ? tea ?) ?h) ; 5
     (iright (house ? ? ? ? ivory)      ; 6
             (house ? ? ? ? green) ?h)
     (member (house ? snails winston ? ?) ?h) ; 7
     (member (house ? ? kools ? yellow) ?h) ; 8
     (nextto (house ? ? chesterfield ? ?) ;11
             (house ? fox ? ? ?) ?h)
     (nextto (house ? ? kools ? ?)      ;12
             (house ? horse ? ? ?) ?h)
     (member (house ? ? luckystrike oj ?) ?h) ;13
     (member (house japanese ? parliaments ? ?) ?h) ;14
     (nextto (house norwegian ? ? ? ?)  ;15
             (house ? ? ? ? blue) ?h)
     (member (house ?w ? ? water ?) ?h) ;Q1
     (member (house ?z zebra ? ? ?) ?h) ;Q2
     )

;; This runs the query:

(?- (zebra ?houses ?water-drinker ?zebra-owner))

;; These are benchmarking and profiling functions.  
;; It is believed that solving zebra a
;; single time requires 12825 inferences.

(defun zebra-benchmark (&optional (n 1000))
  (declare (optimize (speed 3) (safety 0)))
  (let (rt0 rt1)
    (time (loop initially (setf rt0 (get-internal-run-time))
              repeat n do (prolog (zebra ?houses ?water-drinker ?zebra-owner)
                                  !     ; Stop once answer is found.  
                                        ; This appears to be
                                        ; what other implementations do, 
                                        ; e.g. time/1 in
                                        ; SWI Prolog.
                                  )
              finally (setf rt1 (get-internal-run-time))))
    (let (zebra-owner water-drinker houses)
      (prolog (zebra ?houses ?water-drinker ?zebra-owner)
              ;; Nearly any cons structure created by Prolog 
              ;; unification will be consed with
              ;; dynamic extent.  It isn't safe to return such 
              ;; structure outside the contour
              ;; that created it.  Prolog doesn't need to worry, 
              ;; since unification always
              ;; has dynamic extent, but arbitrary Lisp 
              ;; code needs to be careful.  The first
              ;; two values this function will return are 
              ;; symbols, but the third is a cons
              ;; tree created by Prolog unification.  In order 
              ;; to return it, the tree needs
              ;; to be copied with indefinite extent.
              (lisp (setf zebra-owner ?zebra-owner
                          water-drinker ?water-drinker
                          houses (copy-tree ?houses)))
              !)
      (values (/ (* n 12825) (/ (- rt1 rt0) 1000.0)) ; real time 
                                                     ; is milliseconds
              zebra-owner water-drinker houses))))

;;;  zebra.cl end
#+end_src

Here is Prolog code:

#+begin_src prolog

========== zebra.pl

#+end_src

****** /* -*- Mode: prolog -*-
      *
****** This file for benchmarking against SWI Prolog.
 */

#+begin_src prolog

#+end_src
****** nextto(X, Y, List) :- iright(X, Y, List).
****** nextto(X, Y, List) :- iright(Y, X, List).
****** iright(Left, Right, [Left, Right | _]).
****** iright(Left, Right, [_ | Rest]) :- iright(Left, Right, Rest).
****** zebra(H, W, Z) :-
       	 H = [house(norwegian, _, _, _, _), _, house(_, _, _, milk, _), _, _],
       	  member(house(englishman, _, _, _, red), H),
       	  member(house(spaniard, dog, _, _, _), H),

******      member(house(_, _, _, coffee, green), H),
******      member(house(ukrainian, _,  _, tea, _), H),
******      iright(house(_, _, _, _, ivory), house(_, _, _, _, green), H),
******      member(house(_, snails, winston, _, _), H),
******      member(house(_, _, kools, _, yellow), H),
******      nextto(house(_, _, chesterfield, _, _), house(_, fox, _, _, _), H),
******      nextto(house(_, _, kools, _, _), house(_, horse, _, _, _), H),
******      member(house(_, _, luckystrike, oj, _), H),
******      member(house(japanese, _, parliaments, _, _), H),
******      nextto(house(norwegian, _, _, _, _), house(_, _, _, _, blue), H),
******      member(house(W, _, _, water, _), H),
******      member(house(Z, zebra, _, _, _), H).
****** /* This runs the query a single time:
      * 
      * ?- zebra(Houses, WaterDrinker, ZebraOwner).
      */

****** zebra1(Houses, WaterDrinker, ZebraOwner) :-
             zebra(Houses, WaterDrinker, ZebraOwner), !.

****** benchmark1 :-
             flag(benchmark,_,0),
             repeat,
             zebra1(Houses, WaterDrinker, ZebraOwner),
             flag(benchmark,N,N+1),

******         N = 1000,
             !.

****** benchmark :- time(benchmark1).
****** ========== end
#+begin_src emacs-lisp :tangle yes
(shell-command "bnf2xml")
#+end_src
***** Prolog vs. Lisp
European AI researchers favored Prolog while Americans favored Lisp,
reportedly causing many nationalistic debates on the merits of the
languages
***** Pure Prolog
Pure Prolog was soon extended, however, to include negation as
failure, in which negative conditions of the form not(Bi) are shown by
trying and failing to solve the corresponding positive conditions Bi.
***** Buran Spacecraft
the software for the Buran spacecraft was written in the Prolog
programming language.
***** SWI-Prolog and Ciao, support
      server-side web programming with support for web protocols, HTML and
      XML. There are also extensions to support semantic web formats
      such as RDF and OWL. 

****** Prolog has also been suggested as a client-side language.

^ Jan Wielemaker and Michiel Hildebrand and Jacco van Ossenbruggen (2007), "Using {Prolog} as the fundament for applications on the semantic web", in S.Heymans, A. Polleres, E. Ruckhaus, D. Pearse, and G. Gupta, Proceedings of the 2nd Workshop on Applications of Logic Programming and to the web, Semantic Web and Semantic Web Services, CEUR Workshop Proceedings (Porto, Portugal: CEUR-WS.org) 287: 84–98
^ Processing OWL2 Ontologies using Thea: An Application of Logic
Programming. Vangelis Vassiliadis, Jan Wielemaker and Chris
Mungall. Proceedings of the 5th International Workshop on OWL:
Experiences and Directions (OWLED 2009), Chantilly, VA, United States,
October 23–24, 2009

OW Prolog has been created in order to answer Prolog's lack of
graphics and interface.

JPL is a bi-directional Java Prolog bridge which ships with SWI-Prolog
by default, allowing Java and Prolog to call each other
(recursively). It is known to have good concurrency support and is
under active development.

GNU Prolog for Java is an implementation of ISO Prolog as a Java
library (gnu.prolog)

Jekejeke Prolog API provides tightly coupled concurrent call-in and
call-out facilities between Prolog and Java or Android, with the
marked possibility to create individual knowledge base objects. It can
be used to embed the ISO Prolog interpreter in standalones, applets,
servlets, APKs, etc..

***** prolog and reflection
Prolog is a homoiconic language and provides many facilities for
reflection

solve(true, 1) :- !.
solve((A, B), C) :-
    !, solve(A, C1), solve(B, C2), minimum(C1, C2, C).
solve(A, 1) :-
    builtin(A), !, A.
solve(A, C) :-
    clause_cf(A, B, C1), solve(B, C2), C is C1 * C2.

builtin(A is B).
builtin(read(X)).
% etc.

and clauses represented as clause_cf(Head, Body, Certainty). Given
those, it can be called as solve(Goal, Certainty) to execute Goal and
obtain a measure of certainty about the result.
***** Prolog's single data type is the term. 
      Terms are either atoms, numbers, variables or compound terms.

      An atom is a general-purpose name with no inherent meaning. Examples
      of atoms include x, blue, 'Taco', and 'some atom'.  Numbers can be
      floats or integers.  Variables are denoted by a string consisting of
      letters, numbers and underscore characters, and beginning with an
      upper-case letter or underscore. Variables closely resemble
      variables in logic in that they are placeholders for arbitrary
      terms.  A compound term is composed of an atom called a "functor"
      and a number of "arguments", which are again terms. Compound terms
      are ordinarily written as a functor followed by a comma-separated
      list of argument terms, which is contained in parentheses. The
      number of arguments is called the term's arity. An atom can be
      regarded as a compound term with arity zero. Examples of compound
      terms are truck_year('Mazda', 1986) and
      'Person_Friends'(zelda,[tom,jim]).

****** Special cases of compound terms:
       A List is an ordered collection of terms. It is denoted by square
       	brackets with the terms separated by commas or in the case of the
       	empty list, []. For example [1,2,3] or [red,green,blue].  Strings:
       	A sequence of characters surrounded by quotes is equivalent to a
       	list of (numeric) character codes, generally in the local
       	character encoding, or Unicode if the system supports Unicode. For
       	example, "to be, or not to be".

****** Rules and facts

Prolog programs describe relations, defined by means of clauses. Pure
Prolog is restricted to Horn clauses. There are two types of clauses:
facts and rules. A rule is of the form

****** Head :- Body.

and is read as "Head is true if Body is true". A rule's body consists
of calls to predicates, which are called the rule's goals. The
built-in predicate ,/2 (meaning a 2-arity operator with name ,)
denotes conjunction of goals, and ;/2 denotes
disjunction. Conjunctions and disjunctions can only appear in the
body, not in the head of a rule.

****** Clauses with empty bodies are called facts. An example of a fact is:

cat(tom).

which is equivalent to the rule:

cat(tom) :- true.

****** The built-in predicate true/0 is always true.

Given the above fact, one can ask:

is tom a cat?

 ?- cat(tom).
 Yes

what things are cats?

 ?- cat(X).
 X = tom

****** Clauses with bodies are called rules. 
An example of a rule is:

animal(X) :- cat(X).

If we add that rule and ask what things are animals?

 ?- animal(X).
 X = tom
****** Relational nature of many built-in-predicates
Due to the relational nature of many built-in predicates, they can
typically be used in several directions. For example, length/2 can be
used to determine the length of a list (length(List, L), given a list
List) as well as to generate a list skeleton of a given length
(length(X, 5)), and also to generate both list skeletons and their
lengths together (length(X, L)). Similarly, append/3 can be used both
to append two lists (append(ListA, ListB, X) given lists ListA and
ListB) as well as to split a given list into parts (append(X, Y,
List), given a list List). For this reason, a comparatively small set
of library predicates suffices for many Prolog programs.
****** General purpose language
As a general purpose language, Prolog also provides various built-in
predicates to perform routine activities like input/output, using
graphics and otherwise communicating with the operating system. These
predicates are not given a relational meaning and are only useful for
the side-effects they exhibit on the system. For example, the
predicate write/1 displays a term on the screen.
***** Prolog program execution
Execution of a Prolog program is initiated by the user's posting of a
single goal, called the query. Logically, the Prolog engine tries to
find a resolution refutation of the negated query. The resolution
method used by Prolog is called SLD resolution. If the negated query
can be refuted, it follows that the query, with the appropriate
variable bindings in place, is a logical consequence of the
program. In that case, all generated variable bindings are reported to
the user, and the query is said to have succeeded. Operationally,
Prolog's execution strategy can be thought of as a generalization of
function calls in other languages, one difference being that multiple
clause heads can match a given call. In that case, the system creates
a choice-point, unifies the goal with the clause head of the first
alternative, and continues with the goals of that first
alternative. If any goal fails in the course of executing the program,
all variable bindings that were made since the most recent
choice-point was created are undone, and execution continues with the
next alternative of that choice-point. This execution strategy is
called chronological backtracking. For example:

mother_child(trude, sally).
 
father_child(tom, sally).
father_child(tom, erica).
father_child(mike, tom).
 
sibling(X, Y)      :- parent_child(Z, X), parent_child(Z, Y).
 
parent_child(X, Y) :- father_child(X, Y).
parent_child(X, Y) :- mother_child(X, Y).

This results in the following query being evaluated as true:

 ?- sibling(sally, erica).
 Yes

This is obtained as follows: Initially, the only matching clause-head for the query sibling(sally, erica) is the first one, so proving the query is equivalent to proving the body of that clause with the appropriate variable bindings in place, i.e., the conjunction (parent_child(Z,sally), parent_child(Z,erica)). The next goal to be proved is the leftmost one of this conjunction, i.e., parent_child(Z, sally). Two clause heads match this goal. The system creates a choice-point and tries the first alternative, whose body is father_child(Z, sally). This goal can be proved using the fact father_child(tom, sally), so the binding Z = tom is generated, and the next goal to be proved is the second part of the above conjunction: parent_child(tom, erica). Again, this can be proved by the corresponding fact. Since all goals could be proved, the query succeeds. Since the query contained no variables, no bindings are reported to the user. A query with variables, like:

?- father_child(Father, Child).

enumerates all valid answers on backtracking.

Notice that with the code as stated above, the query ?- sibling(sally,
sally). also succeeds. One would insert additional goals to describe
the relevant restrictions, if desired.
****** non-monotonic reasoning
The built-in Prolog predicate \+/1 provides negation as failure, which
allows for non-monotonic reasoning
****** In Prolog, loading code is referred to as consulting

Hello world

An example of a query:

?- write('Hello world!'), nl.
Hello world!
true.
 
?-

****** Any computation can be expressed 
       declaratively as a sequence of state transitions.
***** design pattern
A design pattern is a general reusable solution to a commonly
occurring problem in software design. 

In Prolog, design patterns go under various names: skeletons and
techniques, cliches, program schemata, and logic description schemata.

An alternative to design patterns is higher order programming.

****** higher order predicate
A higher-order predicate is a predicate that takes one or more other
predicates as arguments

call/1, call/2, call/3, findall/3, setof/3, and bagof/3

higher-order predicates like maplist/2, which applies an arbitrary
predicate to each member of a given list, and sublist/3, which filters
elements that satisfy a given predicate, also allowing for currying
****** conversions from temporal representation
to convert solutions from temporal representation (answer substitutions
on backtracking) to spatial representation (terms), Prolog has various
all-solutions predicates that collect all answer substitutions of a
given query in a list. This can be used for list comprehension. 
******* example
For example, perfect numbers equal the sum of their proper divisors:

 perfect(N) :-
     between(1, inf, N), U is N // 2,
     findall(D, (between(1,U,D), N mod D =:= 0), Ds),
     sumlist(Ds, N).

This can be used to enumerate perfect numbers, and also to check
whether a number is perfect.
****** maplist
As another example, the predicate maplist applies a predicate P to all
corresponding positions in a pair of lists:

maplist(_P, [], []).
maplist(P, [X1|X1s], [X2|X2s]) :-
   call(P, X1, X2),
   maplist(P, X1s, X2s).

When P is a function in the sense that for all X, P(X,Y) unifies Y
with a single unique value, maplist(P, Xs, Ys) is equivalent to
applying the map function in functional programming as Ys = map(P,
Xs).

Higher-order programming style in Prolog was pioneered in HiLog and
λProlog.
***** subset of first-order predicate logic
Pure Prolog is based on a subset of first-order predicate logic, Horn
clauses, which is Turing-complete. Turing completeness of Prolog can
be shown by using it to simulate a Turing machine:

turing(Tape0, Tape) :-
    perform(q0, [], Ls, Tape0, Rs),
    reverse(Ls, Ls1),
    append(Ls1, Rs, Tape).
 
perform(qf, Ls, Ls, Rs, Rs) :- !.
perform(Q0, Ls0, Ls, Rs0, Rs) :-
    symbol(Rs0, Sym, RsRest),
    once(rule(Q0, Sym, Q1, NewSym, Action)),
    action(Action, Ls0, Ls1, [NewSym|RsRest], Rs1),
    perform(Q1, Ls1, Ls, Rs1, Rs).
 
symbol([], b, []).
symbol([Sym|Rs], Sym, Rs).
 
action(left, Ls0, Ls, Rs0, Rs) :- left(Ls0, Ls, Rs0, Rs).
action(stay, Ls, Ls, Rs, Rs).
action(right, Ls0, [Sym|Ls0], [Sym|Rs], Rs).
 
left([], [], Rs0, [b|Rs0]).
left([L|Ls], Ls, Rs, [L|Rs]).

A simple example Turing machine is specified by the facts:

rule(q0, 1, q0, 1, right).
rule(q0, b, qf, 1, stay).

This machine performs incrementation by one of a number in unary
encoding: It loops over any number of "1" cells and appends an
additional "1" at the end. Example query and result:

?- turing([1,1,1], Ts).
Ts = [1, 1, 1, 1] ;

This illustrates how any computation can be expressed declaratively as
a sequence of state transitions, implemented in Prolog as a relation
between successive states of interest.

For efficiency, Prolog code is typically compiled to abstract machine
code, often influenced by the register-based Warren Abstract Machine
(WAM) instruction set.

Prolog systems typically implement a well-known optimization method
called tail call optimization (TCO) for deterministic predicates
exhibiting tail recursion or, more generally, tail calls: A clause's
stack frame is discarded before performing a call in a tail
position. Therefore, deterministic tail-recursive predicates are
executed with constant stack space, like loops in other languages.

***** term indexing
Finding clauses that are unifiable with a term in a query is linear in
the number of clauses. Term indexing uses a data structure that
enables sublinear-time lookups. Indexing only affects program
performance, it does not affect semantics.
****** research, education and pragma 
Although Prolog is widely used in research and education, Prolog and
other logic programming languages have not had a significant impact on
the computer industry in general. Most applications are small by
industrial standards, with few exceeding 100,000 lines of
code. Programming in the large is considered to be complicated
because not all Prolog compilers support modules, and there are
compatibility problems between the module systems of the major Prolog
compilers. Portability of Prolog code across implementations has
also been a problem, but developments since 2007 have meant: "the
portability within the family of Edinburgh/Quintus derived Prolog
implementations is good enough to allow for maintaining portable
real-world applications."
****** prolog performance
Software developed in Prolog has been criticised for having a high
performance penalty compared to conventional programming
languages. However, advances in implementation methods have reduced
the penalties to as little as 25%-50% for some applications.
****** prolog is not purely declarative
Prolog is not purely declarative: because of constructs like the cut
operator, a procedural reading of a Prolog program is needed to
understand it. The order of clauses in a Prolog program is
significant. Other logic programming languages, such as Datalog, are
truly declarative but restrict the language.

The syntax of Prolog does not specify which arguments of a predicate
are inputs and which are outputs. However, this information is
significant and it is recommended that it be included in the comments
Modes provide valuable information when reasoning about Prolog
programs and can also be used to accelerate execution
Prolog systems that provide a graphics library are SWI-prolog,
Visual-prolog, LPA Prolog for Windows and B-Prolog.

***** Using Prolog with AllegroGraph 3.3 (and gruff)	       :prolog:gruff:
****** IRI 
file:///archive/xk05/Downloads/agraph-fse-3.3/doc/prolog-tutorial.html   
****** index
Using Prolog with AllegroGraph 3.3

  * AllegroGraph
      + Introduction
      + Upgrade Guide
      + Recent Changes
      + HTTP/Sesame Protocol
      + Server Installation
  * Java
      + Java Tutorial
      + Learning Center (local)
      + Learning Center (franz.com)
      + Javadocs
      + Jena
  * Python
      + Python client
      + Python Tutorial
      + Python API
  * Lisp
      + Lisp Installation
      + AllegroGraph Tutorial
      + Client
      + hasValue Reasoning Tutorial
      + Freetext indexing tutorial
      + Federation tutorial
      + Temporal tutorial
      + Geospatial tutorial
      + RDFS++ Reasoning Tutorial
      + Reference Guide
      + AllegroGraph and Prolog
  * SPARQL
      + SPARQL Tutorial
      + SPARQL Reference
      + SPARQL Client
      + SPARQL Server
      + SPARQL Geospatial Extension
      + SPARQL Construct
      + Twinql Releases Notes
  * Other
      + FAQ
      + LUBM Benchmarks
      + Performance Tuning
      + Suggested Reading
      + Community Resources
      + Copyrights
  * Franz, Inc.
  * Download

***** Introduction

We would urge you to first do this tutorial and then study the Allegro Prolog
documentation if necessary. This is a basic tutorial on how to use Prolog with
AllegroGraph 3.3. It should be enough to get you going but if you have any
questions please write to us and we will help you. In this example we will focus
mainly on how to use the following constructs:

  * select
  * q-
  * q
  * <--
  * <-
  * ??
  * !

When consulting the Reference Guide, one should understand the conventions for
documenting Prolog functors. A Prolog functor clause looks like a regular Lisp
function call, the symbol naming the functor being the first element of the list
and the remaining elements being arguments. But arguments to a Prolog functor call
can either be supplied as input to the functor, or unsupplied so that the clause
might return that argument as a result by unifying some data to it, or may be a
tree of nodes containing both ground data an Prolog variables. The common example
is the functor append which has three arguments and succeeds for any solution
there the third argument is the same as the first two arguments appended. The
remarkable thing about Prolog semantics is that append is a declarative relation
that succeeds regardless which arguments are supplied as inputs and which are
supplied as outputs. <ret> indicates where the user would type a return to ask
Prolog to find the next result.

    > (?- (append (1 2) (3) ?z))  
    ?z = (1 2 3)  
    <ret>  
    No.  
    > (?- (append (1 2) ?y (1 2 3)))  
    ?y = (3)  
    <ret>  
    No.  
    > (?- (append ?x ?y (1 2 3)))  
    ?x = ()  
    ?y = (1 2 3)  
    <ret>  
    ?x = (1)  
    ?y = (2 3)  
    <ret>  
    ?x = (1 2)  
    ?y = (3)  
    <ret>  
    ?x = (1 2 3)  
    ?y = ()  
    <ret>  
    No.  
    > (?- (append ? (1 ?next . ?) (1 2 1 3 4 1 5 1)))  
    ?next = 2  
    <ret>  
    ?next = 3  
    <ret>  
    ?next = 5  
    <ret>  
    No. 

The last example successively unifies to each element in the list immediately
preceded by a 1. It shows the power of unification against partially ground tree
structure.

Now we return to the the notational convention: A functor argument that is an
input to the functor and which must be supplied is marked in the documentaiton
with a +. A functor argument that is returned by the functor and which must not be
supplied is marked with a -. An argument that can be either is marked with ±.
(Prolog documentation generally used ? for this, but in Lisp-bnased Prologs that
character is used as the first character of a symbol that is a Prolog variable,
overloading using it to indicate and input-output argument would be very
confusing.) Within this convention append would be notated as (append &plusmn;left
&plusmn;right &plusmn;result). But a functor like part= which simply checks
whether two parts are the same UPI and which requires two actual which requires
two actual furure-part or UPI arguments, would be documented (part= +upi1 +upi2)`.

The rest of this tutorial will be based on a tiny genealogy database of the
Kennedy family.

Please open the file kennedy.ntriples that came with this distribution in a text
editor or with TopBraidComposer and study the contents of the file. Notice that
people in this file have a type, sometimes multiple children, multiple spouses,
multiple professions, and go to multiple colleges or universities.

This tutorial uses Lisp as the base language but there is also a Java example with
the same content.

***** First let us get AllegroGraph ready to use:

> (require :agraph)  
;; .... output deleted.  
 
> (in-package :triple-store-user)  
#<The db.agraph.user package>  
 
> (enable-!-reader)  
#<Function read-!>  
t  
 
> (register-namespace "ex" "http://www.franz.com/simple#"  
   :errorp nil)  
"http://www.franz.com/simple#" 

Now we can create a triple-store and load it with data. The function 
create-triple-store creates a new triple-store and opens it. If you use the
triple-store name "temp/test", then AllegroGraph will create a new directory named
temp in your current directory (use the top-level command :pwd if you want to see
what this is). It will then make another directory named test as a sub-directory
of temp. All of this triple-store's data will be placed in this new directory temp
/test:

> (defun fill-kennedy-db ()   
    (create-triple-store "temp/test"  
                         :if-exists :supersede)  
    (time  
     (load-ntriples #p"sys:agraph;tutorial-files;kennedy.ntriples"))  
    (index-all-triples))  
fill-kennedy-db  
> (fill-kennedy-db)  
;; .... output deleted. 

***** So let us first look at person1 in this database:

> (print-triples  
   (get-triples-list :s !ex:person1))  
<http://www.franz.com/simple#person1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.franz.com/simple#person> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#first-name> <http://www.franz.com/simple#Joseph> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#middle-initial> <http://www.franz.com/simple#Patrick> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#last-name> <http://www.franz.com/simple#Kennedy> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#birth-year> <http://www.franz.com/simple#1888> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#death-year> <http://www.franz.com/simple#1969> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#sex> <http://www.franz.com/simple#male> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#spouse> <http://www.franz.com/simple#person2> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#suffix> <http://www.franz.com/simple#none> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person9> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person13> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person17> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person4> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person6> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person15> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person11> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person3> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person7> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#profession> <http://www.franz.com/simple#producer> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#profession> <http://www.franz.com/simple#banker> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#profession> <http://www.franz.com/simple#ambassador> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#alma-mater> <http://www.franz.com/simple#Harvard> . 

Now we are ready to try the select statement in combination with the Prolog q
functor. Let us try to find all the children of person1. Just type the following
in the listener. Afterward, I'll explain.

***** select
> (select (?x)  
   (q- !ex:person1 !ex:has-child ?x))  
(("http://www.franz.com/simple#person9")  
 ("http://www.franz.com/simple#person13")  
 ("http://www.franz.com/simple#person17")  
 ("http://www.franz.com/simple#person4")  
 ("http://www.franz.com/simple#person6")  
 ("http://www.franz.com/simple#person15")  
 ("http://www.franz.com/simple#person11")  
 ("http://www.franz.com/simple#person3")  
 ("http://www.franz.com/simple#person7")) 

select is a wrapper used around one or more Prolog statements. The first element
after select is template for the format and variables that you want to bind and
return. So in this example above we want to bind the variable ?x. The rest of the
elements tell Prolog what we want to bind ?x to.

This select statement has only one clause, namely (q- !ex:person1 !ex:has-child ?
x)`

If you have studied how get-triples works you probably can guess what happens
here. q- is a Prolog functor that is our link to the data in the triple-store. It
calls get-triples and unifies the ?x with the objects of all triples with subject
!ex:person1 and predicate !ex:has-child.

So let us make it a little bit more complex. Let us find all the children of the
children of person1. Here is how you do it:

> (select (?y)  
   (q- !ex:person1 !ex:has-child ?x)  
   (q- ?x !ex:has-child ?y))  
(("http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person26")  
 ("http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person56")  
 ("http://www.franz.com/simple#person42")  
 ("http://www.franz.com/simple#person47")  
 ("http://www.franz.com/simple#person51") ...) 

Although Prolog is a declarative language, a procedural reading of this query
works better for most people. So the previous query can be read as

    Find all triples that start with !ex:person1 !ex:has-child. For each match set
    ?x to the object of that triple; then for each triple that starts with ?x !
    ex:has-child find the ?y
   
The following example should now be easy to understand. Here we are trying to find
all the spouses of the grand-children of ?z. Notice that we ignore the ?x and ?y
in the query. The select will only return the ?z

> (select (?z)  
   (q- !ex:person1 !ex:has-child ?x)  
   (q- ?x !ex:has-child ?y)  
   (q- ?y !ex:spouse ?z))  
(("http://www.franz.com/simple#person34")  
 ("http://www.franz.com/simple#person27")  
 ("http://www.franz.com/simple#person30")  
 ("http://www.franz.com/simple#person32")  
 ("http://www.franz.com/simple#person63")  
 ("http://www.franz.com/simple#person57")  
 ("http://www.franz.com/simple#person43")  
 ("http://www.franz.com/simple#person49")  
 ("http://www.franz.com/simple#person48")  
 ("http://www.franz.com/simple#person52") ...) 

Now if you wanted to you could get the other variables back. Here is the same
query but now you also want to see the grand-child.

> (select (?y ?z)  
    (q- !ex:person1 !ex:has-child ?x)  
    (q- ?x !ex:has-child ?y)  
    (q- ?y !ex:spouse ?z))  
(("http://www.franz.com/simple#person33" "http://www.franz.com/simple#person34")  
 ("http://www.franz.com/simple#person26" "http://www.franz.com/simple#person27")  
 ("http://www.franz.com/simple#person28" "http://www.franz.com/simple#person30")  
 ("http://www.franz.com/simple#person31" "http://www.franz.com/simple#person32")  
 ("http://www.franz.com/simple#person62" "http://www.franz.com/simple#person63")  
 ("http://www.franz.com/simple#person56" "http://www.franz.com/simple#person57")  
 ("http://www.franz.com/simple#person42" "http://www.franz.com/simple#person43")  
 ("http://www.franz.com/simple#person47" "http://www.franz.com/simple#person49")  
 ("http://www.franz.com/simple#person47" "http://www.franz.com/simple#person48")  
 ("http://www.franz.com/simple#person51" "http://www.franz.com/simple#person52") ...) 

***** prolog functors
So now we understand the select and the q statement. We are halfway there. Let us
now define some Prolog functors.

The following defines a functor that says: ?x is a male if in the triple store I
can find an ?x that has the !ex:sex !ex:male.

> (<-- (male ?x)  
    (q- ?x !ex:sex !ex:male))  
male 

Let us try it out by finding all the sons of person1.

> (select (?x)  
    (q- !ex:person1 !ex:has-child ?x)  
    (male ?x)) ;;; Note how we use NO q here!  
(("http://www.franz.com/simple#person13")  
 ("http://www.franz.com/simple#person17")  
 ("http://www.franz.com/simple#person4")  
 ("http://www.franz.com/simple#person3")) 

Now this is not too exciting, and it is equivalent to the following:

(select (?x)  
 (q- !ex:person1 !ex:has-child ?x)  
 (q- ?x !ex:sex !ex:male)) 

So let us make it more complex:

> (<-- (female ?x)  
    (q- ?x !ex:sex !ex:female))  
female  
> (<-- (father ?x ?y)  
    (male ?x)  
    (q- ?x !ex:has-child ?y))  
father  
> (<-- (mother ?x ?y)  
    (female ?x)  
    (q- ?x !ex:has-child ?y))  
mother 

The female, father, mother relations are all simple to understand. The following
adds the idea of multiple rules (or functors). Notice how we define the parent
relationship with two rules, where the first rule uses <-- and the second rule
uses <-. The reason is that <-- means: wipe out all the previous rules that I had
about parent and start anew whereas <- means, add to the existing rules for
parent.

The following should be read as:

  * ?x is the parent of ?y if ?x is the father of ?y or
  * ?x is the parent of ?y if ?x is the mother of ?y.

        (<-- (parent ?x ?y)
       
    (father ?x ?y))  
    parent 
    
        (<- (parent ?x ?y)
   
    (mother ?x ?y))  
    parent 
    
So let us try it out by finding the grand children of person1

> (select (?y)  
    (parent !ex:person1 ?x)  
    (parent ?x ?y))  
(("http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person26")  
 ("http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person56")  
 ("http://www.franz.com/simple#person42")  
 ("http://www.franz.com/simple#person47")  
 ("http://www.franz.com/simple#person51") ...) 

We could have done the same thing by defining a grandparent functor. See the next
definition.

> (<-- (grandparent ?x ?y)  
    (parent ?x ?z)  
    (parent ?z ?y))  
grandparent  
> (<-- (grandchild ?x ?y)  
    (grandparent ?y ?x))  
grandchild 

And here it gets really interesting because we now go for the first time to a
recursive functor.

> (<-- (ancestor ?x ?y)  
    (parent ?x ?y))  
ancestor  
> (<-  (ancestor ?x ?y)      
    (parent ?x ?z)  
    (ancestor ?z ?y))                
ancestor 

Read the previous two expressions as

  * ?x is the ancestor of ?y if
      + ?x is the parent of ?y or
      + ?x is the parent of some person ?z and ?z is the ancestor of ?y

A descendant is of course the reverse of ancestor

> (<-- (descendant ?x ?y)  
    (ancestor ?y ?x))  
descendant 

So if we want to find all the male descendants of person1 then here is how to do
it.

> (select (?x)  
    (descendant ?x !ex:person1)  
    (male ?x))  
(("http://www.franz.com/simple#person13")  
 ("http://www.franz.com/simple#person17")  
 ("http://www.franz.com/simple#person4")  
 ("http://www.franz.com/simple#person3")  
 ("http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person47") ...) 

***** some puzzles to work out
And then here are some puzzles that you can work out for yourself.. Note the use
of not and part= in these statements. 'not' can contain any expression. part= will
compare its two arguments as UPIs; It will not unify.

> (<-- (aunt ?x ?y)  
    (father ?z ?x)  
    (female ?x)  
    (father ?z ?w)  
    (not (part= ?x ?w))  
    (parent ?w ?y))  
aunt  
> (<-- (uncle ?x ?y)  
    (father ?z ?x)  
    (male ?x)  
    (father ?z ?w)  
    (not (part= ?x ?w))  
    (parent ?w ?y))  
uncle 

And the final query: find all the children of person1 that are uncles

> (select (?x ?y)  
    (parent !ex:person1 ?x)  
    (uncle ?x ?y))  
(("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person26")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person56")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person42")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person47")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person51")  
 ...)  
> 

***** another convenient shorthand
There is another convenient shorthand to know in Allegro Prolog. It is often
necessary to use small bits of Lisp code inside a series of prolog clauses. A
typical example is here, where it is necessary inside a sequence of prolog clauses
to retrieve a value from the surrounding Lisp environment. Here we define a Lisp
function that returns the first and last name of every person born in the argument
year.

    > (defun born-in-year (year)  
        (select0 (?first-name ?last-name)  
          (lisp ?year (literal (princ-to-string year)))  
          (q- ?person !ex:birth-year ?year)  
          (q- ?person !ex:first-name ?first-name)  
          (q- ?person !ex:last-name ?last-name)))  
    born-in-year  
    > (born-in-year 1915)  
    (({Joseph} {Kennedy}) ({Robert} {Shriver}))  
    t 

The year argument may be a string or an integer, but we need to convert it to a
string since that's the way birth years are stored in this particular database.
Then the argument needs to be interned as a literal. But the important point is
that we need to get the value of year from the surrounding Lisp environments and
bind it to a Prolog variable (here named ?year) so it can be passed to q-.

This necessary transfer of data into the Prolog environment clutters the code and
makes it harder to read. The ?? syntax marker can eliminate much of this:

    > (defun born-in-year (year)  
        (select0 (?first-name ?last-name)  
          (q- ?person !ex:birth-year (?? (literal (princ-to-string year))))  
          (q- ?person !ex:first-name ?first-name)  
          (q- ?person !ex:last-name ?last-name))) 

This is nothing more than a syntactic shorthand of the previous example and
operates just like it. It eliminates the need for the Prolog variable to be
visible. The body of ?? has syntax like Lisp progn and substitutes the value
computed by the progn body into the Prolog clause.

There is a problem with the syntax for the Prolog cut and AllegroGraph's
future-part syntax. Prolog uses the exclamation point ! to denote the cut
operation. When executed, a cut clears all previous backtracking points within the
current predicate. For example,

     > (<-- (parent ?x)  
            (parent ?x ?)  
            !) 

defines a predicate that tests whether the argument person a parent, but if so
succeeds only once. The ! is traditional Prolog notation, but AllegroGraph uses
the ! character as a reader macro to create a future part, so the above definition
will signal a read error when the AllegroGraph readtable is in effect (see the !
-reader macro section).

The simplest way to resolve this is to preface the Prolog ! with a backslash in
any code that might be read with the AllegroGraph readtable in effect. The
backslash suppresses any reader macro for the following character. This adds
minimal clutter to the source code, and is completely harmless even when the
AllegroGraph readtable is not in effect.

     > (<-- (is-a-parent ?x)  
            (parent ?x ?)  
            \!) 

Be aware that sometimes names with syntax parent/2 will appear in Prolog
documentation and in the debugger. The portion of the name is the predicate name
-- also called a functor and the same as the Lisp symbol naming the predicate. The
non-negative integer after the slash is the arity, which is the number of
arguments to the predicate. Two predicates with the same functor but different
arity are completely unrelated to one another. In the example above the predicate 
parent/1 has no relation to the parent/2 predicate defined earlier in this
document and which it calls.

****** logo-franz   
Copyright (c) 2005 - 2010 Franz, Incorporated

Last updated 17 February 2010 at 14:09
**** sparql							 :sparql:rdf:
***** DONE tracker-sparql					 :sparql:rdf:
****** DONE tracker-sparql -q "SELECT ?cl WHERE { ?cl a rdfs:Class }"
Results:
  http://www.w3.org/2001/XMLSchema#string
  http://www.w3.org/2001/XMLSchema#boolean
  http://www.w3.org/2001/XMLSchema#integer
  http://www.w3.org/2001/XMLSchema#double
  http://www.w3.org/2001/XMLSchema#date
  http://www.w3.org/2001/XMLSchema#dateTime
  http://www.w3.org/2000/01/rdf-schema#Resource
  http://www.w3.org/2000/01/rdf-schema#Class
  http://www.w3.org/1999/02/22-rdf-syntax-ns#Property
  http://www.w3.org/2000/01/rdf-schema#Literal
  http://www.tracker-project.org/ontologies/tracker#Namespace
  http://www.tracker-project.org/ontologies/tracker#Ontology
  http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#InverseFunctionalProperty
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataObject
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataSource
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#InformationElement
  http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Tag
  http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Property
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Role
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Affiliation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Contact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactGroup
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactList
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactMedium
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#EmailAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAccount
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#OrganizationContact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PersonContact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PostalAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ModemNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#MessagingNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PagerNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Gender
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VoicePhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VideoTelephoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IsdnNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ParcelDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#FaxNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CarPhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactListDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PcsNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#InternationalDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#BbsNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CellPhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#DomesticDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PresenceStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMCapability
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#AuthorizationStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Document
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Software
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Media
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Visual
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Image
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RasterImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DataContainer
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemotePortAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaFileListEntry
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#VectorImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Audio
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#CompressionType
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Icon
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#TextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PlainTextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HtmlDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#OperatingSystem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaList
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Executable
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Folder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Font
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Filesystem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareService
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareItem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Presentation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemoteDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PaginatedTextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Video
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Spreadsheet
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Trash
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileHash
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SourceCode
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Application
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#EmbeddedFileDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Attachment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#ArchiveItem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Archive
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MindMap
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaStream
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#BookmarkFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FilesystemImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HardDiskPartition
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Cursor
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Bookmark
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DeletedResource
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Website
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#WebHistory
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Note
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareCategory
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareApplication
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Orientation
  http://www.tracker-project.org/ontologies/poi#ObjectOfInterest
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Equipment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HelpDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterest
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterestContent
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MimePart
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Multipart
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Message
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Email
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Attachment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailAccount
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailboxDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MessageHeader
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#IMMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Conversation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#CommunicationChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PermanentChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#TransientChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Call
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#VOIPCall
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#SMSMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessageFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#DeliveryStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#ReportReadStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MMSMessage
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#UnionParentClass
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifier
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttachmentEncoding
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#EventStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceFrequency
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attachment
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AccessClassification
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarDataObject
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#JournalStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifierRange
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeOrOrganizer
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AlarmAction
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceRule
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TodoStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimeTransparency
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalTimeEntity
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarScale
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeRole
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#BydayRulePart
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Weekday
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Trigger
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyType
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarUserType
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#ParticipationStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RequestStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalDateTime
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimezoneObservance
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Organizer
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attendee
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalPeriod
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Calendar
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyPeriod
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TriggerRelation
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Alarm
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Event
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Todo
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Freebusy
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Journal
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Timezone
  http://www.tracker-project.org/temp/scal#Calendar
  http://www.tracker-project.org/temp/scal#CalendarItem
  http://www.tracker-project.org/temp/scal#TransparencyValues
  http://www.tracker-project.org/temp/scal#Attendee
  http://www.tracker-project.org/temp/scal#AttendanceStatus
  http://www.tracker-project.org/temp/scal#AttendeeRole
  http://www.tracker-project.org/temp/scal#RSVPValues
  http://www.tracker-project.org/temp/scal#CalendarUserType
  http://www.tracker-project.org/temp/scal#Event
  http://www.tracker-project.org/temp/scal#Todo
  http://www.tracker-project.org/temp/scal#Journal
  http://www.tracker-project.org/temp/scal#EventStatus
  http://www.tracker-project.org/temp/scal#TodoStatus
  http://www.tracker-project.org/temp/scal#JournalStatus
  http://www.tracker-project.org/temp/scal#CalendarAlarm
  http://www.tracker-project.org/temp/scal#TimePoint
  http://www.tracker-project.org/temp/scal#AccessLevel
  http://www.tracker-project.org/temp/scal#RecurrenceRule
  http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#ID3Audio
  http://www.tracker-project.org/temp/nmm#MusicPiece
  http://www.tracker-project.org/temp/nmm#MusicAlbum
  http://www.tracker-project.org/temp/nmm#MusicAlbumDisc
  http://www.tracker-project.org/temp/nmm#SynchronizedText
  http://www.tracker-project.org/temp/nmm#Video
  http://www.tracker-project.org/temp/nmm#Artist
  http://www.tracker-project.org/temp/nmm#Playlist
  http://www.tracker-project.org/temp/nmm#ImageList
  http://www.tracker-project.org/temp/nmm#Photo
  http://www.tracker-project.org/temp/nmm#Flash
  http://www.tracker-project.org/temp/nmm#MeteringMode
  http://www.tracker-project.org/temp/nmm#WhiteBalance
  http://www.tracker-project.org/temp/nmm#RadioStation
  http://www.tracker-project.org/temp/nmm#DigitalRadio
  http://www.tracker-project.org/temp/nmm#AnalogRadio
  http://www.tracker-project.org/temp/nmm#RadioModulation
  http://www.tracker-project.org/temp/mto#TransferElement
  http://www.tracker-project.org/temp/mto#Transfer
  http://www.tracker-project.org/temp/mto#UploadTransfer
  http://www.tracker-project.org/temp/mto#DownloadTransfer
  http://www.tracker-project.org/temp/mto#SyncTransfer
  http://www.tracker-project.org/temp/mto#State
  http://www.tracker-project.org/temp/mto#TransferMethod
  http://www.tracker-project.org/temp/mlo#GeoLocation
  http://www.tracker-project.org/temp/mlo#GeoPoint
  http://www.tracker-project.org/temp/mlo#GeoSphere
  http://www.tracker-project.org/temp/mlo#GeoBoundingBox
  http://www.tracker-project.org/temp/mlo#LocationBoundingBox
  http://www.tracker-project.org/temp/mlo#Route
  http://www.tracker-project.org/temp/mlo#LandmarkCategory
  http://www.tracker-project.org/temp/mlo#Landmark
  http://www.tracker-project.org/temp/mlo#PointOfInterest
  http://www.tracker-project.org/temp/mfo#FeedElement
  http://www.tracker-project.org/temp/mfo#FeedChannel
  http://www.tracker-project.org/temp/mfo#FeedMessage
  http://www.tracker-project.org/temp/mfo#Enclosure
  http://www.tracker-project.org/temp/mfo#FeedSettings
  http://www.tracker-project.org/temp/mfo#Action
  http://www.tracker-project.org/temp/mfo#FeedType
  http://www.tracker-project.org/temp/mtp#ScanType
  http://www.tracker-project.org/ontologies/tracker#Volume
  http://www.tracker-project.org/temp/slo#LandmarkCategory
  http://www.tracker-project.org/temp/slo#Landmark
  http://www.tracker-project.org/temp/slo#GeoLocation
  http://www.tracker-project.org/temp/slo#Route
  http://www.tracker-project.org/ontologies/osinfo#Installer

****** DONE tracker-sparql -q "SELECT ?prefix ?ns WHERE {
   >                     ?ns a tracker:Namespace ;
   >                     tracker:prefix ?prefix
   >                 }"
Results:
  xsd, http://www.w3.org/2001/XMLSchema#
  rdf, http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs, http://www.w3.org/2000/01/rdf-schema#
  tracker, http://www.tracker-project.org/ontologies/tracker#
  nrl, http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#
  dc, http://purl.org/dc/elements/1.1/
  nie, http://www.semanticdesktop.org/ontologies/2007/01/19/nie#
  nao, http://www.semanticdesktop.org/ontologies/2007/08/15/nao#
  nco, http://www.semanticdesktop.org/ontologies/2007/03/22/nco#
  nfo, http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#
  poi, http://www.tracker-project.org/ontologies/poi#
  nmo, http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#
  ncal, http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#
  scal, http://www.tracker-project.org/temp/scal#
  nid3, http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#
  nmm, http://www.tracker-project.org/temp/nmm#
  mto, http://www.tracker-project.org/temp/mto#
  mlo, http://www.tracker-project.org/temp/mlo#
  mfo, http://www.tracker-project.org/temp/mfo#
  mtp, http://www.tracker-project.org/temp/mtp#
  fts, http://www.tracker-project.org/ontologies/fts#
  slo, http://www.tracker-project.org/temp/slo#
  osinfo, http://www.tracker-project.org/ontologies/osinfo#

***** CONSTRUCT
    "The CONSTRUCT query form returns a single RDF graph
    specified by a graph template. The result is an RDF graph
    formed by taking each query solution in the solution
    sequence, substituting for the variables in the graph
    template, and combining the triples into a single RDF
    graph by set union."
#+begin_src sparql
CONSTRUCT {
    where xk:role ("?chapel" "?leader")
    owl:Exclusion "?anti-chapel"
    , owl:Related "?chancel"
    , owl:Members ("?altar" "?choir")
    }
#+end_src
*** elisp							      :elisp:
**** (if TRUE-OR-FALSE-TEST ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)

#+BEGIN_SRC emacs-lisp
(if (> 5 4)                             ; if-part
    (message "5 is greater than 4!"))   ; then-part
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       (if (equal characteristic 'fierce)
           (message "It's a tiger!")))

(type-of-animal 'fierce)

(type-of-animal 'zebra)

#+END_SRC

#+BEGIN_EXAMPLE
(defun NAME-OF-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       BODY...)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
(defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       BODY: THE `if' EXPRESSION)
#+END_EXAMPLE

**** (let VARLIST BODY)

#+begin_example
(let ((VARIABLE VALUE)
           (VARIABLE VALUE)
           ...)
       BODY...)
#+end_example

#+begin_src emacs-lisp
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
#+end_src

**** TODO problems with macros					      :debug:
***** repeated expansion (how many times is the macro expanded?)
Captured [2014-06-06 Fri 18:47]
  13.5.5 How Many Times is the Macro Expanded?
  --------------------------------------------
  
  Occasionally problems result from the fact that a macro call is
  expanded each time it is evaluated in an interpreted function, but is
  expanded only once (during compilation) for a compiled function.  If the
  macro definition has side effects, they will work differently depending
  on how many times the macro is expanded.
  
     Therefore, you should avoid side effects in computation of the macro
  expansion, unless you really know what you are doing.
  
     One special kind of side effect can't be avoided: constructing Lisp
  objects.  Almost all macro expansions include constructed lists; that is
  the whole point of most macros.  This is usually safe; there is just one
  case where you must be careful: when the object you construct is part
  of a quoted constant in the macro expansion.
  
     If the macro is expanded just once, in compilation, then the object
  is constructed just once, during compilation.  But in interpreted
  execution, the macro is expanded each time the macro call runs, and this
  means a new object is constructed each time.
  
     In most clean Lisp code, this difference won't matter.  It can matter
  only if you perform side-effects on the objects constructed by the macro
  definition.  Thus, to avoid trouble, *avoid side effects on objects
  constructed by macro definitions*.  Here is an example of how such side
  effects can get you into trouble:
  
       (defmacro empty-object ()
         (list 'quote (cons nil nil)))
  
       (defun initialize (condition)
         (let ((object (empty-object)))
           (if condition
               (setcar object condition))
           object))
  
  If `initialize' is interpreted, a new list `(nil)' is constructed each
  time `initialize' is called.  Thus, no side effect survives between
  calls.  If `initialize' is compiled, then the macro `empty-object' is
  expanded during compilation, producing a single "constant" `(nil)' that
  is reused and altered each time `initialize' is called.
****** think of 'empty-object' as a funny kind of constant  
     One way to avoid pathological cases like this is to think of
  `empty-object' as a funny kind of constant, not as a memory allocation
  construct.  You wouldn't use `setcar' on a constant such as `'(nil)',
  so naturally you won't use it on `(empty-object)' either.
  
  [[info:elisp#Repeated%20Expansion][info:elisp#Repeated Expansion]]

empty-object is not a memory allocation construct

***** evaluating macro arguments in expansion
Captured [2014-06-06 Fri 18:46]
  13.5.4 Evaluating Macro Arguments in Expansion
  ----------------------------------------------
  
  Another problem can happen if the macro definition itself evaluates any
  of the macro argument expressions, such as by calling `eval' (*note
  Eval::).  If the argument is supposed to refer to the user's variables,
  you may have trouble if the user happens to use a variable with the
  same name as one of the macro arguments.  Inside the macro body, the
  macro argument binding is the most local binding of this variable, so
  any references inside the form being evaluated do refer to it.  Here is
  an example:
  
       (defmacro foo (a)
         (list 'setq (eval a) t))
       (setq x 'b)
       (foo x) ==> (setq b t)
            => t                  ; and `b' has been set.
       ;; but
       (setq a 'c)
       (foo a) ==> (setq a t)
            => t                  ; but this set `a', not `c'.
  
     It makes a difference whether the user's variable is named `a' or
  `x', because `a' conflicts with the macro argument variable `a'.
  
     Another problem with calling `eval' in a macro definition is that it
  probably won't do what you intend in a compiled program.  The byte
  compiler runs macro definitions while compiling the program, when the
  program's own computations (which you might have wished to access with
  `eval') don't occur and its local variable bindings don't exist.
****** don't evaluate an argument expression while computing the macro expansion  
       To avoid these problems, *don't evaluate an argument expression
    while computing the macro expansion*.  Instead, substitute the
    expression into the macro expansion, so that its value will be computed
    as part of executing the expansion.  This is how the other examples in
    this chapter work.
    
    [[info:elisp#Eval%20During%20Expansion][info:elisp#Eval During Expansion]]

***** local variables in macro expansions
Captured [2014-06-06 Fri 18:45]
  13.5.3 Local Variables in Macro Expansions
  ------------------------------------------
  
  In the previous section, the definition of `for' was fixed as follows
  to make the expansion evaluate the macro arguments the proper number of
  times:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         `(let ((,var ,init)
                (max ,final))
            (while (<= ,var max)
              ,@body
              (inc ,var))))
  
  The new definition of `for' has a new problem: it introduces a local
  variable named `max' which the user does not expect.  This causes
  trouble in examples such as the following:
  
       (let ((max 0))
         (for x from 0 to 10 do
           (let ((this (frob x)))
             (if (< max this)
                 (setq max this)))))
  
  The references to `max' inside the body of the `for', which are
  supposed to refer to the user's binding of `max', really access the
  binding made by `for'.
  
     The way to correct this is to use an uninterned symbol instead of
  `max' (*note Creating Symbols::).  The uninterned symbol can be bound
  and referred to just like any other symbol, but since it is created by
  `for', we know that it cannot already appear in the user's program.
  Since it is not interned, there is no way the user can put it into the
  program later.  It will never appear anywhere except where put by
  `for'.  Here is a definition of `for' that works this way:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         (let ((tempvar (make-symbol "max")))
           `(let ((,var ,init)
                  (,tempvar ,final))
              (while (<= ,var ,tempvar)
                ,@body
                (inc ,var)))))
  
  This creates an uninterned symbol named `max' and puts it in the
  expansion instead of the usual interned symbol `max' that appears in
  expressions ordinarily.
  
  [[info:elisp#Surprising%20Local%20Vars][info:elisp#Surprising Local Vars]]

***** evaluating macro arguments repeatedly
Captured [2014-06-06 Fri 18:44]
  File: elisp.info,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Prev: Wrong Time,  Up: Problems with Macros
  
  13.5.2 Evaluating Macro Arguments Repeatedly
  --------------------------------------------
  
  When defining a macro you must pay attention to the number of times the
  arguments will be evaluated when the expansion is executed.  The
  following macro (used to facilitate iteration) illustrates the problem.
  This macro allows us to write a "for" loop construct.
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple \"for\" loop.
       For example, (for i from 1 to 10 do (print i))."
         (list 'let (list (list var init))
               (cons 'while
                     (cons (list '<= var final)
                           (append body (list (list 'inc var)))))))
  
       (for i from 1 to 3 do
          (setq square (* i i))
          (princ (format "\n%d %d" i square)))
       ==>
       (let ((i 1))
         (while (<= i 3)
           (setq square (* i i))
           (princ (format "\n%d %d" i square))
           (inc i)))
  
            -|1       1
            -|2       4
            -|3       9
       => nil
  
  The arguments `from', `to', and `do' in this macro are "syntactic
  sugar"; they are entirely ignored.  The idea is that you will write
  noise words (such as `from', `to', and `do') in those positions in the
  macro call.
  
     Here's an equivalent definition simplified through use of backquote:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple \"for\" loop.
       For example, (for i from 1 to 10 do (print i))."
         `(let ((,var ,init))
            (while (<= ,var ,final)
              ,@body
              (inc ,var))))
  
     Both forms of this definition (with backquote and without) suffer
  from the defect that FINAL is evaluated on every iteration.  If FINAL
  is a constant, this is not a problem.  If it is a more complex form,
  say `(long-complex-calculation x)', this can slow down the execution
  significantly.  If FINAL has side effects, executing it more than once
  is probably incorrect.
  
     A well-designed macro definition takes steps to avoid this problem by
  producing an expansion that evaluates the argument expressions exactly
  once unless repeated evaluation is part of the intended purpose of the
  macro.  Here is a correct expansion for the `for' macro:
  
       (let ((i 1)
             (max 3))
         (while (<= i max)
           (setq square (* i i))
           (princ (format "%d      %d" i square))
           (inc i)))
  
     Here is a macro definition that creates this expansion:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         `(let ((,var ,init)
                (max ,final))
            (while (<= ,var max)
              ,@body
              (inc ,var))))
  
     Unfortunately, this fix introduces another problem, described in the
  following section.
  
  [[info:elisp#Argument%20Evaluation][info:elisp#Argument Evaluation]]

***** wrong time
Captured [2014-06-06 Fri 18:43]
  13.5.1 Wrong Time
  -----------------
  
  The most common problem in writing macros is doing some of the real
  work prematurely--while expanding the macro, rather than in the
  expansion itself.  For instance, one real package had this macro
  definition:
  
       (defmacro my-set-buffer-multibyte (arg)
         (if (fboundp 'set-buffer-multibyte)
             (set-buffer-multibyte arg)))
  
     With this erroneous macro definition, the program worked fine when
  interpreted but failed when compiled.  This macro definition called
  `set-buffer-multibyte' during compilation, which was wrong, and then
  did nothing when the compiled package was run.  The definition that the
  programmer really wanted was this:
  
       (defmacro my-set-buffer-multibyte (arg)
         (if (fboundp 'set-buffer-multibyte)
             `(set-buffer-multibyte ,arg)))
  
  This macro expands, if appropriate, into a call to
  `set-buffer-multibyte' that will be executed when the compiled program
  is actually run.
  [[info:elisp#Wrong%20Time][info:elisp#Wrong Time]]

**** kill ring concepts
Captured [2014-06-06 Fri 14:00]
  32.8.1 Kill Ring Concepts
  -------------------------
  
  The kill ring records killed text as strings in a list, most recent
  first.  A short kill ring, for example, might look like this:
  
       ("some text" "a different piece of text" "even older text")
  
  When the list reaches `kill-ring-max' entries in length, adding a new
  entry automatically deletes the last entry.
  
     When kill commands are interwoven with other commands, each kill
  command makes a new entry in the kill ring.  Multiple kill commands in
  succession build up a single kill ring entry, which would be yanked as a
  unit; the second and subsequent consecutive kill commands add text to
  the entry made by the first one.
  
     For yanking, one entry in the kill ring is designated the "front" of
  the ring.  Some yank commands "rotate" the ring by designating a
  [[info:elisp#Kill%20Ring%20Concepts][info:elisp#Kill Ring Concepts]]

**** (setq list (cons newelt list))
**** use of a special variable as a formal argument in a function 
     is discouraged.
**** resist the temptation to use error handling to transfer control
 Resist the temptation to use error handling to transfer control from
one part of the program to another; use `catch' and `throw' instead.
*Note Catch and Throw::.
**** TODO function definitions
     It is helpful to think of the five parts of a function definition
     as being organized in a template, with slots for each part:

       (defun FUNCTION-NAME (ARGUMENTS...)
       	 "OPTIONAL-DOCUMENTATION..."
       	 (interactive ARGUMENT-PASSING-INFO)     ; optional
       	 BODY...)

***** the 5 parts
      function-name
      arguments
      optional-documentation
      argument-passing-info
      body

**** TODO errors						:elisp:debug:
***** 10.5.3.4 Error Symbols and Condition Names
Captured [2014-06-01 Sun 22:33]
  File: elisp.info,  Node: Error Symbols,  Prev: Handling Errors,  Up: Errors
  
  10.5.3.4 Error Symbols and Condition Names
  ..........................................
  
  When you signal an error, you specify an "error symbol" to specify the
  kind of error you have in mind.  Each error has one and only one error
  symbol to categorize it.  This is the finest classification of errors
  defined by the Emacs Lisp language.
  
     These narrow classifications are grouped into a hierarchy of wider
  classes called "error conditions", identified by "condition names".
  The narrowest such classes belong to the error symbols themselves: each
  error symbol is also a condition name.  There are also condition names
  for more extensive classes, up to the condition name `error' which
  takes in all kinds of errors (but not `quit').  Thus, each error has
  one or more condition names: `error', the error symbol if that is
  distinct from `error', and perhaps some intermediate classifications.
  
     In order for a symbol to be an error symbol, it must have an
  `error-conditions' property which gives a list of condition names.
  This list defines the conditions that this kind of error belongs to.
  (The error symbol itself, and the symbol `error', should always be
  members of this list.)  Thus, the hierarchy of condition names is
  defined by the `error-conditions' properties of the error symbols.
  Because quitting is not considered an error, the value of the
  `error-conditions' property of `quit' is just `(quit)'.
  
     In addition to the `error-conditions' list, the error symbol should
  have an `error-message' property whose value is a string to be printed
  when that error is signaled but not handled.  If the error symbol has
  no `error-message' property or if the `error-message' property exists,
  but is not a string, the error message `peculiar error' is used.  *Note
  Definition of signal::.
  
     Here is how we define a new error symbol, `new-error':
  
       (put 'new-error
            'error-conditions
            '(error my-own-errors new-error))
       => (error my-own-errors new-error)
       (put 'new-error 'error-message "A new error")
       => "A new error"
  
  This error has three condition names: `new-error', the narrowest
  classification; `my-own-errors', which we imagine is a wider
  classification; and `error', which is the widest of all.
  
     The error string should start with a capital letter but it should
  not end with a period.  This is for consistency with the rest of Emacs.
  
     Naturally, Emacs will never signal `new-error' on its own; only an
  explicit call to `signal' (*note Definition of signal::) in your code
  can do this:
  
       (signal 'new-error '(x y))
            error--> A new error: x, y
  
     This error can be handled through any of the three condition names.
  This example handles `new-error' and any other errors in the class
  `my-own-errors':
  
       (condition-case foo
           (bar nil t)
         (my-own-errors nil))
  
     The significant way that errors are classified is by their condition
  names--the names used to match errors with handlers.  An error symbol
  serves only as a convenient way to specify the intended error message
  and list of condition names.  It would be cumbersome to give `signal' a
  list of condition names rather than one error symbol.
  
     By contrast, using only error symbols without condition names would
  seriously decrease the power of `condition-case'.  Condition names make
  it possible to categorize errors at various levels of generality when
  you write an error handler.  Using error symbols alone would eliminate
  all but the narrowest level of classification.
  
     *Note Standard Errors::, for a list of the main error symbols and
  their conditions.
  
  [[info:elisp#Error%20Symbols][info:elisp#Error Symbols]]

**** Completion::M-TAB knows what you need

     Emacs would not be Emacs without completion, and Org mode uses it
     whenever it makes sense.  If you prefer an iswitchb- or ido-like
     interface for some of the completion prompts, you can specify your
     preference by setting at most one of the variables
     `org-completion-use-iswitchb' `org-completion-use-ido'.

     Org supports in-buffer completion.  This type of completion does not
     make use of the minibuffer.  You simply type a few letters into the
     buffer and use the key to complete text right there.

     `M-<TAB>'
     Complete word at point
          * At the beginning of a headline, complete TODO keywords.

          * After `\', complete TeX symbols supported by the exporter.

          * After `*', complete headlines in the current buffer so that
            they can be used in search links 
	    like `[[*find this headline]]'.

          * After `:' in a headline, complete tags.  The list of tags is
            taken from the variable `org-tag-alist' (possibly set through
            the `#+TAGS' in-buffer option, *note Setting tags::), or it
            is created dynamically from all tags used in the current
            buffer.

          * After `:' and not in a headline, complete property keys.  The
            list of keys is constructed dynamically from all keys used in
            the current buffer.

          * After `[', complete link abbreviations 
	    (*note Link abbreviations::).

          * After `#+', complete the special keywords like `TYP_TODO' or
            `OPTIONS' which set file-specific options for Org mode.  When
            the option keyword is already complete, pressing `M-<TAB>'
            again will insert example settings for this keyword.

          * In the line after `#+STARTUP: ', complete startup keywords,
            i.e., valid keys for this line.

          * Elsewhere, complete dictionary words using Ispell.

**** *we discourage redefinition of primitive functions*

*** third-party content security issues				    :defense:

    Captured [2014-05-30 Fri 14:54]
    Title: Complexity as the Enemy of Security
    Date: Tue, 27 May 2014 10:27:12 PDT
    Feed: Krebs on Security
    Link: http://krebsonsecurity.co[...]as-the-enemy-of-security/
   
    Late last month, hackers allied with the Syrian Electronic Army
    (SEA) compromised the Web site for the RSA Conference, the world's
    largest computer security gathering. The attack, while unremarkable
    in many ways, illustrates the continued success of phishing attacks
    that spoof top executives within targeted organizations. It's also
    a textbook example of how third-party content providers can be
    leveraged to break into high-profile Web sites.

*** perl							  :rdf:shell:
**** command line (emacs -batch)  
    #!/usr/bin/perl

       # define the Emacs command to run
       $cmd = "emacs -batch -l ~/.emacs -eval '(org-batch-agenda-csv \"t\")'";

       # run it and capture the output
       $agenda = qx{$cmd 2>/dev/null};

       # loop over all lines
       foreach $line (split(/\n/,$agenda)) {
       	 # get the individual values
       	 ($category,$head,$type,$todo,$tags,$date,$time,$extra,
          $priority_l,$priority_n) = split(/,/,$line);
       	 # process and print
       	 print "[ ] $head\n";
       }

*** negative-assertion						  :rdf:debug:
    (non) is sometimes failure, sometimes not failure
**** a test for three cases
***** :non a :failure
***** :non a :success
***** :non a :no-result
*** average post size
Captured [2014-05-30 Fri 11:12]
  Title: Irreal: Calculating My Average Post Size
  Date: Thu, 29 May 2014 02:36:00 PDT
  Feed: Planet Emacsen
  Link: http://irreal.org/blog/?p=2719
  
  Most of my posts are pretty short: maybe 250 words or so. The other
  day, I began to wonder how long the average post is so I wrote a few
  lines of Elisp code and just executed it in the scratch buffer. 
  
  Here’s the code: 
  
  (let ((posts 0) (words 0))
    (mapc (lambda(p)
            (with-temp-buffer
              (insert-file-contents p)
              (goto-char 1)
              (setq words (+ words (how-many "\\w+")))
              (setq posts (1+ posts))))
          (directory-files "~/org/blog" t ".*\\.org"))
    (format "Total words: %s, Average per Post: %s" words (/ words posts)))
  
  As you can see there’s nothing special in it. The only points worthy
  of note are the use of with-temp-buffer and =insert-file-contents
  instead of find-file, a trick I learned from Xah Lee, and the use of
  directory-files, which is a nice way of getting a list of files
  satisfying some regex. 
  
  When I run the code I get 
  
  Total words: 362460, Average per Post: 303
  
  so my posts are a bit longer than I thought. It’s also interesting
  that in the 3 years I’ve been posting to Irreal, I’ve written about
  360,000 words or 120,000 words a year. That’s about a novel’s worth of
  words a year. Now if I could only write a novel.

*** cl-org-parser ebnf-ish

#+BEGIN_EXAMPLE
org                    := ( :org org-header org-section org-entry* )
org-header             := ( :header org-option* )
org-entry              := ( :entry org-headline org-section org-entry* )
org-headline           := ( :stars <integer> org-entry-title org-headline-tag* [ org-entry-tags ] )
org-entry-title        := :title <string>
org-headline-tag       := :commented t
                        | :quoted t
                        | :todo <keyword>
                        | :priority <string>
org-entry-tags         := :tags ( <string>* )
org-section            := ( :section org-section-component* )
org-section-component  := org-element
                        | org-greater-element
                        | org-affiliated-keyword
org-element            := <string>
org-greater-element    := org-greater-block
                        | org-dynamic-block
                        | org-drawer
org-greater-block      := ( :block         <string> [ :parameters <string> ] :contents org-section )
org-dynamic-block      := ( :dynamic-block <string> [ :parameters <string> ] :contents org-section )
org-drawer             := org-basic-drawer
                        | org-property-drawer
org-basic-drawer       := ( :basic-drawer    <string> :contents org-section )
org-property-drawer    := ( :property-drawer <string> :contents ( org-property* ) )
org-property           := ( :property <string> :value <string> )
org-affiliated-keyword := org-keyword
                        | org-attribute
org-keyword            := ( :keyword   <string> [ :optional <string> ] :value <string> )
org-attribute          := ( :attribute <string> [ :optional <string> ] :value <string> )
#+END_EXAMPLE

**** features

    mark element(s)
    
    convert elements from org to turtle

    invoke rapper to produce ntriples buffer

    mark parser errors

    comment out or delete parser messages in parser output buffer

    save parser buffer to .nt file

    another way is to do the 'parsing' entirely in elisp, this might
    be better, actually, maybe even easier

    org-elements has a couple of variables and functions that
    basically have done alot or most of the work, what needs to be
    done is to read the parse tree and output the result of the read
    in ntriples. it may be easier to simply output in ntriples than
    going for an intermediate step of using turtle.

    there are a couple different things to consider. first, how
    sophisticated to i need the outputted file to be? it will be
    better to start with simple output, like property lists and
    rdfs:type declarations to begin with than to try and capture all
    of the owl and rdf elements at once

    an interesting consequence is that its probably that i wont have
    all the rdfs and owl compliant predicates ready for direct
    translation to begin with. this may mean an ongoing process where
    rdfs and owl ready translations are elicited as i go.

    for instance, say i have a headline with two subheadlines, each
    with a body of text and a property list. the subheadlines might be
    properties and the text bodies of the subheadlines might be
    properties of properties. this doesnt seem to jibe very well with
    the way org-elements is currently designed because the
    subheadlines have property lists already under the :properties:
    symbols. this might not be an issue, however, if i treat the text
    as just another property. however, this might not be such a good
    idea because the point of conversion to .nt is to capture (subject
    predicate object) relationships.

    property drawers with rdfs and owl compliant property values will
    be helpful in creating the correct ntriples for an element and can
    be made a part of the .org file.

    preparing the .org file

    basically there will be two types of predicate sources to work
    with:
    first, this predicate sources that derive from the structure of
    org-elements. these are the predicates that derive from the way an
    org document is structured and do not depend on user designated
    property lists
    second, are user designated property lists introduced
    with :properties:

    there will be alot of stuff that's in the org-element parse tree
    that i really am not going to want in the .nt file, that
    represents stuff for org internals and emacs specific use that im
    not going to want cluttering things up. therefor my default
    strategy is going to be basically picking out some specific things
    that i want to capture to triples and ignoring the rest

    a way to do start doing this is with a simple interactive function
    that does one thing, creates a triple from a headline element,
    consing onto each element the appropriate URI information.

    where a turtle or n3 stage might be useful here, and why i might
    want to resort to an external parser, is the readability of the
    output of my 'triplize' function while im working. if i do it with
    eval and print then its going to output a ntriple that will most
    likely run right off the end of the screen and making it less
    readable.

    as a stage, will it be a big deal if im producing turtle notation
    that i can process with raptor, or some other parser/printer?
    surely not, although i eventually want to be producing ntriples
    for gruff, or at least until i can get a 64bit laptop so i can run
    later versions of gruff that can read more file formats.

    ergo, i can create some source blocks

    first, i want to eval and print the org-elements parse tree

#+BEGIN_SRC emacs-lisp :results output
(require 'ox)


#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results output
(let ((oem (org-element-map))
        (oem 'org-element-map)
;    (print (format "%s %f" "OEM: " (eval org-element-map)))
    (print (format "%s %d" "OEM: " (eval org-element-map) nil)
    (print "End of org-element-map"))
#+end_src

#+name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."

***** introduce org-babel to =xml= and =n3=

#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

**** library-of-stuff
***** custom query of user before evaluating code block
   :PROPERTIES:
   :DATE:     2012-02-08
   :END:
#+begin_src sh :eval (if (y-or-n-p "Run operation X?") "yes" "no")
  echo "Going ahead with operation X!"
#+end_src
***** call line which dumps out its own header argument info
   :PROPERTIES:
   :DATE:     2012-02-05
   :END:
This call line passes its in-buffer location to a code block.  Notice
that the call to =(point)= in the call line is saved into a header
argument named =:my-point= and is then retrieved by the variable
initialization.  This indirection is required because of /when/ and
/where/ the elisp forms in header arguments are evaluated, a simpler
call line like =#+call: show:((point))= would not work because the
form =(point)= would not be evaluated in the correct place.

#+call: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info)))) :special-header "foo"

The special header argument =:special-header= may be seen in the
output below.  The =results= variable is due to the way that call
lines are evaluated.  During evaluation a call line is converted into
a trivial elisp code block of the form
: #+begin_src emacs-lisp :var results=called-function()
:   results
: #+end_src
which is evaluated in place.

#+RESULTS: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info))))
| (:var results ((:var nil)) ((:colname-names)) ((:rowname-names)) ((:result-params replace)) ((:result-type . value)) ((:comments . )) ((:shebang . )) ((:cache . no)) ((:padline . )) ((:noweb . yes)) ((:tangle . no)) ((:exports . code)) ((:results . replace)) ((:padnewline . yes)) ((:hlines . no)) ((:session . none))) |
| (:colname-names)                                                                                                                                                                                                                                                                                                               |
| (:rowname-names)                                                                                                                                                                                                                                                                                                               |
| (:result-params replace)                                                                                                                                                                                                                                                                                                       |
| (:result-type . value)                                                                                                                                                                                                                                                                                                         |
| (:comments . )                                                                                                                                                                                                                                                                                                                 |
| (:shebang . )                                                                                                                                                                                                                                                                                                                  |
| (:cache . no)                                                                                                                                                                                                                                                                                                                  |
| (:padline . )                                                                                                                                                                                                                                                                                                                  |
| (:noweb . yes)                                                                                                                                                                                                                                                                                                                 |
| (:tangle . no)                                                                                                                                                                                                                                                                                                                 |
| (:exports . code)                                                                                                                                                                                                                                                                                                              |
| (:results . replace)                                                                                                                                                                                                                                                                                                           |
| (:special-header . foo)                                                                                                                                                                                                                                                                                                        |
| (:padnewline . yes)                                                                                                                                                                                                                                                                                                            |
| (:hlines . no)                                                                                                                                                                                                                                                                                                                 |
| (:session . none)                                                                                                                                                                                                                                                                                                              |

This code block visits the location of the call line, and calculates
the info using the same mechanisms used by =org-babel-lob-execute=.
#+name: show
#+begin_src emacs-lisp :var call-line-location=0
  (let ((call-info (save-excursion
                     (goto-char call-line-location)
                     (org-babel-lob-get-info))))
    (mapcar #'list
            (org-babel-process-params
             (org-babel-merge-params
              org-babel-default-header-args
              (org-babel-params-from-properties)
              (org-babel-parse-header-arguments
               (org-babel-clean-text-properties
                (concat ":var results="
                        (mapconcat #'identity (butlast call-info) " "))))))))
#+end_src
***** noweb insertion edge cases
   :PROPERTIES:
   :DATE:     2012-01-24
   :END:
The =cat= line below is dangerously close to a noweb reference.  The
space after test.org keeps it from being interpreted as a noweb
reference.

#+begin_src sh :tangle test.out :noweb yes
  <<task1>>
  <<b>>
  cat <<test.org >> test.out2
#+end_src

#+begin_src sh :noweb-ref task1
 echo "hello world"
#+end_src

#+BEGIN_SRC sh :noweb-ref b
 echo "b"
#+END_SRC

***** issues with call lines result insertion
   :PROPERTIES:
   :session:  *R-babel*
   :DATE:     2012-01-24
   :END:
#+NAME: foo-for-R
#+HEADER: :var a="a1.png"
#+BEGIN_SRC R :results output silent
  cat("in foo-for-R block\n")
  cat.a <- function() { cat(a,"\n",sep="") }
  cat.a()
#+END_SRC

#+NAME: bar-for-R
#+begin_src R :results output raw replace :exports none
 cat.a()
#+end_src

Because there are three instances of the =bar-for-R()= call line, all
of their results are inserted into the same place in the file,
specifically the location of the =#+Results: bar-for-R()= line.  This
can be very confusing if you are expected each =bar-for-R()= line to
generate it's own results.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R()

The solution demonstrated below is to add a nothing header argument to
each bar-for-R to make it unique.  Notice that the three =foo= lines
below don't include results, as their results are inserted at the
identical foo lines above.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R[id=1]()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R[id=2]()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R[id=3]()

***** name src_emacs-lisp{org-current-export-file}
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
Fanciness with running code in header arguments.

One block to tangle.
#+BEGIN_SRC emacs-lisp :tangle yes
  (message "I am tangled")
#+END_SRC

One block to export.
#+BEGIN_SRC emacs-lisp :exports results :var foo=(org-babel-tangle)
  (message "I just tangled %S during export" foo)
#+END_SRC

***** inhibit some call line evaluation on export
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
A buffer in which we want =foo= to be run when called interactively
from /any/ call line, but to only be run by a single call line on
export.  Ensure this works by executing this buffer to html while
tracking =foo-called.times= with =tail -f /tmp/foo-called.times=.

#+NAME: foo
#+BEGIN_SRC sh :var id="foo"
  echo "called by $id at $(date +%s.%N)" |tee -a /tmp/foo-called.times
#+END_SRC

This will *not* be run on export.
#+call: foo[:eval no-export]("bar")

This *will* be run on export.
#+call: foo("baz")

***** code block export template
   :PROPERTIES:
   :DATE:     2012-01-14
   :END:

The =org-babel-exp-code-template= (see below for its documentation)
variable may be customized to control which information from code
blocks is exported.

- Example code block
  #+Name: foo
  #+BEGIN_SRC sh :bar baz
    echo qux
  #+END_SRC

- Evaluate this block to export (shows the export of the name).
  #+Name: do-export-name
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "\n=%name=:\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

- Evaluate this block to export (shows the export of header arguments).
  #+Name: do-export-header-arguments
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "Header arguments for =%name=.
    | header  | value    |
    |---------+----------|
    | bar     | %bar     |
    | results | %results |\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

: ,----[org-babel-exp-code-template]
: | org-babel-exp-code-template is a variable defined in `ob-exp.el'.
: | Its value is "#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"
: | 
: | Documentation:
: | Template used to export the body of code blocks.
: | This template may be customized to include additional information
: | such as the code block name, or the values of particular header
: | arguments.  The template is filled out using `org-fill-template',
: | and the following %keys may be used.
: | 
: |  lang ------ the language of the code block
: |  name ------ the name of the code block
: |  body ------ the body of the code block
: |  flags ----- the flags passed to the code block
: | 
: | In addition to the keys mentioned above, every header argument
: | defined for the code block may be used as a key and will be
: | replaced with its value.
: | 
: | You can customize this variable.
: `----

***** simple R session
   :PROPERTIES:
   :DATE:     2011-09-21
   :END:
#+begin_src R :session R
  paste("Yep!")
#+end_src

#+name:
: Yep!

***** should this throw an error for no variable definition
   :PROPERTIES:
   :DATE:     2011-09-15
   :END:
Evaluating this block should raise an error that there are
uninitialized variables.

#+name: add-column-in-table(table="", column="", something, type="", else, nullability)
#+begin_src sql
-- add column `$column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '$table'
               AND COLUMN_NAME = '$column')
BEGIN
    ALTER TABLE $table
    ADD $column $type $nullability
END
#+end_src

***** header arguments on call lines
   :PROPERTIES:
   :DATE:     2011-09-11
   :END:
#+name: simple-example
#+begin_src emacs-lisp
  "the result"
#+end_src

#+call: simple-example()

#+name: simple-example()
: the result

#+call: simple-example() :results raw

#+name: simple-example()
the result

***** removing result with a silent header argument
   :PROPERTIES:
   :DATE:     2011-09-07
   :END:
evaluating the following code block will remove the related result.

#+begin_src sh :results silent
  date +%Y-%m-%d
#+end_src

#+name:
: 2011-09-07

***** silent results in org but not in export
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
The results of the following code block will not be inserted during
interactive evaluation but will during export.

#+begin_src sh :results (if org-current-export-file "replace" "silent") :exports both
  echo  "I want to see this in HTML/PDF, but not in Org"
#+end_src

***** leading commas in code blocks
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
#+begin_src r :exports code
  a <- c(1
         , 2
         , 3)
#+end_src

#+begin_src org :exports code
  ,this one will have commas removed
  ,#+begin_src R
  ,  a <- c(1
  ,         , 2
  ,         , 3)
  ,#+end_src
#+end_src

***** returning file type to inline call line
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec
hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam
nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis
natoque penatibus et magnis dis parturient montes, nascetur ridiculus
mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non
turpis. call_nothing_to_something()[:results file] [[file:something.txt]]
Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan
nisl.

#+name: nothing_to_something
#+begin_src sh :file something.txt
  echo nothing
#+end_src

***** demarcation of indented blocks
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Demarcating a block with the point part-way in a line should indent
the remainder of the line in the second block.
    #+begin_src sh
      echo 1
      echo 2
      echo 3
      echo 4
    #+end_src

becomes

    #+begin_src sh :results silent :session something
      echo 1
      echo 2
      echo
    #+end_src
    
    #+begin_src sh :results silent :session something
           3
      echo 4
    #+end_src

***** simple indexing
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+name: list-o-numbers
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src sh :var column=list-o-numbers[,0]
  echo $column
#+end_src

#+name:
: 1 4 7

***** simple gnuplot plotting of Org-mode tables
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+tblname: gnuplot-testing
| x |  y |
|---+----|
| 1 |  2 |
| 2 |  4 |
| 3 |  6 |
| 4 |  8 |
| 5 | 10 |
| 6 | 12 |
| 7 | 14 |
| 8 | 16 |

#+begin_src gnuplot :var data=gnuplot-testing :file output.eps
set term postscript
set title "test"
set auto x
set style data histogram
set style fill solid border -1
set boxwidth 0.9
plot data using 2:xtic(1)
#+end_src

***** simple short R block
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+BEGIN_SRC R
c(1,23,54,5)
#+END_SRC

#+name:
|  1 |
| 23 |
| 54 |
|  5 |

***** convert results to all string
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+name: hetero-table
#+begin_src emacs-lisp
  '((1 2 3 4)
    ("a" "b" "c" "d"))
#+end_src

#+name: all-to-string
#+begin_src emacs-lisp :var tbl='()
  (defun all-to-string (tbl)
    (if (listp tbl)
        (mapcar #'all-to-string tbl)
      (if (stringp tbl)
          tbl
        (format "%s" tbl))))
  (all-to-string tbl)
#+end_src

#+begin_src emacs-lisp :var tbl=hetero-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| nil | nil | nil | nil |
| t   | t   | t   | t   |

#+begin_src emacs-lisp :var tbl=all-to-string(hetero-table)
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| t | t | t | t |
| t | t | t | t |

***** two blocks and a table
   :PROPERTIES:
   :DATE:     2011-08-28
   :END:

#+name: stuff
#+begin_src sh
  echo 1
  echo 2
  echo 3
#+end_src

#+name: last-of-stuff
#+begin_src sh :var input=stuff
  echo "$input" |tail -1
#+end_src

| one |
| two |
| 3   |
#+TBLFM: @3$1='(sbe last-of-stuff)

***** inheriting the file property
   :PROPERTIES:
   :FILE: something.png
   :DATE:     2011-08-23
   :END:

#+begin_src ditaa
   +-----------------------------+
   |                             |
   |    +-----+                  |
   |    |     |   +---------+    |
   |    |     |   |         |    |
   |    +-----+   |         |    |
   |              |         |    |
   |   file       |         |    |
   | inheritance  +---------+    |
   |                             |
   +-----------------------------+
#+end_src

#+name:
[[file:something.png]]

***** a table with tags
   :PROPERTIES:
   :DATE:     2011-08-23
   :END:

#+TBLNAME: sandbox           :noexport:
| 1 |         2 | 3 |
| 4 | org-babel | 6 |

#+begin_src emacs-lisp :var table=sandbox
  (message "%S" table)
#+end_src

#+name:
: ((1 2 3) (4 "org-babel" 6))

***** shell script output not in table
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
#+begin_src sh :results scalar
  echo 1
  echo 2
  echo 3
#+end_src

#+name:
: 1
: 2
: 3

***** inline code block and downstream src blocks
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
something src_sh{echo eric}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src sh
  echo schulte
#+end_src
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

***** with R
    :PROPERTIES:
    :DATE:     2011-08-21
    :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
blah blah src_R[:results output]{cat(rnorm(2))}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src R :eval never :exports none
  1+2
  a <- b + c
  xyz
#+end_src
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

***** updating a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-another-table
| 0 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 0 | 0 |

#+name: this-is-another-table
#+begin_src emacs-lisp :var table=this-is-another-table
  (setf (nth 1 table) '(2 2 2))
  table
#+end_src

***** space around exported code blocks
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
try evaluating the following blocks, then removing their results with
M-x `org-babel-remove-result'

Verbiage to begin the paragraph
#+begin_src sh
  echo eric
#+end_src
and verbiage to end the same paragraph.

#+begin_src sh
  echo 1
  echo 2
#+end_src

and verbiage to end the same paragraph.

***** simple ditaa block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ditaa :file work-flow.png
    +-------+             +--------+
    |       |             |        |
    | Org   |------------>| Tex    |
    |       |             |        |
    +-------+             +--------+
#+end_src

#+name:
[[file:work-flow.png]]

***** ruby code block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ruby
  1+2
#+end_src

#+name:
: 3

***** replacing a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-the-table
| 1 | 4 | 7 |
| 2 | 5 | 8 |
| 3 | 6 | 9 |

#+name: this-is-the-table
#+begin_src emacs-lisp :var table=this-is-the-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (* cell 2)) row)) table)
#+end_src

***** tangle before evaluating a code block
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:

#+begin_src sh :var TANGLED=(org-babel-tangle) :tangle no
  wc $TANGLED
#+end_src

#+name:
: 2  2 11 it.sh

#+begin_src sh :tangle it.sh
  echo TEST
#+end_src

***** bug with undefined function copy-seq
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:
#+begin_src R :session :exports both
  1:10
#+end_src

***** plot results with org-plot
   :PROPERTIES:
   :DATE:     2011-08-02
   :END:
#+name: disk-usage
#+begin_src sh :exports both
  df
#+end_src

#+PLOT: title:"Disk Usage" ind:6 deps:(5) type:2d with:histograms set:"yrange [0:100]"
#+name: disk-usage
| Filesystem | 1K-blocks |     Used | Available | Use% | Mounted   | on |
| /dev/sda6  |  28835836 |  8447712 |  18923344 |  31% | /         |    |
| none       |   2997072 |      676 |   2996396 |   1% | /dev      |    |
| none       |   3006056 |        0 |   3006056 |   0% | /dev/shm  |    |
| none       |   3006056 |       96 |   3005960 |   1% | /var/run  |    |
| none       |   3006056 |        0 |   3006056 |   0% | /var/lock |    |
| /dev/sda7  | 144176824 | 72225604 |  64627420 |  53% | /home     |    |

***** premature truncation of emacs-lisp results
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src emacs-lisp
  '(nil nil nil nil)
#+end_src

#+name:
: (nil nil nil nil)

***** non-defined code blocks can still tangle
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src text :tangle somewhere.txt
  This will still tangle out to a file, and it opens in text mode, which
  may be nice.  
#+end_src

***** expand noweb refs
   :PROPERTIES:
   :DATE:     2011-07-25
   :END:
#+name: def-something
#+begin_src sh
  SOMETHING=nothing
#+end_src

#+begin_src sh
  <<def-something>>
  echo $SOMETHING
#+end_src

***** returning file names -- interpreted as lists
   :PROPERTIES:
   :DATE:     2011-07-21
   :END:
#+begin_src sh :results scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
: [[file:./cv.cls]]

#+begin_src sh :results raw scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
[[file:./cv.cls]]

***** java code block
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src java :classname myfirstjavaprog
  class myfirstjavaprog
  {  
      public static void main(String args[])
      {
          System.out.println("Hello World!");
      }
  }
#+end_src

#+name:
: Hello World!

***** including noweb refs w/o last newline
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src sh :noweb yes
  <<my-name>> |\
  <<capitalize-name>>
#+end_src

#+name: my-name
#+begin_src sh
  echo "eric schulte"
#+end_src

#+name: capitalize-name
#+begin_src sh
  sed 's/^e/E/;s/ s/ S/'
#+end_src

***** exporting a ditaa example
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:

#+begin_src ditaa :file blue.png :cmdline -r
/---------------\
|    test       |
|        {cBLU} |
\---------------/
#+end_src

#+name:
[[file:blue.png]]

***** simple sbe example
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

|   1 |
|   2 |
|   3 |
|   4 |
|   5 |
|   6 |
| 3.5 |
#+TBLFM: @7$1='(sbe mean (lst @1..@6))

#+name: mean
#+begin_src emacs-lisp :var lst=()
  (let ((num (car lst)) (nums (cdr lst)))
    (/ (float (+ num (apply #'+ nums))) (1+ (length nums))))
#+end_src

***** eval never
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

#+begin_src emacs-lisp :eval (if org-export-current-backend "never" "yes") :exports results
  (message "launch missles")
#+end_src

#+name:
: launch missles

***** indexing into a list variable
   :PROPERTIES:
   :DATE:     2011-07-06
   :END:

#+begin_src emacs-lisp :var lst='(0 1 2)
  (first lst)
#+end_src

#+name:
: 0

or as a noweb reference

#+name: external-list
- 0
- 1
- 2

#+begin_src sh :noweb yes
  echo <<external-list()[0]>>
#+end_src

#+name:
: 0

***** data alias for resname
   :PROPERTIES:
   :DATE:     2011-07-05
   :END:
#+name: blah
: blahcontent

#+begin_src emacs-lisp :var it=blah
  it
#+end_src

#+name:
: blahcontent

***** find a resource by global id
   :PROPERTIES:
   :DATE:     2011-07-01
   :END:

#+begin_src emacs-lisp :var it=990f3218-6fce-44fb-bd0c-5f6076c0dadc
  it
#+end_src

#+name:
: 
: here it is

****** I'm the resource
    :PROPERTIES:
    :ID:       990f3218-6fce-44fb-bd0c-5f6076c0dadc
    :DATE:     2011-07-01
    :END:

here it is

***** define a block with a name for noweb expansion
   :PROPERTIES:
   :tangle:   yes
   :noweb:    yes
   :DATE:     2011-07-01
   :END:

#+name: simple(something="something")
#+begin_src emacs-lisp
  something
#+end_src

another block including the first block
#+begin_src emacs-lisp
  <<simple(something="something else")>>
#+end_src

***** longtable label and attr lines on code block results
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:

#+name: faz
#+begin_src emacs-lisp :exports results
  '((foo foo)
    (bar baz))
#+end_src

#+LABEL: Foo
#+name: faz
| foo | foo |
| bar | baz |

***** another test
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:
#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

Here is a call_square(it=4), stuck in the middle of some prose.

Here is another 25^2=call_square(it=25).

***** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

***** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

***** multiple variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

Should work call_concat(1, 2, 3) =123= in order.

#+name: concat
#+begin_src emacs-lisp :var a=0 :var b=0 :var c=0
  (format "%S%S%S" a b c)
#+end_src

Should be positive call_lob-minus(4, 3) =1= by order.

***** inline call line
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: double
#+begin_src emacs-lisp :var it=0
  (* 2 it)
#+end_src

This is the number src_sh[:var it=double(it=1)]{echo $it} in the middle

The following exports as a normal call line
#+call: double(it=1)

Now here is an inline call call_double(it=1) stuck in the middle of
some prose.

This one should not be exported =call_double(it=2)= because it is
quoted.

Finally this next one should export, even though it starts a line
call_double(it=3) because sometimes inline blocks fold with a
paragraph.

And, a call with raw results call_double(4)[:results raw] should not
have quoted results.

***** text and graphics from R
   :PROPERTIES:
   :DATE:     2011-06-24
   :END:

#+begin_src R :results output :session
print(seq(1,10))
#+end_src

#+begin_src R :file example.png :results graphics :session
plot(seq(1,10))
#+end_src

#+name:
[[file:example.png]]

***** large code in inline blocks
   :PROPERTIES:
   :DATE:     2011-06-22
   :END:

#+name: big-block
#+begin_src emacs-lisp :exports none
  "something complex"
#+end_src

Here is some text with src_emacs-lisp[:var it=big-block]{it} in the middle.

***** clojure =:results scalar=
   :PROPERTIES:
   :DATE:     2011-06-21
   :END:
#+begin_src clojure :results scalar
  '(1 2 3)
#+end_src

***** expand variable during tangling
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2011-06-20
   :END:

#+begin_src sh :var VER=(vc-working-revision (buffer-file-name))
  echo $VER
#+end_src

***** scalar emacs lisp results
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src emacs-lisp :results scalar
  '(1 2 3)
#+end_src

#+name:
: (1 2 3)

***** python session
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src python :results output :session mypy 
x = 1
for i in range(1,5):
  x = x + i
  print x

print "I throw an error"
#+end_src

#+name:
: 
: ... ... ... 2
: 4
: 7
: 11
: I throw an error

#+begin_src python :results output :session
  print y
#+end_src

#+name:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: NameError: name 'y' is not defined

***** named code block export
   :PROPERTIES:
   :DATE:     2011-06-13
   :END:
This has a name which is not exported.

#+name: rand(n)
#+begin_src R
  runif(n)
#+end_src

***** tangle test
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src R :tangle test.R :shebang #!/bin/cat :padline no
This is
a test
#+end_src

***** ruby with xmpfilter
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src ruby :results xmp code
  2 + 2 # =>
  3.times{ puts :hello }
#+end_src

#+name:
#+BEGIN_SRC ruby
2 + 2 # => 4
3.times{ puts :hello }
# >> hello
# >> hello
# >> hello
#+END_SRC

***** continued code blocks
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2011-06-10
   :END:
#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 1)
#+end_src

#+begin_src emacs-lisp
  (message "un-named")
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 1)
#+end_src

#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 2)
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 2)
#+end_src

#+begin_src emacs-lisp :tangle no :results silent
  (with-temp-buffer
    (insert-file-contents "scraps.el")
    (eval-buffer))
#+end_src

***** simple shell
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh
  sleep 10 && ls
#+end_src

#+name:
| _config.yml     |
| data            |
| development.org |
| elsevier        |
| index.org       |
| paper           |
| publish.org     |
| scraps          |
| scraps.html     |
| scraps.org      |
| scraps.tex      |

#+begin_src ruby :session eric
  puts [1..4]
#+end_src

#+name:
: nil

***** quick testing new session code
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh :session test :results output
  echo foo
#+end_src

#+name:
: foo

#+begin_src ruby :results output :session simple
  puts "foo"
#+end_src

#+name:
: foo

***** =:file= and python
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src python :file /tmp/test.png
  return 1
#+end_src

#+name:
[[file:/tmp/test.png]]

***** testing new data names
   :PROPERTIES:
   :DATE:     2011-06-02
   :END:

#+name: simple-123
: 123

#+begin_src emacs-lisp :var simple=simple-123 :exports both
  (* simple 2)
#+end_src

results

data

my data is results

#+name:
: 246

***** default directory examples in lisp
   :PROPERTIES:
   :DATE:     2011-06-01
   :END:

#+begin_src lisp
  *default-pathname-defaults*
#+end_src

#+begin_src sh
  pwd
#+end_src

#+begin_src lisp :dir
  *default-pathname-defaults*
#+end_src

#+name:
: #P""

***** lisp body with multiple forms
   :PROPERTIES:
   :DATE:     2011-05-31
   :END:

#+begin_src lisp :results value
  (format t "~&eric")
  (+ 1 2)
#+end_src

#+name:
: 3

***** passing values through to STDIN of shell code blocks
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:
#+name: square-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+name: first-col
#+begin_src sh :stdin square-table
  awk '{print $1}'
#+end_src

#+begin_src sh :stdin first-col
  sed 's/4/middle/g'
#+end_src

#+name:
|      1 |
| middle |
|      7 |

***** awk example
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:

#+name: simple-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src awk :stdin simple-table
  {print $1}
#+end_src

#+name:
| 1 |
| 4 |
| 7 |

***** don't match end_src inside of a block
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:

#+name: the_issue
#+begin_src sh :results output
  echo '#+end_src'
#+end_src

#+name: the_issue
: #+end_src block

***** append tables
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:
#+name: table-names
- first-table
- second-table
- third-table

#+name: first-table
| a | 1 |
| b | 2 |

#+name: second-table
| c | 3 |
| d | 4 |

#+name: third-table
| e | 5 |
| f | 6 |

#+begin_src emacs-lisp :var table-names=table-names
  (mapcar #'org-babel-ref-resolve table-names)
#+end_src

#+name:
| (a 1) | (b 2) |
| (c 3) | (d 4) |
| (e 5) | (f 6) |

***** ocaml
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+begin_src ocaml
  [3;2;3] @ [3;2;3;4;5];;
#+end_src

#+name:
| 3 | 2 | 3 | 3 | 2 | 3 | 4 | 5 |

***** new names for results
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+name: simple
: 1

#+begin_src emacs-lisp :var data=simple
  data
#+end_src

#+name:
: 1

changing the variable used to label data
#+begin_src emacs-lisp :results silent
  (setq org-babel-result-fmt
        "^[ \t]*#\\+\\(TBLNAME\\|RESNAME\\|RESULTS\\|DATA\\):[ \t]*%s[ \t]*$")
#+end_src

#+name: not-so-simple
: 2

#+begin_src emacs-lisp :var data=not-so-simple
  data
#+end_src

#+name:
: 2

***** simple latex verbatim wrap example
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-export-latex-verbatim-wrap
        '("{\\scriptsize\n\\begin{verbatim}\n" . "\\end{verbatim}\n}\n"))
#+end_src

#+begin_src sh
  echo eric schulte
  echo another
#+end_src

***** inserting complicated results
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results scalar
  ((lambda (result) (condition-case nil (read result) (error result)))
   "(:return
   (:ok \"{:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}\")
   13)")
#+end_src

#+name:
| :return | (:ok {:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}) | 13 |

***** automatic org-mode formatting
   :PROPERTIES:
   :DATE:     2011-04-27
   :END:

#+name: raw-results
#+begin_src sh :results output tabular
  echo "| 1 |"
  echo "| 2 |"
#+end_src

#+begin_src emacs-lisp :var in=raw-results
  (stringp in)
#+end_src

#+name:
: t

***** units in R plot
   :PROPERTIES:
   :DATE:     2011-04-21
   :END:
#+begin_src R  :results graphics :file test.png :width 8 :height 8 :res 200 :units cm
  x <- -10:10
  y <- x^2
  plot(x, y, type="l", col="red", lty=1)
#+end_src

#+name:
[[file:test.png]]

***** simple Oz example
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
#+begin_src oz :results output
  {Browse 'Hello'}
#+end_src

***** Ocaml appending blocks
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
block

#+begin_src ocaml
  [|1;2;3|];;
#+end_src

#+name:
| 1 | 2 | 3 |

***** complex numbers in tables and python, reference in table formula
   :PROPERTIES:
   :DATE:     2011-04-13
   :END:

#+name: parameter-variation(data=0)
#+begin_src python :result values
  return 'text'
#+end_src

|---------------------------------------|
| "(0.0331901438056,0.000535222885197)" |
| "(0.0333434157791,0.000537930174356)" |
| "(0.0345727512157,0.000559346040457)" |
| "(0.0353146483908,0.000571501584524)" |
| "(0.0355522909393,0.000574387067408)" |
| "(0.0356575682336,0.000574851263615)" |
| "(0.0357806926897,0.000575051685084)" |
|---------------------------------------|
| text                                  |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

| '(1 2 3 4) |
|------------|
|          4 |
#+TBLFM: @2$1='(sbe quote (it @1$1))

| (1 2 3 4) |
|-----------|
| #ERROR    |
#+TBLFM: @2$1='(sbe quote (it @1$1))

***** using vectors to represent complex number is lisp
    :PROPERTIES:
    :DATE:     2011-04-15
    :END:
| [1 2]            |
|------------------|
| real:1 complex:2 |
#+TBLFM: @2$1='(sbe real (it @1$1))

#+name: real(it='())
#+begin_src emacs-lisp
  (format "real:%d complex:%d" (aref it 0) (aref it 1))
#+end_src

***** reference the table in a table formula
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
|-------------------------------------|
|                                   4 |
#+TBLFM: @2$1='(sbe quote (it "complex-data"))

***** externally referencing the table
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

#+begin_src python :var data=complex-data
  return data
#+end_src

#+name:
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |

***** emacs-lisp printing with output to string
   :PROPERTIES:
   :DATE:     2011-04-10
   :END:

#+begin_src emacs-lisp :results output
  (let ((dog (sqrt 2))
        (cat 7))
    (print (format "%s %f" "Dog: " (eval dog)))
    (print (format "%s %d" "Cat: " (eval cat)) nil)
    (print "Fish."))
#+end_src

#+name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."


#+begin_src emacs-lisp
  (let ((dog (sqrt 2))
        (cat 7))
    `((dog ,dog)
      (cat ,cat)
      (fish)))
#+end_src

#+name:
| dog  | 1.4142135623730951 |
| cat  |                  7 |
| fish |                    |

***** headers in R tables during export
   :PROPERTIES:
   :DATE:     2011-04-04
   :END:
#+TBLNAME: Chuah07
| condition | Mean.offer |
|-----------+------------|
| 1.MMM     |      48.49 |
| 2.MMU     |      42.59 |
| 3.MUM     |      44.87 |
| 4.UMU     |      46.43 |
| 5.UUM     |      44.15 |
| 6.UUU     |      43.80 |
| MAL       |      46.28 |
| UK        |       44.1 |
| All       |      45.29 |

#+headers: :var data=Chuah07
#+begin_src R :results output :exports both :cache yes
  str(data)
#+end_src

#+name[135a7f73839b69d118780ca29a64c3840601f7b9]:
: 'data.frame': 9 obs. of  2 variables:
:  $ condition : chr  "1.MMM" "2.MMU" "3.MUM" "4.UMU" ... 
:  $ Mean.offer: num  48.5 42.6 44.9 46.4 44.1 ... eric

***** session associated with R block
   :PROPERTIES:
   :DATE:     2011-04-02
   :END:
#+begin_src R :session *chris*
  x <- 1
  y <- 2
  y-x
#+end_src

#+name:
: 1

***** vc-log
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

A version control log of this file.  The =vc-log= code block lives in
the library of babel.
#+call: vc-log() :exports results

***** tangling out vc information
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

#+headers: :var STATE=(vc-state (or (buffer-file-name) org-current-export-file))
#+headers: :var REV=(vc-working-revision (or (buffer-file-name) org-current-export-file))
#+begin_src sh :tangle yes
  rm -rf ./R
  rm -f ./spreadSim.sub
  REVISION=$REV.$STATE
  tar -xf nsa.$REVISION.tar.gz
  $HOME/R/R/R-2.12.0/bin/Rscript --vanilla -e
"source('./R/generateLatinHypercubeScenarios.R'); doIt()"
  for SCENARIO in ./R/scenarios/*.R; do
    export SCENARIO=${SCENARIO#./R/scenarios/}
    qsub nsa.sub
  done
#+end_src

***** grabbing the current buffer during export
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
Eric

#+begin_src emacs-lisp :var buf=(buffer-file-name (current-buffer)) :exports both
  (message "buffer %S!" buf)
#+end_src

#+begin_src sh :exports results :results output
  git log -1
#+end_src

***** detangling example
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :shebang:  #!/bin/sh
   :ID:       7a22cf71-6be3-4fca-a700-4c8be8237303
   :DATE:     2011-04-01
   :END:

#+name: sh-for-tangling
#+begin_src sh
  echo "this is the `sh-for-tangling' code block"
  num=`expr 1 + 1`
  echo "the value of num is $num"
#+end_src

#+begin_src sh
  echo "this is an unnamed code block"
#+end_src

***** CL example
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
#+begin_src lisp
  (defun range (n &optional m)
    "Return the numbers in range."
    (loop for num from (if m n 0) to (if m m (- n 1)) collect num))
  
  (mapcar #'list (mapcar #'1+ (range 10)))
#+end_src

#+name:
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

***** colnames with call lines
   :PROPERTIES:
   :DATE:     2011-03-29
   :END:
#+TBLNAME: data
| x | parameter | value |
|---+-----------+-------|
| 0 | heat      |    30 |
| 1 | heat      |    30 |

#+name: func5
#+begin_src R :var name=data :var a="one" :colnames yes
  names(name)
#+end_src

#+name: func5
| x         |
|-----------|
| x         |
| parameter |
| value     |

#+call: func5(name=data, a="two") :colnames yes

#+name: func5(name=data, a="two")
| x         |
|-----------|
| x         |
| parameter |
| value     |

***** caching on export
   :PROPERTIES:
   :DATE:     2011-03-23
   :END:
#+name: testcache
#+begin_src R :cache yes :exports results
  dat <-  matrix(runif(12), 3, 4)
  print(dat)
#+end_src

#+name[e7b83e61596da84f85c5a24e61569576c802f9a2]: testcache
| 0.590091332094744 | 0.101750465808436 | 0.487125408137217 |  0.92315583024174 |
| 0.483292032498866 | 0.427640072302893 | 0.974636133294553 | 0.995571716455743 |
|  0.60190233332105 | 0.122638279106468 | 0.437959408387542 | 0.015639441087842 |

***** macros during tangling
   :PROPERTIES:
   :ID:       d2ff9d6f-b413-4072-91a9-3ae8aa32032c
   :DATE:     2011-03-14
   :END:

First, add macro expansion to the new `org-babel-tangle-body-hook'.

#+begin_src emacs-lisp :results silent
  (add-hook 'org-babel-tangle-body-hook
            (lambda () (org-export-preprocess-apply-macros)))
#+end_src

Then define the macro.  Note: you may need to export the buffer before
tangling so that the macro definition is noticed and processed by
Org-mode.

#+MACRO: CONFIG_PARAM01 45

Then on both export and tangling the macro in the following code block
will be replaced.

#+begin_src sh :tangle yes
  echo org-mode set CONFIG_PARAMETER to: {{{CONFIG_PARAM01}}}
#+end_src

***** conflicting header arguments
   :PROPERTIES:
   :DATE:     2011-03-14
   :END:

code block
#+name: conflict-block
#+begin_src sh :exports results :results silent
  echo eric
#+end_src

call line
#+call: conflict-block() :exports results

#+name: conflict-block()
: eric

***** looks like a pipe in a table
   :PROPERTIES:
   :DATE:     2011-03-07
   :END:
#+name: clean
#+begin_src emacs-lisp :var in=""
  (flet ((clean (in)
                (if (listp in)
                    (mapcar #'clean in)
                  (if (stringp in)
                      (replace-regexp-in-string "¦" "|" in)
                    in))))
    (clean in))
#+end_src

#+name: regexps
| first  | (a¦b) |
| second | (1¦2) |

#+begin_src perl :var a=clean(in=regexps)[0,1] :var b=clean(in=regexps)[1,1]
  $a; $b;
#+end_src

#+name:
: (1|2)

***** eval results as a list
   :PROPERTIES:
   :DATE:     2011-03-06
   :END:
#+begin_src python :results value
  return "(mapcar (lambda (el) (+ 1 el)) '(1 2))"
#+end_src

#+name:
| 2 | 3 |

#+begin_src python :results value
  return "[1, 2]"
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return [1, 2]
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return "%r" % "[1 2]"
#+end_src

#+name:
: [1 2]

***** simple mysql
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
#+begin_src sql :engine mysql
  show tables;
#+end_src

***** export of inline R code
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
Here I test inline code evaluation in R.

#+begin_src R :session *R*
x <- 100
#+end_src

#+name:
: 100

Now I want to export the value of x, which should be
src_R[:session *R*]{x} .

Did the number 100 show up at the end of the previous sentence on export?

***** results org raw wrap
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+begin_src sh :results output org :exports none
  cat <<EOF
  - first
  - second
  EOF
#+end_src

#+name:
#+BEGIN_ORG
- first
- second
#+END_ORG

****** Version 1
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version only prints the org code for the table, but does not interprets it.
#+begin_src R :exports both :results output raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

****** Version 2
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version prints the table including the graph as expected, but
:results is used twice as a header argument.
#+begin_src R :results output :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

****** Version 3
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
Finally this version does only export the R code
#+begin_src R :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

***** leading/trailing spaces
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+name: spaces-wrapped-string
- " pass through with space "

#+begin_src emacs-lisp :var res=spaces-wrapped-string[0]
  res
#+end_src

#+name:
:  pass through with space 

***** reference to a commented out subtree
      :PROPERTIES:
      :DATE:     2011-02-28
      :END:
****** COMMENT I don't export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+name: hidden-parameters
| 1 |
| 2 |
| 3 |
| 4 |

****** I do export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+begin_src emacs-lisp :var params=hidden-parameters :exports both
  params
#+end_src

***** literal reference in a table with sbe
   :PROPERTIES:
   :DATE:     2011-02-28
   :END:

| "eric schulte" | 12 |
#+TBLFM: @1$2='(sbe length (in $1))

#+name: length
#+begin_src emacs-lisp :var in="foo"
  (length in)
#+end_src

***** strip hline before processing a variables indices
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+name: table-w-hline
| 1 | a |
|---+---|
| 2 | b |
| 3 | c |
| 4 | d |

#+begin_src emacs-lisp :var table=table-w-hline[1,1] :hlines no
  table
#+end_src

#+name:
: hline

#+tblname: perl-table-w-hline
| colA | colB |
|------+------|
| a1   | b1   |
| a2   | b2   |

#+headers: :var b=perl-table-w-hline[2..,1]
#+headers: :var a=perl-table-w-hline[2..,0]
#+begin_src perl :tangle yes
  $a; $b;
#+end_src 

***** passing elisp-looking variables to code blocks
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src perl :var it="(+ 1 1)" :results output
  printf "passed in %s", $it
#+end_src

#+name:
: passed in (+ 1 1)

#+name: elisp-looking-table
| 1 | (+ 1 1) |
| 2 | (a b c) |
| 3 | (+ 3 3) |

#+begin_src perl :var data=elisp-looking-table[1,1]
  $data
#+end_src

#+name:
: (a b c)

#+begin_src emacs-lisp :var data=elisp-looking-table[1,1]
  data
#+end_src

#+name:
: (a b c)

***** pass a vector to calc
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:

#+begin_src calc :var y=[1 2 3]
  y
#+end_src

#+name:
: [1 2 3]

#+begin_src calc :var y=[1 2 3]
  3 y
#+end_src

#+name:
: [3, 6, 9]

#+begin_src emacs-lisp :var data=[1 2 3]
  (elt data 1)
#+end_src

#+name:
: 2

#+begin_src calc
  1 * 8
#+end_src

#+name:
: 8

***** new block regexp tests
      :PROPERTIES:
      :DATE:     2011-02-27
      :END:
****** Block 1 (Exports OK)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 1
#+END_SRC

****** Block 2 (Exports OK - double blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out


#+END_SRC

****** Block 3 (Fails - single blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out

#+END_SRC

****** Block 4 (Gets consumed by previous Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 4
#+END_SRC

****** Block 5 (Fails - no lines in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
#+END_SRC

****** Block 6 (Gets consumed by previous Block
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 6
#+END_SRC

***** exporting cache and noweb
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+name: test_sleep
#+begin_src R :session :exports code
  Sys.sleep(time=5)
  1:10
#+end_src

#+name: test_sleep
#+begin_src R :session :exports results :noweb yes :cache yes
  <<test_sleep>>
#+end_src

#+name[e2c9e6c2f84563b590a765502057d92463e50182]: test_sleep
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

***** don't interpret tuples as elisp code
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src python :results value
  return (1,2)
#+end_src

#+name:
: (1, 2)

***** source block names in current buffer
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src emacs-lisp :results list
 (org-babel-src-block-names)
#+end_src

***** simple python block
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src python :return foo
  foo = 8
  foo += 1
#+end_src

#+name:
: 9

***** sh return a list of elements with spaces
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src sh :results list
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
- ("eric" "schulte")
- ("dan" "davison")
- ("seb" "vauban")

#+begin_src sh :results scalar
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
: eric schulte
: dan davison
: seb vauban

***** calc variables inside of parenthesis
   :PROPERTIES:
   :DATE:     2011-02-22
   :END:
#+BEGIN_SRC calc :var testvar=9000
testvar - 200
#+END_SRC

#+name:
: 8800

#+BEGIN_SRC calc :var testvar=9000
(testvar - 200) 800
#+END_SRC

#+name:
: 7040000

***** new lists
      :PROPERTIES:
      :DATE:     2011-02-21
      :END:
****** results embedded inside of a list
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
1. this has results
   #+name: something-in-a-list
   : foo
2. and this doesn't work
   #+begin_src emacs-lisp :var data=something-in-a-list
     data
   #+end_src

   #+name:
   : foo

****** reading and writing
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
#+name: simple-list
- 1
- two
- 3
- four


#+name: simple-list
#+begin_src emacs-lisp :var lst=simple-list :results list
  (reverse lst)
#+end_src

***** catch the file name during export
   :PROPERTIES:
   :DATE:     2011-02-21
   :END:

#+begin_src emacs-lisp :var file-name=(buffer-file-name) :exports both
  file-name
#+end_src

***** mentions of file names in file contents
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
directory to search
#+name: graph-dir
: graph-dir

list all files in dir
#+name: graph-files
#+begin_src sh :results vector :var dir=graph-dir
  find $dir -type f -exec basename {} \;
#+end_src

#+name: graph-files
| other |
| dan   |
| eric  |
| seb   |

association of files with mentions
#+name: graph-associations
#+begin_src sh :var dir=graph-dir :var files=graph-files
  for i in $files; do
      for j in `grep -l -r $i $dir`;do
          echo $i, `basename $j`
      done
  done
#+end_src

#+name: graph-associations
| other | eric |
| other | seb  |
| dan   | eric |
| eric  | seb  |
| seb   | dan  |

graphing with dot
#+name: to-dot
#+begin_src sh :var associations=graph-associations :results scalar
  echo "$associations"|awk '{print $1, "->", $2}'
#+end_src

#+name: to-dot
: other -> eric
: other -> seb
: dan -> eric
: eric -> seb
: seb -> dan

#+begin_src dot :var data=to-dot :file files.png
  digraph G{
    $data
  }
#+end_src

#+name:
[[file:files.png]]

***** export of inline code blocks which are silent
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
#+begin_src emacs-lisp :results silent
  (setf org-babel-default-inline-header-args
        '((:session . "none")
          (:results . (if (boundp 'org-current-export-file) "replace" "silent"))
          (:exports . "results")))
#+end_src

Here is an inline code block src_sh{echo 8} <- there

***** inline code block
   :PROPERTIES:
   :DATE:     2011-02-18
   :END:

here is an inline block src_R{1+1}

***** SQL --- example reading org-mode table into sql
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+tblname: example-table-for-sql
| a |  b |
|---+----|
| 1 | 10 |
| 2 | 11 |
| 3 | 12 |
| 4 | 13 |
| 5 | 14 |
| 6 | 15 |

#+headers: :var table=example-table-for-sql
#+begin_src sql :engine mysql
load data infile "$table" into mytable;
#+end_src

***** recutils
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+begin_src sh :file book.rec
  cat <<EOF > book.rec
  # -*- mode: rec -*-
  %rec: Book
  %mandatory: Title
  %type: Location enum loaned home unknown
  %doc:
  + A book in my personal collection.
  
  Title: GNU Emacs Manual
  Author: Richard M. Stallman
  Publisher: FSF
  Location: home
  
  Title: The Colour of Magic
  Author: Terry Pratchett
  Location: loaned
  
  Title: Mio Cid
  Author: Anonymous
  Location: home
  
  Title: chapters.gnu.org administration guide
  Author: Nacho Gonzalez
  Author: Jose E. Marchesi
  Location: unknown
  
  Title: Yeelong User Manual
  Location: home
  
  # End of books.rec
  EOF
#+end_src

#+name:
[[file:book.rec]]

#+begin_src rec :data book.rec :fields Title,Author
  Location = 'loaned'
#+end_src

#+name:
| Title               | Author          |
| The Colour of Magic | Terry Pratchett |

#+begin_src rec :data book.rec :fields Title,Author
  
#+end_src

#+name:
| Title                                 | Author              | Author_2         |
| GNU Emacs Manual                      | Richard M. Stallman |                  |
| The Colour of Magic                   | Terry Pratchett     |                  |
| Mio Cid                               | Anonymous           |                  |
| chapters.gnu.org administration guide | Nacho Gonzalez      | Jose E. Marchesi |
| Yeelong User Manual                   |                     |                  |

***** passing keywords inside header arguments
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:

#+begin_src emacs-lisp :var lst='(:no-expand :other)
  lst
#+end_src

#+name:
| :no-expand | other |

***** two vars in a properties block -- not possible
   :PROPERTIES:
   :var:      test1=7
   :var:      test2=8
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp
  (message "test1=%S test2=%S" test1 test2)
#+end_src

results in Error
: let: Symbol's value as variable is void: test2

****** an alternative
    :PROPERTIES:
    :var:      tests=all-tests
    :DATE:     2011-02-10
    :END:

#+tblname: all-tests
- 7
- 8

#+begin_src emacs-lisp :var eric=89
  (message "test1=%S test2=%S" (first tests) (second tests))
#+end_src

#+name:
: test1=7 test2=8

****** another alternative
    :PROPERTIES:
    :var:      vars=variables
    :DATE:     2011-06-21
    :END:

#+tblname: variables
| var1 | 1 |
| var2 | 2 |

#+begin_src python
  print vars[0][1]
  print vars[1][1]
#+end_src

***** how to set no-expand in properties
   :PROPERTIES:
   :no-expand: yes
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp :var something="other thing" :tangle no-expand.el
  :test
#+end_src

tangles to

***** non-inlined inline code block
   :PROPERTIES:
   :DATE:     2011-01-27
   :END:
The Date is src_sh[:results replace]{date} at the time of =this= export.

src_sh[:results replace]{ls}

***** simple calc example
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src calc 
2*3
#+end_src

#+name:
: 6

***** results replace not always working
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src sh :results output org replace :exports code
  for i in `seq 4`;do
      echo "- place $i in the list"
  done
#+end_src

#+name:
#+BEGIN_ORG
- place 1 in the list
- place 2 in the list
- place 3 in the list
- place 4 in the list
#+END_ORG

inline block src_emacs-lisp[:exports code :results replace]{(+ 1 1 1)} here is was

***** inserting wrappers eats following characters
      :PROPERTIES:
      :DATE:     2011-01-20
      :END:
****** Test
       :PROPERTIES:
       :DATE:     2011-01-20
       :END:
     
     #+begin_src emacs-lisp :results latex
       "\\begin{equation}\\frac{1}{2}\n\\end{equation}"
     #+end_src

     #+name:
     #+BEGIN_LaTeX
     \begin{equation}\frac{1}{2}
     \end{equation}
     #+END_LaTeX
     
****** Watch me die :-(
       :PROPERTIES:
       :DATE:     2011-01-20
       :END:

***** creating a directory when needed for tangling
   :PROPERTIES:
   :DATE:     2011-01-19
   :END:
#+begin_src clojure :tangle (prog1 "src/foo.clj" (make-directory "src" "."))
  (ns something)
#+end_src

a helper function for the above
#+begin_src emacs-lisp
  (defun mkdir-p (file &optional dir)
    "Create any parent directories of FILE if missing and return FILE."
    (make-directory (file-name-directory file) (or dir ".")) file)
#+end_src

allows the following
#+begin_src clojure :tangle (mkdir-p "src/foo.clj")
  (ns something)
#+end_src

There is now a new header argument controlling this behavior
#+begin_src emacs-lisp :mkdirp yes :tangle novel/nested/directories/finally.clj
  (message "contents")
#+end_src

***** passing arguments to the shell
   :PROPERTIES:
   :DATE:     2011-01-18
   :END:
#+name: something
: eric
:   schulte
:     yes
: more

#+name: something-list
| 1 |
| 2 |
| 3 |

#+begin_src sh :var data=something-list
  echo "$data"|wc -l
#+end_src

#+name:
: 3

#+begin_src emacs-lisp :results silent
  (setq org-babel-sh-var-quote-fmt "`cat <<'BABEL_TABLE'\n%s\nBABEL_TABLE\n`")
#+end_src

***** wrap noweb references in comments
   :PROPERTIES:
   :DATE:     2011-01-16
   :END:
#+name: wrappable
#+begin_src emacs-lisp
  (setq x (+ 4 x))
#+end_src

#+begin_src emacs-lisp :comments noweb :noweb yes :tangle yes
  (let ((x 1))
    (message "x=%s" x)
    <<wrappable>>
    (message "x=%s" x))
#+end_src

***** replace inline code block
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
This is src_emacs-lisp{(+ 1 2 3)} an inline block.

#+begin_src emacs-lisp
  (defun replace-inline-block ()
    (interactive)
    (if (save-excursion (re-search-backward "[ \f\t\n\r\v]" nil t)
                        (looking-at org-babel-inline-src-block-regexp))
        (replace-match
         ((lambda (el) (if (stringp el) el (format "%S" el)))
          (org-babel-execute-src-block)) nil nil nil 1)
      (error "not inside of an inline source block.")))
#+end_src

***** noweb then variables
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
#+name: replaced-first
#+begin_src latex
  \begin{itemize}
  \item first
  \item data
  \item third
  \end{itemize}
#+end_src

#+begin_src latex :var data="second" :noweb yes
  \section{ordinals}
  \label{sec:ordinals}
  <<replaced-first>>
#+end_src

***** empty strings as arguments
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:

#+begin_src emacs-lisp :results output :var foo=""
  (concat foo "bar")
#+end_src

#+name:
: bar

***** call lines
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:
#+name: doubler
#+begin_src emacs-lisp :var n=2
  (* n 2)
#+end_src

#+call: doubler(n=3)

#+name: doubler(n=3)
: 6

#+call: doubler[:var n=3]()

#+name: doubler[:var n=3]()
: 6

***** language name abbreviations
   :PROPERTIES:
   :DATE:     2011-01-07
   :END:

#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("clj" . clojure))
#+end_src

#+begin_src clj
  (map (partial + 1) (range 20))
#+end_src

***** eval query
   :PROPERTIES:
   :DATE:     2010-12-21
   :END:
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate
        (lambda (lang body) (not (equal "ditaa" lang))))
#+end_src

#+name:
| lambda | (lang body) | (not (equal ditaa lang)) |

#+begin_src emacs-lisp :eval query
  (message "eval'd")
#+end_src

#+name:
: eval'd

#+begin_src ditaa
  ---
#+end_src

***** new file handling
   :PROPERTIES:
   :DATE:     2010-12-20
   :END:

#+begin_src sh :sep , :file dirlisting
  ls -l
#+end_src

#+name:
[[file:dirlisting]]

#+begin_src ruby :file ruby-out
  [[1, 2, 3, 4],
   [2, 4, 6, 8]]
#+end_src

#+name:
[[file:ruby-out]]

#+begin_src emacs-lisp :results file :results append
  (let ((today (replace-regexp-in-string "[ \t]" "-" (current-time-string))))
    (with-temp-file today
      (insert (message "I'm feeling %s"
                       (nth (random 3) (list "good" "bad" "just fine")))))
    today)
#+end_src

#+name:
[[file:Mon-Dec-20-17:27:52-2010]]

from http://www.graphviz.org/Gallery/directed/fsm.gv.txt
#+begin_src dot :file fsa.png
  digraph finite_state_machine {
          rankdir=LR;
          size="8,5"
          node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;
          node [shape = circle];
          LR_0 -> LR_2 [ label = "SS(B)" ];
          LR_0 -> LR_1 [ label = "SS(S)" ];
          LR_1 -> LR_3 [ label = "S($end)" ];
          LR_2 -> LR_6 [ label = "SS(b)" ];
          LR_2 -> LR_5 [ label = "SS(a)" ];
          LR_2 -> LR_4 [ label = "S(A)" ];
          LR_5 -> LR_7 [ label = "S(b)" ];
          LR_5 -> LR_5 [ label = "S(a)" ];
          LR_6 -> LR_6 [ label = "S(b)" ];
          LR_6 -> LR_5 [ label = "S(a)" ];
          LR_7 -> LR_8 [ label = "S(b)" ];
          LR_7 -> LR_5 [ label = "S(a)" ];
          LR_8 -> LR_6 [ label = "S(b)" ];
          LR_8 -> LR_5 [ label = "S(a)" ];
  }
#+end_src

#+name:
[[file:fsa.png]]

***** utf8 and latin-1 encodings
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+tblname: toto
| é |

#+begin_src python :var t=toto :preamble # -*- coding: latin1 -*- :return [len(babel), len(local)]
  babel = unicode (t[0][0],"latin1")
  local = unicode ("é","latin1")
#+end_src

#+name:
| 2 | 2 |

***** tangle templates
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+name: template-heading
#+begin_src emacs-lisp
  some stuff here
#+end_src

#+name: template-footing
#+begin_src emacs-lisp
  some other stuff here
#+end_src

#+name: template
#+begin_src sh :results output :noweb yes :var body="body stuff"
heading=$(cat<<EOF
<<template-heading>>
EOF
)
footing=$(cat<<EOF
<<template-footing>>
EOF
)
echo $heading
echo "$body"
echo $footing
#+end_src

#+call: template[:noweb yes](body="something new")

#+name: template[:noweb yes](body="something new")
: some stuff here
: something new
: some other stuff here

***** missing lines on tangle
   :PROPERTIES:
   :ID:       83eb62fd-4147-405b-bdc2-567b2d5cbd70
   :DATE:     2010-12-13
   :END:
#+begin_src org :results latex :tangle latex-err.tex
  ,one
  ,two
  ,three
#+end_src

#+begin_src org :results latex :results replace
  ,- eric
  ,- schulte
#+end_src

#+name:
#+BEGIN_LaTeX
\begin{itemize}
\item eric
\item schulte
\end{itemize}
#+END_LaTeX

***** Python requires a utf-8 coding prefix
   :PROPERTIES:
   :DATE:     2010-12-02
   :END:
#+begin_src python :prefix # -*- coding: utf-8 -*- :return s
s = "é"
#+end_src

#+name:
: é

#+begin_src python :prefix # -*- coding: utf-8 -*- :results output
s = "é"
print(s)
#+end_src

#+name:
: é

***** empty lines in R session output
   :PROPERTIES:
   :DATE:     2010-12-01
   :END:
#+begin_src R :results output :session
  x <- 1;
  x
  x + 1
  x + 4
#+end_src R

#+name:
: [1] 1
: [1] 2
: [1] 5

***** sql variables
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: sql-param
| table       | valueTable0       |
| column      | valueColumn0      |
| type        | valueType0        |
| nullability | valueNullability0 |

I want to apply the values onto the following chunk of code:

#+name: add-column-in-table-0
#+begin_src sql :var table=sql-param[0,1] :var column=sql-param[1,1] :var type=sql-param[2,1] :var nullability=sql-param[3,1]
-- add column `@column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '@table'
               AND COLUMN_NAME = '@column')
BEGIN
    ALTER TABLE $table
    ADD $column $type @nullability
END
#+end_src

***** =:eval query= shows the name
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: i-have-a-name
#+begin_src sh :eval query
  date
#+end_src

#+name: i-have-a-name
: Tue Nov 30 22:03:25 MST 2010

***** python with return header argument
   :PROPERTIES:
   :DATE:     2010-11-27
   :END:

#+begin_src python :return y
  x = 8
  y = 98
  2
#+end_src

#+name:
: 98

***** un-named R code blocks
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+begin_src R
  8
#+end_src

#+name:
: 8

#+begin_src emacs-lisp :eric
8  
#+end_src

#+name:
: 8

#+BEGIN_SRC R :session :results output
 xyz
#+END_SRC

#+BEGIN_SRC R :session *R-2* :results output |  xyz
9
#+END_SRC

#+name:
: [1] 9

***** safe lists for Haskell
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:

#+tblname: mixed-table
| 1 | first  |
| 2 | second |
| 3 | third  |
| 4 | fourth | 

#+name: rec-string-wrap
#+begin_src emacs-lisp :var data=mixed-table
  (defun rec-string-wrap (in)
    (if (listp in) (mapcar #'rec-string-wrap in) (format "%S" in)))
  (rec-string-wrap data)
#+end_src

#+begin_src haskell :var tbl=rec-string-wrap(data=mixed-table)
  map head tbl
#+end_src

#+name:
| 1 | 2 | 3 | 4 |

***** reading from single-quote-delim languages
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+BEGIN_SRC python
return [['607', 'Show license short, name on the deed'],
        ['255', "'(message (concat 'hello ' 'world))"]]
#+END_SRC

#+name:
| 607 | Show license short, name on the deed |
| 255 | '(message (concat 'hello ' 'world))  |

#+begin_src ruby
  [['607', 'Show license, short name on the deed'],
   ['255', "))'(message (concat 'hello ' 'world"]]
#+end_src

#+name:
| 607 | Show license, short name on the deed |
| 255 | ))'(message (concat 'hello ' 'world  |

#+begin_src haskell
  [["'single quotes'", "b"], ["\"double quotes\"", "d"]]
#+end_src

#+name:
| 'single quotes' | b |
| "double quotes" | d |

***** add column to table with awk
   :PROPERTIES:
   :question_author: Sébastien Vauban
   :DATE:     2010-11-23
   :END:
I want to *add a column* to the following table.

#+name: table-message
| This is line 1 of the message.        |
| This is line 2 of the message.        |
| This is the last line of the message. |

Its value should be dependant on a *regexp matching* the *current row*
(for example, if 1 is detected in the original column, then write "A"
in the new one, "B" if 2 is read, "C" if 3 is read, etc.).

Hence, I'm thinking using AWK as an easy solution.

    #+begin_src note
    I'm open to other ideas on how I could do this as easily. Just throw me
    ideas, if you have some.
    #+end_src

the easiest (for me) would be with the elisp =mapcar= function
#+begin_src emacs-lisp :var tbl=table-message
  (mapcar (lambda (row) (cons "New col" row)) tbl)
#+end_src

#+name:
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

*First* trial: add a column whose cell contents will be *fixed* (here,
equal to =New col=).

#+name: add-col
#+begin_src sh :var data=table-message :results output raw :exports both
echo "$data" | awk '// {print "| New col | " $0 " |";}'
#+end_src

#+name: add-col
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

***** lists as data types
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:

#+name: a-list
- org-mode
- and
- babel

#+name: a-list
#+begin_src emacs-lisp :var lst=a-list :results list
  (reverse lst)
#+end_src

also for a block inside of a list
1. First element
2. Second element -- has a block
   #+begin_src emacs-lisp
     (+ 1 1 1 1)
   #+end_src

   #+name:
   : 4

3. third element

***** introducing =wrap= header argument
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:
#+begin_src emacs-lisp :results wrap :exports both
  (mapcar (lambda (el) (list el (+ 1 (* el el)))) (number-sequence 0 10))
#+end_src

#+name:
#+BEGIN_RESULT
|  0 |   1 |
|  1 |   2 |
|  2 |   5 |
|  3 |  10 |
|  4 |  17 |
|  5 |  26 |
|  6 |  37 |
|  7 |  50 |
|  8 |  65 |
|  9 |  82 |
| 10 | 101 |
#+END_RESULT

now indented
- first
- second
  #+begin_src emacs-lisp :results wrap :exports both
    "something else"
  #+end_src

  #+name:
  #+BEGIN_RESULT
  : something else
  #+END_RESULT

***** sqlite
   :PROPERTIES:
   :DATE:     2010-11-10
   :END:
#+begin_src sqlite :db paper/climate.sqlite
  select count(*) from temps;
#+end_src

#+name:
: 422689

***** lob calls with header argument pass through
   :PROPERTIES:
   :DATE:     2010-11-08
   :END:

#+name: lob-header
#+begin_src emacs-lisp :var n=20
  n
#+end_src

#+call: lob-header[:results vector](n=15)

#+name: lob-header[:results vector](n=15)
| 15 |

#+call: lob-header(n=10) :results vector

#+name: lob-header(n=10)
| 10 |

need ob-ref.el to pass through the header arguments in "[]"s
#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)
  n
#+end_src

#+name:
| 8 |

#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)[0,0]
  n
#+end_src

#+name:
: 8

***** clojure code blocks and the lazies
   :PROPERTIES:
   :DATE:     2010-11-06
   :END:
#+begin_src emacs-lisp :results silent
  (defun org-babel-execute:clojure (body params)
    (with-temp-buffer
      (insert body)
      (read
       (slime-eval
        `(swank:interactive-eval-region 
          ,(buffer-substring-no-properties (point-min) (point-max)))))))
#+end_src

#+begin_src clojure
  (map (fn [el] (list el (* el el)))(range 10))
#+end_src

#+name:
| 0 |  0 |
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
| 9 | 81 |

***** shell blocks returning a file name
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src sh :file quick.txt :results output
  date
#+end_src

#+name:
[[file:quick.txt]]

***** playing with calc support
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src emacs-lisp
  (require 'ob-calc)
#+end_src

#+begin_src calc :var some=8
  some
  some
  '*
  8+8
  '+
#+end_src

#+name:
: 80

#+begin_src calc
  2*(8+8)
#+end_src

#+name:
: 32

#+begin_src calc
  2*e
#+end_src

#+name:
: 5.43656365692

#+begin_src calc :var something=9
  2*something
#+end_src

#+name:
: 18

***** passing arguments through call lines
   :PROPERTIES:
   :DATE:     2010-10-29
   :END:

#+name: test
#+begin_src R :session :file test.pdf :var myarg="bla"
  plot(1:10, main=myarg)
#+end_src

#+name: test
[[file:test.pdf]]

#+call: test(myarg="hiho")

#+name: test(myarg="hiho")
: test.pdf

***** simple gnuplot tests
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:
#+name: some-more-gnuplot
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=some-more-gnuplot
  plot "$data"
#+end_src

#+name:

Plotting data points from a table could look like this:
#+tblname: basic-plot
|   x |         y1 |         y2 |
|-----+------------+------------|
| 0.1 |      0.425 |      0.375 |
| 0.2 |     0.3125 |     0.3375 |
| 0.3 | 0.24999993 | 0.28333338 |
| 0.4 |      0.275 |    0.28125 |
| 0.5 |       0.26 |       0.27 |
| 0.6 | 0.25833338 | 0.24999993 |
| 0.7 | 0.24642845 | 0.23928553 |
| 0.8 |    0.23125 |     0.2375 |
| 0.9 | 0.23333323 |  0.2333332 |
|   1 |     0.2225 |       0.22 |

#+begin_src gnuplot :var data=basic-plot :exports code :file basic-plot.png
set title "Putting it All Together"

set xlabel "X"
set xrange [0:1]
set xtics 0,0.1,1

set ylabel "Y"
set yrange [0.2:0.5]
set ytics 0.2,0.05,0.5

plot data u 1:2 w p lw 2 title 'x vs. y1', \
     data u 1:3 w lp lw 1 title 'x vx. y2'
#+end_src

#+name:
[[file:basic-plot.png]]

***** latex headers in latex code blocks
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+begin_src latex :headers \usepackage{lmodern} :file name1.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name1.pdf]]

#+begin_src latex :headers '("\\usepackage{mathpazo}" "\\usepackage{fullpage}") :file name2.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name2.pdf]]

***** export-specific header arguments
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+headers: :var out=(if (and (boundp 'latexp) latexp) "latex" "not latex") 
#+begin_src emacs-lisp
  out
#+end_src

#+name:
: not latex

***** security problem with elisp in header arguments
   :PROPERTIES:
   :DATE:     2010-10-14
   :END:
#+begin_src emacs-lisp :var data=(setq org-confirm-babel-evaluate nil) :results silent
  (+ 1 1)
#+end_src

***** weaving with noweb links
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-10-13
   :END:

#+name: name
#+begin_src emacs-lisp
  (message "eric")
#+end_src

#+begin_src emacs-lisp :noweb tangle
  ;; name
  <<name>>
#+end_src

***** very very large numbers
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: numbers
|                           1 |
|                           2 |
|                          12 |
|                          45 |
|                         166 |
|                    12567890 |
| 231231282371983279389999999 |

#+begin_src emacs-lisp :var numbers=numbers
  (mapcar
   (lambda (line)
       (let ((number (car line)))
         (list number (type-of number))))
     numbers)
#+end_src

#+name:
|                      1 | integer |
|                      2 | integer |
|                     12 | integer |
|                     45 | integer |
|                    166 | integer |
|               12567890 | integer |
| 2.3123128237198328e+26 | float   |

***** preceding blank lines on tangle
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-pad-newline nil)
#+end_src

#+begin_src sh :tangle something.reg
  # something
  echo "else"
#+end_src

***** index into a scalar
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: short-list
| a |
| b |

#+begin_src emacs-lisp :var scalar=short-list[0,0]
  scalar
#+end_src

#+name:
: a

***** cycle -- the input is the output
   :PROPERTIES:
   :DATE:     2010-09-29
   :END:
and the rhythm is the base and the base is the treble

#+name: cycle
| one   |
| two   |
| three |

#+name: cycle
#+begin_src emacs-lisp :var table=cycle
  (append (last table) (butlast table))
#+end_src

#+begin_src emacs-lisp :exports results
  (+ 1 1 1)
#+end_src

***** Letter
   :PROPERTIES:
   :DATE:     2010-09-21
   :END:

#+name: body
#+begin_src org :results latex
  ,My body includes a list:
  
  ,- one
  ,- two
  
  ,and a small table:
  
  ,| first | second |
  ,| other | last   |
  
  ,Not more.
#+end_src

#+begin_src latex :noweb yes :tangle yes
\documentclass[11pt]{isodoc}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\setupdocument{
    to = {Eric},
    subject = {Tough to understand what to do...},
    opening = {Hi},
    closing = {Best}
}

\begin{document}
\letter{%
<<body()>>
}
\end{document}
#+end_src

***** splitting code blocks
   :PROPERTIES:
   :DATE:     2010-09-19
   :END:
- with indentation
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-previous-src-block (&optional arg)
      "Jump to the previous source block.
    With optional prefix argument ARG, jump backward ARG many source blocks."
      (interactive "P")
      (condition-case nil
          (re-search-backward org-babel-src-block-regexp nil nil (or arg 1))
        (error (error "No previous code blocks")))
      (goto-char (match-beginning 0)) (org-show-context))
  #+end_src
  
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-split-block-maybe (&optional arg)
      "Split the current source code block on the cursor."
      (interactive "p")
      ((lambda (info)
         (if info
             (let ((lang (nth 0 info))
                   (indent (nth 6 info))
                   (stars (make-string (org-current-level) ?*)))
               (insert (concat (if (looking-at "^") "" "\n")
                               (make-string indent ? ) "#+end_src\n"
                               (if arg stars (make-string indent ? )) "\n"
                               (make-string indent ? ) "#+begin_src " lang
                               (if (looking-at "[\n\r]") "" "\n  "))))
           (message "Not in src block.")))
       (org-babel-get-src-block-info)))
    
    ;; other stuff
  #+end_src

***** header arguments on call line
   :PROPERTIES:
   :DATE:     2010-09-09
   :END:
#+name: eight
#+begin_src R
  8
#+end_src

#+call: eight() :results vector

#+name: eight()
| 8 |

maybe the following with the new proposed header arguments

#+call: eight[:session *R*]() :results vector

***** empty-string results
   :PROPERTIES:
   :DATE:     2010-09-08
   :END:
test me one two 3

#+begin_src emacs-lisp
#+end_src

More test

#+begin_src emacs-lisp
  (mapcar
   (lambda (pair)
     (list (car pair) (cdr pair)))
   params)
#+end_src

#+name:
| :cache    | no      |
| :colnames | no      |
| :comments |         |
| :exports  | code    |
| :hlines   | yes     |
| :noweb    | no      |
| :results  | replace |
| :session  | none    |
| :shebang  |         |
| :tangle   | no      |

***** tangle org-mode block
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+name: org-list
#+begin_src org :results latex
  - one
  - two
  - three
#+end_src

#+begin_src emacs-lisp :tangle example.tangled :noweb yes
  "
  <<org-list()>>
  "
#+end_src

***** remove results when nil is returned
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src emacs-lisp
  (progn (+ 1 1) nil)
#+end_src

#+name:

***** comparative speed of python evaluation
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src python :session test
  2+2
#+end_src

#+name:
: 4

#+begin_src python
  return 2+2
#+end_src

#+name:
: 4

#+begin_src python :session test
def add(a,b):
   return a+b
def sub(a,b):
   return a-b
add(sub(10,1),sub(10,2))
#+end_src

#+name:
: org_babel_python_eoe

***** customizable comment formats
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2010-09-05
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-comment-format-beg "{-# LINE %start-line \"%file\" #-}"
        org-babel-tangle-comment-format-end ""
        org-babel-tangle-pad-newline)
#+end_src

#+begin_src haskell :tangle Main.hs
  test = length
  main = print $ test [1,2,3]
#+end_src

I would like the following output in the tangled file Main.hs:

: {-# LINE 4 "Haskell.org" #-}
: test = length
: main = print $ test [1,2,3]

***** tangling with full comments
   :PROPERTIES:
   :comments: org
   :tangle:   full-comments.el
   :DATE:     2010-09-04
   :END:
The top block
#+begin_src emacs-lisp
  (message "first block")
#+end_src

here's some text which won't be tangled

****** subheading
    :PROPERTIES:
    :DATE:     2010-09-04
    :END:
another block
| 1 | first  |
| 2 | second |
#+begin_src emacs-lisp
  (message "second")
#+end_src

and finally a block with a =:noweb= header argument
#+begin_src emacs-lisp :noweb yes
  (progn
    <<tangle-el-the-second>>)
#+end_src

***** :var (buffer-file-name)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
during export (buffer-file-name) will return nil because the temporary
export buffer is not visiting any file.

/file=(vc-working-revision (buffer-file-name))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) "")) :exports results
  echo $file Revision
#+end_src

/file=(vc-working-revision (or (buffer-file-name) org-current-export-file))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) org-current-export-file)) :exports results
  echo $file Revision
#+end_src

***** quoting header args (e.g. :cmdline)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
#+begin_src C :cmdline 1 2 3 4 5 :includes <stdio.h>
  int main(int argc, char **argv){
    printf("argv[1] %s\n", argv[1]);
    return 0;
  }
#+end_src

#+name:
: argv[1] 1

***** :session evaluation on export
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
This first block is evaluated but /doesn't/ appear in export.

/:session *R* :exports none/
#+begin_src R :session *R* :exports none
  x <- 8
#+end_src

This second block /does/ appear in export.

#+begin_src R :session *R* :exports results
  x
#+end_src

***** ditaa with tilda in path
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
#+begin_src ditaa :file example.png
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
#+end_src

***** scheme sessions
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src scheme :var number=9 :session *scheme* :scheme guile
  (+ number 0)
#+end_src

#+name:
: 9

#+begin_src scheme :var number=9 :session *scheme* :scheme racket
  (+ number 1)
#+end_src

#+name:
: 10

***** conditional tangling
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src emacs-lisp :results silent
  (setq tangle-tag "right")
#+end_src

****** first subheading						       :left:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "first"
#+end_src

****** second subheading					      :right:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "second"
#+end_src

***** pulling information from tags				       :blue:
   :PROPERTIES:
   :DATE:     2010-08-30
   :END:

#+begin_src R :var color=(car (org-get-tags-at (point))) :tangle example.R
  color
#+end_src

#+name:
: blue

***** initial scheme support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
#+name: numbers
#+begin_src scheme
  (map (lambda (el) (+ el 1)) '(1 2 3))
#+end_src

#+name:
| 2 | 3 | 4 |

#+begin_src scheme :var numbers=numbers
  (map (lambda (el) (- el 1)) numbers)
#+end_src

#+name:
| 1 | 2 | 3 |

***** initial javascript support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
using node.js

#+begin_src js
  var n = 0;
  n = n+1;
  return n
#+end_src

#+name:
: 1

#+name: cars
#+begin_src js
  var cars = ["Saab","Volvo","BMW"];
  return cars;
#+end_src

#+name: cars
| Saab | Volvo | BMW |

#+begin_src js :var cars=cars
  return cars[0][0];
#+end_src

#+name:
: Saab

#+begin_src js :var cars=cars
  return cars[0].length;
#+end_src

#+name:
: 3

***** wrapping up raw/org results
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
  - second
  - third
  "
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

***** trying out plantuml
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
setup
#+begin_src emacs-lisp :results silent
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path "~/src/org/contrib/scripts/plantuml.jar")
#+end_src

usage -- sequence diagram
#+begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
#+end_src

#+name:
[[file:tryout.png]]

***** eval for side effect on export
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
- one plus one
  #+name: one-plus-one
  #+begin_src emacs-lisp :exports none :results silent
    (+ 1 1)
  #+end_src
- plus one is
  #+begin_src emacs-lisp :var two=one-plus-one :exports both
    (+ 1 two)
  #+end_src

***** eval and noeval
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
date, should export both, but won't output results because of presence
of the =:noeval= header argument.
#+begin_src sh :noeval :exports both
  date
#+end_src

should export code, so no need to do anything
#+begin_src sh
  date
#+end_src

should export nothing, and should not query
#+name: this-is-ls
#+begin_src sh :eval query :exports code
  date
#+end_src

should export results, and should trigger query above
#+begin_src emacs-lisp :var ls=this-is-ls :exports results
  ls
#+end_src

***** duplicate results on execute subtree
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
- second
- third
"
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

***** not caching
   :PROPERTIES:
   :session:  *R*
   :results:  output
   :exports:  both
   :cache:    yes
   :DATE:     2010-08-25
   :END:

#+begin_src R :noeval
  cat("random result:", runif(1), "\n")
  Sys.sleep(2)
  alarm()
#+end_src 

#+begin_src R :noeval
  cat("random result:", runif(1), "\n")
  Sys.sleep(2)
  alarm()
#+end_src 

****** cache on export
    :PROPERTIES:
    :DATE:     2010-08-25
    :END:
do we export cached blocks

#+begin_src emacs-lisp :cache yes :exports results
  (random)
#+end_src

#+name[46632b4fe2e3a23e847953c95adcba58c270b381]:
: 490528137

****** looks like this is a problem with info collection
    :PROPERTIES:
    :DATE:     2010-08-25
    :END:
#+begin_src emacs-lisp
  (format "%S" info)
#+end_src

#+begin_src emacs-lisp :results scalar :exports results :tangle yes :comments yes
  (mapcar (lambda (el) (list (car el) (cdr el))) (nth 2 info))
#+end_src

#+name[4184710f118ac768ea0d90632508792d695efd7a]:
| :cache    | yes                   |
| :colnames | no                    |
| :comments | yes                   |
| :exports  | results               |
| :hlines   | yes                   |
| :noweb    | no                    |
| :results  | output replace scalar |
| :session  | *R*                   |
| :shebang  |                       |
| :tangle   | yes                   |

#+begin_src emacs-lisp :exports results
  (message "calculating info")
  (org-babel-sha1-hash info)
#+end_src

#+name[0427db66afdc95462d1c8514b662829987d71ff5]:
: 0427db66afdc95462d1c8514b662829987d71ff5

***** issues with shell evaluation
   :PROPERTIES:
   :DATE:     2010-08-25
   :END:
#+begin_src sh :results silent
  cd ~/src/org/
  make
#+end_src

***** org results and replace
   :PROPERTIES:
   :DATE:     2010-08-18
   :END:

#+begin_src emacs-lisp :results org
  "| 1 | 2 |
| 2 | 3 |"
#+end_src

#+name:
| 1 | 2 |
| 2 | 3 |

#+begin_src R
  rnorm(1)
#+end_src

#+begin_src R
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

#+begin_src R :colnames yes
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| V1 | V2 | V3 |
|----+----+----|
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

***** ledger example output text
   :PROPERTIES:
   :DATE:     2010-08-13
   :END:
#+name: ledger-stuff
#+begin_example
09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src sh :var stuff=ledger-stuff
  echo "$stuff"
#+end_src

***** tangle R and load
  :PROPERTIES:
  :tangle:   to-load.r
  :DATE:     2010-08-12
  :END:

evaluate this
#+begin_src emacs-lisp :results silent :tangle no
  (setq org-babel-post-tangle-hook nil)
  (add-hook 'org-babel-post-tangle-hook
            (lambda () (ess-load-file (buffer-file-name))))
#+end_src

then tangle

#+begin_src R :comments yes
x <- 10
#+end_src

#+begin_src R
 y <- 9
#+end_src

#+begin_src R :tangle file2.R
 y <- 9
#+end_src

***** lob -- writing results out to files
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: table
#+begin_src emacs-lisp
  (mapcar
   (lambda (el) (number-sequence el (+ el 3)))
   (number-sequence 0 4))
#+end_src

writes the results out as csv file
#+call: write(data=table, file="~/Desktop/example.csv") :results silent

writes the results out as tab separated file
#+call: write(data=table, file="~/Desktop/example.tsv") :results silent

write the results out as a normal org-mode file
#+call: write(data=table, file="~/Desktop/example.org") :results silent

***** lisp
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src lisp :var n=5
  (mapcar (lambda (el) (* el el)) (append '(1 7 3 4) (list n)))
#+end_src

#+name:
| 1 | 49 | 9 | 16 | 25 |

#+name: short-list
| 1 |
| 2 |
| 3 |

#+begin_src lisp :var lst=short-list :session t
  (+ 1 (length lst))
#+end_src

#+name:
: 4

***** importing the output of ledger
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: ledger-output
#+begin_example 
  09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
  09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
  09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src emacs-lisp :var ledger=ledger-output
  (with-temp-buffer
    (insert ledger)
    (message ledger)
    (org-table-convert-region (point-min) (point-max) 2)
    (org-table-to-lisp))
#+end_src

#+name:
| 09-Aug-21 CHEQUE : 9953055                | Expenses:Unknown | 166.70 EUR  | 166.70 EUR  |
| 09-Sep-17 CHEQUE : 7691785                | Expenses:Unknown | 100.00 EUR  | 266.70 EUR  |
| 09-Oct-16 REMISE CHEQUE N 8686318 001 105 | Expenses:Unknown | -525.00 EUR | -258.30 EUR |

***** comments in R blocks
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src R :session *R* :results output
  # this is a comment
  x <- rnorm(1)
  # this is another comment
  x
#+end_src

#+name:
: 
: [1] 1.320853

***** colnames to specific variables
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+tblname: spec-colnames
| one | two | thee |
|-----+-----+------|
| 1   | 2   | 3    |

#+tblname: nospec-colnames
| three | two | one |
|-------+-----+-----|
|     3 |   2 |   1 |

#+begin_src python :var nospec=nospec-colnames :var spec=spec-colnames :colnames '(spec)
  return nospec
#+end_src

#+name:
| one   | two | thee |
|-------+-----+------|
| three | two | one  |
| 3     | 2   | 1    |

***** caption on code block
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+caption: Examples of variable declaration.
#+label: sql-block
#+begin_src sql
SELECT 6*9;
#+end_src

***** palendromic primes
   :PROPERTIES:
   :DATE:     2010-07-20
   :END:
Note that because Haskell is funny about what can be typed into the
interpreter, the following should be loaded with
=org-babel-load-in-session=.
#+begin_src haskell
  palendromic_primes = [x | x <- [1..], prime x, palendrome x]
      where
        factors n = [x | x <- [1..floor(sqrt(fromIntegral(n)))], n `mod` x == 0]
        prime n = factors n == [1]
        primes = [x | x <- [2..], prime x]
        palendrome n = show(n) == reverse(show(n))
  
  palendromic_prime_distances = map (\(x,y)-> y-x) neighbors
      where
        neighbors = (zip palendromic_primes (tail palendromic_primes))
#+end_src

#+name: palendromic_prime_distances
#+begin_src haskell
  take 180 (zip [1..] palendromic_prime_distances)
#+end_src

For high-quality png output from gnuplot, the following sequence of
graphing to a =.eps= file, and then converting to a =.png= can be
useful.
#+name: dist-graph
#+begin_src gnuplot :var data=palendromic_prime_distances :file pps.eps
  set term postscript landscape color enhanced
  set log y
  set title "distance between consecutive palendromic primes"
  plot "$data" with fs notitle
#+end_src

The =convert= command is part of the [[http://www.imagemagick.org/script/index.php][imagemagick]] suite.
#+begin_src sh :var input=dist-graph :results file
  convert -depth 300 -rotate 90 $input pps.png
  echo "pps.png"
#+end_src

***** input from an example block
   :PROPERTIES:
   :DATE:     2010-07-13
   :END:
#+name: lorem
#+begin_example 
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
  culpa qui officia deserunt mollit anim id est laborum.
#+end_example

#+begin_src emacs-lisp :var lorem=lorem
  (message "%d words in Lorem" (length (split-string lorem)))
#+end_src

#+name:
: 68 words in Lorem

#+name: 1D
| 1 |
| 2 |
| 3 |
| 4 |

#+begin_src emacs-lisp :var lst=1D[:,0]
  lst
#+end_src

#+name:
: 1

***** limited precision
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

#+name: anova-example
| Effect | DFn | DFd |             SSn |              SSd |                F |                    p | p<.05 |              pes |
|--------+-----+-----+-----------------+------------------+------------------+----------------------+-------+------------------|
| Days   |   9 | 153 | 166235.12250176 | 151101.038615303 | 18.7026979326383 | 8.99534541600196e-21 | *     | 0.52384550792003 |

#+begin_src emacs-lisp :var tab=anova-example :colnames yes :cache yes
  (mapcar
   (lambda (row)
     (mapcar
      (lambda (cell) (if (numberp cell) (format "%.4f" cell) cell))
      row))
   tab)
#+end_src

#+name[16ac354f1e7a65594bb59e252ab221e6a4b10f80]:
| Effect |    DFn |      DFd |         SSn |         SSd |       F |                    p | p<.05 |    pes |
|--------+--------+----------+-------------+-------------+---------+----------------------+-------+--------|
| Days   | 9.0000 | 153.0000 | 166235.1225 | 151101.0386 | 18.7027 | 8.99534541600196e-21 | *     | 0.5238 |

***** fixing result insertion
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:
needs to replace the results when there is a new hash

****** normal results
    :PROPERTIES:
    :DATE:     2010-07-12
    :END:
#+begin_src sh
  date
#+end_src

#+name:
: Mon Jul 12 22:18:16 PDT 2010

****** unnamed source block results
    :PROPERTIES:
    :DATE:     2010-07-12
    :END:
#+begin_src emacs-lisp :cache yes
  (+ 1 2 3 4)
#+end_src

#+name[16a776d6d139e1d39e99d736536a546df115c2dc]:
: 10

#+begin_src emacs-lisp :cache yes
  (list '(1 2 3) '(4 5 6))
#+end_src

#+name[53f489ed6977857b9945d79d06e575b2cbbebf11]:
| 1 | 2 | 3 |
| 4 | 5 | 6 |

****** named source block results
    :PROPERTIES:
    :DATE:     2010-07-12
    :END:

#+name: something-w-table
#+begin_src emacs-lisp
  (sleep-for 2)
  (list '(1 2 3) '(4 5 8))
#+end_src

#+name: something
#+begin_src emacs-lisp :cache yes
  (+ 1 2 3 4 8)
#+end_src

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enimad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut
aliquip ex ea commodo consequat. Duis aute irure dolor in
reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
culpa qui officia deserunt mollit anim id est laborum.

# something else
#+name[d053f6643d9dc52a0e804c15f2a762da73a00a07]: something
: 18

#+attr_latex: width=0.4\textwidth
#+name[5fac69648ab749ef9ee88ea65b3d49d93f3f6cc8]: something-w-table
| 1 | 2 | 3 |
| 4 | 5 | 8 |

***** example w/o source name
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

delete emacs-lisp below for errors
#+begin_src emacs-lisp
  (* (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1))
#+end_src

***** tangle R and load
   :PROPERTIES:
   :tangle:   with-comments.r
   :comments: yes
   :DATE:     2010-07-09
   :END:

#+begin_src R :tangle no
  z <- 0
#+end_src

#+begin_src R
  x <- 8
#+end_src

#+begin_src R
  y <- 9
#+end_src

#+name: i-have-a-name
#+begin_src R 
  x+y+z
#+end_src

***** export blocks w/o languages
   :PROPERTIES:
   :DATE:     2010-07-09
   :END:
should raise an error

source
#+begin_src emacs-lisp
  ;; this is a comment
  (+ 1 1 1)
#+end_src

broken source
#+begin_src 
  (+ 2 2 2)
#+end_src

example
#+begin_example 
  this is exampled
#+end_example

#+begin_src ruby
  # this is the first
  [1, 2, 3, 4, 5].map{|r| r+1}
#+end_src

***** scratch
   :PROPERTIES:
   :DATE:     2010-07-08
   :END:

#+begin_src emacs-lisp :exports results
  (+ 1 1 1 1)
  (setq org-export-babel-evaluate t)
#+end_src

and now for src_emacs-lisp{87} an inline block

looking at paths
#+begin_src emacs-lisp
  (buffer-file-name)
#+end_src

***** Tom found a bug
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:

#+begin_src emacs-lisp :tangle something.el
  (list 1 (+ 2 3))
#+end_src

#+name:
| 1 | 5 |

***** dot
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:
#+begin_src dot :file models.png :cmdline -Tpng
  digraph data_relationships {
    "data_requirement" [shape=Mrecord, label="{DataRequirement|description\lformat\l}"]
    "data_product" [shape=Mrecord, label="{DataProduct|name\lversion\lpoc\lformat\l}"]
    "data_requirement" -> "data_product"
  }
#+end_src

#+name:
[[file:models.png]]

***** python errors
   :PROPERTIES:
   :DATE:     2010-07-04
   :END:
#+begin_src python :session :results value
  [1, [2], 3, 4]
#+end_src

#+name:
| 1 | (2) | 3 | 4 |

#+begin_src ruby :results output :session
  [1, 2, 3, 4, 6].map{|n| puts n}
#+end_src

#+name:
: 1
: 2
: 3
: 4
: 6

#+begin_src python :session :results output
  print 9
#+end_src

#+name: R-with-colnames
| one |
|-----|
| 1   |

#+begin_src R :results output
  "something"
#+end_src

#+name:
: [1] "something"

#+begin_src R :session *R* :results output
  1
  2
  3
  4
#+end_src

#+name:
: [1] 1
: [1] 2
: [1] 3
: [1] 4

#+begin_src perl :results output
  print "8\n";
  print "9\n";
#+end_src

#+name:
: 8
: 9

#+begin_src clojure
  (+ 8 7)
#+end_src

#+name:
: 15

#+begin_src clojure :session *clj*
  (println "eric")
#+end_src

#+name:
: nil

#+begin_src perl :results value
  8
#+end_src

#+name:
: 8

#+begin_src c++ :includes '(<stdio.h> <math.h> <cstdlib> <time.h>)
  printf("eric schulte\n");
#+end_src

#+name:
: eric schulte

#+begin_src sh
  echo 78
#+end_src

#+name:
: 78

***** table comment issue
   :PROPERTIES:
   :DATE:     2010-06-30
   :END:
#+BEGIN_changemargin {-4.2cm}{0cm}
  #+TBLNAME: AutresFPNVE
  #+ATTR_LaTeX: align=lrrrrr
  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Total                                    |                      |                 |                |            |    1062.02 |
  | ^ |                                          |                      |                 |                |            |      Total |
  #+tblfm: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+END_changemargin

save me!

#+begin_src org
  ,  #+TBLNAME: AutresFPNVE
  ,  #+ATTR_LaTeX: align=lrrrrr
  ,  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  ,  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  ,  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  ,  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  ,  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Total                                    |                      |                 |                |            |    1062.02 |
  ,  | ^ |                                          |                      |                 |                |            |      Total |
  ,  #+TBLFM: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+end_src

#+begin_example 
#+tblname: example
| 1 | 2 |
#+end_example

***** latex literals in export
      :PROPERTIES:
      :DATE:     2010-06-30
      :END:

     #+ATTR_LaTeX: width=\textwidth
     [[./composite-pattern.png]]

***** captions
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:

#+caption: I'm not removed from export
#+label: also-not-removed
| A | B |
| 1 | 2 |

***** booktabs
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:
#+tblname: months
| num | Abbrev. |
|-----+---------|
|   1 | Jan.    |
|   2 | Feb.    |
|   3 | Mar.    |

#+call: booktabs(table=months, align="r|l") :results latex :exports results

***** table-label
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+label: bam
| 1 |
| 2 |
| 3 |

***** haskell issues
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:

#+begin_src haskell
  length [1, 2]
#+end_src

#+name:
: 2

#+tblname: example-4-haskell
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |

#+begin_src haskell :var this=example-4-haskell
  length this
#+end_src

#+name:
: 7

***** complex
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+name: raw-data
#+begin_src sh :results scalar
  wget --quiet -qO- "http://ogdi.cloudapp.net/v1/dc/RecreationParks?format=json"
#+end_src

#+name: dc-parks
#+begin_src emacs-lisp :var keys='(ward area) :var data=raw-data
  (mapcar
    (lambda (lis) (mapcar (lambda (key) (cdr (assoc key lis))) keys))
    (cdr (car (with-temp-buffer
                (insert data) (goto-char (point-min))
                (json-read)))))
#+end_src

#+name: dc-parks-metric
#+begin_src ruby :var data=dc-parks
  data.map{|f| [f[0], 2.59 * f[1]]}
#+end_src

#+begin_src R :var parkData=dc-parks-metric :file parks.png :session *R*
  plot(parkData)
  title(main="Park size by Ward")
#+end_src

#+name:
[[file:parks.png]]

***** possible prefixes
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                    5 |
| org-b-   |                    2 |
| orgb-    |                    3 |
| org-bbl- |                    0 |
| bbl-     |                    4 |
| babel-   |                    2 |
#+TBLFM: $2='(sbe leftover (prefix $$1))

#+name: leftover
#+begin_src emacs-lisp :var prefix=""
  (-
   ;; length w/o .el
   (- 13 (length ".el"))
   ;; length of prefix
   (length prefix))
#+end_src

***** hlines in python
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+name: echo-table
#+begin_src python :var tab=many-cols :hlines yes :exports both :session
  return tab
#+end_src

#+begin_src emacs-lisp :var table=echo-table :exports none
  (butlast (apply #'append (mapcar (lambda (el) (list el 'hline)) table)))
#+end_src

#+call: echo-table(tab=many-cols)

#+begin_src python :exports results
  return [['foo', 'bar', 'baz'], ["a", "b", "None of the above"], ['1', 2, 3]]
#+end_src

#+begin_src emacs-lisp :exports results
  (message "Exist")
#+end_src

***** protecting block bodies
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
neither of these work as expected

#+begin_src org
  ,#+TITLE: stuff
  
  ,#+begin_src emacs-lisp
  ,  (message "something")
  ,#+end_src
  
  ,more stuffs
  
  ,#+resname: something
  ,: value
  
  ,# and a comment
#+end_src

#+begin_src org
  ,* example org
  
  ,# this is a comment
  ,this is not a comment
#+end_src


#+begin_src org
  ,* escaped org-mode markup
  
  ,this should be exported as is
  ,#+results: escaping-example
  ,: 24
#+end_src


#+begin_html 
<pre>
#comment
#+end_src
</pre>
#+end_html
final

***** multiple evals for refs
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
#+begin_src emacs-lisp
  (setq counter 0)
#+end_src

#+name:
: 0

#+name: counter
#+begin_src emacs-lisp
  (setq counter (+ 1 counter))
  counter
#+end_src

#+begin_src emacs-lisp :var counter_val=counter
  counter_val
#+end_src

#+name:
: 3

***** tangling
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:

#+begin_src sh :shebang #!/bin/sh :tangle yes
  date
#+end_src

#+begin_src sh :shebang #!/bin/bash :tangle whoisme :exports both
  echo $USER
#+end_src

#+begin_src emacs-lisp :tangle yes :comments yes
  (message "BAM")
#+end_src

#+begin_src fortran :exports both
  1+8
#+end_src

***** cache on export
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:
do we export cached blocks

#+begin_src sh :cache yes :exports results
  date
#+end_src

#+name[06ed73c6d8d022cf9c323d92af885952865add17]:
: Thu Jun 17 07:35:19 PDT 2010

***** foo org
   :PROPERTIES:
   :session:  *R*
   :DATE:     2010-06-16
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
#+BEGIN_SRC R 
plot(x, y)
abline(out1)
#+END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
#+attr_latex: width=0.8\textwidth,placement=[p]
#+label: fig:one
#+caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

***** comments not commented
   :PROPERTIES:
   :DATE:     2010-06-16
   :END:

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   #+name: plotxy
   #+begin_src emacs-lisp :exports results
     (message "I think so")
   #+end_src
   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src
   

   can cause problems

2) how about this one...

***** don't eat me!
   :PROPERTIES:
   :DATE:     2010-06-15
   :END:
1) a source block inside of an =enumerate=
   #+begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   #+end_src

   #+name:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

***** simple reference
   :PROPERTIES:
   :DATE:     2010-06-13
   :END:
#+tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src emacs-lisp :var data=table-the-first[1,1]
  data
#+end_src

#+name:
: 5

***** exporting with call lines
   :PROPERTIES:
   :DATE:     2010-06-11
   :END:
#+name: rpn-to-alg(alg)
#+begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \* \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
#+end_src

#+name: distributed-best
: 73*x11/+4/++51xxx13*y/++6y5*6/6-+xx+*

#+call: rpn-to-alg(alg=distributed-best)
 
***** can't open indented results
      :PROPERTIES:
      :DATE:     2010-06-11
      :END:

      #+begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
       	\begin{preview}
       	\ovalbox{
       	\begin{tikzpicture}
       	\node{$n$}
       	  child {
            node{$\left(\frac{n}{2}\right)^2$}
              child{
               	node{$\left(\frac{n}{4}\right)^2$}
               	node{$\left(\frac{n}{4}\right)^2$}
              }
            }
       	  child{
            node{$\left(\frac{n}{2}\right)^2$}
            child{
              node{$\left(\frac{n}{4}\right)^2$}
              node{$\left(\frac{n}{4}\right)^2$}
            }
       	  };
       	\end{tikzpicture}
       	}
       	\end{preview}
      #+end_src

      #+name:
      [[file:recursion.pdf]]

***** indented source-code blocks and indented results
      :PROPERTIES:
      :DATE:     2010-06-10
      :END:

       #+name: time
       #+begin_src emacs-lisp :results append
       	 ;; (list (list (current-time-string)))
       	 (current-time-string)
       #+end_src

       #+name: time
       | 1 | 2 | 3 |


           #+call: time() :results prepend

           #+name: time()
           | 1 | 2 | 3 |
           : Thu Jun 10 14:13:21 2010
           : Thu Jun 10 14:13:21 2010
           : : Thu Jun 10 14:13:21 2010
           : : Thu Jun 10 14:13:21 2010
           : : Thu Jun 10 14:13:21 2010
           : nil
           : nil
           : Thu Jun 10 14:11:22 2010
           : Thu Jun 10 14:11:20 2010
           : nil
           : nil
           : Thu Jun 10 14:06:04 2010
           : Thu Jun 10 14:06:03 2010
           : Thu Jun 10 14:05:51 2010
           : Thu Jun 10 14:05:57 2010
           : Thu Jun 10 14:06:00 2010

***** not expand inlines in examples
   :PROPERTIES:
   :DATE:     2010-06-08
   :END:

: src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

***** updating results "in-situ"
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+name: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be *above* the block

#+name: in-situ
#+begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
#+end_src

#+name: in-situ
#+begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
#+end_src

***** unwind-protect with narrowing
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

I'm not in the subtree

****** I'm in the subtree
    :PROPERTIES:
    :DATE:     2010-06-07
    :END:
#+begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
#+end_src

***** stripping existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
#+name: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

#+begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
#+end_src

#+name:
: don't include me in the export!!!!!!!

#+name: trickily-located-somehwere-else
#+begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
#+end_src

***** non-empty comint prompt
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src ruby :session eric
  8 + 9
#+end_src

***** inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :DATE:     2010-06-07
   :END:

#+begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
#+end_src

***** indented source names
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

   #+name: i-am-indented
   #+begin_src emacs-lisp 
     (message "i am indented")
   #+end_src

#+name: i-am-indented
: i am indented

#+begin_src emacs-lisp :var output=i-am-indented
  (length output)
#+end_src

#+name:
: 13

  #+name:
  : eric

***** export with existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
#+end_src

#+name:
| 1 | 2 |
| 3 | 4 |

#+begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
#+end_src

#+name:
[[file:/tmp/eric.png]]

***** executing emacs-lisp on export
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp
  (error "eric")
#+end_src

***** commas on tangling test
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
test comma protection on tangling

#+begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
#+end_src

#+begin_src org :tangle commas.org
  ,* org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,#+begin_src emacs-lisp
  ,  protected?
  ,#+end_src
#+end_src

#+begin_example 
  ,* this should be
  # commented out
  
  and maybe not this...
#+end_example

***** simple table
   :PROPERTIES:
   :DATE:     2010-06-06
   :END:
#+begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
#+end_src

#+name:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

***** inline expressions
   :PROPERTIES:
   :session:  'default
   :DATE:     2010-06-06
   :END:

#+begin_src R :exports code :results silent
  x<-4
#+end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

***** adding file names to literal values on export
   :PROPERTIES:
   :DATE:     2010-06-01
   :END:

#+name: three
: 9

#+begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
#+end_src

#+begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
#+end_src

***** appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :DATE:     2010-05-28
   :END:
append all these block

#+begin_src emacs-lisp
  (message "block %d" 1)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 2)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 3)
#+end_src

***** visibility affecting execution
      :PROPERTIES:
      :DATE:     2010-05-27
      :END:
***** folding
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:
lets test folding

****** folded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "folded1")
#+end_src

#+name:
: folded1

#+begin_src emacs-lisp
  (message "folded2")
#+end_src

#+name:
: folded2
******* unfolded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "unfolded1")
#+end_src

#+name:
: unfolded1
#+begin_src emacs-lisp
  (message "unfolded2")
#+end_src

#+name:
: unfolded2

***** empty code blocks -- and latex vs. LaTeX
   :PROPERTIES:
   :DATE:     2010-05-26
   :END:
eric
#+begin_src latex
  
#+end_src

michael
#+begin_src LaTeX
  
#+end_src

schulte
#+begin_src emacs-lisp
  (message "error")
#+end_src

***** colnames
   :PROPERTIES:
   :DATE:     2010-05-04
   :END:

#+tblname: A
| a | b | c |
|---+---+---|
| d | e | f |
| g | h | i |

#+begin_src python :var tab=A :colnames yes
return [[val + '*' for val in row] for row in tab]
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"*"} }
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

***** lisps not fully eval'd
   :PROPERTIES:
   :DATE:     2010-04-30
   :END:

#+begin_src emacs-lisp
  (message "one")
  (message "two")
#+end_src

#+name:
: two

#+begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
#+end_src

#+name:
: 3

***** tangling org
   :PROPERTIES:
   :DATE:     2010-04-27
   :END:

#+begin_src org :tangle ~/Desktop/test.org
  ,* first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,* second
  
  ,some more stuff...
  
  ,#+HTML: <b>I bet this is quoted</b>
#+end_src

#+begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
#+end_src

***** variable indexing
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 #+TBLFM: $2=$1*$1::@8$2=vsum(@2..@-1)

#+begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
#+end_src

#+name:
| 0 | 1 | 4 | 9 | 16 | 25 |

#+begin_src python :var sum=MyTable[9,1] :exports none
   return sum
#+end_src

#+name:
: 55

#+begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
#+end_src

***** colnames mismatched sizes
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
#+end_src

#+name:
| 1 | 2 | 3 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
#+end_src

#+name:
| a | b |
|---+---|
| 1 | 2 |

#+begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
#+end_src

#+name:
| 1 | 2 |

***** test gnuplot
   :PROPERTIES:
   :DATE:     2010-04-17
   :END:

#+begin_src gnuplot
  plot sin(x), x+5
#+end_src

***** hline processing
   :PROPERTIES:
   :DATE:     2010-04-12
   :END:
#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

#+tblname: less-cols2
| 1 | 2 | 3 |

#+begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
#+end_src

#+begin_src ruby :var tab=less-cols
  tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var one=2
  1 + 2
#+end_src

#+name:
: 3

#+begin_src python :var tab=less-cols
  return tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var tab=less-cols :colnames no
  tab
#+end_src

#+name:
| 1 |
| 2 |
| 3 |

#+begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
#+end_src

#+name:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

#+tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
#+begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar* #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
#+end_src

***** evaluate references
   :PROPERTIES:
   :DATE:     2010-04-09
   :END:

#+begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
#+end_src

#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src ruby
  + 1 2
#+end_src

#+name:
: nil

***** tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :DATE:     2010-03-31
  :END:

#+name: A
#+begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
#+end_src

#+name: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

***** latex attributes
   :PROPERTIES:
   :DATE:     2010-03-23
   :END:

#+ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
#+begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
#+end_src

***** access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :DATE:     2010-03-22
   :END:

: "(org-entry-get nil "special" t)"

#+begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
#+end_src

#+name:
: 90

#+begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
#+end_src

#+name:
: schulte

***** variables into shell scripts
   :PROPERTIES:
   :DATE:     2010-02-23
   :END:
#+name: into-shell-scripts
| username | guest   |
| password | nothing |

#+begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
#+end_src

#+name:
: username -p nothing

#+name: number-into-shell
: 9

#+begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
#+end_src

#+name:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

***** results lines for function calls
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

#+call: fibonacci(input=5) :resname eric

#+name:
: 8

#+begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
#+end_src

#+name:
: fib(5)=8

***** haskell variables
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

playing with Haskell

#+name: haskell-stuff
: 9

#+begin_src haskell :var num=haskell-stuff
  num + 1
#+end_src

#+begin_src ruby :var num=haskell-stuff
  num + 1
#+end_src

#+name:
: 10

***** list index w/function style name
   :PROPERTIES:
   :DATE:     2010-02-14
   :END:

#+name: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

#+name: function-style-indexing(data=function-style-index[1:4,0])
#+begin_src emacs-lisp
  (message "%S" data)
#+end_src

#+name: function-style-indexing
: ((1) (2) (3) (4))

***** looking at source name exports
   :PROPERTIES:
   :DATE:     2010-02-09
   :END:

#+name: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+name: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

***** short shell test
   :PROPERTIES:
   :DATE:     2010-02-07
   :END:

#+begin_src sh
  date
#+end_src

#+name:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+name:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+name:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+name:
: 1--1

***** tables to shell scripts ideas
   :PROPERTIES:
   :DATE:     2010-02-06
   :END:

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

***** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-02-05
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "foo")
#+end_src

#+name:
: foo

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

***** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :DATE:     2010-02-03
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

***** ditaa blocks
   :PROPERTIES:
   :DATE:     2010-02-03
   :END:

#+begin_src ditaa :file communication.png :cache yes
  -------------
#+end_src

#+name[4fbfc78b37abd8a788958d28a7335445e6042c96]:
[[file:communication.png]]

***** babel block overwrite
   :PROPERTIES:
   :DATE:     2010-01-18
   :END:

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

***** load to session
   :PROPERTIES:
   :DATE:     2010-01-11
   :END:
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

***** links
   :PROPERTIES:
   :DATE:     2010-01-06
   :END:

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

***** fancier export
   :PROPERTIES:
   :DATE:     2010-01-05
   :END:

#+name: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

***** exporting org-source
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

***** exporting and caching
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+name:
[[file:data/example.png]]

***** no noweb by default
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+name: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+name:
: sample

***** looking at double quotes
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+name: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+name: double-quote-test-output
| test | this | 8 | 9 |

***** quoted session name
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+name:
: name-me

***** eval-buffer
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+name:
: 7

***** sql exports to latex
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
example from email list
****** ECM
    :PROPERTIES:
    :DATE:     2009-11-30
    :END:

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+name: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

***** gnuplot variable expansion
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:

#+name: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

***** debug hints
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

***** whitespace/newline results issues
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+name:
: 2

***** sh with sessions
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+name:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

***** xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

***** unresolved noweb references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+name: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

***** testing srcname aliases
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: two
#+begin_src emacs-lisp
  2
#+end_src

#+begin_src emacs-lisp :var input=two
  (+ input 1)
#+end_src

#+name[1ec6c8d3de6aaeac7b2720f1d801402e762875ea]:
: 3

***** =:table= results param
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

***** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

***** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

***** simple scalar
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

***** simple R
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

***** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src

***** results switches
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

***** reference parts of tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

***** quoted latex
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

***** pretty print
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

***** =pp= results
      :PROPERTIES:
      :DATE:     2009-11-20
      :END:
****** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

****** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example
***** noweb referernces
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

***** persistent python
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

****** more persistent python
    :PROPERTIES:
    :session:  default
    :DATE:     2009-11-20
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

***** multiple arguments
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

***** lua export
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

***** latex pngs
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
$x \mapsto y$

****** Theorem
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

***** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
stuff here

***** indexing into results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+name:
| schulte |
| is      |
| my      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

***** indexing into gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

***** indented
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

***** indentation
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src python
          9
#+end_src

***** hiding results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+name:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

***** haskell
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

***** haskell and tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

***** gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src gnuplot
plot cosx
#+end_src


#+end_src
      
***** empty =output= results for emacs-lisp
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

***** elisp variables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+name:
[[file:45.png]]

***** elisp references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+name: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

***** dynamic table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

***** code results
      :PROPERTIES:
      :DATE:     2009-11-20
      :END:
****** emacs lisp
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

****** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

****** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

***** clojure
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

***** changing source name
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

***** cached results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :cache yes
   (setq org-babel-default-header-args '((:session . "none")
                                         (:results . "replace")
                                         (:exports . "code")(:cache)))
#+end_src

#+name[937269632ae5b5eee5c93f9eb50e0bc55e34520d]:
| (:session . none) | (:results . replace) | (:exports . code) | (:cache) |

#+name: eric-schulte
#+begin_src emacs-lisp :cache yes
   (+ 5 7 1)
#+end_src

#+name[005b04829608b3d22b61686e90309af3a9a6fe7c]: eric-schulte
: 13

#+begin_src ditaa :file caching-example.png
    +--------------------+
    |                    |     +-----------+
    |                    |     |           |
    |                    |     |           |
    |      +----+        |     |           |
    |      |    |        |     +-----------+
    |      +----+        |
    |                    |
    +--------------------+
#+end_src

#+name[fd11ddbfd00f6038e6e37db71ddaf43d65b0e200]:
[[file:caching-example.png]]

***** asymptote
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

***** asymptote cosine
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

***** and then more
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
and more stuffs here

***** advanced table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |






















































*** catch and throw example
Captured [2014-06-06 Fri 11:26]
  (defun search-foo ()
         (catch 'loop
           (let ((i 0))
             (while (< i 10)
               (let ((j 0))
                 (while (< j 10)
                   (if (foo i j)
                       (throw 'loop (list i j)))
                   (setq j (1+ j))))
               (setq i (1+ i))))))
  [[info:elisp#Examples%20of%20Catch][info:elisp#Examples of Catch]]

*** assertion
(cl-assert FORM &optional SHOW-ARGS STRING &rest ARGS)

Verify that FORM returns non-nil; signal an error if not.
Second arg SHOW-ARGS means to include arguments of FORM in message.
Other args STRING and ARGS... are arguments to be passed to `error'.
They are not evaluated unless the assertion fails.  If STRING is
omitted, a default message listing FORM itself is used.

#+BEGIN_SRC emacs-lisp
(assert (equalp 2 2))
#+END_SRC

*** xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=

#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

*** custom query of user before evaluating code block
   :PROPERTIES:
   :DATE:     2012-02-08
   :END:
#+begin_src sh :eval (if (y-or-n-p "Run operation X?") "yes" "no")
  echo "Going ahead with operation X!"
#+end_src
*** call line which dumps out its own header argument info
   :PROPERTIES:
   :DATE:     2012-02-05
   :END:
This call line passes its in-buffer location to a code block.  Notice
that the call to =(point)= in the call line is saved into a header
argument named =:my-point= and is then retrieved by the variable
initialization.  This indirection is required because of /when/ and
/where/ the elisp forms in header arguments are evaluated, a simpler
call line like =#+call: show:((point))= would not work because the
form =(point)= would not be evaluated in the correct place.

#+call: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info)))) :special-header "foo"

The special header argument =:special-header= may be seen in the
output below.  The =results= variable is due to the way that call
lines are evaluated.  During evaluation a call line is converted into
a trivial elisp code block of the form
: #+begin_src emacs-lisp :var results=called-function()
:   results
: #+end_src
which is evaluated in place.

#+RESULTS: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info))))
| (:var results ((:var nil)) ((:colname-names)) ((:rowname-names)) ((:result-params replace)) ((:result-type . value)) ((:comments . )) ((:shebang . )) ((:cache . no)) ((:padline . )) ((:noweb . yes)) ((:tangle . no)) ((:exports . code)) ((:results . replace)) ((:padnewline . yes)) ((:hlines . no)) ((:session . none))) |
| (:colname-names)                                                                                                                                                                                                                                                                                                               |
| (:rowname-names)                                                                                                                                                                                                                                                                                                               |
| (:result-params replace)                                                                                                                                                                                                                                                                                                       |
| (:result-type . value)                                                                                                                                                                                                                                                                                                         |
| (:comments . )                                                                                                                                                                                                                                                                                                                 |
| (:shebang . )                                                                                                                                                                                                                                                                                                                  |
| (:cache . no)                                                                                                                                                                                                                                                                                                                  |
| (:padline . )                                                                                                                                                                                                                                                                                                                  |
| (:noweb . yes)                                                                                                                                                                                                                                                                                                                 |
| (:tangle . no)                                                                                                                                                                                                                                                                                                                 |
| (:exports . code)                                                                                                                                                                                                                                                                                                              |
| (:results . replace)                                                                                                                                                                                                                                                                                                           |
| (:special-header . foo)                                                                                                                                                                                                                                                                                                        |
| (:padnewline . yes)                                                                                                                                                                                                                                                                                                            |
| (:hlines . no)                                                                                                                                                                                                                                                                                                                 |
| (:session . none)                                                                                                                                                                                                                                                                                                              |

This code block visits the location of the call line, and calculates
the info using the same mechanisms used by =org-babel-lob-execute=.
#+name: show
#+begin_src emacs-lisp :var call-line-location=0
  (let ((call-info (save-excursion
                     (goto-char call-line-location)
                     (org-babel-lob-get-info))))
    (mapcar #'list
            (org-babel-process-params
             (org-babel-merge-params
              org-babel-default-header-args
              (org-babel-params-from-properties)
              (org-babel-parse-header-arguments
               (org-babel-clean-text-properties
                (concat ":var results="
                        (mapconcat #'identity (butlast call-info) " "))))))))
#+end_src
*** noweb insertion edge cases
   :PROPERTIES:
   :DATE:     2012-01-24
   :END:
The =cat= line below is dangerously close to a noweb reference.  The
space after test.org keeps it from being interpreted as a noweb
reference.

#+begin_src sh :tangle test.out :noweb yes
  <<task1>>
  <<b>>
  cat <<test.org >> test.out2
#+end_src

#+begin_src sh :noweb-ref task1
 echo "hello world"
#+end_src

#+BEGIN_SRC sh :noweb-ref b
 echo "b"
#+END_SRC

*** issues with call lines result insertion
   :PROPERTIES:
   :session:  *R-babel*
   :DATE:     2012-01-24
   :END:
#+NAME: foo-for-R
#+HEADER: :var a="a1.png"
#+BEGIN_SRC R :results output silent
  cat("in foo-for-R block\n")
  cat.a <- function() { cat(a,"\n",sep="") }
  cat.a()
#+END_SRC

#+NAME: bar-for-R
#+begin_src R :results output raw replace :exports none
 cat.a()
#+end_src

Because there are three instances of the =bar-for-R()= call line, all
of their results are inserted into the same place in the file,
specifically the location of the =#+Results: bar-for-R()= line.  This
can be very confusing if you are expected each =bar-for-R()= line to
generate it's own results.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R()

The solution demonstrated below is to add a nothing header argument to
each bar-for-R to make it unique.  Notice that the three =foo= lines
below don't include results, as their results are inserted at the
identical foo lines above.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R[id=1]()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R[id=2]()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R[id=3]()

*** name src_emacs-lisp{org-current-export-file}
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
Fanciness with running code in header arguments.

One block to tangle.
#+BEGIN_SRC emacs-lisp :tangle yes
  (message "I am tangled")
#+END_SRC

One block to export.
#+BEGIN_SRC emacs-lisp :exports results :var foo=(org-babel-tangle)
  (message "I just tangled %S during export" foo)
#+END_SRC

*** inhibit some call line evaluation on export
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
A buffer in which we want =foo= to be run when called interactively
from /any/ call line, but to only be run by a single call line on
export.  Ensure this works by executing this buffer to html while
tracking =foo-called.times= with =tail -f /tmp/foo-called.times=.

#+NAME: foo
#+BEGIN_SRC sh :var id="foo"
  echo "called by $id at $(date +%s.%N)" |tee -a /tmp/foo-called.times
#+END_SRC

This will *not* be run on export.
#+call: foo[:eval no-export]("bar")

This *will* be run on export.
#+call: foo("baz")

*** code block export template
   :PROPERTIES:
   :DATE:     2012-01-14
   :END:

The =org-babel-exp-code-template= (see below for its documentation)
variable may be customized to control which information from code
blocks is exported.

- Example code block
  #+Name: foo
  #+BEGIN_SRC sh :bar baz
    echo qux
  #+END_SRC

- Evaluate this block to export (shows the export of the name).
  #+Name: do-export-name
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "\n=%name=:\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

- Evaluate this block to export (shows the export of header arguments).
  #+Name: do-export-header-arguments
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "Header arguments for =%name=.
    | header  | value    |
    |---------+----------|
    | bar     | %bar     |
    | results | %results |\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

: ,----[org-babel-exp-code-template]
: | org-babel-exp-code-template is a variable defined in `ob-exp.el'.
: | Its value is "#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"
: | 
: | Documentation:
: | Template used to export the body of code blocks.
: | This template may be customized to include additional information
: | such as the code block name, or the values of particular header
: | arguments.  The template is filled out using `org-fill-template',
: | and the following %keys may be used.
: | 
: |  lang ------ the language of the code block
: |  name ------ the name of the code block
: |  body ------ the body of the code block
: |  flags ----- the flags passed to the code block
: | 
: | In addition to the keys mentioned above, every header argument
: | defined for the code block may be used as a key and will be
: | replaced with its value.
: | 
: | You can customize this variable.
: `----

*** simple R session
   :PROPERTIES:
   :DATE:     2011-09-21
   :END:
#+begin_src R :session R
  paste("Yep!")
#+end_src

#+name:
: Yep!

*** should this throw an error for no variable definition
   :PROPERTIES:
   :DATE:     2011-09-15
   :END:
Evaluating this block should raise an error that there are
uninitialized variables.

#+name: add-column-in-table(table="", column="", something, type="", else, nullability)
#+begin_src sql
-- add column `$column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '$table'
               AND COLUMN_NAME = '$column')
BEGIN
    ALTER TABLE $table
    ADD $column $type $nullability
END
#+end_src

*** header arguments on call lines
   :PROPERTIES:
   :DATE:     2011-09-11
   :END:
#+name: simple-example
#+begin_src emacs-lisp
  "the result"
#+end_src

#+call: simple-example()

#+name: simple-example()
: the result

#+call: simple-example() :results raw

#+name: simple-example()
the result

*** removing result with a silent header argument
   :PROPERTIES:
   :DATE:     2011-09-07
   :END:
evaluating the following code block will remove the related result.

#+begin_src sh :results silent
  date +%Y-%m-%d
#+end_src

#+name:
: 2011-09-07

*** silent results in org but not in export
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
The results of the following code block will not be inserted during
interactive evaluation but will during export.

#+begin_src sh :results (if org-current-export-file "replace" "silent") :exports both
  echo  "I want to see this in HTML/PDF, but not in Org"
#+end_src

*** leading commas in code blocks
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
#+begin_src r :exports code
  a <- c(1
         , 2
         , 3)
#+end_src

#+begin_src org :exports code
  ,this one will have commas removed
  ,#+begin_src R
  ,  a <- c(1
  ,         , 2
  ,         , 3)
  ,#+end_src
#+end_src

*** returning file type to inline call line
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec
hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam
nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis
natoque penatibus et magnis dis parturient montes, nascetur ridiculus
mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non
turpis. call_nothing_to_something()[:results file] [[file:something.txt]]
Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan
nisl.

#+name: nothing_to_something
#+begin_src sh :file something.txt
  echo nothing
#+end_src

*** demarcation of indented blocks
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Demarcating a block with the point part-way in a line should indent
the remainder of the line in the second block.
    #+begin_src sh
      echo 1
      echo 2
      echo 3
      echo 4
    #+end_src

becomes

    #+begin_src sh :results silent :session something
      echo 1
      echo 2
      echo
    #+end_src
    
    #+begin_src sh :results silent :session something
           3
      echo 4
    #+end_src

*** simple indexing
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+name: list-o-numbers
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src sh :var column=list-o-numbers[,0]
  echo $column
#+end_src

#+name:
: 1 4 7

*** simple gnuplot plotting of Org-mode tables
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+tblname: gnuplot-testing
| x |  y |
|---+----|
| 1 |  2 |
| 2 |  4 |
| 3 |  6 |
| 4 |  8 |
| 5 | 10 |
| 6 | 12 |
| 7 | 14 |
| 8 | 16 |

#+begin_src gnuplot :var data=gnuplot-testing :file output.eps
set term postscript
set title "test"
set auto x
set style data histogram
set style fill solid border -1
set boxwidth 0.9
plot data using 2:xtic(1)
#+end_src

*** simple short R block
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+BEGIN_SRC R
c(1,23,54,5)
#+END_SRC

#+name:
|  1 |
| 23 |
| 54 |
|  5 |

*** convert results to all string
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+name: hetero-table
#+begin_src emacs-lisp
  '((1 2 3 4)
    ("a" "b" "c" "d"))
#+end_src

#+name: all-to-string
#+begin_src emacs-lisp :var tbl='()
  (defun all-to-string (tbl)
    (if (listp tbl)
        (mapcar #'all-to-string tbl)
      (if (stringp tbl)
          tbl
        (format "%s" tbl))))
  (all-to-string tbl)
#+end_src

#+begin_src emacs-lisp :var tbl=hetero-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| nil | nil | nil | nil |
| t   | t   | t   | t   |

#+begin_src emacs-lisp :var tbl=all-to-string(hetero-table)
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| t | t | t | t |
| t | t | t | t |

*** two blocks and a table
   :PROPERTIES:
   :DATE:     2011-08-28
   :END:

#+name: stuff
#+begin_src sh
  echo 1
  echo 2
  echo 3
#+end_src

#+name: last-of-stuff
#+begin_src sh :var input=stuff
  echo "$input" |tail -1
#+end_src

| one |
| two |
| 3   |
#+TBLFM: @3$1='(sbe last-of-stuff)

*** inheriting the file property
   :PROPERTIES:
   :FILE: something.png
   :DATE:     2011-08-23
   :END:

#+begin_src ditaa
   +-----------------------------+
   |                             |
   |    +-----+                  |
   |    |     |   +---------+    |
   |    |     |   |         |    |
   |    +-----+   |         |    |
   |              |         |    |
   |   file       |         |    |
   | inheritance  +---------+    |
   |                             |
   +-----------------------------+
#+end_src

#+name:
[[file:something.png]]

*** a table with tags
   :PROPERTIES:
   :DATE:     2011-08-23
   :END:

#+TBLNAME: sandbox           :noexport:
| 1 |         2 | 3 |
| 4 | org-babel | 6 |

#+begin_src emacs-lisp :var table=sandbox
  (message "%S" table)
#+end_src

#+name:
: ((1 2 3) (4 "org-babel" 6))

*** shell script output not in table
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
#+begin_src sh :results scalar
  echo 1
  echo 2
  echo 3
#+end_src

#+name:
: 1
: 2
: 3

*** inline code block and downstream src blocks
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
something src_sh{echo eric}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src sh
  echo schulte
#+end_src
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

**** with R
    :PROPERTIES:
    :DATE:     2011-08-21
    :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
blah blah src_R[:results output]{cat(rnorm(2))}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src R :eval never :exports none
  1+2
  a <- b + c
  xyz
#+end_src
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

*** updating a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-another-table
| 0 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 0 | 0 |

#+name: this-is-another-table
#+begin_src emacs-lisp :var table=this-is-another-table
  (setf (nth 1 table) '(2 2 2))
  table
#+end_src

*** space around exported code blocks
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
try evaluating the following blocks, then removing their results with
M-x `org-babel-remove-result'

Verbiage to begin the paragraph
#+begin_src sh
  echo eric
#+end_src
and verbiage to end the same paragraph.

#+begin_src sh
  echo 1
  echo 2
#+end_src

and verbiage to end the same paragraph.

*** simple ditaa block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ditaa :file work-flow.png
    +-------+             +--------+
    |       |             |        |
    | Org   |------------>| Tex    |
    |       |             |        |
    +-------+             +--------+
#+end_src

#+name:
[[file:work-flow.png]]

*** ruby code block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ruby
  1+2
#+end_src

#+name:
: 3

*** replacing a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-the-table
| 1 | 4 | 7 |
| 2 | 5 | 8 |
| 3 | 6 | 9 |

#+name: this-is-the-table
#+begin_src emacs-lisp :var table=this-is-the-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (* cell 2)) row)) table)
#+end_src

*** tangle before evaluating a code block
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:

#+begin_src sh :var TANGLED=(org-babel-tangle) :tangle no
  wc $TANGLED
#+end_src

#+name:
: 2  2 11 it.sh

#+begin_src sh :tangle it.sh
  echo TEST
#+end_src

*** bug with undefined function copy-seq
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:
#+begin_src R :session :exports both
  1:10
#+end_src

*** plot results with org-plot
   :PROPERTIES:
   :DATE:     2011-08-02
   :END:
#+name: disk-usage
#+begin_src sh :exports both
  df
#+end_src

#+PLOT: title:"Disk Usage" ind:6 deps:(5) type:2d with:histograms set:"yrange [0:100]"
#+name: disk-usage
| Filesystem | 1K-blocks |     Used | Available | Use% | Mounted   | on |
| /dev/sda6  |  28835836 |  8447712 |  18923344 |  31% | /         |    |
| none       |   2997072 |      676 |   2996396 |   1% | /dev      |    |
| none       |   3006056 |        0 |   3006056 |   0% | /dev/shm  |    |
| none       |   3006056 |       96 |   3005960 |   1% | /var/run  |    |
| none       |   3006056 |        0 |   3006056 |   0% | /var/lock |    |
| /dev/sda7  | 144176824 | 72225604 |  64627420 |  53% | /home     |    |

*** premature truncation of emacs-lisp results
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src emacs-lisp
  '(nil nil nil nil)
#+end_src

#+name:
: (nil nil nil nil)

*** non-defined code blocks can still tangle
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src text :tangle somewhere.txt
  This will still tangle out to a file, and it opens in text mode, which
  may be nice.  
#+end_src

*** expand noweb refs
   :PROPERTIES:
   :DATE:     2011-07-25
   :END:
#+name: def-something
#+begin_src sh
  SOMETHING=nothing
#+end_src

#+begin_src sh
  <<def-something>>
  echo $SOMETHING
#+end_src

*** returning file names -- interpreted as lists
   :PROPERTIES:
   :DATE:     2011-07-21
   :END:
#+begin_src sh :results scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
: [[file:./cv.cls]]

#+begin_src sh :results raw scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
[[file:./cv.cls]]

*** java code block
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src java :classname myfirstjavaprog
  class myfirstjavaprog
  {  
      public static void main(String args[])
      {
          System.out.println("Hello World!");
      }
  }
#+end_src

#+name:
: Hello World!

*** including noweb refs w/o last newline
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src sh :noweb yes
  <<my-name>> |\
  <<capitalize-name>>
#+end_src

#+name: my-name
#+begin_src sh
  echo "eric schulte"
#+end_src

#+name: capitalize-name
#+begin_src sh
  sed 's/^e/E/;s/ s/ S/'
#+end_src

*** exporting a ditaa example
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:

#+begin_src ditaa :file blue.png :cmdline -r
/---------------\
|    test       |
|        {cBLU} |
\---------------/
#+end_src

#+name:
[[file:blue.png]]

*** simple sbe example
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

|   1 |
|   2 |
|   3 |
|   4 |
|   5 |
|   6 |
| 3.5 |
#+TBLFM: @7$1='(sbe mean (lst @1..@6))

#+name: mean
#+begin_src emacs-lisp :var lst=()
  (let ((num (car lst)) (nums (cdr lst)))
    (/ (float (+ num (apply #'+ nums))) (1+ (length nums))))
#+end_src

*** eval never
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

#+begin_src emacs-lisp :eval (if org-export-current-backend "never" "yes") :exports results
  (message "launch missles")
#+end_src

#+name:
: launch missles

*** indexing into a list variable
   :PROPERTIES:
   :DATE:     2011-07-06
   :END:

#+begin_src emacs-lisp :var lst='(0 1 2)
  (first lst)
#+end_src

#+name:
: 0

or as a noweb reference

#+name: external-list
- 0
- 1
- 2

#+begin_src sh :noweb yes
  echo <<external-list()[0]>>
#+end_src

#+name:
: 0

*** data alias for resname
   :PROPERTIES:
   :DATE:     2011-07-05
   :END:
#+name: blah
: blahcontent

#+begin_src emacs-lisp :var it=blah
  it
#+end_src

#+name:
: blahcontent

*** find a resource by global id
   :PROPERTIES:
   :DATE:     2011-07-01
   :END:

#+begin_src emacs-lisp :var it=990f3218-6fce-44fb-bd0c-5f6076c0dadc
  it
#+end_src

#+name:
: 
: here it is

**** I'm the resource
    :PROPERTIES:
    :ID:       990f3218-6fce-44fb-bd0c-5f6076c0dadc
    :DATE:     2011-07-01
    :END:

here it is

*** define a block with a name for noweb expansion
   :PROPERTIES:
   :tangle:   yes
   :noweb:    yes
   :DATE:     2011-07-01
   :END:

#+name: simple(something="something")
#+begin_src emacs-lisp
  something
#+end_src

another block including the first block
#+begin_src emacs-lisp
  <<simple(something="something else")>>
#+end_src

*** longtable label and attr lines on code block results
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:

#+name: faz
#+begin_src emacs-lisp :exports results
  '((foo foo)
    (bar baz))
#+end_src

#+LABEL: Foo
#+name: faz
| foo | foo |
| bar | baz |

*** another test
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:
#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

Here is a call_square(it=4), stuck in the middle of some prose.

Here is another 25^2=call_square(it=25).

*** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

*** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

*** multiple variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

Should work call_concat(1, 2, 3) =123= in order.

#+name: concat
#+begin_src emacs-lisp :var a=0 :var b=0 :var c=0
  (format "%S%S%S" a b c)
#+end_src

Should be positive call_lob-minus(4, 3) =1= by order.

*** inline call line
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: double
#+begin_src emacs-lisp :var it=0
  (* 2 it)
#+end_src

This is the number src_sh[:var it=double(it=1)]{echo $it} in the middle

The following exports as a normal call line
#+call: double(it=1)

Now here is an inline call call_double(it=1) stuck in the middle of
some prose.

This one should not be exported =call_double(it=2)= because it is
quoted.

Finally this next one should export, even though it starts a line
call_double(it=3) because sometimes inline blocks fold with a
paragraph.

And, a call with raw results call_double(4)[:results raw] should not
have quoted results.

*** text and graphics from R
   :PROPERTIES:
   :DATE:     2011-06-24
   :END:

#+begin_src R :results output :session
print(seq(1,10))
#+end_src

#+begin_src R :file example.png :results graphics :session
plot(seq(1,10))
#+end_src

#+name:
[[file:example.png]]

*** large code in inline blocks
   :PROPERTIES:
   :DATE:     2011-06-22
   :END:

#+name: big-block
#+begin_src emacs-lisp :exports none
  "something complex"
#+end_src

Here is some text with src_emacs-lisp[:var it=big-block]{it} in the middle.

*** clojure =:results scalar=
   :PROPERTIES:
   :DATE:     2011-06-21
   :END:
#+begin_src clojure :results scalar
  '(1 2 3)
#+end_src

*** expand variable during tangling
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2011-06-20
   :END:

#+begin_src sh :var VER=(vc-working-revision (buffer-file-name))
  echo $VER
#+end_src

*** scalar emacs lisp results
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src emacs-lisp :results scalar
  '(1 2 3)
#+end_src

#+name:
: (1 2 3)

*** python session
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src python :results output :session mypy 
x = 1
for i in range(1,5):
  x = x + i
  print x

print "I throw an error"
#+end_src

#+name:
: 
: ... ... ... 2
: 4
: 7
: 11
: I throw an error

#+begin_src python :results output :session
  print y
#+end_src

#+name:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: NameError: name 'y' is not defined

*** named code block export
   :PROPERTIES:
   :DATE:     2011-06-13
   :END:
This has a name which is not exported.

#+name: rand(n)
#+begin_src R
  runif(n)
#+end_src

*** tangle test
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src R :tangle test.R :shebang #!/bin/cat :padline no
This is
a test
#+end_src

*** ruby with xmpfilter
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src ruby :results xmp code
  2 + 2 # =>
  3.times{ puts :hello }
#+end_src

#+name:
#+BEGIN_SRC ruby
2 + 2 # => 4
3.times{ puts :hello }
# >> hello
# >> hello
# >> hello
#+END_SRC

*** continued code blocks
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2011-06-10
   :END:
#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 1)
#+end_src

#+begin_src emacs-lisp
  (message "un-named")
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 1)
#+end_src

#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 2)
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 2)
#+end_src

#+begin_src emacs-lisp :tangle no :results silent
  (with-temp-buffer
    (insert-file-contents "~/src/lisp/org-make-triple.el")
    (eval-buffer))
#+end_src

*** simple shell
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh
  sleep 10 && ls
#+end_src

#+name:
| _config.yml     |
| data            |
| development.org |
| elsevier        |
| index.org       |
| paper           |
| publish.org     |
| scraps          |
| scraps.html     |
| scraps.org      |
| scraps.tex      |

#+begin_src ruby :session eric
  puts [1..4]
#+end_src

#+name:
: nil

*** quick testing new session code
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh :session test :results output
  echo foo
#+end_src

#+name:
: foo

#+begin_src ruby :results output :session simple
  puts "foo"
#+end_src

#+name:
: foo

*** =:file= and python
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src python :file /tmp/test.png
  return 1
#+end_src

#+name:
[[file:/tmp/test.png]]

*** testing new data names
   :PROPERTIES:
   :DATE:     2011-06-02
   :END:

#+name: simple-123
: 123

#+begin_src emacs-lisp :var simple=simple-123 :exports both
  (* simple 2)
#+end_src

results

data

my data is results

#+name:
: 246

*** default directory examples in lisp
   :PROPERTIES:
   :DATE:     2011-06-01
   :END:

#+begin_src lisp
  *default-pathname-defaults*
#+end_src

#+begin_src sh
  pwd
#+end_src

#+begin_src lisp :dir
  *default-pathname-defaults*
#+end_src

#+name:
: #P""

*** lisp body with multiple forms
   :PROPERTIES:
   :DATE:     2011-05-31
   :END:

#+begin_src lisp :results value
  (format t "~&eric")
  (+ 1 2)
#+end_src

#+name:
: 3

*** passing values through to STDIN of shell code blocks
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:
#+name: square-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+name: first-col
#+begin_src sh :stdin square-table
  awk '{print $1}'
#+end_src

#+begin_src sh :stdin first-col
  sed 's/4/middle/g'
#+end_src

#+name:
|      1 |
| middle |
|      7 |

*** awk example
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:

#+name: simple-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src awk :stdin simple-table
  {print $1}
#+end_src

#+name:
| 1 |
| 4 |
| 7 |

*** don't match end_src inside of a block
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:

#+name: the_issue
#+begin_src sh :results output
  echo '#+end_src'
#+end_src

#+name: the_issue
: #+end_src block

*** append tables
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:
#+name: table-names
- first-table
- second-table
- third-table

#+name: first-table
| a | 1 |
| b | 2 |

#+name: second-table
| c | 3 |
| d | 4 |

#+name: third-table
| e | 5 |
| f | 6 |

#+begin_src emacs-lisp :var table-names=table-names
  (mapcar #'org-babel-ref-resolve table-names)
#+end_src

#+name:
| (a 1) | (b 2) |
| (c 3) | (d 4) |
| (e 5) | (f 6) |

*** ocaml
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+begin_src ocaml
  [3;2;3] @ [3;2;3;4;5];;
#+end_src

#+name:
| 3 | 2 | 3 | 3 | 2 | 3 | 4 | 5 |

*** new names for results
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+name: simple
: 1

#+begin_src emacs-lisp :var data=simple
  data
#+end_src

#+name:
: 1

changing the variable used to label data
#+begin_src emacs-lisp :results silent
  (setq org-babel-result-fmt
        "^[ \t]*#\\+\\(TBLNAME\\|RESNAME\\|RESULTS\\|DATA\\):[ \t]*%s[ \t]*$")
#+end_src

#+name: not-so-simple
: 2

#+begin_src emacs-lisp :var data=not-so-simple
  data
#+end_src

#+name:
: 2

*** simple latex verbatim wrap example
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-export-latex-verbatim-wrap
        '("{\\scriptsize\n\\begin{verbatim}\n" . "\\end{verbatim}\n}\n"))
#+end_src

#+begin_src sh
  echo eric schulte
  echo another
#+end_src

*** inserting complicated results
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results scalar
  ((lambda (result) (condition-case nil (read result) (error result)))
   "(:return
   (:ok \"{:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}\")
   13)")
#+end_src

#+name:
| :return | (:ok {:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}) | 13 |

*** automatic org-mode formatting
   :PROPERTIES:
   :DATE:     2011-04-27
   :END:

#+name: raw-results
#+begin_src sh :results output tabular
  echo "| 1 |"
  echo "| 2 |"
#+end_src

#+begin_src emacs-lisp :var in=raw-results
  (stringp in)
#+end_src

#+name:
: t

*** units in R plot
   :PROPERTIES:
   :DATE:     2011-04-21
   :END:
#+begin_src R  :results graphics :file test.png :width 8 :height 8 :res 200 :units cm
  x <- -10:10
  y <- x^2
  plot(x, y, type="l", col="red", lty=1)
#+end_src

#+name:
[[file:test.png]]

*** simple Oz example
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
#+begin_src oz :results output
  {Browse 'Hello'}
#+end_src

*** Ocaml appending blocks
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
block

#+begin_src ocaml
  [|1;2;3|];;
#+end_src

#+name:
| 1 | 2 | 3 |

*** complex numbers in tables and python, reference in table formula
   :PROPERTIES:
   :DATE:     2011-04-13
   :END:

#+name: parameter-variation(data=0)
#+begin_src python :result values
  return 'text'
#+end_src

|---------------------------------------|
| "(0.0331901438056,0.000535222885197)" |
| "(0.0333434157791,0.000537930174356)" |
| "(0.0345727512157,0.000559346040457)" |
| "(0.0353146483908,0.000571501584524)" |
| "(0.0355522909393,0.000574387067408)" |
| "(0.0356575682336,0.000574851263615)" |
| "(0.0357806926897,0.000575051685084)" |
|---------------------------------------|
| text                                  |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

| '(1 2 3 4) |
|------------|
|          4 |
#+TBLFM: @2$1='(sbe quote (it @1$1))

| (1 2 3 4) |
|-----------|
| #ERROR    |
#+TBLFM: @2$1='(sbe quote (it @1$1))

**** using vectors to represent complex number is lisp
    :PROPERTIES:
    :DATE:     2011-04-15
    :END:
| [1 2]            |
|------------------|
| real:1 complex:2 |
#+TBLFM: @2$1='(sbe real (it @1$1))

#+name: real(it='())
#+begin_src emacs-lisp
  (format "real:%d complex:%d" (aref it 0) (aref it 1))
#+end_src

**** reference the table in a table formula
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
|-------------------------------------|
|                                   4 |
#+TBLFM: @2$1='(sbe quote (it "complex-data"))

**** externally referencing the table
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

#+begin_src python :var data=complex-data
  return data
#+end_src

#+name:
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |

*** emacs-lisp printing with output to string
   :PROPERTIES:
   :DATE:     2011-04-10
   :END:

#+begin_src emacs-lisp :results output
  (let ((dog (sqrt 2))
        (cat 7))
    (print (format "%s %f" "Dog: " (eval dog)))
    (print (format "%s %d" "Cat: " (eval cat)) nil)
    (print "Fish."))
#+end_src

#+name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."

#+begin_src emacs-lisp
  (let ((dog (sqrt 2))
        (cat 7))
    `((dog ,dog)
      (cat ,cat)
      (fish)))
#+end_src

#+name:
| dog  | 1.4142135623730951 |
| cat  |                  7 |
| fish |                    |

*** session associated with R block
   :PROPERTIES:
   :DATE:     2011-04-02
   :END:
#+begin_src R :session *chris*
  x <- 1
  y <- 2
  y-x
#+end_src

#+name:
: 1

*** vc-log
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

A version control log of this file.  The =vc-log= code block lives in
the library of babel.
#+call: vc-log() :exports results

*** tangling out vc information
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

#+headers: :var STATE=(vc-state (or (buffer-file-name) org-current-export-file))
#+headers: :var REV=(vc-working-revision (or (buffer-file-name) org-current-export-file))
#+begin_src sh :tangle yes
  rm -rf ./R
  rm -f ./spreadSim.sub
  REVISION=$REV.$STATE
  tar -xf nsa.$REVISION.tar.gz
  $HOME/R/R/R-2.12.0/bin/Rscript --vanilla -e
"source('./R/generateLatinHypercubeScenarios.R'); doIt()"
  for SCENARIO in ./R/scenarios/*.R; do
    export SCENARIO=${SCENARIO#./R/scenarios/}
    qsub nsa.sub
  done
#+end_src

*** grabbing the current buffer during export
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
Eric

#+begin_src emacs-lisp :var buf=(buffer-file-name (current-buffer)) :exports both
  (message "buffer %S!" buf)
#+end_src

#+begin_src sh :exports results :results output
  git log -1
#+end_src

*** detangling example
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :shebang:  #!/bin/sh
   :ID:       7a22cf71-6be3-4fca-a700-4c8be8237303
   :DATE:     2011-04-01
   :END:

#+name: sh-for-tangling
#+begin_src sh
  echo "this is the `sh-for-tangling' code block"
  num=`expr 1 + 1`
  echo "the value of num is $num"
#+end_src

#+begin_src sh
  echo "this is an unnamed code block"
#+end_src

*** CL example
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
#+begin_src lisp
  (defun range (n &optional m)
    "Return the numbers in range."
    (loop for num from (if m n 0) to (if m m (- n 1)) collect num))
  
  (mapcar #'list (mapcar #'1+ (range 10)))
#+end_src

#+name:
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

*** colnames with call lines
   :PROPERTIES:
   :DATE:     2011-03-29
   :END:
#+TBLNAME: data
| x | parameter | value |
|---+-----------+-------|
| 0 | heat      |    30 |
| 1 | heat      |    30 |

#+name: func5
#+begin_src R :var name=data :var a="one" :colnames yes
  names(name)
#+end_src

#+name: func5
| x         |
|-----------|
| x         |
| parameter |
| value     |

#+call: func5(name=data, a="two") :colnames yes

#+name: func5(name=data, a="two")
| x         |
|-----------|
| x         |
| parameter |
| value     |

*** macros during tangling
   :PROPERTIES:
   :ID:       d2ff9d6f-b413-4072-91a9-3ae8aa32032c
   :DATE:     2011-03-14
   :END:

First, add macro expansion to the new `org-babel-tangle-body-hook'.

#+begin_src emacs-lisp :results silent
  (add-hook 'org-babel-tangle-body-hook
            (lambda () (org-export-preprocess-apply-macros)))
#+end_src

Then define the macro.  Note: you may need to export the buffer before
tangling so that the macro definition is noticed and processed by
Org-mode.

#+MACRO: CONFIG_PARAM01 45

Then on both export and tangling the macro in the following code block
will be replaced.

#+begin_src sh :tangle yes
  echo org-mode set CONFIG_PARAMETER to: {{{CONFIG_PARAM01}}}
#+end_src

*** conflicting header arguments
   :PROPERTIES:
   :DATE:     2011-03-14
   :END:

code block
#+name: conflict-block
#+begin_src sh :exports results :results silent
  echo eric
#+end_src

call line
#+call: conflict-block() :exports results

#+name: conflict-block()
: eric

*** looks like a pipe in a table
   :PROPERTIES:
   :DATE:     2011-03-07
   :END:
#+name: clean
#+begin_src emacs-lisp :var in=""
  (flet ((clean (in)
                (if (listp in)
                    (mapcar #'clean in)
                  (if (stringp in)
                      (replace-regexp-in-string "¦" "|" in)
                    in))))
    (clean in))
#+end_src

#+name: regexps
| first  | (a¦b) |
| second | (1¦2) |

#+begin_src perl :var a=clean(in=regexps)[0,1] :var b=clean(in=regexps)[1,1]
  $a; $b;
#+end_src

#+name:
: (1|2)

*** eval results as a list
   :PROPERTIES:
   :DATE:     2011-03-06
   :END:
#+begin_src python :results value
  return "(mapcar (lambda (el) (+ 1 el)) '(1 2))"
#+end_src

#+name:
| 2 | 3 |

#+begin_src python :results value
  return "[1, 2]"
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return [1, 2]
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return "%r" % "[1 2]"
#+end_src

#+name:
: [1 2]

*** simple mysql
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
#+begin_src sql :engine mysql
  show tables;
#+end_src

*** export of inline R code
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
Here I test inline code evaluation in R.

#+begin_src R :session *R*
x <- 100
#+end_src

#+name:
: 100

Now I want to export the value of x, which should be
src_R[:session *R*]{x} .

Did the number 100 show up at the end of the previous sentence on export?

*** results org raw wrap
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+begin_src sh :results output org :exports none
  cat <<EOF
  - first
  - second
  EOF
#+end_src

#+name:
#+BEGIN_ORG
- first
- second
#+END_ORG

**** Version 1
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version only prints the org code for the table, but does not interprets it.
#+begin_src R :exports both :results output raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

**** Version 2
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version prints the table including the graph as expected, but
:results is used twice as a header argument.
#+begin_src R :results output :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

**** Version 3
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
Finally this version does only export the R code
#+begin_src R :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

*** leading/trailing spaces
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+name: spaces-wrapped-string
- " pass through with space "

#+begin_src emacs-lisp :var res=spaces-wrapped-string[0]
  res
#+end_src

#+name:
:  pass through with space 

*** reference to a commented out subtree
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
**** COMMENT I don't export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+name: hidden-parameters
| 1 |
| 2 |
| 3 |
| 4 |

**** I do export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+begin_src emacs-lisp :var params=hidden-parameters :exports both
  params
#+end_src

*** literal reference in a table with sbe
   :PROPERTIES:
   :DATE:     2011-02-28
   :END:

| "eric schulte" | 12 |
#+TBLFM: @1$2='(sbe length (in $1))

#+name: length
#+begin_src emacs-lisp :var in="foo"
  (length in)
#+end_src

*** strip hline before processing a variables indices
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+name: table-w-hline
| 1 | a |
|---+---|
| 2 | b |
| 3 | c |
| 4 | d |

#+begin_src emacs-lisp :var table=table-w-hline[1,1] :hlines no
  table
#+end_src

#+name:
: hline

#+tblname: perl-table-w-hline
| colA | colB |
|------+------|
| a1   | b1   |
| a2   | b2   |

#+headers: :var b=perl-table-w-hline[2..,1]
#+headers: :var a=perl-table-w-hline[2..,0]
#+begin_src perl :tangle yes
  $a; $b;
#+end_src 

*** passing elisp-looking variables to code blocks
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src perl :var it="(+ 1 1)" :results output
  printf "passed in %s", $it
#+end_src

#+name:
: passed in (+ 1 1)

#+name: elisp-looking-table
| 1 | (+ 1 1) |
| 2 | (a b c) |
| 3 | (+ 3 3) |

#+begin_src perl :var data=elisp-looking-table[1,1]
  $data
#+end_src

#+name:
: (a b c)

#+begin_src emacs-lisp :var data=elisp-looking-table[1,1]
  data
#+end_src

#+name:
: (a b c)

*** pass a vector to calc
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:

#+begin_src calc :var y=[1 2 3]
  y
#+end_src

#+name:
: [1 2 3]

#+begin_src calc :var y=[1 2 3]
  3 y
#+end_src

#+name:
: [3, 6, 9]

#+begin_src emacs-lisp :var data=[1 2 3]
  (elt data 1)
#+end_src

#+name:
: 2

#+begin_src calc
  1 * 8
#+end_src

#+name:
: 8

*** new block regexp tests
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:
**** Block 1 (Exports OK)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 1
#+END_SRC

**** Block 2 (Exports OK - double blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out


#+END_SRC

**** Block 3 (Fails - single blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out

#+END_SRC

**** Block 4 (Gets consumed by previous Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 4
#+END_SRC

**** Block 5 (Fails - no lines in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
#+END_SRC

**** Block 6 (Gets consumed by previous Block
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 6
#+END_SRC

*** don't interpret tuples as elisp code
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src python :results value
  return (1,2)
#+end_src

#+name:
: (1, 2)

*** source block names in current buffer
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src emacs-lisp :results list
 (org-babel-src-block-names)
#+end_src

*** simple python block
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src python :return foo
  foo = 8
  foo += 1
#+end_src

#+name:
: 9

*** sh return a list of elements with spaces
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src sh :results list
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
- ("eric" "schulte")
- ("dan" "davison")
- ("seb" "vauban")

#+begin_src sh :results scalar
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
: eric schulte
: dan davison
: seb vauban

*** calc variables inside of parenthesis
   :PROPERTIES:
   :DATE:     2011-02-22
   :END:
#+BEGIN_SRC calc :var testvar=9000
testvar - 200
#+END_SRC

#+name:
: 8800

#+BEGIN_SRC calc :var testvar=9000
(testvar - 200) 800
#+END_SRC

#+name:
: 7040000

*** new lists
    :PROPERTIES:
    :DATE:     2011-02-21
    :END:
**** results embedded inside of a list
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
1. this has results
   #+name: something-in-a-list
   : foo
2. and this doesn't work
   #+begin_src emacs-lisp :var data=something-in-a-list
     data
   #+end_src

   #+name:
   : foo

**** reading and writing
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
#+name: simple-list
- 1
- two
- 3
- four


#+name: simple-list
#+begin_src emacs-lisp :var lst=simple-list :results list
  (reverse lst)
#+end_src

*** catch the file name during export
   :PROPERTIES:
   :DATE:     2011-02-21
   :END:

#+begin_src emacs-lisp :var file-name=(buffer-file-name) :exports both
  file-name
#+end_src

*** mentions of file names in file contents
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
directory to search
#+name: graph-dir
: graph-dir

list all files in dir
#+name: graph-files
#+begin_src sh :results vector :var dir=graph-dir
  find $dir -type f -exec basename {} \;
#+end_src

#+name: graph-files
| other |
| dan   |
| eric  |
| seb   |

association of files with mentions
#+name: graph-associations
#+begin_src sh :var dir=graph-dir :var files=graph-files
  for i in $files; do
      for j in `grep -l -r $i $dir`;do
          echo $i, `basename $j`
      done
  done
#+end_src

#+name: graph-associations
| other | eric |
| other | seb  |
| dan   | eric |
| eric  | seb  |
| seb   | dan  |

graphing with dot
#+name: to-dot
#+begin_src sh :var associations=graph-associations :results scalar
  echo "$associations"|awk '{print $1, "->", $2}'
#+end_src

#+name: to-dot
: other -> eric
: other -> seb
: dan -> eric
: eric -> seb
: seb -> dan

#+begin_src dot :var data=to-dot :file files.png
  digraph G{
    $data
  }
#+end_src

#+name:
[[file:files.png]]

*** export of inline code blocks which are silent
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
#+begin_src emacs-lisp :results silent
  (setf org-babel-default-inline-header-args
        '((:session . "none")
          (:results . (if (boundp 'org-current-export-file) "replace" "silent"))
          (:exports . "results")))
#+end_src

Here is an inline code block src_sh{echo 8} <- there

*** inline code block
   :PROPERTIES:
   :DATE:     2011-02-18
   :END:

here is an inline block src_R{1+1}

*** SQL --- example reading org-mode table into sql
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+tblname: example-table-for-sql
| a |  b |
|---+----|
| 1 | 10 |
| 2 | 11 |
| 3 | 12 |
| 4 | 13 |
| 5 | 14 |
| 6 | 15 |

#+headers: :var table=example-table-for-sql
#+begin_src sql :engine mysql
load data infile "$table" into mytable;
#+end_src

*** recutils
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+begin_src sh :file book.rec
  cat <<EOF > book.rec
  # -*- mode: rec -*-
  %rec: Book
  %mandatory: Title
  %type: Location enum loaned home unknown
  %doc:
  + A book in my personal collection.
  
  Title: GNU Emacs Manual
  Author: Richard M. Stallman
  Publisher: FSF
  Location: home
  
  Title: The Colour of Magic
  Author: Terry Pratchett
  Location: loaned
  
  Title: Mio Cid
  Author: Anonymous
  Location: home
  
  Title: chapters.gnu.org administration guide
  Author: Nacho Gonzalez
  Author: Jose E. Marchesi
  Location: unknown
  
  Title: Yeelong User Manual
  Location: home
  
  # End of books.rec
  EOF
#+end_src

#+name:
[[file:book.rec]]

#+begin_src rec :data book.rec :fields Title,Author
  Location = 'loaned'
#+end_src

#+name:
| Title               | Author          |
| The Colour of Magic | Terry Pratchett |

#+begin_src rec :data book.rec :fields Title,Author
  
#+end_src

#+name:
| Title                                 | Author              | Author_2         |
| GNU Emacs Manual                      | Richard M. Stallman |                  |
| The Colour of Magic                   | Terry Pratchett     |                  |
| Mio Cid                               | Anonymous           |                  |
| chapters.gnu.org administration guide | Nacho Gonzalez      | Jose E. Marchesi |
| Yeelong User Manual                   |                     |                  |

*** passing keywords inside header arguments
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:

#+begin_src emacs-lisp :var lst='(:no-expand :other)
  lst
#+end_src

#+name:
| :no-expand | other |

*** two vars in a properties block -- not possible
   :PROPERTIES:
   :var:      test1=7
   :var:      test2=8
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp
  (message "test1=%S test2=%S" test1 test2)
#+end_src

results in Error
: let: Symbol's value as variable is void: test2

**** an alternative
    :PROPERTIES:
    :var:      tests=all-tests
    :DATE:     2011-02-10
    :END:

#+tblname: all-tests
- 7
- 8

#+begin_src emacs-lisp :var eric=89
  (message "test1=%S test2=%S" (first tests) (second tests))
#+end_src

#+name:
: test1=7 test2=8

**** another alternative
    :PROPERTIES:
    :var:      vars=variables
    :DATE:     2011-06-21
    :END:

#+tblname: variables
| var1 | 1 |
| var2 | 2 |

#+begin_src python
  print vars[0][1]
  print vars[1][1]
#+end_src

*** how to set no-expand in properties
   :PROPERTIES:
   :no-expand: yes
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp :var something="other thing" :tangle no-expand.el
  :test
#+end_src

tangles to

*** non-inlined inline code block
   :PROPERTIES:
   :DATE:     2011-01-27
   :END:
The Date is src_sh[:results replace]{date} at the time of =this= export.

src_sh[:results replace]{ls}

*** simple calc example
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src calc 
2*3
#+end_src

#+name:
: 6

*** results replace not always working
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src sh :results output org replace :exports code
  for i in `seq 4`;do
      echo "- place $i in the list"
  done
#+end_src

#+name:
#+BEGIN_ORG
- place 1 in the list
- place 2 in the list
- place 3 in the list
- place 4 in the list
#+END_ORG

inline block src_emacs-lisp[:exports code :results replace]{(+ 1 1 1)} here is was

*** inserting wrappers eats following characters
    :PROPERTIES:
    :DATE:     2011-01-20
    :END:
**** Test
     :PROPERTIES:
     :DATE:     2011-01-20
     :END:
   
   #+begin_src emacs-lisp :results latex
     "\\begin{equation}\\frac{1}{2}\n\\end{equation}"
   #+end_src

   #+name:
   #+BEGIN_LaTeX
   \begin{equation}\frac{1}{2}
   \end{equation}
   #+END_LaTeX
   
**** Watch me die :-(
     :PROPERTIES:
     :DATE:     2011-01-20
     :END:

*** creating a directory when needed for tangling
   :PROPERTIES:
   :DATE:     2011-01-19
   :END:
#+begin_src clojure :tangle (prog1 "src/foo.clj" (make-directory "src" "."))
  (ns something)
#+end_src

a helper function for the above
#+begin_src emacs-lisp
  (defun mkdir-p (file &optional dir)
    "Create any parent directories of FILE if missing and return FILE."
    (make-directory (file-name-directory file) (or dir ".")) file)
#+end_src

allows the following
#+begin_src clojure :tangle (mkdir-p "src/foo.clj")
  (ns something)
#+end_src

There is now a new header argument controlling this behavior
#+begin_src emacs-lisp :mkdirp yes :tangle novel/nested/directories/finally.clj
  (message "contents")
#+end_src

*** passing arguments to the shell
   :PROPERTIES:
   :DATE:     2011-01-18
   :END:
#+name: something
: eric
:   schulte
:     yes
: more

#+name: something-list
| 1 |
| 2 |
| 3 |

#+begin_src sh :var data=something-list
  echo "$data"|wc -l
#+end_src

#+name:
: 3

#+begin_src emacs-lisp :results silent
  (setq org-babel-sh-var-quote-fmt "`cat <<'BABEL_TABLE'\n%s\nBABEL_TABLE\n`")
#+end_src

*** wrap noweb references in comments
   :PROPERTIES:
   :DATE:     2011-01-16
   :END:
#+name: wrappable
#+begin_src emacs-lisp
  (setq x (+ 4 x))
#+end_src

#+begin_src emacs-lisp :comments noweb :noweb yes :tangle yes
  (let ((x 1))
    (message "x=%s" x)
    <<wrappable>>
    (message "x=%s" x))
#+end_src

*** replace inline code block
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
This is src_emacs-lisp{(+ 1 2 3)} an inline block.

#+begin_src emacs-lisp
  (defun replace-inline-block ()
    (interactive)
    (if (save-excursion (re-search-backward "[ \f\t\n\r\v]" nil t)
                        (looking-at org-babel-inline-src-block-regexp))
        (replace-match
         ((lambda (el) (if (stringp el) el (format "%S" el)))
          (org-babel-execute-src-block)) nil nil nil 1)
      (error "not inside of an inline source block.")))
#+end_src

*** noweb then variables
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
#+name: replaced-first
#+begin_src latex
  \begin{itemize}
  \item first
  \item data
  \item third
  \end{itemize}
#+end_src

#+begin_src latex :var data="second" :noweb yes
  \section{ordinals}
  \label{sec:ordinals}
  <<replaced-first>>
#+end_src

*** empty strings as arguments
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:

#+begin_src emacs-lisp :results output :var foo=""
  (concat foo "bar")
#+end_src

#+name:
: bar

*** call lines
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:
#+name: doubler
#+begin_src emacs-lisp :var n=2
  (* n 2)
#+end_src

#+call: doubler(n=3)

#+name: doubler(n=3)
: 6

#+call: doubler[:var n=3]()

#+name: doubler[:var n=3]()
: 6

*** language name abbreviations
   :PROPERTIES:
   :DATE:     2011-01-07
   :END:

#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("clj" . clojure))
#+end_src

#+begin_src clj
  (map (partial + 1) (range 20))
#+end_src

*** eval query
   :PROPERTIES:
   :DATE:     2010-12-21
   :END:
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate
        (lambda (lang body) (not (equal "ditaa" lang))))
#+end_src

#+name:
| lambda | (lang body) | (not (equal ditaa lang)) |

#+begin_src emacs-lisp :eval query
  (message "eval'd")
#+end_src

#+name:
: eval'd

#+begin_src ditaa
  ---
#+end_src

*** new file handling
   :PROPERTIES:
   :DATE:     2010-12-20
   :END:

#+begin_src sh :sep , :file dirlisting
  ls -l
#+end_src

#+name:
[[file:dirlisting]]

#+begin_src ruby :file ruby-out
  [[1, 2, 3, 4],
   [2, 4, 6, 8]]
#+end_src

#+name:
[[file:ruby-out]]

#+begin_src emacs-lisp :results file :results append
  (let ((today (replace-regexp-in-string "[ \t]" "-" (current-time-string))))
    (with-temp-file today
      (insert (message "I'm feeling %s"
                       (nth (random 3) (list "good" "bad" "just fine")))))
    today)
#+end_src

#+name:
[[file:Mon-Dec-20-17:27:52-2010]]

from http://www.graphviz.org/Gallery/directed/fsm.gv.txt
#+begin_src dot :file fsa.png
  digraph finite_state_machine {
          rankdir=LR;
          size="8,5"
          node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;
          node [shape = circle];
          LR_0 -> LR_2 [ label = "SS(B)" ];
          LR_0 -> LR_1 [ label = "SS(S)" ];
          LR_1 -> LR_3 [ label = "S($end)" ];
          LR_2 -> LR_6 [ label = "SS(b)" ];
          LR_2 -> LR_5 [ label = "SS(a)" ];
          LR_2 -> LR_4 [ label = "S(A)" ];
          LR_5 -> LR_7 [ label = "S(b)" ];
          LR_5 -> LR_5 [ label = "S(a)" ];
          LR_6 -> LR_6 [ label = "S(b)" ];
          LR_6 -> LR_5 [ label = "S(a)" ];
          LR_7 -> LR_8 [ label = "S(b)" ];
          LR_7 -> LR_5 [ label = "S(a)" ];
          LR_8 -> LR_6 [ label = "S(b)" ];
          LR_8 -> LR_5 [ label = "S(a)" ];
  }
#+end_src

#+name:
[[file:fsa.png]]

*** utf8 and latin-1 encodings
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+tblname: toto
| é |

#+begin_src python :var t=toto :preamble # -*- coding: latin1 -*- :return [len(babel), len(local)]
  babel = unicode (t[0][0],"latin1")
  local = unicode ("é","latin1")
#+end_src

#+name:
| 2 | 2 |

*** tangle templates
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+name: template-heading
#+begin_src emacs-lisp
  some stuff here
#+end_src

#+name: template-footing
#+begin_src emacs-lisp
  some other stuff here
#+end_src

#+name: template
#+begin_src sh :results output :noweb yes :var body="body stuff"
heading=$(cat<<EOF
<<template-heading>>
EOF
)
footing=$(cat<<EOF
<<template-footing>>
EOF
)
echo $heading
echo "$body"
echo $footing
#+end_src

#+call: template[:noweb yes](body="something new")

#+name: template[:noweb yes](body="something new")
: some stuff here
: something new
: some other stuff here

*** missing lines on tangle
   :PROPERTIES:
   :ID:       83eb62fd-4147-405b-bdc2-567b2d5cbd70
   :DATE:     2010-12-13
   :END:
#+begin_src org :results latex :tangle latex-err.tex
  ,one
  ,two
  ,three
#+end_src

#+begin_src org :results latex :results replace
  ,- eric
  ,- schulte
#+end_src

#+name:
#+BEGIN_LaTeX
\begin{itemize}
\item eric
\item schulte
\end{itemize}
#+END_LaTeX

*** Python requires a utf-8 coding prefix
   :PROPERTIES:
   :DATE:     2010-12-02
   :END:
#+begin_src python :prefix # -*- coding: utf-8 -*- :return s
s = "é"
#+end_src

#+name:
: é

#+begin_src python :prefix # -*- coding: utf-8 -*- :results output
s = "é"
print(s)
#+end_src

#+name:
: é

*** empty lines in R session output
   :PROPERTIES:
   :DATE:     2010-12-01
   :END:
#+begin_src R :results output :session
  x <- 1;
  x
  x + 1
  x + 4
#+end_src R

#+name:
: [1] 1
: [1] 2
: [1] 5

*** sql variables
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: sql-param
| table       | valueTable0       |
| column      | valueColumn0      |
| type        | valueType0        |
| nullability | valueNullability0 |

I want to apply the values onto the following chunk of code:

#+name: add-column-in-table-0
#+begin_src sql :var table=sql-param[0,1] :var column=sql-param[1,1] :var type=sql-param[2,1] :var nullability=sql-param[3,1]
-- add column `@column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '@table'
               AND COLUMN_NAME = '@column')
BEGIN
    ALTER TABLE $table
    ADD $column $type @nullability
END
#+end_src

*** =:eval query= shows the name
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: i-have-a-name
#+begin_src sh :eval query
  date
#+end_src

#+name: i-have-a-name
: Tue Nov 30 22:03:25 MST 2010

*** python with return header argument
   :PROPERTIES:
   :DATE:     2010-11-27
   :END:

#+begin_src python :return y
  x = 8
  y = 98
  2
#+end_src

#+name:
: 98

*** un-named R code blocks
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+begin_src R
  8
#+end_src

#+name:
: 8

#+begin_src emacs-lisp :eric
8  
#+end_src

#+name:
: 8

#+BEGIN_SRC R :session :results output
 xyz
#+END_SRC

#+BEGIN_SRC R :session *R-2* :results output |  xyz
9
#+END_SRC

#+name:
: [1] 9

*** safe lists for Haskell
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:

#+tblname: mixed-table
| 1 | first  |
| 2 | second |
| 3 | third  |
| 4 | fourth | 

#+name: rec-string-wrap
#+begin_src emacs-lisp :var data=mixed-table
  (defun rec-string-wrap (in)
    (if (listp in) (mapcar #'rec-string-wrap in) (format "%S" in)))
  (rec-string-wrap data)
#+end_src

#+begin_src haskell :var tbl=rec-string-wrap(data=mixed-table)
  map head tbl
#+end_src

#+name:
| 1 | 2 | 3 | 4 |

*** reading from single-quote-delim languages
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+BEGIN_SRC python
return [['607', 'Show license short, name on the deed'],
        ['255', "'(message (concat 'hello ' 'world))"]]
#+END_SRC

#+name:
| 607 | Show license short, name on the deed |
| 255 | '(message (concat 'hello ' 'world))  |

#+begin_src ruby
  [['607', 'Show license, short name on the deed'],
   ['255', "))'(message (concat 'hello ' 'world"]]
#+end_src

#+name:
| 607 | Show license, short name on the deed |
| 255 | ))'(message (concat 'hello ' 'world  |

#+begin_src haskell
  [["'single quotes'", "b"], ["\"double quotes\"", "d"]]
#+end_src

#+name:
| 'single quotes' | b |
| "double quotes" | d |

*** add column to table with awk
   :PROPERTIES:
   :question_author: Sébastien Vauban
   :DATE:     2010-11-23
   :END:
I want to *add a column* to the following table.

#+name: table-message
| This is line 1 of the message.        |
| This is line 2 of the message.        |
| This is the last line of the message. |

Its value should be dependant on a *regexp matching* the *current row*
(for example, if 1 is detected in the original column, then write "A"
in the new one, "B" if 2 is read, "C" if 3 is read, etc.).

Hence, I'm thinking using AWK as an easy solution.

    #+begin_src note
    I'm open to other ideas on how I could do this as easily. Just throw me
    ideas, if you have some.
    #+end_src

the easiest (for me) would be with the elisp =mapcar= function
#+begin_src emacs-lisp :var tbl=table-message
  (mapcar (lambda (row) (cons "New col" row)) tbl)
#+end_src

#+name:
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

*First* trial: add a column whose cell contents will be *fixed* (here,
equal to =New col=).

#+name: add-col
#+begin_src sh :var data=table-message :results output raw :exports both
echo "$data" | awk '// {print "| New col | " $0 " |";}'
#+end_src

#+name: add-col
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

*** lists as data types
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:

#+name: a-list
- org-mode
- and
- babel

#+name: a-list
#+begin_src emacs-lisp :var lst=a-list :results list
  (reverse lst)
#+end_src

also for a block inside of a list
1. First element
2. Second element -- has a block
   #+begin_src emacs-lisp
     (+ 1 1 1 1)
   #+end_src

   #+name:
   : 4

3. third element

*** introducing =wrap= header argument
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:
#+begin_src emacs-lisp :results wrap :exports both
  (mapcar (lambda (el) (list el (+ 1 (* el el)))) (number-sequence 0 10))
#+end_src

#+name:
#+BEGIN_RESULT
|  0 |   1 |
|  1 |   2 |
|  2 |   5 |
|  3 |  10 |
|  4 |  17 |
|  5 |  26 |
|  6 |  37 |
|  7 |  50 |
|  8 |  65 |
|  9 |  82 |
| 10 | 101 |
#+END_RESULT

now indented
- first
- second
  #+begin_src emacs-lisp :results wrap :exports both
    "something else"
  #+end_src

  #+name:
  #+BEGIN_RESULT
  : something else
  #+END_RESULT

*** sqlite
   :PROPERTIES:
   :DATE:     2010-11-10
   :END:
#+begin_src sqlite :db paper/climate.sqlite
  select count(*) from temps;
#+end_src

#+name:
: 422689

*** lob calls with header argument pass through
   :PROPERTIES:
   :DATE:     2010-11-08
   :END:

#+name: lob-header
#+begin_src emacs-lisp :var n=20
  n
#+end_src

#+call: lob-header[:results vector](n=15)

#+name: lob-header[:results vector](n=15)
| 15 |

#+call: lob-header(n=10) :results vector

#+name: lob-header(n=10)
| 10 |

need ob-ref.el to pass through the header arguments in "[]"s
#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)
  n
#+end_src

#+name:
| 8 |

#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)[0,0]
  n
#+end_src

#+name:
: 8

*** clojure code blocks and the lazies
   :PROPERTIES:
   :DATE:     2010-11-06
   :END:
#+begin_src emacs-lisp :results silent
  (defun org-babel-execute:clojure (body params)
    (with-temp-buffer
      (insert body)
      (read
       (slime-eval
        `(swank:interactive-eval-region 
          ,(buffer-substring-no-properties (point-min) (point-max)))))))
#+end_src

#+begin_src clojure
  (map (fn [el] (list el (* el el)))(range 10))
#+end_src

#+name:
| 0 |  0 |
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
| 9 | 81 |

*** shell blocks returning a file name
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src sh :file quick.txt :results output
  date
#+end_src

#+name:
[[file:quick.txt]]

*** playing with calc support
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src emacs-lisp
  (require 'ob-calc)
#+end_src

#+begin_src calc :var some=8
  some
  some
  '*
  8+8
  '+
#+end_src

#+name:
: 80

#+begin_src calc
  2*(8+8)
#+end_src

#+name:
: 32

#+begin_src calc
  2*e
#+end_src

#+name:
: 5.43656365692

#+begin_src calc :var something=9
  2*something
#+end_src

#+name:
: 18

*** passing arguments through call lines
   :PROPERTIES:
   :DATE:     2010-10-29
   :END:

#+name: test
#+begin_src R :session :file test.pdf :var myarg="bla"
  plot(1:10, main=myarg)
#+end_src

#+name: test
[[file:test.pdf]]

#+call: test(myarg="hiho")

#+name: test(myarg="hiho")
: test.pdf

*** simple gnuplot tests
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:
#+name: some-more-gnuplot
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=some-more-gnuplot
  plot "$data"
#+end_src

#+name:

Plotting data points from a table could look like this:
#+tblname: basic-plot
|   x |         y1 |         y2 |
|-----+------------+------------|
| 0.1 |      0.425 |      0.375 |
| 0.2 |     0.3125 |     0.3375 |
| 0.3 | 0.24999993 | 0.28333338 |
| 0.4 |      0.275 |    0.28125 |
| 0.5 |       0.26 |       0.27 |
| 0.6 | 0.25833338 | 0.24999993 |
| 0.7 | 0.24642845 | 0.23928553 |
| 0.8 |    0.23125 |     0.2375 |
| 0.9 | 0.23333323 |  0.2333332 |
|   1 |     0.2225 |       0.22 |

#+begin_src gnuplot :var data=basic-plot :exports code :file basic-plot.png
set title "Putting it All Together"

set xlabel "X"
set xrange [0:1]
set xtics 0,0.1,1

set ylabel "Y"
set yrange [0.2:0.5]
set ytics 0.2,0.05,0.5

plot data u 1:2 w p lw 2 title 'x vs. y1', \
     data u 1:3 w lp lw 1 title 'x vx. y2'
#+end_src

#+name:
[[file:basic-plot.png]]

*** latex headers in latex code blocks
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+begin_src latex :headers \usepackage{lmodern} :file name1.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name1.pdf]]

#+begin_src latex :headers '("\\usepackage{mathpazo}" "\\usepackage{fullpage}") :file name2.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name2.pdf]]

*** export-specific header arguments
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+headers: :var out=(if (and (boundp 'latexp) latexp) "latex" "not latex") 
#+begin_src emacs-lisp
  out
#+end_src

#+name:
: not latex

*** security problem with elisp in header arguments
   :PROPERTIES:
   :DATE:     2010-10-14
   :END:
#+begin_src emacs-lisp :var data=(setq org-confirm-babel-evaluate nil) :results silent
  (+ 1 1)
#+end_src

*** weaving with noweb links
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-10-13
   :END:

#+name: name
#+begin_src emacs-lisp
  (message "eric")
#+end_src

#+begin_src emacs-lisp :noweb tangle
  ;; name
  <<name>>
#+end_src

*** very very large numbers
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: numbers
|                           1 |
|                           2 |
|                          12 |
|                          45 |
|                         166 |
|                    12567890 |
| 231231282371983279389999999 |

#+begin_src emacs-lisp :var numbers=numbers
  (mapcar
   (lambda (line)
       (let ((number (car line)))
         (list number (type-of number))))
     numbers)
#+end_src

#+name:
|                      1 | integer |
|                      2 | integer |
|                     12 | integer |
|                     45 | integer |
|                    166 | integer |
|               12567890 | integer |
| 2.3123128237198328e+26 | float   |

*** preceding blank lines on tangle
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-pad-newline nil)
#+end_src

#+begin_src sh :tangle something.reg
  # something
  echo "else"
#+end_src

*** index into a scalar
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: short-list
| a |
| b |

#+begin_src emacs-lisp :var scalar=short-list[0,0]
  scalar
#+end_src

#+name:
: a

*** cycle -- the input is the output
   :PROPERTIES:
   :DATE:     2010-09-29
   :END:
and the rhythm is the base and the base is the treble

#+name: cycle
| one   |
| two   |
| three |

#+name: cycle
#+begin_src emacs-lisp :var table=cycle
  (append (last table) (butlast table))
#+end_src

#+begin_src emacs-lisp :exports results
  (+ 1 1 1)
#+end_src

*** Letter
   :PROPERTIES:
   :DATE:     2010-09-21
   :END:

#+name: body
#+begin_src org :results latex
  ,My body includes a list:
  
  ,- one
  ,- two
  
  ,and a small table:
  
  ,| first | second |
  ,| other | last   |
  
  ,Not more.
#+end_src

#+begin_src latex :noweb yes :tangle yes
\documentclass[11pt]{isodoc}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\setupdocument{
    to = {Eric},
    subject = {Tough to understand what to do...},
    opening = {Hi},
    closing = {Best}
}

\begin{document}
\letter{%
<<body()>>
}
\end{document}
#+end_src

*** splitting code blocks
   :PROPERTIES:
   :DATE:     2010-09-19
   :END:
- with indentation
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-previous-src-block (&optional arg)
      "Jump to the previous source block.
    With optional prefix argument ARG, jump backward ARG many source blocks."
      (interactive "P")
      (condition-case nil
          (re-search-backward org-babel-src-block-regexp nil nil (or arg 1))
        (error (error "No previous code blocks")))
      (goto-char (match-beginning 0)) (org-show-context))
  #+end_src
  
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-split-block-maybe (&optional arg)
      "Split the current source code block on the cursor."
      (interactive "p")
      ((lambda (info)
         (if info
             (let ((lang (nth 0 info))
                   (indent (nth 6 info))
                   (stars (make-string (org-current-level) ?*)))
               (insert (concat (if (looking-at "^") "" "\n")
                               (make-string indent ? ) "#+end_src\n"
                               (if arg stars (make-string indent ? )) "\n"
                               (make-string indent ? ) "#+begin_src " lang
                               (if (looking-at "[\n\r]") "" "\n  "))))
           (message "Not in src block.")))
       (org-babel-get-src-block-info)))
    
    ;; other stuff
  #+end_src

*** header arguments on call line
   :PROPERTIES:
   :DATE:     2010-09-09
   :END:
#+name: eight
#+begin_src R
  8
#+end_src

#+call: eight() :results vector

#+name: eight()
| 8 |

maybe the following with the new proposed header arguments

#+call: eight[:session *R*]() :results vector

*** empty-string results
   :PROPERTIES:
   :DATE:     2010-09-08
   :END:
test me one two 3

#+begin_src emacs-lisp
#+end_src

More test

#+begin_src emacs-lisp
  (mapcar
   (lambda (pair)
     (list (car pair) (cdr pair)))
   params)
#+end_src

#+name:
| :cache    | no      |
| :colnames | no      |
| :comments |         |
| :exports  | code    |
| :hlines   | yes     |
| :noweb    | no      |
| :results  | replace |
| :session  | none    |
| :shebang  |         |
| :tangle   | no      |

*** tangle org-mode block
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+name: org-list
#+begin_src org :results latex
  - one
  - two
  - three
#+end_src

#+begin_src emacs-lisp :tangle example.tangled :noweb yes
  "
  <<org-list()>>
  "
#+end_src

*** remove results when nil is returned
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src emacs-lisp
  (progn (+ 1 1) nil)
#+end_src

#+name:

*** comparative speed of python evaluation
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src python :session test
  2+2
#+end_src

#+name:
: 4

#+begin_src python
  return 2+2
#+end_src

#+name:
: 4

#+begin_src python :session test
def add(a,b):
   return a+b
def sub(a,b):
   return a-b
add(sub(10,1),sub(10,2))
#+end_src

#+name:
: org_babel_python_eoe

*** customizable comment formats
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2010-09-05
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-comment-format-beg "{-# LINE %start-line \"%file\" #-}"
        org-babel-tangle-comment-format-end ""
        org-babel-tangle-pad-newline)
#+end_src

#+begin_src haskell :tangle Main.hs
  test = length
  main = print $ test [1,2,3]
#+end_src

I would like the following output in the tangled file Main.hs:

: {-# LINE 4 "Haskell.org" #-}
: test = length
: main = print $ test [1,2,3]

*** tangling with full comments
   :PROPERTIES:
   :comments: org
   :tangle:   full-comments.el
   :DATE:     2010-09-04
   :END:
The top block
#+begin_src emacs-lisp
  (message "first block")
#+end_src

here's some text which won't be tangled

**** subheading
    :PROPERTIES:
    :DATE:     2010-09-04
    :END:
another block
| 1 | first  |
| 2 | second |
#+begin_src emacs-lisp
  (message "second")
#+end_src

and finally a block with a =:noweb= header argument
#+begin_src emacs-lisp :noweb yes
  (progn
    <<tangle-el-the-second>>)
#+end_src

*** :var (buffer-file-name)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
during export (buffer-file-name) will return nil because the temporary
export buffer is not visiting any file.

/file=(vc-working-revision (buffer-file-name))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) "")) :exports results
  echo $file Revision
#+end_src

/file=(vc-working-revision (or (buffer-file-name) org-current-export-file))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) org-current-export-file)) :exports results
  echo $file Revision
#+end_src

*** quoting header args (e.g. :cmdline)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
#+begin_src C :cmdline 1 2 3 4 5 :includes <stdio.h>
  int main(int argc, char **argv){
    printf("argv[1] %s\n", argv[1]);
    return 0;
  }
#+end_src

#+name:
: argv[1] 1

*** :session evaluation on export
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
This first block is evaluated but /doesn't/ appear in export.

/:session *R* :exports none/
#+begin_src R :session *R* :exports none
  x <- 8
#+end_src

This second block /does/ appear in export.

#+begin_src R :session *R* :exports results
  x
#+end_src

*** ditaa with tilda in path
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
#+begin_src ditaa :file example.png
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
#+end_src

*** scheme sessions
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src scheme :var number=9 :session *scheme* :scheme guile
  (+ number 0)
#+end_src

#+name:
: 9

#+begin_src scheme :var number=9 :session *scheme* :scheme racket
  (+ number 1)
#+end_src

#+name:
: 10

*** conditional tangling
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src emacs-lisp :results silent
  (setq tangle-tag "right")
#+end_src

**** first subheading						       :left:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "first"
#+end_src

**** second subheading						      :right:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "second"
#+end_src

*** pulling information from tags				       :blue:
   :PROPERTIES:
   :DATE:     2010-08-30
   :END:

#+begin_src R :var color=(car (org-get-tags-at (point))) :tangle example.R
  color
#+end_src

#+name:
: blue

*** initial scheme support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
#+name: numbers
#+begin_src scheme
  (map (lambda (el) (+ el 1)) '(1 2 3))
#+end_src

#+name:
| 2 | 3 | 4 |

#+begin_src scheme :var numbers=numbers
  (map (lambda (el) (- el 1)) numbers)
#+end_src

#+name:
| 1 | 2 | 3 |

*** initial javascript support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
using node.js

#+begin_src js
  var n = 0;
  n = n+1;
  return n
#+end_src

#+name:
: 1

#+name: cars
#+begin_src js
  var cars = ["Saab","Volvo","BMW"];
  return cars;
#+end_src

#+name: cars
| Saab | Volvo | BMW |

#+begin_src js :var cars=cars
  return cars[0][0];
#+end_src

#+name:
: Saab

#+begin_src js :var cars=cars
  return cars[0].length;
#+end_src

#+name:
: 3

*** wrapping up raw/org results
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
  - second
  - third
  "
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

*** trying out plantuml
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
setup
#+begin_src emacs-lisp :results silent
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path "~/src/org/contrib/scripts/plantuml.jar")
#+end_src

usage -- sequence diagram
#+begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
#+end_src

#+name:
[[file:tryout.png]]

*** eval for side effect on export
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
- one plus one
  #+name: one-plus-one
  #+begin_src emacs-lisp :exports none :results silent
    (+ 1 1)
  #+end_src
- plus one is
  #+begin_src emacs-lisp :var two=one-plus-one :exports both
    (+ 1 two)
  #+end_src

*** eval and noeval
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
date, should export both, but won't output results because of presence
of the =:noeval= header argument.
#+begin_src sh :noeval :exports both
  date
#+end_src

should export code, so no need to do anything
#+begin_src sh
  date
#+end_src

should export nothing, and should not query
#+name: this-is-ls
#+begin_src sh :eval query :exports code
  date
#+end_src

should export results, and should trigger query above
#+begin_src emacs-lisp :var ls=this-is-ls :exports results
  ls
#+end_src

*** duplicate results on execute subtree
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
- second
- third
"
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

*** issues with shell evaluation
   :PROPERTIES:
   :DATE:     2010-08-25
   :END:
#+begin_src sh :results silent
  cd ~/src/org/
  make
#+end_src

*** org results and replace
   :PROPERTIES:
   :DATE:     2010-08-18
   :END:

#+begin_src emacs-lisp :results org
  "| 1 | 2 |
| 2 | 3 |"
#+end_src

#+name:
| 1 | 2 |
| 2 | 3 |

#+begin_src R
  rnorm(1)
#+end_src

#+begin_src R
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

#+begin_src R :colnames yes
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| V1 | V2 | V3 |
|----+----+----|
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

*** ledger example output text
   :PROPERTIES:
   :DATE:     2010-08-13
   :END:
#+name: ledger-stuff
#+begin_example
09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src sh :var stuff=ledger-stuff
  echo "$stuff"
#+end_src

*** tangle R and load
  :PROPERTIES:
  :tangle:   to-load.r
  :DATE:     2010-08-12
  :END:

evaluate this
#+begin_src emacs-lisp :results silent :tangle no
  (setq org-babel-post-tangle-hook nil)
  (add-hook 'org-babel-post-tangle-hook
            (lambda () (ess-load-file (buffer-file-name))))
#+end_src

then tangle

#+begin_src R :comments yes
x <- 10
#+end_src

#+begin_src R
 y <- 9
#+end_src

#+begin_src R :tangle file2.R
 y <- 9
#+end_src

*** lob -- writing results out to files
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: table
#+begin_src emacs-lisp
  (mapcar
   (lambda (el) (number-sequence el (+ el 3)))
   (number-sequence 0 4))
#+end_src

writes the results out as csv file
#+call: write(data=table, file="~/Desktop/example.csv") :results silent

writes the results out as tab separated file
#+call: write(data=table, file="~/Desktop/example.tsv") :results silent

write the results out as a normal org-mode file
#+call: write(data=table, file="~/Desktop/example.org") :results silent

*** lisp
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src lisp :var n=5
  (mapcar (lambda (el) (* el el)) (append '(1 7 3 4) (list n)))
#+end_src

#+name:
| 1 | 49 | 9 | 16 | 25 |

#+name: short-list
| 1 |
| 2 |
| 3 |

#+begin_src lisp :var lst=short-list :session t
  (+ 1 (length lst))
#+end_src

#+name:
: 4

*** importing the output of ledger
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: ledger-output
#+begin_example 
  09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
  09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
  09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src emacs-lisp :var ledger=ledger-output
  (with-temp-buffer
    (insert ledger)
    (message ledger)
    (org-table-convert-region (point-min) (point-max) 2)
    (org-table-to-lisp))
#+end_src

#+name:
| 09-Aug-21 CHEQUE : 9953055                | Expenses:Unknown | 166.70 EUR  | 166.70 EUR  |
| 09-Sep-17 CHEQUE : 7691785                | Expenses:Unknown | 100.00 EUR  | 266.70 EUR  |
| 09-Oct-16 REMISE CHEQUE N 8686318 001 105 | Expenses:Unknown | -525.00 EUR | -258.30 EUR |

*** comments in R blocks
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src R :session *R* :results output
  # this is a comment
  x <- rnorm(1)
  # this is another comment
  x
#+end_src

#+name:
: 
: [1] 1.320853

*** colnames to specific variables
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+tblname: spec-colnames
| one | two | thee |
|-----+-----+------|
| 1   | 2   | 3    |

#+tblname: nospec-colnames
| three | two | one |
|-------+-----+-----|
|     3 |   2 |   1 |

#+begin_src python :var nospec=nospec-colnames :var spec=spec-colnames :colnames '(spec)
  return nospec
#+end_src

#+name:
| one   | two | thee |
|-------+-----+------|
| three | two | one  |
| 3     | 2   | 1    |

*** caption on code block
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+caption: Examples of variable declaration.
#+label: sql-block
#+begin_src sql
SELECT 6*9;
#+end_src

*** palendromic primes
   :PROPERTIES:
   :DATE:     2010-07-20
   :END:
Note that because Haskell is funny about what can be typed into the
interpreter, the following should be loaded with
=org-babel-load-in-session=.
#+begin_src haskell
  palendromic_primes = [x | x <- [1..], prime x, palendrome x]
      where
        factors n = [x | x <- [1..floor(sqrt(fromIntegral(n)))], n `mod` x == 0]
        prime n = factors n == [1]
        primes = [x | x <- [2..], prime x]
        palendrome n = show(n) == reverse(show(n))
  
  palendromic_prime_distances = map (\(x,y)-> y-x) neighbors
      where
        neighbors = (zip palendromic_primes (tail palendromic_primes))
#+end_src

#+name: palendromic_prime_distances
#+begin_src haskell
  take 180 (zip [1..] palendromic_prime_distances)
#+end_src

For high-quality png output from gnuplot, the following sequence of
graphing to a =.eps= file, and then converting to a =.png= can be
useful.
#+name: dist-graph
#+begin_src gnuplot :var data=palendromic_prime_distances :file pps.eps
  set term postscript landscape color enhanced
  set log y
  set title "distance between consecutive palendromic primes"
  plot "$data" with fs notitle
#+end_src

The =convert= command is part of the [[http://www.imagemagick.org/script/index.php][imagemagick]] suite.
#+begin_src sh :var input=dist-graph :results file
  convert -depth 300 -rotate 90 $input pps.png
  echo "pps.png"
#+end_src

*** input from an example block
   :PROPERTIES:
   :DATE:     2010-07-13
   :END:
#+name: lorem
#+begin_example 
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
  culpa qui officia deserunt mollit anim id est laborum.
#+end_example

#+begin_src emacs-lisp :var lorem=lorem
  (message "%d words in Lorem" (length (split-string lorem)))
#+end_src

#+name:
: 68 words in Lorem

#+name: 1D
| 1 |
| 2 |
| 3 |
| 4 |

#+begin_src emacs-lisp :var lst=1D[:,0]
  lst
#+end_src

#+name:
: 1

*** example w/o source name
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

delete emacs-lisp below for errors
#+begin_src emacs-lisp
  (* (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1))
#+end_src

*** tangle R and load
   :PROPERTIES:
   :tangle:   with-comments.r
   :comments: yes
   :DATE:     2010-07-09
   :END:

#+begin_src R :tangle no
  z <- 0
#+end_src

#+begin_src R
  x <- 8
#+end_src

#+begin_src R
  y <- 9
#+end_src

#+name: i-have-a-name
#+begin_src R 
  x+y+z
#+end_src

*** export blocks w/o languages
   :PROPERTIES:
   :DATE:     2010-07-09
   :END:
should raise an error

source
#+begin_src emacs-lisp
  ;; this is a comment
  (+ 1 1 1)
#+end_src

broken source
#+begin_src 
  (+ 2 2 2)
#+end_src

example
#+begin_example 
  this is exampled
#+end_example

#+begin_src ruby
  # this is the first
  [1, 2, 3, 4, 5].map{|r| r+1}
#+end_src

*** scratch
   :PROPERTIES:
   :DATE:     2010-07-08
   :END:

#+begin_src emacs-lisp :exports results
  (+ 1 1 1 1)
  (setq org-export-babel-evaluate t)
#+end_src

and now for src_emacs-lisp{87} an inline block

looking at paths
#+begin_src emacs-lisp
  (buffer-file-name)
#+end_src

*** Tom found a bug
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:

#+begin_src emacs-lisp :tangle something.el
  (list 1 (+ 2 3))
#+end_src

#+name:
| 1 | 5 |

*** dot
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:
#+begin_src dot :file models.png :cmdline -Tpng
  digraph data_relationships {
    "data_requirement" [shape=Mrecord, label="{DataRequirement|description\lformat\l}"]
    "data_product" [shape=Mrecord, label="{DataProduct|name\lversion\lpoc\lformat\l}"]
    "data_requirement" -> "data_product"
  }
#+end_src

#+name:
[[file:models.png]]

*** python errors
   :PROPERTIES:
   :DATE:     2010-07-04
   :END:
#+begin_src python :session :results value
  [1, [2], 3, 4]
#+end_src

#+name:
| 1 | (2) | 3 | 4 |

#+begin_src ruby :results output :session
  [1, 2, 3, 4, 6].map{|n| puts n}
#+end_src

#+name:
: 1
: 2
: 3
: 4
: 6

#+begin_src python :session :results output
  print 9
#+end_src

#+name: R-with-colnames
| one |
|-----|
| 1   |

#+begin_src R :results output
  "something"
#+end_src

#+name:
: [1] "something"

#+begin_src R :session *R* :results output
  1
  2
  3
  4
#+end_src

#+name:
: [1] 1
: [1] 2
: [1] 3
: [1] 4

#+begin_src perl :results output
  print "8\n";
  print "9\n";
#+end_src

#+name:
: 8
: 9

#+begin_src clojure
  (+ 8 7)
#+end_src

#+name:
: 15

#+begin_src clojure :session *clj*
  (println "eric")
#+end_src

#+name:
: nil

#+begin_src perl :results value
  8
#+end_src

#+name:
: 8

#+begin_src c++ :includes '(<stdio.h> <math.h> <cstdlib> <time.h>)
  printf("eric schulte\n");
#+end_src

#+name:
: eric schulte

#+begin_src sh
  echo 78
#+end_src

#+name:
: 78

*** table comment issue
   :PROPERTIES:
   :DATE:     2010-06-30
   :END:
#+BEGIN_changemargin {-4.2cm}{0cm}
  #+TBLNAME: AutresFPNVE
  #+ATTR_LaTeX: align=lrrrrr
  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Total                                    |                      |                 |                |            |    1062.02 |
  | ^ |                                          |                      |                 |                |            |      Total |
  #+tblfm: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+END_changemargin

save me!

#+begin_src org
  ,  #+TBLNAME: AutresFPNVE
  ,  #+ATTR_LaTeX: align=lrrrrr
  ,  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  ,  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  ,  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  ,  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  ,  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Total                                    |                      |                 |                |            |    1062.02 |
  ,  | ^ |                                          |                      |                 |                |            |      Total |
  ,  #+TBLFM: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+end_src

#+begin_example 
#+tblname: example
| 1 | 2 |
#+end_example

*** latex literals in export
    :PROPERTIES:
    :DATE:     2010-06-30
    :END:

   #+ATTR_LaTeX: width=\textwidth
   [[./composite-pattern.png]]

*** captions
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:

#+caption: I'm not removed from export
#+label: also-not-removed
| A | B |
| 1 | 2 |

*** booktabs
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:
#+tblname: months
| num | Abbrev. |
|-----+---------|
|   1 | Jan.    |
|   2 | Feb.    |
|   3 | Mar.    |

#+call: booktabs(table=months, align="r|l") :results latex :exports results

*** table-label
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+label: bam
| 1 |
| 2 |
| 3 |

*** haskell issues
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:

#+begin_src haskell
  length [1, 2]
#+end_src

#+name:
: 2

#+tblname: example-4-haskell
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |

#+begin_src haskell :var this=example-4-haskell
  length this
#+end_src

#+name:
: 7

*** complex
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+name: raw-data
#+begin_src sh :results scalar
  wget --quiet -qO- "http://ogdi.cloudapp.net/v1/dc/RecreationParks?format=json"
#+end_src

#+name: dc-parks
#+begin_src emacs-lisp :var keys='(ward area) :var data=raw-data
  (mapcar
    (lambda (lis) (mapcar (lambda (key) (cdr (assoc key lis))) keys))
    (cdr (car (with-temp-buffer
                (insert data) (goto-char (point-min))
                (json-read)))))
#+end_src

#+name: dc-parks-metric
#+begin_src ruby :var data=dc-parks
  data.map{|f| [f[0], 2.59 * f[1]]}
#+end_src

#+begin_src R :var parkData=dc-parks-metric :file parks.png :session *R*
  plot(parkData)
  title(main="Park size by Ward")
#+end_src

#+name:
[[file:parks.png]]

*** possible prefixes
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                    5 |
| org-b-   |                    2 |
| orgb-    |                    3 |
| org-bbl- |                    0 |
| bbl-     |                    4 |
| babel-   |                    2 |
#+TBLFM: $2='(sbe leftover (prefix $$1))

#+name: leftover
#+begin_src emacs-lisp :var prefix=""
  (-
   ;; length w/o .el
   (- 13 (length ".el"))
   ;; length of prefix
   (length prefix))
#+end_src

*** hlines in python
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+name: echo-table
#+begin_src python :var tab=many-cols :hlines yes :exports both :session
  return tab
#+end_src

#+begin_src emacs-lisp :var table=echo-table :exports none
  (butlast (apply #'append (mapcar (lambda (el) (list el 'hline)) table)))
#+end_src

#+call: echo-table(tab=many-cols)

#+begin_src python :exports results
  return [['foo', 'bar', 'baz'], ["a", "b", "None of the above"], ['1', 2, 3]]
#+end_src

#+begin_src emacs-lisp :exports results
  (message "Exist")
#+end_src

*** protecting block bodies
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
neither of these work as expected

#+begin_src org
  ,#+TITLE: stuff
  
  ,#+begin_src emacs-lisp
  ,  (message "something")
  ,#+end_src
  
  ,more stuffs
  
  ,#+resname: something
  ,: value
  
  ,# and a comment
#+end_src

#+begin_src org
  ,* example org
  
  ,# this is a comment
  ,this is not a comment
#+end_src


#+begin_src org
  ,* escaped org-mode markup
  
  ,this should be exported as is
  ,#+results: escaping-example
  ,: 24
#+end_src


#+begin_html 
<pre>
#comment
#+end_src
</pre>
#+end_html
final

*** multiple evals for refs
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
#+begin_src emacs-lisp
  (setq counter 0)
#+end_src

#+name:
: 0

#+name: counter
#+begin_src emacs-lisp
  (setq counter (+ 1 counter))
  counter
#+end_src

#+begin_src emacs-lisp :var counter_val=counter
  counter_val
#+end_src

#+name:
: 3

*** tangling
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:

#+begin_src sh :shebang #!/bin/sh :tangle yes
  date
#+end_src

#+begin_src sh :shebang #!/bin/bash :tangle whoisme :exports both
  echo $USER
#+end_src

#+begin_src emacs-lisp :tangle yes :comments yes
  (message "BAM")
#+end_src

#+begin_src fortran :exports both
  1+8
#+end_src

*** foo org
   :PROPERTIES:
   :session:  *R*
   :DATE:     2010-06-16
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
#+BEGIN_SRC R 
plot(x, y)
abline(out1)
#+END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
#+attr_latex: width=0.8\textwidth,placement=[p]
#+label: fig:one
#+caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

*** comments not commented
   :PROPERTIES:
   :DATE:     2010-06-16
   :END:

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   #+name: plotxy
   #+begin_src emacs-lisp :exports results
     (message "I think so")
   #+end_src
   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src
   

   can cause problems

2) how about this one...

*** don't eat me!
   :PROPERTIES:
   :DATE:     2010-06-15
   :END:
1) a source block inside of an =enumerate=
   #+begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   #+end_src

   #+name:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

*** simple reference
   :PROPERTIES:
   :DATE:     2010-06-13
   :END:
#+tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src emacs-lisp :var data=table-the-first[1,1]
  data
#+end_src

#+name:
: 5

*** exporting with call lines
   :PROPERTIES:
   :DATE:     2010-06-11
   :END:
#+name: rpn-to-alg(alg)
#+begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \* \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
#+end_src

#+name: distributed-best
: 73*x11/+4/++51xxx13*y/++6y5*6/6-+xx+*

#+call: rpn-to-alg(alg=distributed-best)
 
*** can't open indented results
    :PROPERTIES:
    :DATE:     2010-06-11
    :END:

    #+begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
      \begin{preview}
      \ovalbox{
      \begin{tikzpicture}
      \node{$n$}
       	child {
          node{$\left(\frac{n}{2}\right)^2$}
            child{
              node{$\left(\frac{n}{4}\right)^2$}
              node{$\left(\frac{n}{4}\right)^2$}
            }
          }
       	child{
          node{$\left(\frac{n}{2}\right)^2$}
          child{
            node{$\left(\frac{n}{4}\right)^2$}
            node{$\left(\frac{n}{4}\right)^2$}
          }
       	};
      \end{tikzpicture}
      }
      \end{preview}
    #+end_src

    #+name:
    [[file:recursion.pdf]]

*** indented source-code blocks and indented results
    :PROPERTIES:
    :DATE:     2010-06-10
    :END:

     #+name: time
     #+begin_src emacs-lisp :results append
       ;; (list (list (current-time-string)))
       (current-time-string)
     #+end_src

     #+name: time
     | 1 | 2 | 3 |


         #+call: time() :results prepend

         #+name: time()
         | 1 | 2 | 3 |
         : Thu Jun 10 14:13:21 2010
         : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : nil
         : nil
         : Thu Jun 10 14:11:22 2010
         : Thu Jun 10 14:11:20 2010
         : nil
         : nil
         : Thu Jun 10 14:06:04 2010
         : Thu Jun 10 14:06:03 2010
         : Thu Jun 10 14:05:51 2010
         : Thu Jun 10 14:05:57 2010
         : Thu Jun 10 14:06:00 2010

*** not expand inlines in examples
   :PROPERTIES:
   :DATE:     2010-06-08
   :END:

: src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

*** updating results "in-situ"
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+name: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be *above* the block

#+name: in-situ
#+begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
#+end_src

#+name: in-situ
#+begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
#+end_src

*** unwind-protect with narrowing
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

I'm not in the subtree

**** I'm in the subtree
    :PROPERTIES:
    :DATE:     2010-06-07
    :END:
#+begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
#+end_src

*** stripping existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
#+name: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

#+begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
#+end_src

#+name:
: don't include me in the export!!!!!!!

#+name: trickily-located-somehwere-else
#+begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
#+end_src

*** non-empty comint prompt
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src ruby :session eric
  8 + 9
#+end_src

*** inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :DATE:     2010-06-07
   :END:

#+begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
#+end_src

*** indented source names
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

   #+name: i-am-indented
   #+begin_src emacs-lisp 
     (message "i am indented")
   #+end_src

#+name: i-am-indented
: i am indented

#+begin_src emacs-lisp :var output=i-am-indented
  (length output)
#+end_src

#+name:
: 13

  #+name:
  : eric

*** export with existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
#+end_src

#+name:
| 1 | 2 |
| 3 | 4 |

#+begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
#+end_src

#+name:
[[file:/tmp/eric.png]]

*** executing emacs-lisp on export
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp
  (error "eric")
#+end_src

*** commas on tangling test
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
test comma protection on tangling

#+begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
#+end_src

#+begin_src org :tangle commas.org
  ,* org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,#+begin_src emacs-lisp
  ,  protected?
  ,#+end_src
#+end_src

#+begin_example 
  ,* this should be
  # commented out
  
  and maybe not this...
#+end_example

*** simple table
   :PROPERTIES:
   :DATE:     2010-06-06
   :END:
#+begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
#+end_src

#+name:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

*** inline expressions
   :PROPERTIES:
   :session:  'default
   :DATE:     2010-06-06
   :END:

#+begin_src R :exports code :results silent
  x<-4
#+end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

*** adding file names to literal values on export
   :PROPERTIES:
   :DATE:     2010-06-01
   :END:

#+name: three
: 9

#+begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
#+end_src

#+begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
#+end_src

*** appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :DATE:     2010-05-28
   :END:
append all these block

#+begin_src emacs-lisp
  (message "block %d" 1)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 2)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 3)
#+end_src

*** visibility affecting execution
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:

**** folding
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:
lets test folding

***** folded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "folded1")
#+end_src

#+name:
: folded1

#+begin_src emacs-lisp
  (message "folded2")
#+end_src

#+name:
: folded2
***** unfolded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "unfolded1")
#+end_src

#+name:
: unfolded1
#+begin_src emacs-lisp
  (message "unfolded2")
#+end_src

#+name:
: unfolded2

*** empty code blocks -- and latex vs. LaTeX
   :PROPERTIES:
   :DATE:     2010-05-26
   :END:
eric
#+begin_src latex
  
#+end_src

michael
#+begin_src LaTeX
  
#+end_src

schulte
#+begin_src emacs-lisp
  (message "error")
#+end_src

*** colnames
   :PROPERTIES:
   :DATE:     2010-05-04
   :END:

#+tblname: A
| a | b | c |
|---+---+---|
| d | e | f |
| g | h | i |

#+begin_src python :var tab=A :colnames yes
return [[val + '*' for val in row] for row in tab]
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"*"} }
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

*** lisps not fully eval'd
   :PROPERTIES:
   :DATE:     2010-04-30
   :END:

#+begin_src emacs-lisp
  (message "one")
  (message "two")
#+end_src

#+name:
: two

#+begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
#+end_src

#+name:
: 3

*** tangling org
   :PROPERTIES:
   :DATE:     2010-04-27
   :END:

#+begin_src org :tangle ~/Desktop/test.org
  ,* first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,* second
  
  ,some more stuff...
  
  ,#+HTML: <b>I bet this is quoted</b>
#+end_src

#+begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
#+end_src

*** variable indexing
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 #+TBLFM: $2=$1*$1::@8$2=vsum(@2..@-1)

#+begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
#+end_src

#+name:
| 0 | 1 | 4 | 9 | 16 | 25 |

#+begin_src python :var sum=MyTable[9,1] :exports none
   return sum
#+end_src

#+name:
: 55

#+begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
#+end_src

*** colnames mismatched sizes
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
#+end_src

#+name:
| 1 | 2 | 3 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
#+end_src

#+name:
| a | b |
|---+---|
| 1 | 2 |

#+begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
#+end_src

#+name:
| 1 | 2 |

*** test gnuplot
   :PROPERTIES:
   :DATE:     2010-04-17
   :END:

#+begin_src gnuplot
  plot sin(x), x+5
#+end_src

*** hline processing
   :PROPERTIES:
   :DATE:     2010-04-12
   :END:
#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

#+tblname: less-cols2
| 1 | 2 | 3 |

#+begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
#+end_src

#+begin_src ruby :var tab=less-cols
  tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var one=2
  1 + 2
#+end_src

#+name:
: 3

#+begin_src python :var tab=less-cols
  return tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var tab=less-cols :colnames no
  tab
#+end_src

#+name:
| 1 |
| 2 |
| 3 |

#+begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
#+end_src

#+name:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

#+tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
#+begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar* #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
#+end_src

*** evaluate references
   :PROPERTIES:
   :DATE:     2010-04-09
   :END:

#+begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
#+end_src

#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src ruby
  + 1 2
#+end_src

#+name:
: nil

*** tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :DATE:     2010-03-31
  :END:

#+name: A
#+begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
#+end_src

#+name: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

*** latex attributes
   :PROPERTIES:
   :DATE:     2010-03-23
   :END:

#+ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
#+begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
#+end_src

*** access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :DATE:     2010-03-22
   :END:

: "(org-entry-get nil "special" t)"

#+begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
#+end_src

#+name:
: 90

#+begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
#+end_src

#+name:
: schulte

*** variables into shell scripts
   :PROPERTIES:
   :DATE:     2010-02-23
   :END:
#+name: into-shell-scripts
| username | guest   |
| password | nothing |

#+begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
#+end_src

#+name:
: username -p nothing

#+name: number-into-shell
: 9

#+begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
#+end_src

#+name:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

*** results lines for function calls
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

#+call: fibonacci(input=5) :resname eric

#+name:
: 8

#+begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
#+end_src

#+name:
: fib(5)=8

*** haskell variables
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

playing with Haskell

#+name: haskell-stuff
: 9

#+begin_src haskell :var num=haskell-stuff
  num + 1
#+end_src

#+begin_src ruby :var num=haskell-stuff
  num + 1
#+end_src

#+name:
: 10

*** list index w/function style name
   :PROPERTIES:
   :DATE:     2010-02-14
   :END:

#+name: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

#+name: function-style-indexing(data=function-style-index[1:4,0])
#+begin_src emacs-lisp
  (message "%S" data)
#+end_src

#+name: function-style-indexing
: ((1) (2) (3) (4))

*** looking at source name exports
   :PROPERTIES:
   :DATE:     2010-02-09
   :END:

#+name: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+name: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

*** short shell test
   :PROPERTIES:
   :DATE:     2010-02-07
   :END:

#+begin_src sh
  date
#+end_src

#+name:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+name:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+name:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+name:
: 1--1

*** tables to shell scripts ideas
   :PROPERTIES:
   :DATE:     2010-02-06
   :END:

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

*** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-02-05
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "foo")
#+end_src

#+name:
: foo

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

*** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :DATE:     2010-02-03
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

*** babel block overwrite
   :PROPERTIES:
   :DATE:     2010-01-18
   :END:

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

*** load to session
   :PROPERTIES:
   :DATE:     2010-01-11
   :END:
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

*** links
   :PROPERTIES:
   :DATE:     2010-01-06
   :END:

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

*** fancier export
   :PROPERTIES:
   :DATE:     2010-01-05
   :END:

#+name: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

*** exporting org-source
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

*** exporting and caching
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+name:
[[file:data/example.png]]

*** no noweb by default
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+name: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+name:
: sample

*** looking at double quotes
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+name: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+name: double-quote-test-output
| test | this | 8 | 9 |

*** quoted session name
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+name:
: name-me

*** eval-buffer
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+name:
: 7

*** sql exports to latex
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
example from email list
**** ECM
    :PROPERTIES:
    :DATE:     2009-11-30
    :END:

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+name: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

*** gnuplot variable expansion
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:

#+name: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

*** debug hints
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

*** whitespace/newline results issues
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+name:
: 2

*** sh with sessions
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+name:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

*** xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

*** unresolved noweb references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+name: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

*** =:table= results param
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

*** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

*** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

*** simple scalar
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

*** simple R
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

*** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src

*** results switches
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

*** reference parts of tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

*** quoted latex
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

*** pretty print
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

*** =pp= results
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
**** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

**** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example

*** persistent python
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

**** more persistent python
    :PROPERTIES:
    :session:  default
    :DATE:     2009-11-20
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

*** noweb referernces
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

*** multiple arguments
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

*** lua export
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

*** latex pngs
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
$x \mapsto y$

**** Theorem
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

*** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
stuff here

*** indexing into results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+name:
| schulte |
| is      |
| my      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

*** indexing into gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

*** indented
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

*** indentation
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src python
          9
#+end_src

*** hiding results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+name:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

*** haskell
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

*** haskell and tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

*** gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src gnuplot
plot cosx
#+end_src


#+end_src
      
*** empty =output= results for emacs-lisp
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

*** elisp variables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+name:
[[file:45.png]]

*** elisp references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+name: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

*** dynamic table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

*** code results
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
**** emacs lisp
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

**** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

**** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

*** clojure
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

*** changing source name
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

*** asymptote
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

*** asymptote cosine
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

*** and then more
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
and more stuffs here

*** advanced table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |

** TODO edit docs 						       :@doc:
*** org								     :buffer:
**** yasnippit issue
Captured [2014-06-08 Sun 15:25]
  `yasnippet.el'
       The way Org mode binds the <TAB> key (binding to `[tab]' instead of
       `"\t"') overrules YASnippet's access to this key.  The following
       code fixed this problem:
       
            (add-hook 'org-mode-hook
                      (lambda ()
                        (org-set-local 'yas/trigger-key [tab])
                        (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
  
       The latest version of yasnippet doesn't play well with Org mode.
       If the above code does not fix the conflict, start by defining the
       following function:
  
            (defun yas/org-very-safe-expand ()
              (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))
  
       Then, tell Org mode what to do with the new function:
  
            (add-hook 'org-mode-hook
                      (lambda ()
                        (make-variable-buffer-local 'yas/trigger-key)
                        (setq yas/trigger-key [tab])
                        (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                        (define-key yas/keymap [tab] 'yas/next-field)))
  [[info:org#Conflicts]]

**** Heading
       	  :PROPERTIES:
       	  :header-args:clojure:    :session *clojure-1*
       	  :header-args:R:          :session *R*
       	  :END:
       	** Subheading
       	  :PROPERTIES:
       	  :header-args:clojure:    :session *clojure-2*
       	  :END:
**** `M-<TAB>     (`pcomplete')'
    After an initial colon in a line, complete property keys.  All
    keys used in the current file will be offered as possible
    completions.  

**** property syntax

    Properties are key-value pairs.  When they are associated with a
    single entry or with a tree they need to be inserted into a
    special drawer (*note Drawers::) with the name `PROPERTIES'.  Each
    property is specified on a single line, with the key (surrounded
    by colons) first, and the value after it.  Here is an example:

#+BEGIN_EXAMPLE
     * CD collection
     ** Classic
     *** Goldberg Variations
         :PROPERTIES:
         :Title:     Goldberg Variations
         :Composer:  J.S. Bach
         :Artist:    Glen Gould
         :Publisher: Deutsche Grammophon
         :NDisks:    1
         :END:
#+END_EXAMPLE

    Depending on the value of `org-use-property-inheritance', a
    property set this way will either be associated with a single
    entry, or the sub-tree defined by the entry, see *note Property
    inheritance::.

    You may define the allowed values for a particular property
    `:Xyz:' by setting a property `:Xyz_ALL:'.  This special property
    is _inherited_, so if you set it in a level 1 entry, it will apply
    to the entire tree.  When allowed values are defined, setting the
    corresponding property becomes easier and is less prone to typing
    errors.  For the example with the CD collection, we can predefine
    publishers and the number of disks in a box like this:

#+BEGIN_EXAMPLE
     * CD collection
       :PROPERTIES:
       :NDisks_ALL:  1 2 3 4
       :Publisher_ALL: "Deutsche Grammophon" Philips EMI
       :END:
#+END_EXAMPLE

   If you want to set properties that can be inherited by any entry in
   a file, use a line like

   #+PROPERTY: NDisks_ALL 1 2 3 4

   Contrary to properties set from a special drawer, you have to
   refresh the buffer with `C-c C-c' to activate this changes.

   If you want to add to the value of an existing property, append a
   `+' to the property name.  The following results in the property
   `var' having the value "foo=1 bar=2".
   
   #+PROPERTY: var  foo=1
   #+PROPERTY: var+ bar=2

   It is also possible to add to the values of inherited properties.
   The following results in the `genres' property having the value
   "Classic Baroque" under the `Goldberg Variations' subtree.

#+BEGIN_EXAMPLE
     * CD collection
     ** Classic
         :PROPERTIES:
         :GENRES: Classic
         :END:
     *** Goldberg Variations
         :PROPERTIES:
         :Title:     Goldberg Variations
         :Composer:  J.S. Bach
         :Artist:    Glen Gould
         :Publisher: Deutsche Grammophon
         :NDisks:    1
         :GENRES+:   Baroque
         :END:
#+END_EXAMPLE   
     
   Note that a property can only have one entry per Drawer.

   Property values set with the global variable
   `org-global-properties' can be inherited by all entries in all Org
   files.

   The following commands help to work with properties:

**** `C-c C-x p     (`org-set-property')'
    Set a property.  This prompts for a property name and a value.  If
    necessary, the property drawer is created as well.

**** `C-u M-x org-insert-drawer RET'
    Insert a property drawer into the current entry.  The drawer will
    be inserted early in the entry, but after the lines with planning
    information like deadlines.  

**** `C-c C-c     (`org-property-action')'
    With the cursor in a property drawer, this executes property
    commands.  

**** `C-c C-c s     (`org-set-property')'
    Set a property in the current entry.  Both the property and the
    value can be inserted using completion.  

**** `S-<right>     (`org-property-next-allowed-value')'
    `S-<left>     (`org-property-previous-allowed-value')'
    Switch property at point to the next/previous allowed value.  

**** `C-c C-c d     (`org-delete-property')'
    Remove a property from the current entry.  

**** `C-c C-c D     (`org-delete-property-globally')'
    Globally remove a property, from all entries in the current file.  

**** `C-c C-c c     (`org-compute-property-at-point')'
    Compute the property at point, using the operator and scope from
    the nearest column format definition.

**** buffer, window and frame switching and management
Captured [2014-05-28 Wed 17:02]

**** babel
Major Mode Bindings Starting With C-c C-v:
key             binding
---             -------
C-c C-v C-a	org-babel-sha1-hash
C-c C-v C-b	org-babel-execute-buffer
C-c C-v C-c	org-babel-check-src-block
C-c C-v C-d	org-babel-demarcate-block
C-c C-v C-e	org-babel-execute-maybe
C-c C-v C-f	org-babel-tangle-file
C-c C-v TAB	org-babel-view-src-block-info
C-c C-v C-j	org-babel-insert-header-arg
C-c C-v C-l	org-babel-load-in-session
C-c C-v C-n	org-babel-next-src-block
C-c C-v C-o	org-babel-open-src-block-result
C-c C-v C-p	org-babel-previous-src-block
C-c C-v C-r	org-babel-goto-named-result
C-c C-v C-s	org-babel-execute-subtree
C-c C-v C-t	org-babel-tangle
C-c C-v C-u	org-babel-goto-src-block-head
C-c C-v C-v	org-babel-expand-src-block
C-c C-v C-x	org-babel-do-key-sequence-in-edit-buffer
C-c C-v C-z	org-babel-switch-to-session
C-c C-v ESC	Prefix Command
C-c C-v I	org-babel-view-src-block-info
C-c C-v a	org-babel-sha1-hash
C-c C-v b	org-babel-execute-buffer
C-c C-v c	org-babel-check-src-block
C-c C-v d	org-babel-demarcate-block
C-c C-v e	org-babel-execute-maybe
C-c C-v f	org-babel-tangle-file
C-c C-v g	org-babel-goto-named-src-block
C-c C-v h	org-babel-describe-bindings
C-c C-v i	org-babel-lob-ingest
C-c C-v j	org-babel-insert-header-arg
C-c C-v l	org-babel-load-in-session
C-c C-v n	org-babel-next-src-block
C-c C-v o	org-babel-open-src-block-result
C-c C-v p	org-babel-previous-src-block
C-c C-v r	org-babel-goto-named-result
C-c C-v s	org-babel-execute-subtree
C-c C-v t	org-babel-tangle
C-c C-v u	org-babel-goto-src-block-head
C-c C-v v	org-babel-expand-src-block
C-c C-v x	org-babel-do-key-sequence-in-edit-buffer
C-c C-v z	org-babel-switch-to-session-with-code
C-c C-v C-M-h	org-babel-mark-block
**** org-element.el
;;; org-element.el --- Parser And Applications for Org syntax

;; Copyright (C) 2012-2014 Free Software Foundation, Inc.

;; Author: Nicolas Goaziou <n.goaziou at gmail dot com>
;; Keywords: outlines, hypermedia, calendar, wp

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Org syntax can be divided into three categories: "Greater
;; elements", "Elements" and "Objects".
;;
;; Elements are related to the structure of the document.  Indeed, all
;; elements are a cover for the document: each position within belongs
;; to at least one element.
;;
;; An element always starts and ends at the beginning of a line.  With
;; a few exceptions (`clock', `headline', `inlinetask', `item',
;; `planning', `node-property', `quote-section' `section' and
;; `table-row' types), it can also accept a fixed set of keywords as
;; attributes.  Those are called "affiliated keywords" to distinguish
;; them from other keywords, which are full-fledged elements.  Almost
;; all affiliated keywords are referenced in
;; `org-element-affiliated-keywords'; the others are export attributes
;; and start with "ATTR_" prefix.
;;
;; Element containing other elements (and only elements) are called
;; greater elements.  Concerned types are: `center-block', `drawer',
;; `dynamic-block', `footnote-definition', `headline', `inlinetask',
;; `item', `plain-list', `property-drawer', `quote-block', `section'
;; and `special-block'.
;;
;; Other element types are: `babel-call', `clock', `comment',
;; `comment-block', `diary-sexp', `example-block', `export-block',
;; `fixed-width', `horizontal-rule', `keyword', `latex-environment',
;; `node-property', `paragraph', `planning', `quote-section',
;; `src-block', `table', `table-row' and `verse-block'.  Among them,
;; `paragraph' and `verse-block' types can contain Org objects and
;; plain text.
;;
;; Objects are related to document's contents.  Some of them are
;; recursive.  Associated types are of the following: `bold', `code',
;; `entity', `export-snippet', `footnote-reference',
;; `inline-babel-call', `inline-src-block', `italic',
;; `latex-fragment', `line-break', `link', `macro', `radio-target',
;; `statistics-cookie', `strike-through', `subscript', `superscript',
;; `table-cell', `target', `timestamp', `underline' and `verbatim'.
;;
;; Some elements also have special properties whose value can hold
;; objects themselves (e.g. an item tag or a headline name).  Such
;; values are called "secondary strings".  Any object belongs to
;; either an element or a secondary string.
;;
;; Notwithstanding affiliated keywords, each greater element, element
;; and object has a fixed set of properties attached to it.  Among
;; them, four are shared by all types: `:begin' and `:end', which
;; refer to the beginning and ending buffer positions of the
;; considered element or object, `:post-blank', which holds the number
;; of blank lines, or white spaces, at its end and `:parent' which
;; refers to the element or object containing it.  Greater elements,
;; elements and objects containing objects will also have
;; `:contents-begin' and `:contents-end' properties to delimit
;; contents.  Eventually, greater elements and elements accepting
;; affiliated keywords will have a `:post-affiliated' property,
;; referring to the buffer position after all such keywords.
;;
;; At the lowest level, a `:parent' property is also attached to any
;; string, as a text property.
;;
;; Lisp-wise, an element or an object can be represented as a list.
;; It follows the pattern (TYPE PROPERTIES CONTENTS), where:
;;   TYPE is a symbol describing the Org element or object.
;;   PROPERTIES is the property list attached to it.  See docstring of
;;              appropriate parsing function to get an exhaustive
;;              list.
;;   CONTENTS is a list of elements, objects or raw strings contained
;;            in the current element or object, when applicable.
;;
;; An Org buffer is a nested list of such elements and objects, whose
;; type is `org-data' and properties is nil.
;;
;; The first part of this file defines Org syntax, while the second
;; one provide accessors and setters functions.
;;
;; The next part implements a parser and an interpreter for each
;; element and object type in Org syntax.
;;
;; The following part creates a fully recursive buffer parser.  It
;; also provides a tool to map a function to elements or objects
;; matching some criteria in the parse tree.  Functions of interest
;; are `org-element-parse-buffer', `org-element-map' and, to a lesser
;; extent, `org-element-parse-secondary-string'.
;;
;; The penultimate part is the cradle of an interpreter for the
;; obtained parse tree: `org-element-interpret-data'.
;;
;; The library ends by furnishing `org-element-at-point' function, and
;; a way to give information about document structure around point
;; with `org-element-context'.


;;; Code:

(eval-when-compile (require 'cl))
(require 'org)



;;; Definitions And Rules
;;
;; Define elements, greater elements and specify recursive objects,
;; along with the affiliated keywords recognized.  Also set up
;; restrictions on recursive objects combinations.
;;
;; These variables really act as a control center for the parsing
;; process.

(defconst org-element-paragraph-separate
  (concat "^\\(?:"
          ;; Headlines, inlinetasks.
          org-outline-regexp "\\|"
          ;; Footnote definitions.
	  "\\[\\(?:[0-9]+\\|fn:[-_[:word:]]+\\)\\]" "\\|"
	  ;; Diary sexps.
	  "%%(" "\\|"
          "[ \t]*\\(?:"
          ;; Empty lines.
          "$" "\\|"
	  ;; Tables (any type).
	  "\\(?:|\\|\\+-[-+]\\)" "\\|"
          ;; Blocks (any type), Babel calls and keywords.  Note: this
	  ;; is only an indication and need some thorough check.
          "#\\(?:[+ ]\\|$\\)" "\\|"
	  ;; Drawers (any type) and fixed-width areas.  This is also
	  ;; only an indication.
	  ":" "\\|"
          ;; Horizontal rules.
          "-\\{5,\\}[ \t]*$" "\\|"
          ;; LaTeX environments.
          "\\\\begin{\\([A-Za-z0-9]+\\*?\\)}" "\\|"
          ;; Planning and Clock lines.
          (regexp-opt (list org-scheduled-string
                            org-deadline-string
                            org-closed-string
                            org-clock-string))
          "\\|"
          ;; Lists.
          (let ((term (case org-plain-list-ordered-item-terminator
                        (?\) ")") (?. "\\.") (otherwise "[.)]")))
                (alpha (and org-list-allow-alphabetical "\\|[A-Za-z]")))
            (concat "\\(?:[-+*]\\|\\(?:[0-9]+" alpha "\\)" term "\\)"
                    "\\(?:[ \t]\\|$\\)"))
          "\\)\\)")
  "Regexp to separate paragraphs in an Org buffer.
In the case of lines starting with \"#\" and \":\", this regexp
is not sufficient to know if point is at a paragraph ending.  See
`org-element-paragraph-parser' for more information.")

(defconst org-element-all-elements
  '(babel-call center-block clock comment comment-block diary-sexp drawer
	       dynamic-block example-block export-block fixed-width
	       footnote-definition headline horizontal-rule inlinetask item
	       keyword latex-environment node-property paragraph plain-list
	       planning property-drawer quote-block quote-section section
	       special-block src-block table table-row verse-block)
  "Complete list of element types.")

(defconst org-element-greater-elements
  '(center-block drawer dynamic-block footnote-definition headline inlinetask
		 item plain-list property-drawer quote-block section
		 special-block table)
  "List of recursive element types aka Greater Elements.")

(defconst org-element-all-successors
  '(link export-snippet footnote-reference inline-babel-call
	 inline-src-block latex-or-entity line-break macro plain-link
	 radio-target statistics-cookie sub/superscript table-cell target
	 text-markup timestamp)
  "Complete list of successors.")

(defconst org-element-object-successor-alist
  '((subscript . sub/superscript) (superscript . sub/superscript)
    (bold . text-markup) (code . text-markup) (italic . text-markup)
    (strike-through . text-markup) (underline . text-markup)
    (verbatim . text-markup) (entity . latex-or-entity)
    (latex-fragment . latex-or-entity))
  "Alist of translations between object type and successor name.
Sharing the same successor comes handy when, for example, the
regexp matching one object can also match the other object.")

(defconst org-element-all-objects
  '(bold code entity export-snippet footnote-reference inline-babel-call
	 inline-src-block italic line-break latex-fragment link macro
	 radio-target statistics-cookie strike-through subscript superscript
	 table-cell target timestamp underline verbatim)
  "Complete list of object types.")

(defconst org-element-recursive-objects
  '(bold italic link subscript radio-target strike-through superscript
	 table-cell underline)
  "List of recursive object types.")

(defvar org-element-block-name-alist
  '(("CENTER" . org-element-center-block-parser)
    ("COMMENT" . org-element-comment-block-parser)
    ("EXAMPLE" . org-element-example-block-parser)
    ("QUOTE" . org-element-quote-block-parser)
    ("SRC" . org-element-src-block-parser)
    ("VERSE" . org-element-verse-block-parser))
  "Alist between block names and the associated parsing function.
Names must be uppercase.  Any block whose name has no association
is parsed with `org-element-special-block-parser'.")

(defconst org-element-link-type-is-file
  '("file" "file+emacs" "file+sys" "docview")
  "List of link types equivalent to \"file\".
Only these types can accept search options and an explicit
application to open them.")

(defconst org-element-affiliated-keywords
  '("CAPTION" "DATA" "HEADER" "HEADERS" "LABEL" "NAME" "PLOT" "RESNAME" "RESULT"
    "RESULTS" "SOURCE" "SRCNAME" "TBLNAME")
  "List of affiliated keywords as strings.
By default, all keywords setting attributes (e.g., \"ATTR_LATEX\")
are affiliated keywords and need not to be in this list.")

(defconst org-element-keyword-translation-alist
  '(("DATA" . "NAME")  ("LABEL" . "NAME") ("RESNAME" . "NAME")
    ("SOURCE" . "NAME") ("SRCNAME" . "NAME") ("TBLNAME" . "NAME")
    ("RESULT" . "RESULTS") ("HEADERS" . "HEADER"))
  "Alist of usual translations for keywords.
The key is the old name and the value the new one.  The property
holding their value will be named after the translated name.")

(defconst org-element-multiple-keywords '("CAPTION" "HEADER")
  "List of affiliated keywords that can occur more than once in an element.

Their value will be consed into a list of strings, which will be
returned as the value of the property.

This list is checked after translations have been applied.  See
`org-element-keyword-translation-alist'.

By default, all keywords setting attributes (e.g., \"ATTR_LATEX\")
allow multiple occurrences and need not to be in this list.")

(defconst org-element-parsed-keywords '("CAPTION")
  "List of affiliated keywords whose value can be parsed.

Their value will be stored as a secondary string: a list of
strings and objects.

This list is checked after translations have been applied.  See
`org-element-keyword-translation-alist'.")

(defconst org-element-dual-keywords '("CAPTION" "RESULTS")
  "List of affiliated keywords which can have a secondary value.

In Org syntax, they can be written with optional square brackets
before the colons.  For example, RESULTS keyword can be
associated to a hash value with the following:

  #+RESULTS[hash-string]: some-source

This list is checked after translations have been applied.  See
`org-element-keyword-translation-alist'.")

(defconst org-element-document-properties '("AUTHOR" "DATE" "TITLE")
  "List of properties associated to the whole document.
Any keyword in this list will have its value parsed and stored as
a secondary string.")

(defconst org-element--affiliated-re
  (format "[ \t]*#\\+\\(?:%s\\):\\(?: \\|$\\)"
	  (concat
	   ;; Dual affiliated keywords.
	   (format "\\(?1:%s\\)\\(?:\\[\\(.*\\)\\]\\)?"
		   (regexp-opt org-element-dual-keywords))
	   "\\|"
	   ;; Regular affiliated keywords.
	   (format "\\(?1:%s\\)"
		   (regexp-opt
		    (org-remove-if
		     #'(lambda (keyword)
			 (member keyword org-element-dual-keywords))
		     org-element-affiliated-keywords)))
	   "\\|"
	   ;; Export attributes.
	   "\\(?1:ATTR_[-_A-Za-z0-9]+\\)"))
  "Regexp matching any affiliated keyword.

Keyword name is put in match group 1.  Moreover, if keyword
belongs to `org-element-dual-keywords', put the dual value in
match group 2.

Don't modify it, set `org-element-affiliated-keywords' instead.")

(defconst org-element-object-restrictions
  (let* ((standard-set
	  (remq 'plain-link (remq 'table-cell org-element-all-successors)))
	 (standard-set-no-line-break (remq 'line-break standard-set)))
    `((bold ,@standard-set)
      (footnote-reference ,@standard-set)
      (headline ,@standard-set-no-line-break)
      (inlinetask ,@standard-set-no-line-break)
      (italic ,@standard-set)
      (item ,@standard-set-no-line-break)
      (keyword ,@standard-set)
      ;; Ignore all links excepted plain links in a link description.
      ;; Also ignore radio-targets and line breaks.
      (link export-snippet inline-babel-call inline-src-block latex-or-entity
	    macro plain-link statistics-cookie sub/superscript text-markup)
      (paragraph ,@standard-set)
      ;; Remove any variable object from radio target as it would
      ;; prevent it from being properly recognized.
      (radio-target latex-or-entity sub/superscript text-markup)
      (strike-through ,@standard-set)
      (subscript ,@standard-set)
      (superscript ,@standard-set)
      ;; Ignore inline babel call and inline src block as formulas are
      ;; possible.  Also ignore line breaks and statistics cookies.
      (table-cell link export-snippet footnote-reference latex-or-entity macro
		  radio-target sub/superscript target text-markup timestamp)
      (table-row table-cell)
      (underline ,@standard-set)
      (verse-block ,@standard-set)))
  "Alist of objects restrictions.

CAR is an element or object type containing objects and CDR is
a list of successors that will be called within an element or
object of such type.

For example, in a `radio-target' object, one can only find
entities, latex-fragments, subscript, superscript and text
markup.

This alist also applies to secondary string.  For example, an
`headline' type element doesn't directly contain objects, but
still has an entry since one of its properties (`:title') does.")

(defconst org-element-secondary-value-alist
  '((headline . :title)
    (inlinetask . :title)
    (item . :tag)
    (footnote-reference . :inline-definition))
  "Alist between element types and location of secondary value.")

(defconst org-element-object-variables '(org-link-abbrev-alist-local)
  "List of buffer-local variables used when parsing objects.
These variables are copied to the temporary buffer created by
`org-export-secondary-string'.")



;;; Accessors and Setters
;;
;; Provide four accessors: `org-element-type', `org-element-property'
;; `org-element-contents' and `org-element-restriction'.
;;
;; Setter functions allow to modify elements by side effect.  There is
;; `org-element-put-property', `org-element-set-contents',
;; `org-element-set-element' and `org-element-adopt-element'.  Note
;; that `org-element-set-element' and `org-element-adopt-elements' are
;; higher level functions since also update `:parent' property.

(defsubst org-element-type (element)
  "Return type of ELEMENT.

The function returns the type of the element or object provided.
It can also return the following special value:
  `plain-text'       for a string
  `org-data'         for a complete document
  nil                in any other case."
  (cond
   ((not (consp element)) (and (stringp element) 'plain-text))
   ((symbolp (car element)) (car element))))

(defsubst org-element-property (property element)
  "Extract the value from the PROPERTY of an ELEMENT."
  (if (stringp element) (get-text-property 0 property element)
    (plist-get (nth 1 element) property)))

(defsubst org-element-contents (element)
  "Extract contents from an ELEMENT."
  (cond ((not (consp element)) nil)
	((symbolp (car element)) (nthcdr 2 element))
	(t element)))

(defsubst org-element-restriction (element)
  "Return restriction associated to ELEMENT.
ELEMENT can be an element, an object or a symbol representing an
element or object type."
  (cdr (assq (if (symbolp element) element (org-element-type element))
	     org-element-object-restrictions)))

(defsubst org-element-put-property (element property value)
  "In ELEMENT set PROPERTY to VALUE.
Return modified element."
  (if (stringp element) (org-add-props element nil property value)
    (setcar (cdr element) (plist-put (nth 1 element) property value))
    element))

(defsubst org-element-set-contents (element &rest contents)
  "Set ELEMENT contents to CONTENTS.
Return modified element."
  (cond ((not element) (list contents))
	((not (symbolp (car element))) contents)
	((cdr element) (setcdr (cdr element) contents))
	(t (nconc element contents))))

(defsubst org-element-set-element (old new)
  "Replace element or object OLD with element or object NEW.
The function takes care of setting `:parent' property for NEW."
  ;; Since OLD is going to be changed into NEW by side-effect, first
  ;; make sure that every element or object within NEW has OLD as
  ;; parent.
  (mapc (lambda (blob) (org-element-put-property blob :parent old))
	(org-element-contents new))
  ;; Transfer contents.
  (apply 'org-element-set-contents old (org-element-contents new))
  ;; Ensure NEW has same parent as OLD, then overwrite OLD properties
  ;; with NEW's.
  (org-element-put-property new :parent (org-element-property :parent old))
  (setcar (cdr old) (nth 1 new))
  ;; Transfer type.
  (setcar old (car new)))

(defsubst org-element-adopt-elements (parent &rest children)
  "Append elements to the contents of another element.

PARENT is an element or object.  CHILDREN can be elements,
objects, or a strings.

The function takes care of setting `:parent' property for CHILD.
Return parent element."
  ;; Link every child to PARENT. If PARENT is nil, it is a secondary
  ;; string: parent is the list itself.
  (mapc (lambda (child)
	  (org-element-put-property child :parent (or parent children)))
	children)
  ;; Add CHILDREN at the end of PARENT contents.
  (when parent
    (apply 'org-element-set-contents
	   parent
	   (nconc (org-element-contents parent) children)))
  ;; Return modified PARENT element.
  (or parent children))



;;; Greater elements
;;
;; For each greater element type, we define a parser and an
;; interpreter.
;;
;; A parser returns the element or object as the list described above.
;; Most of them accepts no argument.  Though, exceptions exist.  Hence
;; every element containing a secondary string (see
;; `org-element-secondary-value-alist') will accept an optional
;; argument to toggle parsing of that secondary string.  Moreover,
;; `item' parser requires current list's structure as its first
;; element.
;;
;; An interpreter accepts two arguments: the list representation of
;; the element or object, and its contents.  The latter may be nil,
;; depending on the element or object considered.  It returns the
;; appropriate Org syntax, as a string.
;;
;; Parsing functions must follow the naming convention:
;; org-element-TYPE-parser, where TYPE is greater element's type, as
;; defined in `org-element-greater-elements'.
;;
;; Similarly, interpreting functions must follow the naming
;; convention: org-element-TYPE-interpreter.
;;
;; With the exception of `headline' and `item' types, greater elements
;; cannot contain other greater elements of their own type.
;;
;; Beside implementing a parser and an interpreter, adding a new
;; greater element requires to tweak `org-element--current-element'.
;; Moreover, the newly defined type must be added to both
;; `org-element-all-elements' and `org-element-greater-elements'.


;;;; Center Block

(defun org-element-center-block-parser (limit affiliated)
  "Parse a center block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `center-block' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.

Assume point is at the beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion
	       (re-search-forward "^[ \t]*#\\+END_CENTER[ \t]*$" limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
	(let* ((begin (car affiliated))
	       (post-affiliated (point))
	       ;; Empty blocks have no contents.
	       (contents-begin (progn (forward-line)
				      (and (< (point) block-end-line)
					   (point))))
	       (contents-end (and contents-begin block-end-line))
	       (hidden (org-invisible-p2))
	       (pos-before-blank (progn (goto-char block-end-line)
					(forward-line)
					(point)))
	       (end (save-excursion
		      (skip-chars-forward " \r\t\n" limit)
		      (if (eobp) (point) (line-beginning-position)))))
	  (list 'center-block
		(nconc
		 (list :begin begin
		       :end end
		       :hiddenp hidden
		       :contents-begin contents-begin
		       :contents-end contents-end
		       :post-blank (count-lines pos-before-blank end)
		       :post-affiliated post-affiliated)
		 (cdr affiliated))))))))

(defun org-element-center-block-interpreter (center-block contents)
  "Interpret CENTER-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (format "#+BEGIN_CENTER\n%s#+END_CENTER" contents))


;;;; Drawer

(defun org-element-drawer-parser (limit affiliated)
  "Parse a drawer.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `drawer' and CDR is a plist containing
`:drawer-name', `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.

Assume point is at beginning of drawer."
  (let ((case-fold-search t))
    (if (not (save-excursion (re-search-forward "^[ \t]*:END:[ \t]*$" limit t)))
	;; Incomplete drawer: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (save-excursion
	(let* ((drawer-end-line (match-beginning 0))
	       (name (progn (looking-at org-drawer-regexp)
			    (org-match-string-no-properties 1)))
	       (begin (car affiliated))
	       (post-affiliated (point))
	       ;; Empty drawers have no contents.
	       (contents-begin (progn (forward-line)
				      (and (< (point) drawer-end-line)
					   (point))))
	       (contents-end (and contents-begin drawer-end-line))
	       (hidden (org-invisible-p2))
	       (pos-before-blank (progn (goto-char drawer-end-line)
					(forward-line)
					(point)))
	       (end (progn (skip-chars-forward " \r\t\n" limit)
			   (if (eobp) (point) (line-beginning-position)))))
	  (list 'drawer
		(nconc
		 (list :begin begin
		       :end end
		       :drawer-name name
		       :hiddenp hidden
		       :contents-begin contents-begin
		       :contents-end contents-end
		       :post-blank (count-lines pos-before-blank end)
		       :post-affiliated post-affiliated)
		 (cdr affiliated))))))))

(defun org-element-drawer-interpreter (drawer contents)
  "Interpret DRAWER element as Org syntax.
CONTENTS is the contents of the element."
  (format ":%s:\n%s:END:"
	  (org-element-property :drawer-name drawer)
	  contents))


;;;; Dynamic Block

(defun org-element-dynamic-block-parser (limit affiliated)
  "Parse a dynamic block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `dynamic-block' and CDR is a plist
containing `:block-name', `:begin', `:end', `:hiddenp',
`:contents-begin', `:contents-end', `:arguments', `:post-blank'
and `:post-affiliated' keywords.

Assume point is at beginning of dynamic block."
  (let ((case-fold-search t))
    (if (not (save-excursion
	       (re-search-forward "^[ \t]*#\\+END:?[ \t]*$" limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
	(save-excursion
	  (let* ((name (progn (looking-at org-dblock-start-re)
			      (org-match-string-no-properties 1)))
		 (arguments (org-match-string-no-properties 3))
		 (begin (car affiliated))
		 (post-affiliated (point))
		 ;; Empty blocks have no contents.
		 (contents-begin (progn (forward-line)
					(and (< (point) block-end-line)
					     (point))))
		 (contents-end (and contents-begin block-end-line))
		 (hidden (org-invisible-p2))
		 (pos-before-blank (progn (goto-char block-end-line)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'dynamic-block
		  (nconc
		   (list :begin begin
			 :end end
			 :block-name name
			 :arguments arguments
			 :hiddenp hidden
			 :contents-begin contents-begin
			 :contents-end contents-end
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-dynamic-block-interpreter (dynamic-block contents)
  "Interpret DYNAMIC-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (format "#+BEGIN: %s%s\n%s#+END:"
	  (org-element-property :block-name dynamic-block)
	  (let ((args (org-element-property :arguments dynamic-block)))
	    (and args (concat " " args)))
	  contents))


;;;; Footnote Definition

(defun org-element-footnote-definition-parser (limit affiliated)
  "Parse a footnote definition.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `footnote-definition' and CDR is
a plist containing `:label', `:begin' `:end', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.

Assume point is at the beginning of the footnote definition."
  (save-excursion
    (let* ((label (progn (looking-at org-footnote-definition-re)
			 (org-match-string-no-properties 1)))
	   (begin (car affiliated))
	   (post-affiliated (point))
	   (ending (save-excursion
		     (if (progn
			   (end-of-line)
			   (re-search-forward
			    (concat org-outline-regexp-bol "\\|"
				    org-footnote-definition-re "\\|"
				    "^\\([ \t]*\n\\)\\{2,\\}") limit 'move))
			 (match-beginning 0)
		       (point))))
	   (contents-begin (progn
			     (search-forward "]")
			     (skip-chars-forward " \r\t\n" ending)
			     (cond ((= (point) ending) nil)
				   ((= (line-beginning-position) begin) (point))
				   (t (line-beginning-position)))))
	   (contents-end (and contents-begin ending))
	   (end (progn (goto-char ending)
		       (skip-chars-forward " \r\t\n" limit)
		       (if (eobp) (point) (line-beginning-position)))))
      (list 'footnote-definition
	    (nconc
	     (list :label label
		   :begin begin
		   :end end
		   :contents-begin contents-begin
		   :contents-end contents-end
		   :post-blank (count-lines ending end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-footnote-definition-interpreter (footnote-definition contents)
  "Interpret FOOTNOTE-DEFINITION element as Org syntax.
CONTENTS is the contents of the footnote-definition."
  (concat (format "[%s]" (org-element-property :label footnote-definition))
	  " "
	  contents))


;;;; Headline

(defun org-element-headline-parser (limit &optional raw-secondary-p)
  "Parse a headline.

Return a list whose CAR is `headline' and CDR is a plist
containing `:raw-value', `:title', `:alt-title', `:begin',
`:end', `:pre-blank', `:hiddenp', `:contents-begin' and
`:contents-end', `:level', `:priority', `:tags',
`:todo-keyword',`:todo-type', `:scheduled', `:deadline',
`:closed', `:quotedp', `:archivedp', `:commentedp' and
`:footnote-section-p' keywords.

The plist also contains any property set in the property drawer,
with its name in upper cases and colons added at the
beginning (e.g., `:CUSTOM_ID').

LIMIT is a buffer position bounding the search.

When RAW-SECONDARY-P is non-nil, headline's title will not be
parsed as a secondary string, but as a plain string instead.

Assume point is at beginning of the headline."
  (save-excursion
    (let* ((components (org-heading-components))
	   (level (nth 1 components))
	   (todo (nth 2 components))
	   (todo-type
	    (and todo (if (member todo org-done-keywords) 'done 'todo)))
	   (tags (let ((raw-tags (nth 5 components)))
		   (and raw-tags (org-split-string raw-tags ":"))))
	   (raw-value (or (nth 4 components) ""))
	   (quotedp
	    (let ((case-fold-search nil))
	      (string-match (format "^%s\\( \\|$\\)" org-quote-string)
			    raw-value)))
	   (commentedp
	    (let ((case-fold-search nil))
	      (string-match (format "^%s\\( \\|$\\)" org-comment-string)
			    raw-value)))
	   (archivedp (member org-archive-tag tags))
	   (footnote-section-p (and org-footnote-section
				    (string= org-footnote-section raw-value)))
	   ;; Upcase property names.  It avoids confusion between
	   ;; properties obtained through property drawer and default
	   ;; properties from the parser (e.g. `:end' and :END:)
	   (standard-props
	    (let (plist)
	      (mapc
	       (lambda (p)
		 (setq plist
		       (plist-put plist
				  (intern (concat ":" (upcase (car p))))
				  (cdr p))))
	       (org-entry-properties nil 'standard))
	      plist))
	   (time-props
	    ;; Read time properties on the line below the headline.
	    (save-excursion
	      (when (progn (forward-line)
			   (looking-at org-planning-or-clock-line-re))
		(let ((end (line-end-position)) plist)
		  (while (re-search-forward
			  org-keyword-time-not-clock-regexp end t)
		    (goto-char (match-end 1))
		    (skip-chars-forward " \t")
		    (let ((keyword (match-string 1))
			  (time (org-element-timestamp-parser)))
		      (cond ((equal keyword org-scheduled-string)
			     (setq plist (plist-put plist :scheduled time)))
			    ((equal keyword org-deadline-string)
			     (setq plist (plist-put plist :deadline time)))
			    (t (setq plist (plist-put plist :closed time))))))
		  plist))))
	   (begin (point))
	   (end (min (save-excursion (org-end-of-subtree t t)) limit))
	   (pos-after-head (progn (forward-line) (point)))
	   (contents-begin (save-excursion
			     (skip-chars-forward " \r\t\n" end)
			     (and (/= (point) end) (line-beginning-position))))
	   (hidden (org-invisible-p2))
	   (contents-end (and contents-begin
			      (progn (goto-char end)
				     (skip-chars-backward " \r\t\n")
				     (forward-line)
				     (point)))))
      ;; Clean RAW-VALUE from any quote or comment string.
      (when (or quotedp commentedp)
	(let ((case-fold-search nil))
	  (setq raw-value
		(replace-regexp-in-string
		 (concat
		  (regexp-opt (list org-quote-string org-comment-string))
		  "\\(?: \\|$\\)")
		 ""
		 raw-value))))
      ;; Clean TAGS from archive tag, if any.
      (when archivedp (setq tags (delete org-archive-tag tags)))
      (let ((headline
	     (list 'headline
		   (nconc
		    (list :raw-value raw-value
			  :begin begin
			  :end end
			  :pre-blank
			  (if (not contents-begin) 0
			    (count-lines pos-after-head contents-begin))
			  :hiddenp hidden
			  :contents-begin contents-begin
			  :contents-end contents-end
			  :level level
			  :priority (nth 3 components)
			  :tags tags
			  :todo-keyword todo
			  :todo-type todo-type
			  :post-blank (count-lines
				       (or contents-end pos-after-head)
				       end)
			  :footnote-section-p footnote-section-p
			  :archivedp archivedp
			  :commentedp commentedp
			  :quotedp quotedp)
		    time-props
		    standard-props))))
	(let ((alt-title (org-element-property :ALT_TITLE headline)))
	  (when alt-title
	    (org-element-put-property
	     headline :alt-title
	     (if raw-secondary-p alt-title
	       (org-element-parse-secondary-string
		alt-title (org-element-restriction 'headline) headline)))))
	(org-element-put-property
	 headline :title
	 (if raw-secondary-p raw-value
	   (org-element-parse-secondary-string
	    raw-value (org-element-restriction 'headline) headline)))))))

(defun org-element-headline-interpreter (headline contents)
  "Interpret HEADLINE element as Org syntax.
CONTENTS is the contents of the element."
  (let* ((level (org-element-property :level headline))
	 (todo (org-element-property :todo-keyword headline))
	 (priority (org-element-property :priority headline))
	 (title (org-element-interpret-data
		 (org-element-property :title headline)))
	 (tags (let ((tag-list (if (org-element-property :archivedp headline)
				   (cons org-archive-tag
					 (org-element-property :tags headline))
				 (org-element-property :tags headline))))
		 (and tag-list
		      (format ":%s:" (mapconcat 'identity tag-list ":")))))
	 (commentedp (org-element-property :commentedp headline))
	 (quotedp (org-element-property :quotedp headline))
	 (pre-blank (or (org-element-property :pre-blank headline) 0))
	 (heading (concat (make-string (org-reduced-level level) ?*)
			  (and todo (concat " " todo))
			  (and quotedp (concat " " org-quote-string))
			  (and commentedp (concat " " org-comment-string))
			  (and priority
			       (format " [#%s]" (char-to-string priority)))
			  (cond ((and org-footnote-section
				      (org-element-property
				       :footnote-section-p headline))
				 (concat " " org-footnote-section))
				(title (concat " " title))))))
    (concat heading
	    ;; Align tags.
	    (when tags
	      (cond
	       ((zerop org-tags-column) (format " %s" tags))
	       ((< org-tags-column 0)
		(concat
		 (make-string
		  (max (- (+ org-tags-column (length heading) (length tags))) 1)
		  ? )
		 tags))
	       (t
		(concat
		 (make-string (max (- org-tags-column (length heading)) 1) ? )
		 tags))))
	    (make-string (1+ pre-blank) 10)
	    contents)))


;;;; Inlinetask

(defun org-element-inlinetask-parser (limit &optional raw-secondary-p)
  "Parse an inline task.

Return a list whose CAR is `inlinetask' and CDR is a plist
containing `:title', `:begin', `:end', `:hiddenp',
`:contents-begin' and `:contents-end', `:level', `:priority',
`:raw-value', `:tags', `:todo-keyword', `:todo-type',
`:scheduled', `:deadline', `:closed' and `:post-blank' keywords.

The plist also contains any property set in the property drawer,
with its name in upper cases and colons added at the
beginning (e.g., `:CUSTOM_ID').

When optional argument RAW-SECONDARY-P is non-nil, inline-task's
title will not be parsed as a secondary string, but as a plain
string instead.

Assume point is at beginning of the inline task."
  (save-excursion
    (let* ((begin (point))
	   (components (org-heading-components))
	   (todo (nth 2 components))
	   (todo-type (and todo
			   (if (member todo org-done-keywords) 'done 'todo)))
	   (tags (let ((raw-tags (nth 5 components)))
		   (and raw-tags (org-split-string raw-tags ":"))))
	   (raw-value (or (nth 4 components) ""))
	   ;; Upcase property names.  It avoids confusion between
	   ;; properties obtained through property drawer and default
	   ;; properties from the parser (e.g. `:end' and :END:)
	   (standard-props
	    (let (plist)
	      (mapc
	       (lambda (p)
		 (setq plist
		       (plist-put plist
				  (intern (concat ":" (upcase (car p))))
				  (cdr p))))
	       (org-entry-properties nil 'standard))
	      plist))
	   (time-props
	    ;; Read time properties on the line below the inlinetask
	    ;; opening string.
	    (save-excursion
	      (when (progn (forward-line)
			   (looking-at org-planning-or-clock-line-re))
		(let ((end (line-end-position)) plist)
		  (while (re-search-forward
			  org-keyword-time-not-clock-regexp end t)
		    (goto-char (match-end 1))
		    (skip-chars-forward " \t")
		    (let ((keyword (match-string 1))
			  (time (org-element-timestamp-parser)))
		      (cond ((equal keyword org-scheduled-string)
			     (setq plist (plist-put plist :scheduled time)))
			    ((equal keyword org-deadline-string)
			     (setq plist (plist-put plist :deadline time)))
			    (t (setq plist (plist-put plist :closed time))))))
		  plist))))
	   (task-end (save-excursion
		       (end-of-line)
		       (and (re-search-forward org-outline-regexp-bol limit t)
			    (org-looking-at-p "END[ \t]*$")
			    (line-beginning-position))))
	   (contents-begin (progn (forward-line)
				  (and task-end (< (point) task-end) (point))))
	   (hidden (and contents-begin (org-invisible-p2)))
	   (contents-end (and contents-begin task-end))
	   (before-blank (if (not task-end) (point)
			   (goto-char task-end)
			   (forward-line)
			   (point)))
	   (end (progn (skip-chars-forward " \r\t\n" limit)
		       (if (eobp) (point) (line-beginning-position))))
	   (inlinetask
	    (list 'inlinetask
		  (nconc
		   (list :raw-value raw-value
			 :begin begin
			 :end end
			 :hiddenp hidden
			 :contents-begin contents-begin
			 :contents-end contents-end
			 :level (nth 1 components)
			 :priority (nth 3 components)
			 :tags tags
			 :todo-keyword todo
			 :todo-type todo-type
			 :post-blank (count-lines before-blank end))
		   time-props
		   standard-props))))
      (org-element-put-property
       inlinetask :title
       (if raw-secondary-p raw-value
	 (org-element-parse-secondary-string
	  raw-value
	  (org-element-restriction 'inlinetask)
	  inlinetask))))))

(defun org-element-inlinetask-interpreter (inlinetask contents)
  "Interpret INLINETASK element as Org syntax.
CONTENTS is the contents of inlinetask."
  (let* ((level (org-element-property :level inlinetask))
	 (todo (org-element-property :todo-keyword inlinetask))
	 (priority (org-element-property :priority inlinetask))
	 (title (org-element-interpret-data
		 (org-element-property :title inlinetask)))
	 (tags (let ((tag-list (org-element-property :tags inlinetask)))
		 (and tag-list
		      (format ":%s:" (mapconcat 'identity tag-list ":")))))
	 (task (concat (make-string level ?*)
		       (and todo (concat " " todo))
		       (and priority
			    (format " [#%s]" (char-to-string priority)))
		       (and title (concat " " title)))))
    (concat task
	    ;; Align tags.
	    (when tags
	      (cond
	       ((zerop org-tags-column) (format " %s" tags))
	       ((< org-tags-column 0)
		(concat
		 (make-string
		  (max (- (+ org-tags-column (length task) (length tags))) 1)
		  ? )
		 tags))
	       (t
		(concat
		 (make-string (max (- org-tags-column (length task)) 1) ? )
		 tags))))
	    ;; Prefer degenerate inlinetasks when there are no
	    ;; contents.
	    (when contents
	      (concat "\n"
		      contents
		      (make-string level ?*) " END")))))


;;;; Item

(defun org-element-item-parser (limit struct &optional raw-secondary-p)
  "Parse an item.

STRUCT is the structure of the plain list.

Return a list whose CAR is `item' and CDR is a plist containing
`:bullet', `:begin', `:end', `:contents-begin', `:contents-end',
`:checkbox', `:counter', `:tag', `:structure', `:hiddenp' and
`:post-blank' keywords.

When optional argument RAW-SECONDARY-P is non-nil, item's tag, if
any, will not be parsed as a secondary string, but as a plain
string instead.

Assume point is at the beginning of the item."
  (save-excursion
    (beginning-of-line)
    (looking-at org-list-full-item-re)
    (let* ((begin (point))
	   (bullet (org-match-string-no-properties 1))
	   (checkbox (let ((box (org-match-string-no-properties 3)))
		       (cond ((equal "[ ]" box) 'off)
			     ((equal "[X]" box) 'on)
			     ((equal "[-]" box) 'trans))))
	   (counter (let ((c (org-match-string-no-properties 2)))
		      (save-match-data
			(cond
			 ((not c) nil)
			 ((string-match "[A-Za-z]" c)
			  (- (string-to-char (upcase (match-string 0 c)))
			     64))
			 ((string-match "[0-9]+" c)
			  (string-to-number (match-string 0 c)))))))
	   (end (save-excursion (goto-char (org-list-get-item-end begin struct))
				(unless (bolp) (forward-line))
				(point)))
	   (contents-begin
	    (progn (goto-char
		    ;; Ignore tags in un-ordered lists: they are just
		    ;; a part of item's body.
		    (if (and (match-beginning 4)
			     (save-match-data (string-match "[.)]" bullet)))
			(match-beginning 4)
		      (match-end 0)))
		   (skip-chars-forward " \r\t\n" limit)
		   ;; If first line isn't empty, contents really start
		   ;; at the text after item's meta-data.
		   (if (= (point-at-bol) begin) (point) (point-at-bol))))
	   (hidden (progn (forward-line)
			  (and (not (= (point) end)) (org-invisible-p2))))
	   (contents-end (progn (goto-char end)
				(skip-chars-backward " \r\t\n")
				(forward-line)
				(point)))
	   (item
	    (list 'item
		  (list :bullet bullet
			:begin begin
			:end end
			;; CONTENTS-BEGIN and CONTENTS-END may be
			;; mixed up in the case of an empty item
			;; separated from the next by a blank line.
			;; Thus ensure the former is always the
			;; smallest.
			:contents-begin (min contents-begin contents-end)
			:contents-end (max contents-begin contents-end)
			:checkbox checkbox
			:counter counter
			:hiddenp hidden
			:structure struct
			:post-blank (count-lines contents-end end)))))
      (org-element-put-property
       item :tag
       (let ((raw-tag (org-list-get-tag begin struct)))
	 (and raw-tag
	      (if raw-secondary-p raw-tag
		(org-element-parse-secondary-string
		 raw-tag (org-element-restriction 'item) item))))))))

(defun org-element-item-interpreter (item contents)
  "Interpret ITEM element as Org syntax.
CONTENTS is the contents of the element."
  (let* ((bullet (let ((bullet (org-element-property :bullet item)))
		   (org-list-bullet-string
		    (cond ((not (string-match "[0-9a-zA-Z]" bullet)) "- ")
			  ((eq org-plain-list-ordered-item-terminator ?\)) "1)")
			  (t "1.")))))
	 (checkbox (org-element-property :checkbox item))
	 (counter (org-element-property :counter item))
	 (tag (let ((tag (org-element-property :tag item)))
		(and tag (org-element-interpret-data tag))))
	 ;; Compute indentation.
	 (ind (make-string (length bullet) 32))
	 (item-starts-with-par-p
	  (eq (org-element-type (car (org-element-contents item)))
	      'paragraph)))
    ;; Indent contents.
    (concat
     bullet
     (and counter (format "[@%d] " counter))
     (case checkbox
       (on "[X] ")
       (off "[ ] ")
       (trans "[-] "))
     (and tag (format "%s :: " tag))
     (when contents
       (let ((contents (replace-regexp-in-string
			"\\(^\\)[ \t]*\\S-" ind contents nil nil 1)))
	 (if item-starts-with-par-p (org-trim contents)
	   (concat "\n" contents)))))))


;;;; Plain List

(defun org-element--list-struct (limit)
  ;; Return structure of list at point.  Internal function.  See
  ;; `org-list-struct' for details.
  (let ((case-fold-search t)
	(top-ind limit)
	(item-re (org-item-re))
	(drawers-re (concat ":\\("
			    (mapconcat 'regexp-quote org-drawers "\\|")
			    "\\):[ \t]*$"))
	(inlinetask-re (and (featurep 'org-inlinetask) "^\\*+ "))
	items struct)
    (save-excursion
      (catch 'exit
	(while t
	  (cond
	   ;; At limit: end all items.
	   ((>= (point) limit)
	    (throw 'exit
		   (let ((end (progn (skip-chars-backward " \r\t\n")
				     (forward-line)
				     (point))))
		     (dolist (item items (sort (nconc items struct)
					       'car-less-than-car))
		       (setcar (nthcdr 6 item) end)))))
	   ;; At list end: end all items.
	   ((looking-at org-list-end-re)
	    (throw 'exit (dolist (item items (sort (nconc items struct)
						   'car-less-than-car))
			   (setcar (nthcdr 6 item) (point)))))
	   ;; At a new item: end previous sibling.
	   ((looking-at item-re)
	    (let ((ind (save-excursion (skip-chars-forward " \t")
				       (current-column))))
	      (setq top-ind (min top-ind ind))
	      (while (and items (<= ind (nth 1 (car items))))
		(let ((item (pop items)))
		  (setcar (nthcdr 6 item) (point))
		  (push item struct)))
	      (push (progn (looking-at org-list-full-item-re)
			   (let ((bullet (match-string-no-properties 1)))
			     (list (point)
				   ind
				   bullet
				   (match-string-no-properties 2) ; counter
				   (match-string-no-properties 3) ; checkbox
				   ;; Description tag.
				   (and (save-match-data
					  (string-match "[-+*]" bullet))
					(match-string-no-properties 4))
				   ;; Ending position, unknown so far.
				   nil)))
		    items))
	    (forward-line 1))
	   ;; Skip empty lines.
	   ((looking-at "^[ \t]*$") (forward-line))
	   ;; Skip inline tasks and blank lines along the way.
	   ((and inlinetask-re (looking-at inlinetask-re))
	    (forward-line)
	    (let ((origin (point)))
	      (when (re-search-forward inlinetask-re limit t)
		(if (org-looking-at-p "END[ \t]*$") (forward-line)
		  (goto-char origin)))))
	   ;; At some text line.  Check if it ends any previous item.
	   (t
	    (let ((ind (progn (skip-chars-forward " \t") (current-column))))
	      (when (<= ind top-ind)
		(skip-chars-backward " \r\t\n")
		(forward-line))
	      (while (<= ind (nth 1 (car items)))
		(let ((item (pop items)))
		  (setcar (nthcdr 6 item) (line-beginning-position))
		  (push item struct)
		  (unless items
		    (throw 'exit (sort struct 'car-less-than-car))))))
	    ;; Skip blocks (any type) and drawers contents.
	    (cond
	     ((and (looking-at "#\\+BEGIN\\(:\\|_\\S-+\\)")
		   (re-search-forward
		    (format "^[ \t]*#\\+END%s[ \t]*$"
			    (org-match-string-no-properties 1))
		    limit t)))
	     ((and (looking-at drawers-re)
		   (re-search-forward "^[ \t]*:END:[ \t]*$" limit t))))
	    (forward-line))))))))

(defun org-element-plain-list-parser (limit affiliated structure)
  "Parse a plain list.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.  STRUCTURE is the structure of the plain list being
parsed.

Return a list whose CAR is `plain-list' and CDR is a plist
containing `:type', `:begin', `:end', `:contents-begin' and
`:contents-end', `:structure', `:post-blank' and
`:post-affiliated' keywords.

Assume point is at the beginning of the list."
  (save-excursion
    (let* ((struct (or structure (org-element--list-struct limit)))
	   (prevs (org-list-prevs-alist struct))
	   (type (org-list-get-list-type (point) struct prevs))
	   (contents-begin (point))
	   (begin (car affiliated))
	   (contents-end
	    (progn (goto-char (org-list-get-list-end (point) struct prevs))
		   (unless (bolp) (forward-line))
		   (point)))
	   (end (progn (skip-chars-forward " \r\t\n" limit)
		       (if (= (point) limit) limit (line-beginning-position)))))
      ;; Return value.
      (list 'plain-list
	    (nconc
	     (list :type type
		   :begin begin
		   :end end
		   :contents-begin contents-begin
		   :contents-end contents-end
		   :structure struct
		   :post-blank (count-lines contents-end end)
		   :post-affiliated contents-begin)
	     (cdr affiliated))))))

(defun org-element-plain-list-interpreter (plain-list contents)
  "Interpret PLAIN-LIST element as Org syntax.
CONTENTS is the contents of the element."
  (with-temp-buffer
    (insert contents)
    (goto-char (point-min))
    (org-list-repair)
    (buffer-string)))


;;;; Property Drawer

(defun org-element-property-drawer-parser (limit affiliated)
  "Parse a property drawer.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `property-drawer' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.

Assume point is at the beginning of the property drawer."
  (save-excursion
    (let ((case-fold-search t))
      (if (not (save-excursion
		 (re-search-forward "^[ \t]*:END:[ \t]*$" limit t)))
	  ;; Incomplete drawer: parse it as a paragraph.
	  (org-element-paragraph-parser limit affiliated)
	(save-excursion
	  (let* ((drawer-end-line (match-beginning 0))
		 (begin (car affiliated))
		 (post-affiliated (point))
		 (contents-begin (progn (forward-line)
					(and (< (point) drawer-end-line)
					     (point))))
		 (contents-end (and contents-begin drawer-end-line))
		 (hidden (org-invisible-p2))
		 (pos-before-blank (progn (goto-char drawer-end-line)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'property-drawer
		  (nconc
		   (list :begin begin
			 :end end
			 :hiddenp hidden
			 :contents-begin contents-begin
			 :contents-end contents-end
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-property-drawer-interpreter (property-drawer contents)
  "Interpret PROPERTY-DRAWER element as Org syntax.
CONTENTS is the properties within the drawer."
  (format ":PROPERTIES:\n%s:END:" contents))


;;;; Quote Block

(defun org-element-quote-block-parser (limit affiliated)
  "Parse a quote block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `quote-block' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.

Assume point is at the beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion
	       (re-search-forward "^[ \t]*#\\+END_QUOTE[ \t]*$" limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
	(save-excursion
	  (let* ((begin (car affiliated))
		 (post-affiliated (point))
		 ;; Empty blocks have no contents.
		 (contents-begin (progn (forward-line)
					(and (< (point) block-end-line)
					     (point))))
		 (contents-end (and contents-begin block-end-line))
		 (hidden (org-invisible-p2))
		 (pos-before-blank (progn (goto-char block-end-line)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'quote-block
		  (nconc
		   (list :begin begin
			 :end end
			 :hiddenp hidden
			 :contents-begin contents-begin
			 :contents-end contents-end
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-quote-block-interpreter (quote-block contents)
  "Interpret QUOTE-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (format "#+BEGIN_QUOTE\n%s#+END_QUOTE" contents))


;;;; Section

(defun org-element-section-parser (limit)
  "Parse a section.

LIMIT bounds the search.

Return a list whose CAR is `section' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `contents-end'
and `:post-blank' keywords."
  (save-excursion
    ;; Beginning of section is the beginning of the first non-blank
    ;; line after previous headline.
    (let ((begin (point))
	  (end (progn (org-with-limited-levels (outline-next-heading))
		      (point)))
	  (pos-before-blank (progn (skip-chars-backward " \r\t\n")
				   (forward-line)
				   (point))))
      (list 'section
	    (list :begin begin
		  :end end
		  :contents-begin begin
		  :contents-end pos-before-blank
		  :post-blank (count-lines pos-before-blank end))))))

(defun org-element-section-interpreter (section contents)
  "Interpret SECTION element as Org syntax.
CONTENTS is the contents of the element."
  contents)


;;;; Special Block

(defun org-element-special-block-parser (limit affiliated)
  "Parse a special block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `special-block' and CDR is a plist
containing `:type', `:begin', `:end', `:hiddenp',
`:contents-begin', `:contents-end', `:post-blank' and
`:post-affiliated' keywords.

Assume point is at the beginning of the block."
  (let* ((case-fold-search t)
	 (type (progn (looking-at "[ \t]*#\\+BEGIN_\\(\\S-+\\)")
		      (upcase (match-string-no-properties 1)))))
    (if (not (save-excursion
	       (re-search-forward
		(format "^[ \t]*#\\+END_%s[ \t]*$" (regexp-quote type))
		limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
	(save-excursion
	  (let* ((begin (car affiliated))
		 (post-affiliated (point))
		 ;; Empty blocks have no contents.
		 (contents-begin (progn (forward-line)
					(and (< (point) block-end-line)
					     (point))))
		 (contents-end (and contents-begin block-end-line))
		 (hidden (org-invisible-p2))
		 (pos-before-blank (progn (goto-char block-end-line)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'special-block
		  (nconc
		   (list :type type
			 :begin begin
			 :end end
			 :hiddenp hidden
			 :contents-begin contents-begin
			 :contents-end contents-end
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-special-block-interpreter (special-block contents)
  "Interpret SPECIAL-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (let ((block-type (org-element-property :type special-block)))
    (format "#+BEGIN_%s\n%s#+END_%s" block-type contents block-type)))



;;; Elements
;;
;; For each element, a parser and an interpreter are also defined.
;; Both follow the same naming convention used for greater elements.
;;
;; Also, as for greater elements, adding a new element type is done
;; through the following steps: implement a parser and an interpreter,
;; tweak `org-element--current-element' so that it recognizes the new
;; type and add that new type to `org-element-all-elements'.
;;
;; As a special case, when the newly defined type is a block type,
;; `org-element-block-name-alist' has to be modified accordingly.


;;;; Babel Call

(defun org-element-babel-call-parser (limit affiliated)
  "Parse a babel call.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `babel-call' and CDR is a plist
containing `:begin', `:end', `:info', `:post-blank' and
`:post-affiliated' as keywords."
  (save-excursion
    (let ((case-fold-search t)
	  (info (progn (looking-at org-babel-block-lob-one-liner-regexp)
		       (org-babel-lob-get-info)))
	  (begin (car affiliated))
	  (post-affiliated (point))
	  (pos-before-blank (progn (forward-line) (point)))
	  (end (progn (skip-chars-forward " \r\t\n" limit)
		      (if (eobp) (point) (line-beginning-position)))))
      (list 'babel-call
	    (nconc
	     (list :begin begin
		   :end end
		   :info info
		   :post-blank (count-lines pos-before-blank end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-babel-call-interpreter (babel-call contents)
  "Interpret BABEL-CALL element as Org syntax.
CONTENTS is nil."
  (let* ((babel-info (org-element-property :info babel-call))
	 (main (car babel-info))
	 (post-options (nth 1 babel-info)))
    (concat "#+CALL: "
	    (if (not (string-match "\\[\\(\\[.*?\\]\\)\\]" main)) main
	      ;; Remove redundant square brackets.
	      (replace-match (match-string 1 main) nil nil main))
	    (and post-options (format "[%s]" post-options)))))


;;;; Clock

(defun org-element-clock-parser (limit)
  "Parse a clock.

LIMIT bounds the search.

Return a list whose CAR is `clock' and CDR is a plist containing
`:status', `:value', `:time', `:begin', `:end' and `:post-blank'
as keywords."
  (save-excursion
    (let* ((case-fold-search nil)
	   (begin (point))
	   (value (progn (search-forward org-clock-string (line-end-position) t)
			 (skip-chars-forward " \t")
			 (org-element-timestamp-parser)))
	   (duration (and (search-forward " => " (line-end-position) t)
			  (progn (skip-chars-forward " \t")
				 (looking-at "\\(\\S-+\\)[ \t]*$"))
			  (org-match-string-no-properties 1)))
	   (status (if duration 'closed 'running))
	   (post-blank (let ((before-blank (progn (forward-line) (point))))
			 (skip-chars-forward " \r\t\n" limit)
			 (skip-chars-backward " \t")
			 (unless (bolp) (end-of-line))
			 (count-lines before-blank (point))))
	   (end (point)))
      (list 'clock
	    (list :status status
		  :value value
		  :duration duration
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-clock-interpreter (clock contents)
  "Interpret CLOCK element as Org syntax.
CONTENTS is nil."
  (concat org-clock-string " "
	  (org-element-timestamp-interpreter
	   (org-element-property :value clock) nil)
	  (let ((duration (org-element-property :duration clock)))
	    (and duration
		 (concat " => "
			 (apply 'format
				"%2s:%02s"
				(org-split-string duration ":")))))))


;;;; Comment

(defun org-element-comment-parser (limit affiliated)
  "Parse a comment.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `comment' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank',
`:post-affiliated' keywords.

Assume point is at comment beginning."
  (save-excursion
    (let* ((begin (car affiliated))
	   (post-affiliated (point))
	   (value (prog2 (looking-at "[ \t]*# ?")
		      (buffer-substring-no-properties
		       (match-end 0) (line-end-position))
		    (forward-line)))
	   (com-end
	    ;; Get comments ending.
	    (progn
	      (while (and (< (point) limit) (looking-at "[ \t]*#\\( \\|$\\)"))
		;; Accumulate lines without leading hash and first
		;; whitespace.
		(setq value
		      (concat value
			      "\n"
			      (buffer-substring-no-properties
			       (match-end 0) (line-end-position))))
		(forward-line))
	      (point)))
	   (end (progn (goto-char com-end)
		       (skip-chars-forward " \r\t\n" limit)
		       (if (eobp) (point) (line-beginning-position)))))
      (list 'comment
	    (nconc
	     (list :begin begin
		   :end end
		   :value value
		   :post-blank (count-lines com-end end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-comment-interpreter (comment contents)
  "Interpret COMMENT element as Org syntax.
CONTENTS is nil."
  (replace-regexp-in-string "^" "# " (org-element-property :value comment)))


;;;; Comment Block

(defun org-element-comment-block-parser (limit affiliated)
  "Parse an export block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `comment-block' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:value', `:post-blank'
and `:post-affiliated' keywords.

Assume point is at comment block beginning."
  (let ((case-fold-search t))
    (if (not (save-excursion
	       (re-search-forward "^[ \t]*#\\+END_COMMENT[ \t]*$" limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
	(save-excursion
	  (let* ((begin (car affiliated))
		 (post-affiliated (point))
		 (contents-begin (progn (forward-line) (point)))
		 (hidden (org-invisible-p2))
		 (pos-before-blank (progn (goto-char contents-end)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position))))
		 (value (buffer-substring-no-properties
			 contents-begin contents-end)))
	    (list 'comment-block
		  (nconc
		   (list :begin begin
			 :end end
			 :value value
			 :hiddenp hidden
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-comment-block-interpreter (comment-block contents)
  "Interpret COMMENT-BLOCK element as Org syntax.
CONTENTS is nil."
  (format "#+BEGIN_COMMENT\n%s#+END_COMMENT"
	  (org-remove-indentation (org-element-property :value comment-block))))


;;;; Diary Sexp

(defun org-element-diary-sexp-parser (limit affiliated)
  "Parse a diary sexp.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `diary-sexp' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank' and
`:post-affiliated' keywords."
  (save-excursion
    (let ((begin (car affiliated))
	  (post-affiliated (point))
	  (value (progn (looking-at "\\(%%(.*\\)[ \t]*$")
			(org-match-string-no-properties 1)))
	  (pos-before-blank (progn (forward-line) (point)))
	  (end (progn (skip-chars-forward " \r\t\n" limit)
		      (if (eobp) (point) (line-beginning-position)))))
      (list 'diary-sexp
	    (nconc
	     (list :value value
		   :begin begin
		   :end end
		   :post-blank (count-lines pos-before-blank end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-diary-sexp-interpreter (diary-sexp contents)
  "Interpret DIARY-SEXP as Org syntax.
CONTENTS is nil."
  (org-element-property :value diary-sexp))


;;;; Example Block

(defun org-element--remove-indentation (s &optional n)
  "Remove maximum common indentation in string S and return it.
When optional argument N is a positive integer, remove exactly
that much characters from indentation, if possible, or return
S as-is otherwise.  Unlike to `org-remove-indentation', this
function doesn't call `untabify' on S."
  (catch 'exit
    (with-temp-buffer
      (insert s)
      (goto-char (point-min))
      ;; Find maximum common indentation, if not specified.
      (setq n (or n
                  (let ((min-ind (point-max)))
		    (save-excursion
		      (while (re-search-forward "^[ \t]*\\S-" nil t)
			(let ((ind (1- (current-column))))
			  (if (zerop ind) (throw 'exit s)
			    (setq min-ind (min min-ind ind))))))
		    min-ind)))
      (if (zerop n) s
	;; Remove exactly N indentation, but give up if not possible.
	(while (not (eobp))
	  (let ((ind (progn (skip-chars-forward " \t") (current-column))))
	    (cond ((eolp) (delete-region (line-beginning-position) (point)))
		  ((< ind n) (throw 'exit s))
		  (t (org-indent-line-to (- ind n))))
	    (forward-line)))
	(buffer-string)))))

(defun org-element-example-block-parser (limit affiliated)
  "Parse an example block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `example-block' and CDR is a plist
containing `:begin', `:end', `:number-lines', `:preserve-indent',
`:retain-labels', `:use-labels', `:label-fmt', `:hiddenp',
`:switches', `:value', `:post-blank' and `:post-affiliated'
keywords."
  (let ((case-fold-search t))
    (if (not (save-excursion
	       (re-search-forward "^[ \t]*#\\+END_EXAMPLE[ \t]*$" limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
	(save-excursion
	  (let* ((switches
		  (progn
		    (looking-at "^[ \t]*#\\+BEGIN_EXAMPLE\\(?: +\\(.*\\)\\)?")
		    (org-match-string-no-properties 1)))
		 ;; Switches analysis
		 (number-lines
		  (cond ((not switches) nil)
			((string-match "-n\\>" switches) 'new)
			((string-match "+n\\>" switches) 'continued)))
		 (preserve-indent
		  (or org-src-preserve-indentation
		      (and switches (string-match "-i\\>" switches))))
		 ;; Should labels be retained in (or stripped from) example
		 ;; blocks?
		 (retain-labels
		  (or (not switches)
		      (not (string-match "-r\\>" switches))
		      (and number-lines (string-match "-k\\>" switches))))
		 ;; What should code-references use - labels or
		 ;; line-numbers?
		 (use-labels
		  (or (not switches)
		      (and retain-labels
			   (not (string-match "-k\\>" switches)))))
		 (label-fmt
		  (and switches
		       (string-match "-l +\"\\([^\"\n]+\\)\"" switches)
		       (match-string 1 switches)))
		 ;; Standard block parsing.
		 (begin (car affiliated))
		 (post-affiliated (point))
		 (block-ind (progn (skip-chars-forward " \t") (current-column)))
		 (contents-begin (progn (forward-line) (point)))
		 (hidden (org-invisible-p2))
		 (value (org-element--remove-indentation
			 (org-unescape-code-in-string
			  (buffer-substring-no-properties
			   contents-begin contents-end))
			 (and preserve-indent block-ind)))
		 (pos-before-blank (progn (goto-char contents-end)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'example-block
		  (nconc
		   (list :begin begin
			 :end end
			 :value value
			 :switches switches
			 :number-lines number-lines
			 :preserve-indent preserve-indent
			 :retain-labels retain-labels
			 :use-labels use-labels
			 :label-fmt label-fmt
			 :hiddenp hidden
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-example-block-interpreter (example-block contents)
  "Interpret EXAMPLE-BLOCK element as Org syntax.
CONTENTS is nil."
  (let ((switches (org-element-property :switches example-block)))
    (concat "#+BEGIN_EXAMPLE" (and switches (concat " " switches)) "\n"
	    (org-escape-code-in-string
	     (org-element-property :value example-block))
	    "#+END_EXAMPLE")))


;;;; Export Block

(defun org-element-export-block-parser (limit affiliated)
  "Parse an export block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `export-block' and CDR is a plist
containing `:begin', `:end', `:type', `:hiddenp', `:value',
`:post-blank' and `:post-affiliated' keywords.

Assume point is at export-block beginning."
  (let* ((case-fold-search t)
	 (type (progn (looking-at "[ \t]*#\\+BEGIN_\\(\\S-+\\)")
		      (upcase (org-match-string-no-properties 1)))))
    (if (not (save-excursion
	       (re-search-forward
		(format "^[ \t]*#\\+END_%s[ \t]*$" type) limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
	(save-excursion
	  (let* ((begin (car affiliated))
		 (post-affiliated (point))
		 (contents-begin (progn (forward-line) (point)))
		 (hidden (org-invisible-p2))
		 (pos-before-blank (progn (goto-char contents-end)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position))))
		 (value (buffer-substring-no-properties contents-begin
							contents-end)))
	    (list 'export-block
		  (nconc
		   (list :begin begin
			 :end end
			 :type type
			 :value value
			 :hiddenp hidden
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-export-block-interpreter (export-block contents)
  "Interpret EXPORT-BLOCK element as Org syntax.
CONTENTS is nil."
  (let ((type (org-element-property :type export-block)))
    (concat (format "#+BEGIN_%s\n" type)
	    (org-element-property :value export-block)
	    (format "#+END_%s" type))))


;;;; Fixed-width

(defun org-element-fixed-width-parser (limit affiliated)
  "Parse a fixed-width section.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `fixed-width' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank' and
`:post-affiliated' keywords.

Assume point is at the beginning of the fixed-width area."
  (save-excursion
    (let* ((begin (car affiliated))
	   (post-affiliated (point))
	   value
	   (end-area
	    (progn
	      (while (and (< (point) limit)
			  (looking-at "[ \t]*:\\( \\|$\\)"))
		;; Accumulate text without starting colons.
		(setq value
		      (concat value
			      (buffer-substring-no-properties
			       (match-end 0) (point-at-eol))
			      "\n"))
		(forward-line))
	      (point)))
	   (end (progn (skip-chars-forward " \r\t\n" limit)
		       (if (eobp) (point) (line-beginning-position)))))
      (list 'fixed-width
	    (nconc
	     (list :begin begin
		   :end end
		   :value value
		   :post-blank (count-lines end-area end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-fixed-width-interpreter (fixed-width contents)
  "Interpret FIXED-WIDTH element as Org syntax.
CONTENTS is nil."
  (let ((value (org-element-property :value fixed-width)))
    (and value
	 (replace-regexp-in-string
	  "^" ": "
	  (if (string-match "\n\\'" value) (substring value 0 -1) value)))))


;;;; Horizontal Rule

(defun org-element-horizontal-rule-parser (limit affiliated)
  "Parse an horizontal rule.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `horizontal-rule' and CDR is a plist
containing `:begin', `:end', `:post-blank' and `:post-affiliated'
keywords."
  (save-excursion
    (let ((begin (car affiliated))
	  (post-affiliated (point))
	  (post-hr (progn (forward-line) (point)))
	  (end (progn (skip-chars-forward " \r\t\n" limit)
		      (if (eobp) (point) (line-beginning-position)))))
      (list 'horizontal-rule
	    (nconc
	     (list :begin begin
		   :end end
		   :post-blank (count-lines post-hr end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-horizontal-rule-interpreter (horizontal-rule contents)
  "Interpret HORIZONTAL-RULE element as Org syntax.
CONTENTS is nil."
  "-----")


;;;; Keyword

(defun org-element-keyword-parser (limit affiliated)
  "Parse a keyword at point.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `keyword' and CDR is a plist
containing `:key', `:value', `:begin', `:end', `:post-blank' and
`:post-affiliated' keywords."
  (save-excursion
    (let ((begin (car affiliated))
	  (post-affiliated (point))
	  (key (progn (looking-at "[ \t]*#\\+\\(\\S-+*\\):")
		      (upcase (org-match-string-no-properties 1))))
	  (value (org-trim (buffer-substring-no-properties
			    (match-end 0) (point-at-eol))))
	  (pos-before-blank (progn (forward-line) (point)))
	  (end (progn (skip-chars-forward " \r\t\n" limit)
		      (if (eobp) (point) (line-beginning-position)))))
      (list 'keyword
	    (nconc
	     (list :key key
		   :value value
		   :begin begin
		   :end end
		   :post-blank (count-lines pos-before-blank end)
		   :post-affiliated post-affiliated)
	     (cdr affiliated))))))

(defun org-element-keyword-interpreter (keyword contents)
  "Interpret KEYWORD element as Org syntax.
CONTENTS is nil."
  (format "#+%s: %s"
	  (org-element-property :key keyword)
	  (org-element-property :value keyword)))


;;;; Latex Environment

(defun org-element-latex-environment-parser (limit affiliated)
  "Parse a LaTeX environment.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `latex-environment' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank' and
`:post-affiliated' keywords.

Assume point is at the beginning of the latex environment."
  (save-excursion
    (let ((case-fold-search t)
	  (code-begin (point)))
      (looking-at "[ \t]*\\\\begin{\\([A-Za-z0-9]+\\*?\\)}")
      (if (not (re-search-forward (format "^[ \t]*\\\\end{%s}[ \t]*$"
					  (regexp-quote (match-string 1)))
				  limit t))
	  ;; Incomplete latex environment: parse it as a paragraph.
	  (org-element-paragraph-parser limit affiliated)
	(let* ((code-end (progn (forward-line) (point)))
	       (begin (car affiliated))
	       (value (buffer-substring-no-properties code-begin code-end))
	       (end (progn (skip-chars-forward " \r\t\n" limit)
			   (if (eobp) (point) (line-beginning-position)))))
	  (list 'latex-environment
		(nconc
		 (list :begin begin
		       :end end
		       :value value
		       :post-blank (count-lines code-end end)
		       :post-affiliated code-begin)
		 (cdr affiliated))))))))

(defun org-element-latex-environment-interpreter (latex-environment contents)
  "Interpret LATEX-ENVIRONMENT element as Org syntax.
CONTENTS is nil."
  (org-element-property :value latex-environment))


;;;; Node Property

(defun org-element-node-property-parser (limit)
  "Parse a node-property at point.

LIMIT bounds the search.

Return a list whose CAR is `node-property' and CDR is a plist
containing `:key', `:value', `:begin', `:end' and `:post-blank'
keywords."
  (save-excursion
    (looking-at org-property-re)
    (let ((case-fold-search t)
	  (begin (point))
	  (key   (org-match-string-no-properties 2))
	  (value (org-match-string-no-properties 3))
	  (pos-before-blank (progn (forward-line) (point)))
	  (end (progn (skip-chars-forward " \r\t\n" limit)
		      (if (eobp) (point) (point-at-bol)))))
      (list 'node-property
	    (list :key key
		  :value value
		  :begin begin
		  :end end
		  :post-blank (count-lines pos-before-blank end))))))

(defun org-element-node-property-interpreter (node-property contents)
  "Interpret NODE-PROPERTY element as Org syntax.
CONTENTS is nil."
  (format org-property-format
	  (format ":%s:" (org-element-property :key node-property))
	  (org-element-property :value node-property)))


;;;; Paragraph

(defun org-element-paragraph-parser (limit affiliated)
  "Parse a paragraph.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `paragraph' and CDR is a plist
containing `:begin', `:end', `:contents-begin' and
`:contents-end', `:post-blank' and `:post-affiliated' keywords.

Assume point is at the beginning of the paragraph."
  (save-excursion
    (let* ((begin (car affiliated))
	   (contents-begin (point))
	   (before-blank
	    (let ((case-fold-search t))
	      (end-of-line)
	      (if (not (re-search-forward
			org-element-paragraph-separate limit 'm))
		  limit
		;; A matching `org-element-paragraph-separate' is not
		;; necessarily the end of the paragraph.  In
		;; particular, lines starting with # or : as a first
		;; non-space character are ambiguous.  We have to
		;; check if they are valid Org syntax (e.g., not an
		;; incomplete keyword).
		(beginning-of-line)
		(while (not
			(or
			 ;; There's no ambiguity for other symbols or
			 ;; empty lines: stop here.
			 (looking-at "[ \t]*\\(?:[^:#]\\|$\\)")
			 ;; Stop at valid fixed-width areas.
			 (looking-at "[ \t]*:\\(?: \\|$\\)")
			 ;; Stop at drawers.
			 (and (looking-at org-drawer-regexp)
			      (save-excursion
				(re-search-forward
				 "^[ \t]*:END:[ \t]*$" limit t)))
			 ;; Stop at valid comments.
			 (looking-at "[ \t]*#\\(?: \\|$\\)")
			 ;; Stop at valid dynamic blocks.
			 (and (looking-at org-dblock-start-re)
			      (save-excursion
				(re-search-forward
				 "^[ \t]*#\\+END:?[ \t]*$" limit t)))
			 ;; Stop at valid blocks.
			 (and (looking-at "[ \t]*#\\+BEGIN_\\(\\S-+\\)")
			      (save-excursion
				(re-search-forward
				 (format "^[ \t]*#\\+END_%s[ \t]*$"
					 (regexp-quote
					  (org-match-string-no-properties 1)))
				 limit t)))
			 ;; Stop at valid latex environments.
			 (and (looking-at
			       "[ \t]*\\\\begin{\\([A-Za-z0-9]+\\*?\\)}")
			      (save-excursion
				(re-search-forward
				 (format "^[ \t]*\\\\end{%s}[ \t]*$"
					 (regexp-quote
					  (org-match-string-no-properties 1)))
				 limit t)))
			 ;; Stop at valid keywords.
			 (looking-at "[ \t]*#\\+\\S-+:")
			 ;; Skip everything else.
			 (not
			  (progn
			    (end-of-line)
			    (re-search-forward org-element-paragraph-separate
					       limit 'm)))))
		  (beginning-of-line)))
	      (if (= (point) limit) limit
		(goto-char (line-beginning-position)))))
	   (contents-end (progn (skip-chars-backward " \r\t\n" contents-begin)
				(forward-line)
				(point)))
	   (end (progn (skip-chars-forward " \r\t\n" limit)
		       (if (eobp) (point) (line-beginning-position)))))
      (list 'paragraph
	    (nconc
	     (list :begin begin
		   :end end
		   :contents-begin contents-begin
		   :contents-end contents-end
		   :post-blank (count-lines before-blank end)
		   :post-affiliated contents-begin)
	     (cdr affiliated))))))

(defun org-element-paragraph-interpreter (paragraph contents)
  "Interpret PARAGRAPH element as Org syntax.
CONTENTS is the contents of the element."
  contents)


;;;; Planning

(defun org-element-planning-parser (limit)
  "Parse a planning.

LIMIT bounds the search.

Return a list whose CAR is `planning' and CDR is a plist
containing `:closed', `:deadline', `:scheduled', `:begin', `:end'
and `:post-blank' keywords."
  (save-excursion
    (let* ((case-fold-search nil)
	   (begin (point))
	   (post-blank (let ((before-blank (progn (forward-line) (point))))
			 (skip-chars-forward " \r\t\n" limit)
			 (skip-chars-backward " \t")
			 (unless (bolp) (end-of-line))
			 (count-lines before-blank (point))))
	   (end (point))
	   closed deadline scheduled)
      (goto-char begin)
      (while (re-search-forward org-keyword-time-not-clock-regexp end t)
	(goto-char (match-end 1))
	(skip-chars-forward " \t" end)
	(let ((keyword (match-string 1))
	      (time (org-element-timestamp-parser)))
	  (cond ((equal keyword org-closed-string) (setq closed time))
		((equal keyword org-deadline-string) (setq deadline time))
		(t (setq scheduled time)))))
      (list 'planning
	    (list :closed closed
		  :deadline deadline
		  :scheduled scheduled
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-planning-interpreter (planning contents)
  "Interpret PLANNING element as Org syntax.
CONTENTS is nil."
  (mapconcat
   'identity
   (delq nil
	 (list (let ((deadline (org-element-property :deadline planning)))
		 (when deadline
		   (concat org-deadline-string " "
			   (org-element-timestamp-interpreter deadline nil))))
	       (let ((scheduled (org-element-property :scheduled planning)))
		 (when scheduled
		   (concat org-scheduled-string " "
			   (org-element-timestamp-interpreter scheduled nil))))
	       (let ((closed (org-element-property :closed planning)))
		 (when closed
		   (concat org-closed-string " "
			   (org-element-timestamp-interpreter closed nil))))))
   " "))


;;;; Quote Section

(defun org-element-quote-section-parser (limit)
  "Parse a quote section.

LIMIT bounds the search.

Return a list whose CAR is `quote-section' and CDR is a plist
containing `:begin', `:end', `:value' and `:post-blank' keywords.

Assume point is at beginning of the section."
  (save-excursion
    (let* ((begin (point))
	   (end (progn (org-with-limited-levels (outline-next-heading))
		       (point)))
	   (pos-before-blank (progn (skip-chars-backward " \r\t\n")
				    (forward-line)
				    (point)))
	   (value (buffer-substring-no-properties begin pos-before-blank)))
      (list 'quote-section
	    (list :begin begin
		  :end end
		  :value value
		  :post-blank (count-lines pos-before-blank end))))))

(defun org-element-quote-section-interpreter (quote-section contents)
  "Interpret QUOTE-SECTION element as Org syntax.
CONTENTS is nil."
  (org-element-property :value quote-section))


;;;; Src Block

(defun org-element-src-block-parser (limit affiliated)
  "Parse a src block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `src-block' and CDR is a plist
containing `:language', `:switches', `:parameters', `:begin',
`:end', `:hiddenp', `:number-lines', `:retain-labels',
`:use-labels', `:label-fmt', `:preserve-indent', `:value',
`:post-blank' and `:post-affiliated' keywords.

Assume point is at the beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion (re-search-forward "^[ \t]*#\\+END_SRC[ \t]*$"
						limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
	(save-excursion
	  (let* ((begin (car affiliated))
		 (post-affiliated (point))
		 ;; Get language as a string.
		 (language
		  (progn
		    (looking-at
		     (concat "^[ \t]*#\\+BEGIN_SRC"
			     "\\(?: +\\(\\S-+\\)\\)?"
			     "\\(\\(?: +\\(?:-l \".*?\"\\|[-+][A-Za-z]\\)\\)+\\)?"
			     "\\(.*\\)[ \t]*$"))
		    (org-match-string-no-properties 1)))
		 ;; Get switches.
		 (switches (org-match-string-no-properties 2))
		 ;; Get parameters.
		 (parameters (org-match-string-no-properties 3))
		 ;; Switches analysis
		 (number-lines
		  (cond ((not switches) nil)
			((string-match "-n\\>" switches) 'new)
			((string-match "+n\\>" switches) 'continued)))
		 (preserve-indent (or org-src-preserve-indentation
				      (and switches
					   (string-match "-i\\>" switches))))
		 (label-fmt
		  (and switches
		       (string-match "-l +\"\\([^\"\n]+\\)\"" switches)
		       (match-string 1 switches)))
		 ;; Should labels be retained in (or stripped from)
		 ;; src blocks?
		 (retain-labels
		  (or (not switches)
		      (not (string-match "-r\\>" switches))
		      (and number-lines (string-match "-k\\>" switches))))
		 ;; What should code-references use - labels or
		 ;; line-numbers?
		 (use-labels
		  (or (not switches)
		      (and retain-labels
			   (not (string-match "-k\\>" switches)))))
		 ;; Indentation.
		 (block-ind (progn (skip-chars-forward " \t") (current-column)))
		 ;; Get visibility status.
		 (hidden (progn (forward-line) (org-invisible-p2)))
		 ;; Retrieve code.
		 (value (org-element--remove-indentation
			 (org-unescape-code-in-string
			  (buffer-substring-no-properties
			   (point) contents-end))
			 (and preserve-indent block-ind)))
		 (pos-before-blank (progn (goto-char contents-end)
					  (forward-line)
					  (point)))
		 ;; Get position after ending blank lines.
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'src-block
		  (nconc
		   (list :language language
			 :switches (and (org-string-nw-p switches)
					(org-trim switches))
			 :parameters (and (org-string-nw-p parameters)
					  (org-trim parameters))
			 :begin begin
			 :end end
			 :number-lines number-lines
			 :preserve-indent preserve-indent
			 :retain-labels retain-labels
			 :use-labels use-labels
			 :label-fmt label-fmt
			 :hiddenp hidden
			 :value value
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-src-block-interpreter (src-block contents)
  "Interpret SRC-BLOCK element as Org syntax.
CONTENTS is nil."
  (let ((lang (org-element-property :language src-block))
	(switches (org-element-property :switches src-block))
	(params (org-element-property :parameters src-block))
	(value (let ((val (org-element-property :value src-block)))
		 (cond
		  ((org-element-property :preserve-indent src-block) val)
		  ((zerop org-edit-src-content-indentation) val)
		  (t
		   (let ((ind (make-string
			       org-edit-src-content-indentation 32)))
		     (replace-regexp-in-string
		      "\\(^\\)[ \t]*\\S-" ind val nil nil 1)))))))
    (concat (format "#+BEGIN_SRC%s\n"
		    (concat (and lang (concat " " lang))
			    (and switches (concat " " switches))
			    (and params (concat " " params))))
	    (org-escape-code-in-string value)
	    "#+END_SRC")))


;;;; Table

(defun org-element-table-parser (limit affiliated)
  "Parse a table at point.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `table' and CDR is a plist containing
`:begin', `:end', `:tblfm', `:type', `:contents-begin',
`:contents-end', `:value', `:post-blank' and `:post-affiliated'
keywords.

Assume point is at the beginning of the table."
  (save-excursion
    (let* ((case-fold-search t)
	   (table-begin (point))
	   (type (if (org-at-table.el-p) 'table.el 'org))
	   (begin (car affiliated))
	   (table-end
	    (if (re-search-forward org-table-any-border-regexp limit 'm)
		(goto-char (match-beginning 0))
	      (point)))
	   (tblfm (let (acc)
		    (while (looking-at "[ \t]*#\\+TBLFM: +\\(.*\\)[ \t]*$")
		      (push (org-match-string-no-properties 1) acc)
		      (forward-line))
		    acc))
	   (pos-before-blank (point))
	   (end (progn (skip-chars-forward " \r\t\n" limit)
		       (if (eobp) (point) (line-beginning-position)))))
      (list 'table
	    (nconc
	     (list :begin begin
		   :end end
		   :type type
		   :tblfm tblfm
		   ;; Only `org' tables have contents.  `table.el' tables
		   ;; use a `:value' property to store raw table as
		   ;; a string.
		   :contents-begin (and (eq type 'org) table-begin)
		   :contents-end (and (eq type 'org) table-end)
		   :value (and (eq type 'table.el)
			       (buffer-substring-no-properties
				table-begin table-end))
		   :post-blank (count-lines pos-before-blank end)
		   :post-affiliated table-begin)
	     (cdr affiliated))))))

(defun org-element-table-interpreter (table contents)
  "Interpret TABLE element as Org syntax.
CONTENTS is nil."
  (if (eq (org-element-property :type table) 'table.el)
      (org-remove-indentation (org-element-property :value table))
    (concat (with-temp-buffer (insert contents)
			      (org-table-align)
			      (buffer-string))
	    (mapconcat (lambda (fm) (concat "#+TBLFM: " fm))
		       (reverse (org-element-property :tblfm table))
		       "\n"))))


;;;; Table Row

(defun org-element-table-row-parser (limit)
  "Parse table row at point.

LIMIT bounds the search.

Return a list whose CAR is `table-row' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `:contents-end',
`:type' and `:post-blank' keywords."
  (save-excursion
    (let* ((type (if (looking-at "^[ \t]*|-") 'rule 'standard))
	   (begin (point))
	   ;; A table rule has no contents.  In that case, ensure
	   ;; CONTENTS-BEGIN matches CONTENTS-END.
	   (contents-begin (and (eq type 'standard)
				(search-forward "|")
				(point)))
	   (contents-end (and (eq type 'standard)
			      (progn
				(end-of-line)
				(skip-chars-backward " \t")
				(point))))
	   (end (progn (forward-line) (point))))
      (list 'table-row
	    (list :type type
		  :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank 0)))))

(defun org-element-table-row-interpreter (table-row contents)
  "Interpret TABLE-ROW element as Org syntax.
CONTENTS is the contents of the table row."
  (if (eq (org-element-property :type table-row) 'rule) "|-"
    (concat "| " contents)))


;;;; Verse Block

(defun org-element-verse-block-parser (limit affiliated)
  "Parse a verse block.

LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.

Return a list whose CAR is `verse-block' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `:contents-end',
`:hiddenp', `:post-blank' and `:post-affiliated' keywords.

Assume point is at beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion
	       (re-search-forward "^[ \t]*#\\+END_VERSE[ \t]*$" limit t)))
	;; Incomplete block: parse it as a paragraph.
	(org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
	(save-excursion
	  (let* ((begin (car affiliated))
		 (post-affiliated (point))
		 (hidden (progn (forward-line) (org-invisible-p2)))
		 (contents-begin (point))
		 (pos-before-blank (progn (goto-char contents-end)
					  (forward-line)
					  (point)))
		 (end (progn (skip-chars-forward " \r\t\n" limit)
			     (if (eobp) (point) (line-beginning-position)))))
	    (list 'verse-block
		  (nconc
		   (list :begin begin
			 :end end
			 :contents-begin contents-begin
			 :contents-end contents-end
			 :hiddenp hidden
			 :post-blank (count-lines pos-before-blank end)
			 :post-affiliated post-affiliated)
		   (cdr affiliated)))))))))

(defun org-element-verse-block-interpreter (verse-block contents)
  "Interpret VERSE-BLOCK element as Org syntax.
CONTENTS is verse block contents."
  (format "#+BEGIN_VERSE\n%s#+END_VERSE" contents))



;;; Objects
;;
;; Unlike to elements, interstices can be found between objects.
;; That's why, along with the parser, successor functions are provided
;; for each object.  Some objects share the same successor (e.g.,
;; `code' and `verbatim' objects).
;;
;; A successor must accept a single argument bounding the search.  It
;; will return either a cons cell whose CAR is the object's type, as
;; a symbol, and CDR the position of its next occurrence, or nil.
;;
;; Successors follow the naming convention:
;; org-element-NAME-successor, where NAME is the name of the
;; successor, as defined in `org-element-all-successors'.
;;
;; Some object types (e.g., `italic') are recursive.  Restrictions on
;; object types they can contain will be specified in
;; `org-element-object-restrictions'.
;;
;; Adding a new type of object is simple.  Implement a successor,
;; a parser, and an interpreter for it, all following the naming
;; convention.  Register type in `org-element-all-objects' and
;; successor in `org-element-all-successors'.  Maybe tweak
;; restrictions about it, and that's it.


;;;; Bold

(defun org-element-bold-parser ()
  "Parse bold object at point.

Return a list whose CAR is `bold' and CDR is a plist with
`:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.

Assume point is at the first star marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
	  (contents-begin (match-beginning 4))
	  (contents-end (match-end 4))
	  (post-blank (progn (goto-char (match-end 2))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'bold
	    (list :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-bold-interpreter (bold contents)
  "Interpret BOLD object as Org syntax.
CONTENTS is the contents of the object."
  (format "*%s*" contents))

(defun org-element-text-markup-successor ()
  "Search for the next text-markup object.

Return value is a cons cell whose CAR is a symbol among `bold',
`italic', `underline', `strike-through', `code' and `verbatim'
and CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (when (re-search-forward org-emph-re nil t)
      (let ((marker (match-string 3)))
	(cons (cond
	       ((equal marker "*") 'bold)
	       ((equal marker "/") 'italic)
	       ((equal marker "_") 'underline)
	       ((equal marker "+") 'strike-through)
	       ((equal marker "~") 'code)
	       ((equal marker "=") 'verbatim)
	       (t (error "Unknown marker at %d" (match-beginning 3))))
	      (match-beginning 2))))))


;;;; Code

(defun org-element-code-parser ()
  "Parse code object at point.

Return a list whose CAR is `code' and CDR is a plist with
`:value', `:begin', `:end' and `:post-blank' keywords.

Assume point is at the first tilde marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
	  (value (org-match-string-no-properties 4))
	  (post-blank (progn (goto-char (match-end 2))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'code
	    (list :value value
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-code-interpreter (code contents)
  "Interpret CODE object as Org syntax.
CONTENTS is nil."
  (format "~%s~" (org-element-property :value code)))


;;;; Entity

(defun org-element-entity-parser ()
  "Parse entity at point.

Return a list whose CAR is `entity' and CDR a plist with
`:begin', `:end', `:latex', `:latex-math-p', `:html', `:latin1',
`:utf-8', `:ascii', `:use-brackets-p' and `:post-blank' as
keywords.

Assume point is at the beginning of the entity."
  (save-excursion
    (looking-at "\\\\\\(there4\\|sup[123]\\|frac[13][24]\\|[a-zA-Z]+\\)\\($\\|{}\\|[^[:alpha:]]\\)")
    (let* ((value (org-entity-get (match-string 1)))
	   (begin (match-beginning 0))
	   (bracketsp (string= (match-string 2) "{}"))
	   (post-blank (progn (goto-char (match-end 1))
			      (when bracketsp (forward-char 2))
			      (skip-chars-forward " \t")))
	   (end (point)))
      (list 'entity
	    (list :name (car value)
		  :latex (nth 1 value)
		  :latex-math-p (nth 2 value)
		  :html (nth 3 value)
		  :ascii (nth 4 value)
		  :latin1 (nth 5 value)
		  :utf-8 (nth 6 value)
		  :begin begin
		  :end end
		  :use-brackets-p bracketsp
		  :post-blank post-blank)))))

(defun org-element-entity-interpreter (entity contents)
  "Interpret ENTITY object as Org syntax.
CONTENTS is nil."
  (concat "\\"
	  (org-element-property :name entity)
	  (when (org-element-property :use-brackets-p entity) "{}")))

(defun org-element-latex-or-entity-successor ()
  "Search for the next latex-fragment or entity object.

Return value is a cons cell whose CAR is `entity' or
`latex-fragment' and CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (let ((matchers (cdr org-latex-regexps))
	  ;; ENTITY-RE matches both LaTeX commands and Org entities.
	  (entity-re
	   "\\\\\\(there4\\|sup[123]\\|frac[13][24]\\|[a-zA-Z]+\\)\\($\\|{}\\|[^[:alpha:]]\\)"))
      (when (re-search-forward
	     (concat (mapconcat #'cadr matchers "\\|") "\\|" entity-re) nil t)
	(goto-char (match-beginning 0))
	(if (looking-at entity-re)
	    ;; Determine if it's a real entity or a LaTeX command.
	    (cons (if (org-entity-get (match-string 1)) 'entity 'latex-fragment)
		  (match-beginning 0))
	  ;; No entity nor command: point is at a LaTeX fragment.
	  ;; Determine its type to get the correct beginning position.
	  (cons 'latex-fragment
		(catch 'return
		  (dolist (e matchers)
		    (when (looking-at (nth 1 e))
		      (throw 'return (match-beginning (nth 2 e)))))
		  (point))))))))


;;;; Export Snippet

(defun org-element-export-snippet-parser ()
  "Parse export snippet at point.

Return a list whose CAR is `export-snippet' and CDR a plist with
`:begin', `:end', `:back-end', `:value' and `:post-blank' as
keywords.

Assume point is at the beginning of the snippet."
  (save-excursion
    (re-search-forward "@@\\([-A-Za-z0-9]+\\):" nil t)
    (let* ((begin (match-beginning 0))
	   (back-end (org-match-string-no-properties 1))
	   (value (buffer-substring-no-properties
		   (point)
		   (progn (re-search-forward "@@" nil t) (match-beginning 0))))
	   (post-blank (skip-chars-forward " \t"))
	   (end (point)))
      (list 'export-snippet
	    (list :back-end back-end
		  :value value
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-export-snippet-interpreter (export-snippet contents)
  "Interpret EXPORT-SNIPPET object as Org syntax.
CONTENTS is nil."
  (format "@@%s:%s@@"
	  (org-element-property :back-end export-snippet)
	  (org-element-property :value export-snippet)))

(defun org-element-export-snippet-successor ()
  "Search for the next export-snippet object.

Return value is a cons cell whose CAR is `export-snippet' and CDR
its beginning position."
  (save-excursion
    (let (beg)
      (when (and (re-search-forward "@@[-A-Za-z0-9]+:" nil t)
		 (setq beg (match-beginning 0))
		 (search-forward "@@" nil t))
	(cons 'export-snippet beg)))))


;;;; Footnote Reference

(defun org-element-footnote-reference-parser ()
  "Parse footnote reference at point.

Return a list whose CAR is `footnote-reference' and CDR a plist
with `:label', `:type', `:inline-definition', `:begin', `:end'
and `:post-blank' as keywords."
  (save-excursion
    (looking-at org-footnote-re)
    (let* ((begin (point))
	   (label (or (org-match-string-no-properties 2)
		      (org-match-string-no-properties 3)
		      (and (match-string 1)
			   (concat "fn:" (org-match-string-no-properties 1)))))
	   (type (if (or (not label) (match-string 1)) 'inline 'standard))
	   (inner-begin (match-end 0))
	   (inner-end
	    (let ((count 1))
	      (forward-char)
	      (while (and (> count 0) (re-search-forward "[][]" nil t))
		(if (equal (match-string 0) "[") (incf count) (decf count)))
	      (1- (point))))
	   (post-blank (progn (goto-char (1+ inner-end))
			      (skip-chars-forward " \t")))
	   (end (point))
	   (footnote-reference
	    (list 'footnote-reference
		  (list :label label
			:type type
			:begin begin
			:end end
			:post-blank post-blank))))
      (org-element-put-property
       footnote-reference :inline-definition
       (and (eq type 'inline)
	    (org-element-parse-secondary-string
	     (buffer-substring inner-begin inner-end)
	     (org-element-restriction 'footnote-reference)
	     footnote-reference))))))

(defun org-element-footnote-reference-interpreter (footnote-reference contents)
  "Interpret FOOTNOTE-REFERENCE object as Org syntax.
CONTENTS is nil."
  (let ((label (or (org-element-property :label footnote-reference) "fn:"))
	(def
	 (let ((inline-def
		(org-element-property :inline-definition footnote-reference)))
	   (if (not inline-def) ""
	     (concat ":" (org-element-interpret-data inline-def))))))
    (format "[%s]" (concat label def))))

(defun org-element-footnote-reference-successor ()
  "Search for the next footnote-reference object.

Return value is a cons cell whose CAR is `footnote-reference' and
CDR is beginning position."
  (save-excursion
    (catch 'exit
      (while (re-search-forward org-footnote-re nil t)
	(save-excursion
	  (let ((beg (match-beginning 0))
		(count 1))
	    (backward-char)
	    (while (re-search-forward "[][]" nil t)
	      (if (equal (match-string 0) "[") (incf count) (decf count))
	      (when (zerop count)
		(throw 'exit (cons 'footnote-reference beg))))))))))


;;;; Inline Babel Call

(defun org-element-inline-babel-call-parser ()
  "Parse inline babel call at point.

Return a list whose CAR is `inline-babel-call' and CDR a plist
with `:begin', `:end', `:info' and `:post-blank' as keywords.

Assume point is at the beginning of the babel call."
  (save-excursion
    (unless (bolp) (backward-char))
    (looking-at org-babel-inline-lob-one-liner-regexp)
    (let ((info (save-match-data (org-babel-lob-get-info)))
	  (begin (match-end 1))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'inline-babel-call
	    (list :begin begin
		  :end end
		  :info info
		  :post-blank post-blank)))))

(defun org-element-inline-babel-call-interpreter (inline-babel-call contents)
  "Interpret INLINE-BABEL-CALL object as Org syntax.
CONTENTS is nil."
  (let* ((babel-info (org-element-property :info inline-babel-call))
	 (main-source (car babel-info))
	 (post-options (nth 1 babel-info)))
    (concat "call_"
	    (if (string-match "\\[\\(\\[.*?\\]\\)\\]" main-source)
		;; Remove redundant square brackets.
		(replace-match
		 (match-string 1 main-source) nil nil main-source)
	      main-source)
	    (and post-options (format "[%s]" post-options)))))

(defun org-element-inline-babel-call-successor ()
  "Search for the next inline-babel-call object.

Return value is a cons cell whose CAR is `inline-babel-call' and
CDR is beginning position."
  (save-excursion
    (when (re-search-forward org-babel-inline-lob-one-liner-regexp nil t)
      (cons 'inline-babel-call (match-end 1)))))


;;;; Inline Src Block

(defun org-element-inline-src-block-parser ()
  "Parse inline source block at point.

Return a list whose CAR is `inline-src-block' and CDR a plist
with `:begin', `:end', `:language', `:value', `:parameters' and
`:post-blank' as keywords.

Assume point is at the beginning of the inline src block."
  (save-excursion
    (unless (bolp) (backward-char))
    (looking-at org-babel-inline-src-block-regexp)
    (let ((begin (match-beginning 1))
	  (language (org-match-string-no-properties 2))
	  (parameters (org-match-string-no-properties 4))
	  (value (org-match-string-no-properties 5))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'inline-src-block
	    (list :language language
		  :value value
		  :parameters parameters
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-inline-src-block-interpreter (inline-src-block contents)
  "Interpret INLINE-SRC-BLOCK object as Org syntax.
CONTENTS is nil."
  (let ((language (org-element-property :language inline-src-block))
	(arguments (org-element-property :parameters inline-src-block))
	(body (org-element-property :value inline-src-block)))
    (format "src_%s%s{%s}"
	    language
	    (if arguments (format "[%s]" arguments) "")
	    body)))

(defun org-element-inline-src-block-successor ()
  "Search for the next inline-babel-call element.

Return value is a cons cell whose CAR is `inline-babel-call' and
CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (when (re-search-forward org-babel-inline-src-block-regexp nil t)
      (cons 'inline-src-block (match-beginning 1)))))

;;;; Italic

(defun org-element-italic-parser ()
  "Parse italic object at point.

Return a list whose CAR is `italic' and CDR is a plist with
`:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.

Assume point is at the first slash marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
	  (contents-begin (match-beginning 4))
	  (contents-end (match-end 4))
	  (post-blank (progn (goto-char (match-end 2))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'italic
	    (list :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-italic-interpreter (italic contents)
  "Interpret ITALIC object as Org syntax.
CONTENTS is the contents of the object."
  (format "/%s/" contents))


;;;; Latex Fragment

(defun org-element-latex-fragment-parser ()
  "Parse LaTeX fragment at point.

Return a list whose CAR is `latex-fragment' and CDR a plist with
`:value', `:begin', `:end', and `:post-blank' as keywords.

Assume point is at the beginning of the LaTeX fragment."
  (save-excursion
    (let* ((begin (point))
	   (substring-match
	    (catch 'exit
	      (dolist (e (cdr org-latex-regexps))
		(let ((latex-regexp (nth 1 e)))
		  (when (or (looking-at latex-regexp)
			    (and (not (bobp))
				 (save-excursion
				   (backward-char)
				   (looking-at latex-regexp))))
		    (throw 'exit (nth 2 e)))))
	      ;; None found: it's a macro.
	      (looking-at "\\\\[a-zA-Z]+\\*?\\(\\(\\[[^][\n{}]*\\]\\)\\|\\({[^{}\n]*}\\)\\)*")
	      0))
	   (value (org-match-string-no-properties substring-match))
	   (post-blank (progn (goto-char (match-end substring-match))
			      (skip-chars-forward " \t")))
	   (end (point)))
      (list 'latex-fragment
	    (list :value value
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-latex-fragment-interpreter (latex-fragment contents)
  "Interpret LATEX-FRAGMENT object as Org syntax.
CONTENTS is nil."
  (org-element-property :value latex-fragment))

;;;; Line Break

(defun org-element-line-break-parser ()
  "Parse line break at point.

Return a list whose CAR is `line-break', and CDR a plist with
`:begin', `:end' and `:post-blank' keywords.

Assume point is at the beginning of the line break."
  (list 'line-break
	(list :begin (point)
	      :end (progn (forward-line) (point))
	      :post-blank 0)))

(defun org-element-line-break-interpreter (line-break contents)
  "Interpret LINE-BREAK object as Org syntax.
CONTENTS is nil."
  "\\\\\n")

(defun org-element-line-break-successor ()
  "Search for the next line-break object.

Return value is a cons cell whose CAR is `line-break' and CDR is
beginning position."
  (save-excursion
    (let ((beg (and (re-search-forward "[^\\\\]\\(\\\\\\\\\\)[ \t]*$" nil t)
		    (goto-char (match-beginning 1)))))
      ;; A line break can only happen on a non-empty line.
      (when (and beg (re-search-backward "\\S-" (point-at-bol) t))
	(cons 'line-break beg)))))


;;;; Link

(defun org-element-link-parser ()
  "Parse link at point.

Return a list whose CAR is `link' and CDR a plist with `:type',
`:path', `:raw-link', `:application', `:search-option', `:begin',
`:end', `:contents-begin', `:contents-end' and `:post-blank' as
keywords.

Assume point is at the beginning of the link."
  (save-excursion
    (let ((begin (point))
	  end contents-begin contents-end link-end post-blank path type
	  raw-link link search-option application)
      (cond
       ;; Type 1: Text targeted from a radio target.
       ((and org-target-link-regexp (looking-at org-target-link-regexp))
	(setq type "radio"
	      link-end (match-end 0)
	      path (org-match-string-no-properties 0)
	      contents-begin (match-beginning 0)
	      contents-end (match-end 0)))
       ;; Type 2: Standard link, i.e. [[http://orgmode.org][homepage]]
       ((looking-at org-bracket-link-regexp)
	(setq contents-begin (match-beginning 3)
	      contents-end (match-end 3)
	      link-end (match-end 0)
	      ;; RAW-LINK is the original link.  Expand any
	      ;; abbreviation in it.
	      raw-link (org-translate-link
			(org-link-expand-abbrev
			 (org-match-string-no-properties 1))))
	;; Determine TYPE of link and set PATH accordingly.
	(cond
	 ;; File type.
	 ((or (file-name-absolute-p raw-link)
	      (string-match "^\\.\\.?/" raw-link))
	  (setq type "file" path raw-link))
	 ;; Explicit type (http, irc, bbdb...).  See `org-link-types'.
	 ((string-match org-link-re-with-space3 raw-link)
	  (setq type (match-string 1 raw-link) path (match-string 2 raw-link)))
	 ;; Id type: PATH is the id.
	 ((string-match "^id:\\([-a-f0-9]+\\)" raw-link)
	  (setq type "id" path (match-string 1 raw-link)))
	 ;; Code-ref type: PATH is the name of the reference.
	 ((string-match "^(\\(.*\\))$" raw-link)
	  (setq type "coderef" path (match-string 1 raw-link)))
	 ;; Custom-id type: PATH is the name of the custom id.
	 ((= (aref raw-link 0) ?#)
	  (setq type "custom-id" path (substring raw-link 1)))
	 ;; Fuzzy type: Internal link either matches a target, an
	 ;; headline name or nothing.  PATH is the target or
	 ;; headline's name.
	 (t (setq type "fuzzy" path raw-link))))
       ;; Type 3: Plain link, e.g., http://orgmode.org
       ((looking-at org-plain-link-re)
	(setq raw-link (org-match-string-no-properties 0)
	      type (org-match-string-no-properties 1)
	      link-end (match-end 0)
	      path (org-match-string-no-properties 2)))
       ;; Type 4: Angular link, e.g., <http://orgmode.org>
       ((looking-at org-angle-link-re)
	(setq raw-link (buffer-substring-no-properties
			(match-beginning 1) (match-end 2))
	      type (org-match-string-no-properties 1)
	      link-end (match-end 0)
	      path (org-match-string-no-properties 2))))
      ;; In any case, deduce end point after trailing white space from
      ;; LINK-END variable.
      (setq post-blank (progn (goto-char link-end) (skip-chars-forward " \t"))
	    end (point))
      ;; Special "file" type link processing.
      (when (member type org-element-link-type-is-file)
	;; Extract opening application and search option.
	(cond ((string-match "^file\\+\\(.*\\)$" type)
	       (setq application (match-string 1 type)))
	      ((not (string-match "^file" type))
	       (setq application type)))
	(when (string-match "::\\(.*\\)\\'" path)
	  (setq search-option (match-string 1 path)
		path (replace-match "" nil nil path)))
	;; Normalize URI.
	(when (and (not (org-string-match-p "\\`//" path))
		   (file-name-absolute-p path))
	  (setq path (concat "//" (expand-file-name path))))
	;; Make sure TYPE always reports "file".
	(setq type "file"))
      (list 'link
	    (list :type type
		  :path path
		  :raw-link (or raw-link path)
		  :application application
		  :search-option search-option
		  :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-link-interpreter (link contents)
  "Interpret LINK object as Org syntax.
CONTENTS is the contents of the object, or nil."
  (let ((type (org-element-property :type link))
	(raw-link (org-element-property :raw-link link)))
    (if (string= type "radio") raw-link
      (format "[[%s]%s]"
	      raw-link
	      (if contents (format "[%s]" contents) "")))))

(defun org-element-link-successor ()
  "Search for the next link object.

Return value is a cons cell whose CAR is `link' and CDR is
beginning position."
  (save-excursion
    (let ((link-regexp
	   (if (not org-target-link-regexp) org-any-link-re
	     (concat org-any-link-re "\\|" org-target-link-regexp))))
      (when (re-search-forward link-regexp nil t)
	(cons 'link (match-beginning 0))))))

(defun org-element-plain-link-successor ()
  "Search for the next plain link object.

Return value is a cons cell whose CAR is `link' and CDR is
beginning position."
  (and (save-excursion (re-search-forward org-plain-link-re nil t))
       (cons 'link (match-beginning 0))))


;;;; Macro

(defun org-element-macro-parser ()
  "Parse macro at point.

Return a list whose CAR is `macro' and CDR a plist with `:key',
`:args', `:begin', `:end', `:value' and `:post-blank' as
keywords.

Assume point is at the macro."
  (save-excursion
    (looking-at "{{{\\([a-zA-Z][-a-zA-Z0-9_]*\\)\\(([ \t\n]*\\([^\000]*?\\))\\)?}}}")
    (let ((begin (point))
	  (key (downcase (org-match-string-no-properties 1)))
	  (value (org-match-string-no-properties 0))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point))
	  (args (let ((args (org-match-string-no-properties 3)))
		  (when args
		    ;; Do not use `org-split-string' since empty
		    ;; strings are meaningful here.
		    (split-string
		     (replace-regexp-in-string
		      "\\(\\\\*\\)\\(,\\)"
		      (lambda (str)
			(let ((len (length (match-string 1 str))))
			  (concat (make-string (/ len 2) ?\\)
				  (if (zerop (mod len 2)) "\000" ","))))
		      args nil t)
		     "\000")))))
      (list 'macro
	    (list :key key
		  :value value
		  :args args
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-macro-interpreter (macro contents)
  "Interpret MACRO object as Org syntax.
CONTENTS is nil."
  (org-element-property :value macro))

(defun org-element-macro-successor ()
  "Search for the next macro object.

Return value is cons cell whose CAR is `macro' and CDR is
beginning position."
  (save-excursion
    (when (re-search-forward
	   "{{{\\([a-zA-Z][-a-zA-Z0-9_]*\\)\\(([ \t\n]*\\([^\000]*?\\))\\)?}}}"
	   nil t)
      (cons 'macro (match-beginning 0)))))


;;;; Radio-target

(defun org-element-radio-target-parser ()
  "Parse radio target at point.

Return a list whose CAR is `radio-target' and CDR a plist with
`:begin', `:end', `:contents-begin', `:contents-end', `:value'
and `:post-blank' as keywords.

Assume point is at the radio target."
  (save-excursion
    (looking-at org-radio-target-regexp)
    (let ((begin (point))
	  (contents-begin (match-beginning 1))
	  (contents-end (match-end 1))
	  (value (org-match-string-no-properties 1))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'radio-target
	    (list :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank
		  :value value)))))

(defun org-element-radio-target-interpreter (target contents)
  "Interpret TARGET object as Org syntax.
CONTENTS is the contents of the object."
  (concat "<<<" contents ">>>"))

(defun org-element-radio-target-successor ()
  "Search for the next radio-target object.

Return value is a cons cell whose CAR is `radio-target' and CDR
is beginning position."
  (save-excursion
    (when (re-search-forward org-radio-target-regexp nil t)
      (cons 'radio-target (match-beginning 0)))))


;;;; Statistics Cookie

(defun org-element-statistics-cookie-parser ()
  "Parse statistics cookie at point.

Return a list whose CAR is `statistics-cookie', and CDR a plist
with `:begin', `:end', `:value' and `:post-blank' keywords.

Assume point is at the beginning of the statistics-cookie."
  (save-excursion
    (looking-at "\\[[0-9]*\\(%\\|/[0-9]*\\)\\]")
    (let* ((begin (point))
	   (value (buffer-substring-no-properties
		   (match-beginning 0) (match-end 0)))
	   (post-blank (progn (goto-char (match-end 0))
			      (skip-chars-forward " \t")))
	   (end (point)))
      (list 'statistics-cookie
	    (list :begin begin
		  :end end
		  :value value
		  :post-blank post-blank)))))

(defun org-element-statistics-cookie-interpreter (statistics-cookie contents)
  "Interpret STATISTICS-COOKIE object as Org syntax.
CONTENTS is nil."
  (org-element-property :value statistics-cookie))

(defun org-element-statistics-cookie-successor ()
  "Search for the next statistics cookie object.

Return value is a cons cell whose CAR is `statistics-cookie' and
CDR is beginning position."
  (save-excursion
    (when (re-search-forward "\\[[0-9]*\\(%\\|/[0-9]*\\)\\]" nil t)
      (cons 'statistics-cookie (match-beginning 0)))))


;;;; Strike-Through

(defun org-element-strike-through-parser ()
  "Parse strike-through object at point.

Return a list whose CAR is `strike-through' and CDR is a plist
with `:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.

Assume point is at the first plus sign marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
	  (contents-begin (match-beginning 4))
	  (contents-end (match-end 4))
	  (post-blank (progn (goto-char (match-end 2))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'strike-through
	    (list :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-strike-through-interpreter (strike-through contents)
  "Interpret STRIKE-THROUGH object as Org syntax.
CONTENTS is the contents of the object."
  (format "+%s+" contents))


;;;; Subscript

(defun org-element-subscript-parser ()
  "Parse subscript at point.

Return a list whose CAR is `subscript' and CDR a plist with
`:begin', `:end', `:contents-begin', `:contents-end',
`:use-brackets-p' and `:post-blank' as keywords.

Assume point is at the underscore."
  (save-excursion
    (unless (bolp) (backward-char))
    (let ((bracketsp (if (looking-at org-match-substring-with-braces-regexp)
			 t
		       (not (looking-at org-match-substring-regexp))))
	  (begin (match-beginning 2))
	  (contents-begin (or (match-beginning 5)
			      (match-beginning 3)))
	  (contents-end (or (match-end 5) (match-end 3)))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'subscript
	    (list :begin begin
		  :end end
		  :use-brackets-p bracketsp
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-subscript-interpreter (subscript contents)
  "Interpret SUBSCRIPT object as Org syntax.
CONTENTS is the contents of the object."
  (format
   (if (org-element-property :use-brackets-p subscript) "_{%s}" "_%s")
   contents))

(defun org-element-sub/superscript-successor ()
  "Search for the next sub/superscript object.

Return value is a cons cell whose CAR is either `subscript' or
`superscript' and CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (when (re-search-forward org-match-substring-regexp nil t)
      (cons (if (string= (match-string 2) "_") 'subscript 'superscript)
	    (match-beginning 2)))))


;;;; Superscript

(defun org-element-superscript-parser ()
  "Parse superscript at point.

Return a list whose CAR is `superscript' and CDR a plist with
`:begin', `:end', `:contents-begin', `:contents-end',
`:use-brackets-p' and `:post-blank' as keywords.

Assume point is at the caret."
  (save-excursion
    (unless (bolp) (backward-char))
    (let ((bracketsp (if (looking-at org-match-substring-with-braces-regexp) t
		       (not (looking-at org-match-substring-regexp))))
	  (begin (match-beginning 2))
	  (contents-begin (or (match-beginning 5)
			      (match-beginning 3)))
	  (contents-end (or (match-end 5) (match-end 3)))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'superscript
	    (list :begin begin
		  :end end
		  :use-brackets-p bracketsp
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-superscript-interpreter (superscript contents)
  "Interpret SUPERSCRIPT object as Org syntax.
CONTENTS is the contents of the object."
  (format
   (if (org-element-property :use-brackets-p superscript) "^{%s}" "^%s")
   contents))


;;;; Table Cell

(defun org-element-table-cell-parser ()
  "Parse table cell at point.

Return a list whose CAR is `table-cell' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `:contents-end'
and `:post-blank' keywords."
  (looking-at "[ \t]*\\(.*?\\)[ \t]*\\(?:|\\|$\\)")
  (let* ((begin (match-beginning 0))
	 (end (match-end 0))
	 (contents-begin (match-beginning 1))
	 (contents-end (match-end 1)))
    (list 'table-cell
	  (list :begin begin
		:end end
		:contents-begin contents-begin
		:contents-end contents-end
		:post-blank 0))))

(defun org-element-table-cell-interpreter (table-cell contents)
  "Interpret TABLE-CELL element as Org syntax.
CONTENTS is the contents of the cell, or nil."
  (concat  " " contents " |"))

(defun org-element-table-cell-successor ()
  "Search for the next table-cell object.

Return value is a cons cell whose CAR is `table-cell' and CDR is
beginning position."
  (when (looking-at "[ \t]*.*?[ \t]*\\(|\\|$\\)") (cons 'table-cell (point))))


;;;; Target

(defun org-element-target-parser ()
  "Parse target at point.

Return a list whose CAR is `target' and CDR a plist with
`:begin', `:end', `:value' and `:post-blank' as keywords.

Assume point is at the target."
  (save-excursion
    (looking-at org-target-regexp)
    (let ((begin (point))
	  (value (org-match-string-no-properties 1))
	  (post-blank (progn (goto-char (match-end 0))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'target
	    (list :begin begin
		  :end end
		  :value value
		  :post-blank post-blank)))))

(defun org-element-target-interpreter (target contents)
  "Interpret TARGET object as Org syntax.
CONTENTS is nil."
  (format "<<%s>>" (org-element-property :value target)))

(defun org-element-target-successor ()
  "Search for the next target object.

Return value is a cons cell whose CAR is `target' and CDR is
beginning position."
  (save-excursion
    (when (re-search-forward org-target-regexp nil t)
      (cons 'target (match-beginning 0)))))


;;;; Timestamp

(defun org-element-timestamp-parser ()
  "Parse time stamp at point.

Return a list whose CAR is `timestamp', and CDR a plist with
`:type', `:raw-value', `:year-start', `:month-start',
`:day-start', `:hour-start', `:minute-start', `:year-end',
`:month-end', `:day-end', `:hour-end', `:minute-end',
`:repeater-type', `:repeater-value', `:repeater-unit',
`:warning-type', `:warning-value', `:warning-unit', `:begin',
`:end' and `:post-blank' keywords.

Assume point is at the beginning of the timestamp."
  (save-excursion
    (let* ((begin (point))
	   (activep (eq (char-after) ?<))
	   (raw-value
	    (progn
	      (looking-at "\\([<[]\\(%%\\)?.*?\\)[]>]\\(?:--\\([<[].*?[]>]\\)\\)?")
	      (match-string-no-properties 0)))
	   (date-start (match-string-no-properties 1))
	   (date-end (match-string 3))
	   (diaryp (match-beginning 2))
	   (post-blank (progn (goto-char (match-end 0))
			      (skip-chars-forward " \t")))
	   (end (point))
	   (time-range
	    (and (not diaryp)
		 (string-match
		  "[012]?[0-9]:[0-5][0-9]\\(-\\([012]?[0-9]\\):\\([0-5][0-9]\\)\\)"
		  date-start)
		 (cons (string-to-number (match-string 2 date-start))
		       (string-to-number (match-string 3 date-start)))))
	   (type (cond (diaryp 'diary)
		       ((and activep (or date-end time-range)) 'active-range)
		       (activep 'active)
		       ((or date-end time-range) 'inactive-range)
		       (t 'inactive)))
	   (repeater-props
	    (and (not diaryp)
		 (string-match "\\([.+]?\\+\\)\\([0-9]+\\)\\([hdwmy]\\)"
			       raw-value)
		 (list
		  :repeater-type
		  (let ((type (match-string 1 raw-value)))
		    (cond ((equal "++" type) 'catch-up)
			  ((equal ".+" type) 'restart)
			  (t 'cumulate)))
		  :repeater-value (string-to-number (match-string 2 raw-value))
		  :repeater-unit
		  (case (string-to-char (match-string 3 raw-value))
		    (?h 'hour) (?d 'day) (?w 'week) (?m 'month) (t 'year)))))
	   (warning-props
	    (and (not diaryp)
		 (string-match "\\(-\\)?-\\([0-9]+\\)\\([hdwmy]\\)" raw-value)
		 (list
		  :warning-type (if (match-string 1 raw-value) 'first 'all)
		  :warning-value (string-to-number (match-string 2 raw-value))
		  :warning-unit
		  (case (string-to-char (match-string 3 raw-value))
		    (?h 'hour) (?d 'day) (?w 'week) (?m 'month) (t 'year)))))
	   year-start month-start day-start hour-start minute-start year-end
	   month-end day-end hour-end minute-end)
      ;; Parse date-start.
      (unless diaryp
	(let ((date (org-parse-time-string date-start t)))
	  (setq year-start (nth 5 date)
		month-start (nth 4 date)
		day-start (nth 3 date)
		hour-start (nth 2 date)
		minute-start (nth 1 date))))
      ;; Compute date-end.  It can be provided directly in time-stamp,
      ;; or extracted from time range.  Otherwise, it defaults to the
      ;; same values as date-start.
      (unless diaryp
	(let ((date (and date-end (org-parse-time-string date-end t))))
	  (setq year-end (or (nth 5 date) year-start)
		month-end (or (nth 4 date) month-start)
		day-end (or (nth 3 date) day-start)
		hour-end (or (nth 2 date) (car time-range) hour-start)
		minute-end (or (nth 1 date) (cdr time-range) minute-start))))
      (list 'timestamp
	    (nconc (list :type type
			 :raw-value raw-value
			 :year-start year-start
			 :month-start month-start
			 :day-start day-start
			 :hour-start hour-start
			 :minute-start minute-start
			 :year-end year-end
			 :month-end month-end
			 :day-end day-end
			 :hour-end hour-end
			 :minute-end minute-end
			 :begin begin
			 :end end
			 :post-blank post-blank)
		   repeater-props
		   warning-props)))))

(defun org-element-timestamp-interpreter (timestamp contents)
  "Interpret TIMESTAMP object as Org syntax.
CONTENTS is nil."
  ;; Use `:raw-value' if specified.
  (or (org-element-property :raw-value timestamp)
      ;; Otherwise, build timestamp string.
      (let* ((repeat-string
	      (concat
	       (case (org-element-property :repeater-type timestamp)
		 (cumulate "+") (catch-up "++") (restart ".+"))
	       (let ((val (org-element-property :repeater-value timestamp)))
		 (and val (number-to-string val)))
	       (case (org-element-property :repeater-unit timestamp)
		 (hour "h") (day "d") (week "w") (month "m") (year "y"))))
	     (warning-string
	      (concat
	       (case (org-element-property :warning-type timestamp)
		 (first "--")
		 (all "-"))
	       (let ((val (org-element-property :warning-value timestamp)))
		 (and val (number-to-string val)))
	       (case (org-element-property :warning-unit timestamp)
		 (hour "h") (day "d") (week "w") (month "m") (year "y"))))
	     (build-ts-string
	      ;; Build an Org timestamp string from TIME.  ACTIVEP is
	      ;; non-nil when time stamp is active.  If WITH-TIME-P is
	      ;; non-nil, add a time part.  HOUR-END and MINUTE-END
	      ;; specify a time range in the timestamp.  REPEAT-STRING
	      ;; is the repeater string, if any.
	      (lambda (time activep &optional with-time-p hour-end minute-end)
		(let ((ts (format-time-string
			   (funcall (if with-time-p 'cdr 'car)
				    org-time-stamp-formats)
			   time)))
		  (when (and hour-end minute-end)
		    (string-match "[012]?[0-9]:[0-5][0-9]" ts)
		    (setq ts
			  (replace-match
			   (format "\\&-%02d:%02d" hour-end minute-end)
			   nil nil ts)))
		  (unless activep (setq ts (format "[%s]" (substring ts 1 -1))))
		  (dolist (s (list repeat-string warning-string))
		    (when (org-string-nw-p s)
		      (setq ts (concat (substring ts 0 -1)
				       " "
				       s
				       (substring ts -1)))))
		  ;; Return value.
		  ts)))
	     (type (org-element-property :type timestamp)))
	(case type
	  ((active inactive)
	   (let* ((minute-start (org-element-property :minute-start timestamp))
		  (minute-end (org-element-property :minute-end timestamp))
		  (hour-start (org-element-property :hour-start timestamp))
		  (hour-end (org-element-property :hour-end timestamp))
		  (time-range-p (and hour-start hour-end minute-start minute-end
				     (or (/= hour-start hour-end)
					 (/= minute-start minute-end)))))
	     (funcall
	      build-ts-string
	      (encode-time 0
			   (or minute-start 0)
			   (or hour-start 0)
			   (org-element-property :day-start timestamp)
			   (org-element-property :month-start timestamp)
			   (org-element-property :year-start timestamp))
	      (eq type 'active)
	      (and hour-start minute-start)
	      (and time-range-p hour-end)
	      (and time-range-p minute-end))))
	  ((active-range inactive-range)
	   (let ((minute-start (org-element-property :minute-start timestamp))
		 (minute-end (org-element-property :minute-end timestamp))
		 (hour-start (org-element-property :hour-start timestamp))
		 (hour-end (org-element-property :hour-end timestamp)))
	     (concat
	      (funcall
	       build-ts-string (encode-time
				0
				(or minute-start 0)
				(or hour-start 0)
				(org-element-property :day-start timestamp)
				(org-element-property :month-start timestamp)
				(org-element-property :year-start timestamp))
	       (eq type 'active-range)
	       (and hour-start minute-start))
	      "--"
	      (funcall build-ts-string
		       (encode-time 0
				    (or minute-end 0)
				    (or hour-end 0)
				    (org-element-property :day-end timestamp)
				    (org-element-property :month-end timestamp)
				    (org-element-property :year-end timestamp))
		       (eq type 'active-range)
		       (and hour-end minute-end)))))))))

(defun org-element-timestamp-successor ()
  "Search for the next timestamp object.

Return value is a cons cell whose CAR is `timestamp' and CDR is
beginning position."
  (save-excursion
    (when (re-search-forward
	   (concat org-ts-regexp-both
		   "\\|"
		   "\\(?:<[0-9]+-[0-9]+-[0-9]+[^>\n]+?\\+[0-9]+[dwmy]>\\)"
		   "\\|"
		   "\\(?:<%%\\(?:([^>\n]+)\\)>\\)")
	   nil t)
      (cons 'timestamp (match-beginning 0)))))


;;;; Underline

(defun org-element-underline-parser ()
  "Parse underline object at point.

Return a list whose CAR is `underline' and CDR is a plist with
`:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.

Assume point is at the first underscore marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
	  (contents-begin (match-beginning 4))
	  (contents-end (match-end 4))
	  (post-blank (progn (goto-char (match-end 2))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'underline
	    (list :begin begin
		  :end end
		  :contents-begin contents-begin
		  :contents-end contents-end
		  :post-blank post-blank)))))

(defun org-element-underline-interpreter (underline contents)
  "Interpret UNDERLINE object as Org syntax.
CONTENTS is the contents of the object."
  (format "_%s_" contents))


;;;; Verbatim

(defun org-element-verbatim-parser ()
  "Parse verbatim object at point.

Return a list whose CAR is `verbatim' and CDR is a plist with
`:value', `:begin', `:end' and `:post-blank' keywords.

Assume point is at the first equal sign marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
	  (value (org-match-string-no-properties 4))
	  (post-blank (progn (goto-char (match-end 2))
			     (skip-chars-forward " \t")))
	  (end (point)))
      (list 'verbatim
	    (list :value value
		  :begin begin
		  :end end
		  :post-blank post-blank)))))

(defun org-element-verbatim-interpreter (verbatim contents)
  "Interpret VERBATIM object as Org syntax.
CONTENTS is nil."
  (format "=%s=" (org-element-property :value verbatim)))



;;; Parsing Element Starting At Point
;;
;; `org-element--current-element' is the core function of this section.
;; It returns the Lisp representation of the element starting at
;; point.
;;
;; `org-element--current-element' makes use of special modes.  They
;; are activated for fixed element chaining (e.g., `plain-list' >
;; `item') or fixed conditional element chaining (e.g., `headline' >
;; `section').  Special modes are: `first-section', `item',
;; `node-property', `quote-section', `section' and `table-row'.

(defun org-element--current-element
  (limit &optional granularity special structure)
  "Parse the element starting at point.

Return value is a list like (TYPE PROPS) where TYPE is the type
of the element and PROPS a plist of properties associated to the
element.

Possible types are defined in `org-element-all-elements'.

LIMIT bounds the search.

Optional argument GRANULARITY determines the depth of the
recursion.  Allowed values are `headline', `greater-element',
`element', `object' or nil.  When it is broader than `object' (or
nil), secondary values will not be parsed, since they only
contain objects.

Optional argument SPECIAL, when non-nil, can be either
`first-section', `item', `node-property', `quote-section',
`section', and `table-row'.

If STRUCTURE isn't provided but SPECIAL is set to `item', it will
be computed.

This function assumes point is always at the beginning of the
element it has to parse."
  (save-excursion
    (let ((case-fold-search t)
	  ;; Determine if parsing depth allows for secondary strings
	  ;; parsing.  It only applies to elements referenced in
	  ;; `org-element-secondary-value-alist'.
	  (raw-secondary-p (and granularity (not (eq granularity 'object)))))
      (cond
       ;; Item.
       ((eq special 'item)
	(org-element-item-parser limit structure raw-secondary-p))
       ;; Table Row.
       ((eq special 'table-row) (org-element-table-row-parser limit))
       ;; Node Property.
       ((eq special 'node-property) (org-element-node-property-parser limit))
       ;; Headline.
       ((org-with-limited-levels (org-at-heading-p))
        (org-element-headline-parser limit raw-secondary-p))
       ;; Sections (must be checked after headline).
       ((eq special 'section) (org-element-section-parser limit))
       ((eq special 'quote-section) (org-element-quote-section-parser limit))
       ((eq special 'first-section)
	(org-element-section-parser
	 (or (save-excursion (org-with-limited-levels (outline-next-heading)))
	     limit)))
       ;; When not at bol, point is at the beginning of an item or
       ;; a footnote definition: next item is always a paragraph.
       ((not (bolp)) (org-element-paragraph-parser limit (list (point))))
       ;; Planning and Clock.
       ((looking-at org-planning-or-clock-line-re)
	(if (equal (match-string 1) org-clock-string)
	    (org-element-clock-parser limit)
	  (org-element-planning-parser limit)))
       ;; Inlinetask.
       ((org-at-heading-p)
	(org-element-inlinetask-parser limit raw-secondary-p))
       ;; From there, elements can have affiliated keywords.
       (t (let ((affiliated (org-element--collect-affiliated-keywords limit)))
	    (cond
	     ;; Jumping over affiliated keywords put point off-limits.
	     ;; Parse them as regular keywords.
	     ((and (cdr affiliated) (>= (point) limit))
	      (goto-char (car affiliated))
	      (org-element-keyword-parser limit nil))
	     ;; LaTeX Environment.
	     ((looking-at
	       "[ \t]*\\\\begin{[A-Za-z0-9*]+}\\(\\[.*?\\]\\|{.*?}\\)*[ \t]*$")
	      (org-element-latex-environment-parser limit affiliated))
	     ;; Drawer and Property Drawer.
	     ((looking-at org-drawer-regexp)
	      (if (equal (match-string 1) "PROPERTIES")
		  (org-element-property-drawer-parser limit affiliated)
		(org-element-drawer-parser limit affiliated)))
	     ;; Fixed Width
	     ((looking-at "[ \t]*:\\( \\|$\\)")
	      (org-element-fixed-width-parser limit affiliated))
	     ;; Inline Comments, Blocks, Babel Calls, Dynamic Blocks and
	     ;; Keywords.
	     ((looking-at "[ \t]*#")
	      (goto-char (match-end 0))
	      (cond ((looking-at "\\(?: \\|$\\)")
		     (beginning-of-line)
		     (org-element-comment-parser limit affiliated))
		    ((looking-at "\\+BEGIN_\\(\\S-+\\)")
		     (beginning-of-line)
		     (let ((parser (assoc (upcase (match-string 1))
					  org-element-block-name-alist)))
		       (if parser (funcall (cdr parser) limit affiliated)
			 (org-element-special-block-parser limit affiliated))))
		    ((looking-at "\\+CALL:")
		     (beginning-of-line)
		     (org-element-babel-call-parser limit affiliated))
		    ((looking-at "\\+BEGIN:? ")
		     (beginning-of-line)
		     (org-element-dynamic-block-parser limit affiliated))
		    ((looking-at "\\+\\S-+:")
		     (beginning-of-line)
		     (org-element-keyword-parser limit affiliated))
		    (t
		     (beginning-of-line)
		     (org-element-paragraph-parser limit affiliated))))
	     ;; Footnote Definition.
	     ((looking-at org-footnote-definition-re)
	      (org-element-footnote-definition-parser limit affiliated))
	     ;; Horizontal Rule.
	     ((looking-at "[ \t]*-\\{5,\\}[ \t]*$")
	      (org-element-horizontal-rule-parser limit affiliated))
	     ;; Diary Sexp.
	     ((looking-at "%%(")
	      (org-element-diary-sexp-parser limit affiliated))
	     ;; Table.
	     ((org-at-table-p t) (org-element-table-parser limit affiliated))
	     ;; List.
	     ((looking-at (org-item-re))
	      (org-element-plain-list-parser
	       limit affiliated
	       (or structure (org-element--list-struct limit))))
	     ;; Default element: Paragraph.
	     (t (org-element-paragraph-parser limit affiliated)))))))))


;; Most elements can have affiliated keywords.  When looking for an
;; element beginning, we want to move before them, as they belong to
;; that element, and, in the meantime, collect information they give
;; into appropriate properties.  Hence the following function.

(defun org-element--collect-affiliated-keywords (limit)
  "Collect affiliated keywords from point down to LIMIT.

Return a list whose CAR is the position at the first of them and
CDR a plist of keywords and values and move point to the
beginning of the first line after them.

As a special case, if element doesn't start at the beginning of
the line (e.g., a paragraph starting an item), CAR is current
position of point and CDR is nil."
  (if (not (bolp)) (list (point))
    (let ((case-fold-search t)
	  (origin (point))
	  ;; RESTRICT is the list of objects allowed in parsed
	  ;; keywords value.
	  (restrict (org-element-restriction 'keyword))
	  output)
      (while (and (< (point) limit) (looking-at org-element--affiliated-re))
	(let* ((raw-kwd (upcase (match-string 1)))
	       ;; Apply translation to RAW-KWD.  From there, KWD is
	       ;; the official keyword.
	       (kwd (or (cdr (assoc raw-kwd
				    org-element-keyword-translation-alist))
			raw-kwd))
	       ;; Find main value for any keyword.
	       (value
		(save-match-data
		  (org-trim
		   (buffer-substring-no-properties
		    (match-end 0) (point-at-eol)))))
	       ;; PARSEDP is non-nil when keyword should have its
	       ;; value parsed.
	       (parsedp (member kwd org-element-parsed-keywords))
	       ;; If KWD is a dual keyword, find its secondary
	       ;; value.  Maybe parse it.
	       (dualp (member kwd org-element-dual-keywords))
	       (dual-value
		(and dualp
		     (let ((sec (org-match-string-no-properties 2)))
		       (if (or (not sec) (not parsedp)) sec
			 (org-element-parse-secondary-string sec restrict)))))
	       ;; Attribute a property name to KWD.
	       (kwd-sym (and kwd (intern (concat ":" (downcase kwd))))))
	  ;; Now set final shape for VALUE.
	  (when parsedp
	    (setq value (org-element-parse-secondary-string value restrict)))
	  (when dualp
	    (setq value (and (or value dual-value) (cons value dual-value))))
	  (when (or (member kwd org-element-multiple-keywords)
		    ;; Attributes can always appear on multiple lines.
		    (string-match "^ATTR_" kwd))
	    (setq value (cons value (plist-get output kwd-sym))))
	  ;; Eventually store the new value in OUTPUT.
	  (setq output (plist-put output kwd-sym value))
	  ;; Move to next keyword.
	  (forward-line)))
      ;; If affiliated keywords are orphaned: move back to first one.
      ;; They will be parsed as a paragraph.
      (when (looking-at "[ \t]*$") (goto-char origin) (setq output nil))
      ;; Return value.
      (cons origin output))))



;;; The Org Parser
;;
;; The two major functions here are `org-element-parse-buffer', which
;; parses Org syntax inside the current buffer, taking into account
;; region, narrowing, or even visibility if specified, and
;; `org-element-parse-secondary-string', which parses objects within
;; a given string.
;;
;; The (almost) almighty `org-element-map' allows to apply a function
;; on elements or objects matching some type, and accumulate the
;; resulting values.  In an export situation, it also skips unneeded
;; parts of the parse tree.

(defun org-element-parse-buffer (&optional granularity visible-only)
  "Recursively parse the buffer and return structure.
If narrowing is in effect, only parse the visible part of the
buffer.

Optional argument GRANULARITY determines the depth of the
recursion.  It can be set to the following symbols:

`headline'          Only parse headlines.
`greater-element'   Don't recurse into greater elements excepted
		    headlines and sections.  Thus, elements
		    parsed are the top-level ones.
`element'           Parse everything but objects and plain text.
`object'            Parse the complete buffer (default).

When VISIBLE-ONLY is non-nil, don't parse contents of hidden
elements.

An element or an objects is represented as a list with the
pattern (TYPE PROPERTIES CONTENTS), where :

  TYPE is a symbol describing the element or object.  See
  `org-element-all-elements' and `org-element-all-objects' for an
  exhaustive list of such symbols.  One can retrieve it with
  `org-element-type' function.

  PROPERTIES is the list of attributes attached to the element or
  object, as a plist.  Although most of them are specific to the
  element or object type, all types share `:begin', `:end',
  `:post-blank' and `:parent' properties, which respectively
  refer to buffer position where the element or object starts,
  ends, the number of white spaces or blank lines after it, and
  the element or object containing it.  Properties values can be
  obtained by using `org-element-property' function.

  CONTENTS is a list of elements, objects or raw strings
  contained in the current element or object, when applicable.
  One can access them with `org-element-contents' function.

The Org buffer has `org-data' as type and nil as properties.
`org-element-map' function can be used to find specific elements
or objects within the parse tree.

This function assumes that current major mode is `org-mode'."
  (save-excursion
    (goto-char (point-min))
    (org-skip-whitespace)
    (org-element--parse-elements
     (point-at-bol) (point-max)
     ;; Start in `first-section' mode so text before the first
     ;; headline belongs to a section.
     'first-section nil granularity visible-only (list 'org-data nil))))

(defun org-element-parse-secondary-string (string restriction &optional parent)
  "Recursively parse objects in STRING and return structure.

RESTRICTION is a symbol limiting the object types that will be
looked after.

Optional argument PARENT, when non-nil, is the element or object
containing the secondary string.  It is used to set correctly
`:parent' property within the string."
  ;; Copy buffer-local variables listed in
  ;; `org-element-object-variables' into temporary buffer.  This is
  ;; required since object parsing is dependent on these variables.
  (let ((pairs (delq nil (mapcar (lambda (var)
				   (when (boundp var)
				     (cons var (symbol-value var))))
				 org-element-object-variables))))
    (with-temp-buffer
      (mapc (lambda (pair) (org-set-local (car pair) (cdr pair))) pairs)
      (insert string)
      (let ((secondary (org-element--parse-objects
			(point-min) (point-max) nil restriction)))
	(when parent
	  (mapc (lambda (obj) (org-element-put-property obj :parent parent))
		secondary))
	secondary))))

(defun org-element-map
  (data types fun &optional info first-match no-recursion with-affiliated)
  "Map a function on selected elements or objects.

DATA is a parse tree, an element, an object, a string, or a list
of such constructs.  TYPES is a symbol or list of symbols of
elements or objects types (see `org-element-all-elements' and
`org-element-all-objects' for a complete list of types).  FUN is
the function called on the matching element or object.  It has to
accept one argument: the element or object itself.

When optional argument INFO is non-nil, it should be a plist
holding export options.  In that case, parts of the parse tree
not exportable according to that property list will be skipped.

When optional argument FIRST-MATCH is non-nil, stop at the first
match for which FUN doesn't return nil, and return that value.

Optional argument NO-RECURSION is a symbol or a list of symbols
representing elements or objects types.  `org-element-map' won't
enter any recursive element or object whose type belongs to that
list.  Though, FUN can still be applied on them.

When optional argument WITH-AFFILIATED is non-nil, FUN will also
apply to matching objects within parsed affiliated keywords (see
`org-element-parsed-keywords').

Nil values returned from FUN do not appear in the results.


Examples:
---------

Assuming TREE is a variable containing an Org buffer parse tree,
the following example will return a flat list of all `src-block'
and `example-block' elements in it:

  \(org-element-map tree '(example-block src-block) 'identity)

The following snippet will find the first headline with a level
of 1 and a \"phone\" tag, and will return its beginning position:

  \(org-element-map tree 'headline
   \(lambda (hl)
     \(and (= (org-element-property :level hl) 1)
          \(member \"phone\" (org-element-property :tags hl))
          \(org-element-property :begin hl)))
   nil t)

The next example will return a flat list of all `plain-list' type
elements in TREE that are not a sub-list themselves:

  \(org-element-map tree 'plain-list 'identity nil nil 'plain-list)

Eventually, this example will return a flat list of all `bold'
type objects containing a `latex-snippet' type object, even
looking into captions:

  \(org-element-map tree 'bold
   \(lambda (b)
     \(and (org-element-map b 'latex-snippet 'identity nil t) b))
   nil nil nil t)"
  ;; Ensure TYPES and NO-RECURSION are a list, even of one element.
  (unless (listp types) (setq types (list types)))
  (unless (listp no-recursion) (setq no-recursion (list no-recursion)))
  ;; Recursion depth is determined by --CATEGORY.
  (let* ((--category
	  (catch 'found
	    (let ((category 'greater-elements))
	      (mapc (lambda (type)
		      (cond ((or (memq type org-element-all-objects)
				 (eq type 'plain-text))
			     ;; If one object is found, the function
			     ;; has to recurse into every object.
			     (throw 'found 'objects))
			    ((not (memq type org-element-greater-elements))
			     ;; If one regular element is found, the
			     ;; function has to recurse, at least,
			     ;; into every element it encounters.
			     (and (not (eq category 'elements))
				  (setq category 'elements)))))
		    types)
	      category)))
	 ;; Compute properties for affiliated keywords if necessary.
	 (--affiliated-alist
	  (and with-affiliated
	       (mapcar (lambda (kwd)
			 (cons kwd (intern (concat ":" (downcase kwd)))))
		       org-element-affiliated-keywords)))
	 --acc
	 --walk-tree
	 (--walk-tree
	  (function
	   (lambda (--data)
	     ;; Recursively walk DATA.  INFO, if non-nil, is a plist
	     ;; holding contextual information.
	     (let ((--type (org-element-type --data)))
	       (cond
		((not --data))
		;; Ignored element in an export context.
		((and info (memq --data (plist-get info :ignore-list))))
		;; List of elements or objects.
		((not --type) (mapc --walk-tree --data))
		;; Unconditionally enter parse trees.
		((eq --type 'org-data)
		 (mapc --walk-tree (org-element-contents --data)))
		(t
		 ;; Check if TYPE is matching among TYPES.  If so,
		 ;; apply FUN to --DATA and accumulate return value
		 ;; into --ACC (or exit if FIRST-MATCH is non-nil).
		 (when (memq --type types)
		   (let ((result (funcall fun --data)))
		     (cond ((not result))
			   (first-match (throw '--map-first-match result))
			   (t (push result --acc)))))
		 ;; If --DATA has a secondary string that can contain
		 ;; objects with their type among TYPES, look into it.
		 (when (and (eq --category 'objects) (not (stringp --data)))
		   (let ((sec-prop
			  (assq --type org-element-secondary-value-alist)))
		     (when sec-prop
		       (funcall --walk-tree
				(org-element-property (cdr sec-prop) --data)))))
		 ;; If --DATA has any affiliated keywords and
		 ;; WITH-AFFILIATED is non-nil, look for objects in
		 ;; them.
		 (when (and with-affiliated
			    (eq --category 'objects)
			    (memq --type org-element-all-elements))
		   (mapc (lambda (kwd-pair)
			   (let ((kwd (car kwd-pair))
				 (value (org-element-property
					 (cdr kwd-pair) --data)))
			     ;; Pay attention to the type of value.
			     ;; Preserve order for multiple keywords.
			     (cond
			      ((not value))
			      ((and (member kwd org-element-multiple-keywords)
				    (member kwd org-element-dual-keywords))
			       (mapc (lambda (line)
				       (funcall --walk-tree (cdr line))
				       (funcall --walk-tree (car line)))
				     (reverse value)))
			      ((member kwd org-element-multiple-keywords)
			       (mapc (lambda (line) (funcall --walk-tree line))
				     (reverse value)))
			      ((member kwd org-element-dual-keywords)
			       (funcall --walk-tree (cdr value))
			       (funcall --walk-tree (car value)))
			      (t (funcall --walk-tree value)))))
			 --affiliated-alist))
		 ;; Determine if a recursion into --DATA is possible.
		 (cond
		  ;; --TYPE is explicitly removed from recursion.
		  ((memq --type no-recursion))
		  ;; --DATA has no contents.
		  ((not (org-element-contents --data)))
		  ;; Looking for greater elements but --DATA is simply
		  ;; an element or an object.
		  ((and (eq --category 'greater-elements)
			(not (memq --type org-element-greater-elements))))
		  ;; Looking for elements but --DATA is an object.
		  ((and (eq --category 'elements)
			(memq --type org-element-all-objects)))
		  ;; In any other case, map contents.
		  (t (mapc --walk-tree (org-element-contents --data)))))))))))
    (catch '--map-first-match
      (funcall --walk-tree data)
      ;; Return value in a proper order.
      (nreverse --acc))))
(put 'org-element-map 'lisp-indent-function 2)

;; The following functions are internal parts of the parser.
;;
;; The first one, `org-element--parse-elements' acts at the element's
;; level.
;;
;; The second one, `org-element--parse-objects' applies on all objects
;; of a paragraph or a secondary string.  It uses
;; `org-element--get-next-object-candidates' to optimize the search of
;; the next object in the buffer.
;;
;; More precisely, that function looks for every allowed object type
;; first.  Then, it discards failed searches, keeps further matches,
;; and searches again types matched behind point, for subsequent
;; calls.  Thus, searching for a given type fails only once, and every
;; object is searched only once at top level (but sometimes more for
;; nested types).

(defun org-element--parse-elements
  (beg end special structure granularity visible-only acc)
  "Parse elements between BEG and END positions.

SPECIAL prioritize some elements over the others.  It can be set
to `first-section', `quote-section', `section' `item' or
`table-row'.

When value is `item', STRUCTURE will be used as the current list
structure.

GRANULARITY determines the depth of the recursion.  See
`org-element-parse-buffer' for more information.

When VISIBLE-ONLY is non-nil, don't parse contents of hidden
elements.

Elements are accumulated into ACC."
  (save-excursion
    (goto-char beg)
    ;; Visible only: skip invisible parts at the beginning of the
    ;; element.
    (when (and visible-only (org-invisible-p2))
      (goto-char (min (1+ (org-find-visible)) end)))
    ;; When parsing only headlines, skip any text before first one.
    (when (and (eq granularity 'headline) (not (org-at-heading-p)))
      (org-with-limited-levels (outline-next-heading)))
    ;; Main loop start.
    (while (< (point) end)
      ;; Find current element's type and parse it accordingly to
      ;; its category.
      (let* ((element (org-element--current-element
		       end granularity special structure))
	     (type (org-element-type element))
	     (cbeg (org-element-property :contents-begin element)))
	(goto-char (org-element-property :end element))
	;; Visible only: skip invisible parts between siblings.
	(when (and visible-only (org-invisible-p2))
	  (goto-char (min (1+ (org-find-visible)) end)))
	;; Fill ELEMENT contents by side-effect.
	(cond
	 ;; If element has no contents, don't modify it.
	 ((not cbeg))
	 ;; Greater element: parse it between `contents-begin' and
	 ;; `contents-end'.  Make sure GRANULARITY allows the
	 ;; recursion, or ELEMENT is a headline, in which case going
	 ;; inside is mandatory, in order to get sub-level headings.
	 ((and (memq type org-element-greater-elements)
	       (or (memq granularity '(element object nil))
		   (and (eq granularity 'greater-element)
			(eq type 'section))
		   (eq type 'headline)))
	  (org-element--parse-elements
	   cbeg (org-element-property :contents-end element)
	   ;; Possibly switch to a special mode.
	   (case type
	     (headline
	      (if (org-element-property :quotedp element) 'quote-section
		'section))
	     (plain-list 'item)
	     (property-drawer 'node-property)
	     (table 'table-row))
	   (and (memq type '(item plain-list))
		(org-element-property :structure element))
	   granularity visible-only element))
	 ;; ELEMENT has contents.  Parse objects inside, if
	 ;; GRANULARITY allows it.
	 ((memq granularity '(object nil))
	  (org-element--parse-objects
	   cbeg (org-element-property :contents-end element) element
	   (org-element-restriction type))))
	(org-element-adopt-elements acc element)))
    ;; Return result.
    acc))

(defun org-element--parse-objects (beg end acc restriction)
  "Parse objects between BEG and END and return recursive structure.

Objects are accumulated in ACC.

RESTRICTION is a list of object successors which are allowed in
the current object."
  (let ((candidates 'initial))
    (save-excursion
      (save-restriction
	(narrow-to-region beg end)
	(goto-char (point-min))
	(while (and (not (eobp))
		    (setq candidates
			  (org-element--get-next-object-candidates
			   restriction candidates)))
	  (let ((next-object
		 (let ((pos (apply 'min (mapcar 'cdr candidates))))
		   (save-excursion
		     (goto-char pos)
		     (funcall (intern (format "org-element-%s-parser"
					      (car (rassq pos candidates)))))))))
	    ;; 1. Text before any object.  Untabify it.
	    (let ((obj-beg (org-element-property :begin next-object)))
	      (unless (= (point) obj-beg)
		(setq acc
		      (org-element-adopt-elements
		       acc
		       (replace-regexp-in-string
			"\t" (make-string tab-width ? )
			(buffer-substring-no-properties (point) obj-beg))))))
	    ;; 2. Object...
	    (let ((obj-end (org-element-property :end next-object))
		  (cont-beg (org-element-property :contents-begin next-object)))
	      ;; Fill contents of NEXT-OBJECT by side-effect, if it has
	      ;; a recursive type.
	      (when (and cont-beg
			 (memq (car next-object) org-element-recursive-objects))
		(org-element--parse-objects
		 cont-beg (org-element-property :contents-end next-object)
		 next-object (org-element-restriction next-object)))
	      (setq acc (org-element-adopt-elements acc next-object))
	      (goto-char obj-end))))
	;; 3. Text after last object.  Untabify it.
	(unless (eobp)
	  (setq acc
		(org-element-adopt-elements
		 acc
		 (replace-regexp-in-string
		  "\t" (make-string tab-width ? )
		  (buffer-substring-no-properties (point) end)))))
	;; Result.
	acc))))

(defun org-element--get-next-object-candidates (restriction objects)
  "Return an alist of candidates for the next object.

RESTRICTION is a list of object types, as symbols.  Only
candidates with such types are looked after.

OBJECTS is the previous candidates alist.  If it is set to
`initial', no search has been done before, and all symbols in
RESTRICTION should be looked after.

Return value is an alist whose CAR is the object type and CDR its
beginning position."
  (delq
   nil
   (if (eq objects 'initial)
       ;; When searching for the first time, look for every successor
       ;; allowed in RESTRICTION.
       (mapcar
	(lambda (res)
	  (funcall (intern (format "org-element-%s-successor" res))))
	restriction)
     ;; Focus on objects returned during last search.  Keep those
     ;; still after point.  Search again objects before it.
     (mapcar
      (lambda (obj)
	(if (>= (cdr obj) (point)) obj
	  (let* ((type (car obj))
		 (succ (or (cdr (assq type org-element-object-successor-alist))
			   type)))
	    (and succ
		 (funcall (intern (format "org-element-%s-successor" succ)))))))
      objects))))



;;; Towards A Bijective Process
;;
;; The parse tree obtained with `org-element-parse-buffer' is really
;; a snapshot of the corresponding Org buffer.  Therefore, it can be
;; interpreted and expanded into a string with canonical Org syntax.
;; Hence `org-element-interpret-data'.
;;
;; The function relies internally on
;; `org-element--interpret-affiliated-keywords'.

;;;###autoload
(defun org-element-interpret-data (data &optional parent)
  "Interpret DATA as Org syntax.

DATA is a parse tree, an element, an object or a secondary string
to interpret.

Optional argument PARENT is used for recursive calls.  It contains
the element or object containing data, or nil.

Return Org syntax as a string."
  (let* ((type (org-element-type data))
	 (results
	  (cond
	   ;; Secondary string.
	   ((not type)
	    (mapconcat
	     (lambda (obj) (org-element-interpret-data obj parent))
	     data ""))
	   ;; Full Org document.
	   ((eq type 'org-data)
	    (mapconcat
	     (lambda (obj) (org-element-interpret-data obj parent))
	     (org-element-contents data) ""))
	   ;; Plain text: return it.
	   ((stringp data) data)
	   ;; Element/Object without contents.
	   ((not (org-element-contents data))
	    (funcall (intern (format "org-element-%s-interpreter" type))
		     data nil))
	   ;; Element/Object with contents.
	   (t
	    (let* ((greaterp (memq type org-element-greater-elements))
		   (objectp (and (not greaterp)
				 (memq type org-element-recursive-objects)))
		   (contents
		    (mapconcat
		     (lambda (obj) (org-element-interpret-data obj data))
		     (org-element-contents
		      (if (or greaterp objectp) data
			;; Elements directly containing objects must
			;; have their indentation normalized first.
			(org-element-normalize-contents
			 data
			 ;; When normalizing first paragraph of an
			 ;; item or a footnote-definition, ignore
			 ;; first line's indentation.
			 (and (eq type 'paragraph)
			      (equal data (car (org-element-contents parent)))
			      (memq (org-element-type parent)
				    '(footnote-definition item))))))
		     "")))
	      (funcall (intern (format "org-element-%s-interpreter" type))
		       data
		       (if greaterp (org-element-normalize-contents contents)
			 contents)))))))
    (if (memq type '(org-data plain-text nil)) results
      ;; Build white spaces.  If no `:post-blank' property is
      ;; specified, assume its value is 0.
      (let ((post-blank (or (org-element-property :post-blank data) 0)))
	(if (memq type org-element-all-objects)
	    (concat results (make-string post-blank 32))
	  (concat
	   (org-element--interpret-affiliated-keywords data)
	   (org-element-normalize-string results)
	   (make-string post-blank 10)))))))

(defun org-element--interpret-affiliated-keywords (element)
  "Return ELEMENT's affiliated keywords as Org syntax.
If there is no affiliated keyword, return the empty string."
  (let ((keyword-to-org
	 (function
	  (lambda (key value)
	    (let (dual)
	      (when (member key org-element-dual-keywords)
		(setq dual (cdr value) value (car value)))
	      (concat "#+" key
		      (and dual
			   (format "[%s]" (org-element-interpret-data dual)))
		      ": "
		      (if (member key org-element-parsed-keywords)
			  (org-element-interpret-data value)
			value)
		      "\n"))))))
    (mapconcat
     (lambda (prop)
       (let ((value (org-element-property prop element))
	     (keyword (upcase (substring (symbol-name prop) 1))))
	 (when value
	   (if (or (member keyword org-element-multiple-keywords)
		   ;; All attribute keywords can have multiple lines.
		   (string-match "^ATTR_" keyword))
	       (mapconcat (lambda (line) (funcall keyword-to-org keyword line))
			  (reverse value)
			  "")
	     (funcall keyword-to-org keyword value)))))
     ;; List all ELEMENT's properties matching an attribute line or an
     ;; affiliated keyword, but ignore translated keywords since they
     ;; cannot belong to the property list.
     (loop for prop in (nth 1 element) by 'cddr
	   when (let ((keyword (upcase (substring (symbol-name prop) 1))))
		  (or (string-match "^ATTR_" keyword)
		      (and
		       (member keyword org-element-affiliated-keywords)
		       (not (assoc keyword
				   org-element-keyword-translation-alist)))))
	   collect prop)
     "")))

;; Because interpretation of the parse tree must return the same
;; number of blank lines between elements and the same number of white
;; space after objects, some special care must be given to white
;; spaces.
;;
;; The first function, `org-element-normalize-string', ensures any
;; string different from the empty string will end with a single
;; newline character.
;;
;; The second function, `org-element-normalize-contents', removes
;; global indentation from the contents of the current element.

(defun org-element-normalize-string (s)
  "Ensure string S ends with a single newline character.

If S isn't a string return it unchanged.  If S is the empty
string, return it.  Otherwise, return a new string with a single
newline character at its end."
  (cond
   ((not (stringp s)) s)
   ((string= "" s) "")
   (t (and (string-match "\\(\n[ \t]*\\)*\\'" s)
	   (replace-match "\n" nil nil s)))))

(defun org-element-normalize-contents (element &optional ignore-first)
  "Normalize plain text in ELEMENT's contents.

ELEMENT must only contain plain text and objects.

If optional argument IGNORE-FIRST is non-nil, ignore first line's
indentation to compute maximal common indentation.

Return the normalized element that is element with global
indentation removed from its contents.  The function assumes that
indentation is not done with TAB characters."
  (let* ((min-ind most-positive-fixnum)
	 find-min-ind			; For byte-compiler.
	 (find-min-ind
	  (function
	   ;; Return minimal common indentation within BLOB.  This is
	   ;; done by walking recursively BLOB and updating MIN-IND
	   ;; along the way.  FIRST-FLAG is non-nil when the first
	   ;; string hasn't been seen yet.  It is required as this
	   ;; string is the only one whose indentation doesn't happen
	   ;; after a newline character.
	   (lambda (blob first-flag)
	     (dolist (object (org-element-contents blob))
	       (when (and first-flag (stringp object))
		 (setq first-flag nil)
		 (string-match "\\`\\( *\\)" object)
		 (let ((len (length (match-string 1 object))))
		   ;; An indentation of zero means no string will be
		   ;; modified.  Quit the process.
		   (if (zerop len) (throw 'zero (setq min-ind 0))
		     (setq min-ind (min len min-ind)))))
	       (cond
		((stringp object)
		 (dolist (line (delq "" (cdr (org-split-string object " *\n"))))
		   (setq min-ind (min (org-get-indentation line) min-ind))))
		((memq (org-element-type object) org-element-recursive-objects)
		 (funcall find-min-ind object first-flag))))))))
    ;; Find minimal indentation in ELEMENT.
    (catch 'zero (funcall find-min-ind element (not ignore-first)))
    (if (or (zerop min-ind) (= min-ind most-positive-fixnum)) element
      ;; Build ELEMENT back, replacing each string with the same
      ;; string minus common indentation.
      (let* (build			; For byte compiler.
	     (build
	      (function
	       (lambda (blob first-flag)
		 ;; Return BLOB with all its strings indentation
		 ;; shortened from MIN-IND white spaces.  FIRST-FLAG
		 ;; is non-nil when the first string hasn't been seen
		 ;; yet.
		 (setcdr (cdr blob)
			 (mapcar
			  #'(lambda (object)
			      (when (and first-flag (stringp object))
				(setq first-flag nil)
				(setq object
				      (replace-regexp-in-string
				       (format "\\` \\{%d\\}" min-ind)
				       "" object)))
			      (cond
			       ((stringp object)
				(replace-regexp-in-string
				 (format "\n \\{%d\\}" min-ind) "\n" object))
			       ((memq (org-element-type object)
				      org-element-recursive-objects)
				(funcall build object first-flag))
			       (t object)))
			  (org-element-contents blob)))
		 blob))))
	(funcall build element (not ignore-first))))))



;;; The Toolbox
;;
;; The first move is to implement a way to obtain the smallest element
;; containing point.  This is the job of `org-element-at-point'.  It
;; basically jumps back to the beginning of section containing point
;; and moves, element after element, with
;; `org-element--current-element' until the container is found.  Note:
;; When using `org-element-at-point', secondary values are never
;; parsed since the function focuses on elements, not on objects.
;;
;; At a deeper level, `org-element-context' lists all elements and
;; objects containing point.
;;
;; `org-element-nested-p' and `org-element-swap-A-B' may be used
;; internally by navigation and manipulation tools.

;;;###autoload
(defun org-element-at-point (&optional keep-trail)
  "Determine closest element around point.

Return value is a list like (TYPE PROPS) where TYPE is the type
of the element and PROPS a plist of properties associated to the
element.

Possible types are defined in `org-element-all-elements'.
Properties depend on element or object type, but always include
`:begin', `:end', `:parent' and `:post-blank' properties.

As a special case, if point is at the very beginning of a list or
sub-list, returned element will be that list instead of the first
item.  In the same way, if point is at the beginning of the first
row of a table, returned element will be the table instead of the
first row.

If optional argument KEEP-TRAIL is non-nil, the function returns
a list of elements leading to element at point.  The list's CAR
is always the element at point.  The following positions contain
element's siblings, then parents, siblings of parents, until the
first element of current section."
  (org-with-wide-buffer
   ;; If at a headline, parse it.  It is the sole element that
   ;; doesn't require to know about context.  Be sure to disallow
   ;; secondary string parsing, though.
   (if (org-with-limited-levels (org-at-heading-p))
       (progn
	 (beginning-of-line)
	 (if (not keep-trail) (org-element-headline-parser (point-max) t)
	   (list (org-element-headline-parser (point-max) t))))
     ;; Otherwise move at the beginning of the section containing
     ;; point.
     (catch 'exit
       (let ((origin (point))
	     (end (save-excursion
		    (org-with-limited-levels (outline-next-heading)) (point)))
	     element type special-flag trail struct prevs parent)
	 (org-with-limited-levels
	  (if (org-before-first-heading-p)
	      ;; In empty lines at buffer's beginning, return nil.
	      (progn (goto-char (point-min))
		     (org-skip-whitespace)
		     (when (or (eobp) (> (line-beginning-position) origin))
		       (throw 'exit nil)))
	    (org-back-to-heading)
	    (forward-line)
	    (org-skip-whitespace)
	    (when (or (eobp) (> (line-beginning-position) origin))
	      ;; In blank lines just after the headline, point still
	      ;; belongs to the headline.
	      (throw 'exit
		     (progn (skip-chars-backward " \r\t\n")
			    (beginning-of-line)
			    (if (not keep-trail)
				(org-element-headline-parser (point-max) t)
			      (list (org-element-headline-parser
				     (point-max) t))))))))
	 (beginning-of-line)
	 ;; Parse successively each element, skipping those ending
	 ;; before original position.
	 (while t
	   (setq element
		 (org-element--current-element end 'element special-flag struct)
		 type (car element))
	   (org-element-put-property element :parent parent)
	   (when keep-trail (push element trail))
	   (cond
	    ;; 1. Skip any element ending before point.  Also skip
	    ;;    element ending at point when we're sure that another
	    ;;    element has started.
	    ((let ((elem-end (org-element-property :end element)))
	       (when (or (< elem-end origin)
			 (and (= elem-end origin) (/= elem-end end)))
		 (goto-char elem-end))))
	    ;; 2. An element containing point is always the element at
	    ;;    point.
	    ((not (memq type org-element-greater-elements))
	     (throw 'exit (if keep-trail trail element)))
	    ;; 3. At any other greater element type, if point is
	    ;;    within contents, move into it.
	    (t
	     (let ((cbeg (org-element-property :contents-begin element))
		   (cend (org-element-property :contents-end element)))
	       (if (or (not cbeg) (not cend) (> cbeg origin) (< cend origin)
		       ;; Create an anchor for tables and plain lists:
		       ;; when point is at the very beginning of these
		       ;; elements, ignoring affiliated keywords,
		       ;; target them instead of their contents.
		       (and (= cbeg origin) (memq type '(plain-list table)))
		       ;; When point is at contents end, do not move
		       ;; into elements with an explicit ending, but
		       ;; return that element instead.
		       (and (= cend origin)
			    (or (memq type
				      '(center-block
					drawer dynamic-block inlinetask
					property-drawer quote-block
					special-block))
				;; Corner case: if a list ends at the
				;; end of a buffer without a final new
				;; line, return last element in last
				;; item instead.
				(and (memq type '(item plain-list))
				     (progn (goto-char cend)
					    (or (bolp) (not (eobp))))))))
		   (throw 'exit (if keep-trail trail element))
		 (setq parent element)
		 (case type
		   (plain-list
		    (setq special-flag 'item
			  struct (org-element-property :structure element)))
		   (item (setq special-flag nil))
		   (property-drawer
		    (setq special-flag 'node-property struct nil))
		   (table (setq special-flag 'table-row struct nil))
		   (otherwise (setq special-flag nil struct nil)))
		 (setq end cend)
		 (goto-char cbeg)))))))))))

;;;###autoload
(defun org-element-context (&optional element)
  "Return closest element or object around point.

Return value is a list like (TYPE PROPS) where TYPE is the type
of the element or object and PROPS a plist of properties
associated to it.

Possible types are defined in `org-element-all-elements' and
`org-element-all-objects'.  Properties depend on element or
object type, but always include `:begin', `:end', `:parent' and
`:post-blank'.

Optional argument ELEMENT, when non-nil, is the closest element
containing point, as returned by `org-element-at-point'.
Providing it allows for quicker computation."
  (catch 'objects-forbidden
    (org-with-wide-buffer
     (let* ((origin (point))
            (element (or element (org-element-at-point)))
            (type (org-element-type element))
            context)
       ;; Check if point is inside an element containing objects or at
       ;; a secondary string.  In that case, narrow buffer to the
       ;; containing area.  Otherwise, return ELEMENT.
       (cond
	;; At a parsed affiliated keyword, check if we're inside main
	;; or dual value.
	((let ((post (org-element-property :post-affiliated element)))
	   (and post (< origin post)))
	 (beginning-of-line)
	 (let ((case-fold-search t)) (looking-at org-element--affiliated-re))
	 (cond
	  ((not (member-ignore-case (match-string 1)
				    org-element-parsed-keywords))
	   (throw 'objects-forbidden element))
	  ((< (match-end 0) origin)
	   (narrow-to-region (match-end 0) (line-end-position)))
	  ((and (match-beginning 2)
		(>= origin (match-beginning 2))
		(< origin (match-end 2)))
	   (narrow-to-region (match-beginning 2) (match-end 2)))
	  (t (throw 'objects-forbidden element)))
	 ;; Also change type to retrieve correct restrictions.
	 (setq type 'keyword))
	;; At an item, objects can only be located within tag, if any.
	((eq type 'item)
	 (let ((tag (org-element-property :tag element)))
	   (if (not tag) (throw 'objects-forbidden element)
	     (beginning-of-line)
	     (search-forward tag (line-end-position))
	     (goto-char (match-beginning 0))
	     (if (and (>= origin (point)) (< origin (match-end 0)))
		 (narrow-to-region (point) (match-end 0))
	       (throw 'objects-forbidden element)))))
	;; At an headline or inlinetask, objects are located within
	;; their title.
	((memq type '(headline inlinetask))
	 (goto-char (org-element-property :begin element))
	 (skip-chars-forward "*")
	 (if (and (> origin (point)) (< origin (line-end-position)))
	     (narrow-to-region (point) (line-end-position))
	   (throw 'objects-forbidden element)))
	;; At a paragraph, a table-row or a verse block, objects are
	;; located within their contents.
	((memq type '(paragraph table-row verse-block))
	 (let ((cbeg (org-element-property :contents-begin element))
	       (cend (org-element-property :contents-end element)))
	   ;; CBEG is nil for table rules.
	   (if (and cbeg cend (>= origin cbeg) (< origin cend))
	       (narrow-to-region cbeg cend)
	     (throw 'objects-forbidden element))))
	;; At a parsed keyword, objects are located within value.
	((eq type 'keyword)
	 (if (not (member (org-element-property :key element)
			  org-element-document-properties))
	     (throw 'objects-forbidden element)
	   (beginning-of-line)
	   (search-forward ":")
	   (if (and (>= origin (point)) (< origin (line-end-position)))
	       (narrow-to-region (point) (line-end-position))
	     (throw 'objects-forbidden element))))
	;; At a planning line, if point is at a timestamp, return it,
	;; otherwise, return element.
	((eq type 'planning)
	 (dolist (p '(:closed :deadline :scheduled))
	   (let ((timestamp (org-element-property p element)))
	     (when (and timestamp
			(<= (org-element-property :begin timestamp) origin)
			(> (org-element-property :end timestamp) origin))
	       (throw 'objects-forbidden timestamp))))
	 (throw 'objects-forbidden element))
	(t (throw 'objects-forbidden element)))
       (goto-char (point-min))
       (let ((restriction (org-element-restriction type))
             (parent element)
             (candidates 'initial))
         (catch 'exit
           (while (setq candidates
			(org-element--get-next-object-candidates
			 restriction candidates))
             (let ((closest-cand (rassq (apply 'min (mapcar 'cdr candidates))
                                        candidates)))
               ;; If ORIGIN is before next object in element, there's
               ;; no point in looking further.
               (if (> (cdr closest-cand) origin) (throw 'exit parent)
                 (let* ((object
                         (progn (goto-char (cdr closest-cand))
                                (funcall (intern (format "org-element-%s-parser"
                                                         (car closest-cand))))))
                        (cbeg (org-element-property :contents-begin object))
                        (cend (org-element-property :contents-end object))
                        (obj-end (org-element-property :end object)))
                   (cond
                    ;; ORIGIN is after OBJECT, so skip it.
                    ((<= obj-end origin) (goto-char obj-end))
                    ;; ORIGIN is within a non-recursive object or at
                    ;; an object boundaries: Return that object.
                    ((or (not cbeg) (< origin cbeg) (>= origin cend))
                     (throw 'exit
                            (org-element-put-property object :parent parent)))
                    ;; Otherwise, move within current object and
                    ;; restrict search to the end of its contents.
                    (t (goto-char cbeg)
                       (narrow-to-region (point) cend)
                       (org-element-put-property object :parent parent)
                       (setq parent object
                             restriction (org-element-restriction object)
                             candidates 'initial)))))))
           parent))))))

(defun org-element-nested-p (elem-A elem-B)
  "Non-nil when elements ELEM-A and ELEM-B are nested."
  (let ((beg-A (org-element-property :begin elem-A))
	(beg-B (org-element-property :begin elem-B))
	(end-A (org-element-property :end elem-A))
	(end-B (org-element-property :end elem-B)))
    (or (and (>= beg-A beg-B) (<= end-A end-B))
	(and (>= beg-B beg-A) (<= end-B end-A)))))

(defun org-element-swap-A-B (elem-A elem-B)
  "Swap elements ELEM-A and ELEM-B.
Assume ELEM-B is after ELEM-A in the buffer.  Leave point at the
end of ELEM-A."
  (goto-char (org-element-property :begin elem-A))
  ;; There are two special cases when an element doesn't start at bol:
  ;; the first paragraph in an item or in a footnote definition.
  (let ((specialp (not (bolp))))
    ;; Only a paragraph without any affiliated keyword can be moved at
    ;; ELEM-A position in such a situation.  Note that the case of
    ;; a footnote definition is impossible: it cannot contain two
    ;; paragraphs in a row because it cannot contain a blank line.
    (if (and specialp
	     (or (not (eq (org-element-type elem-B) 'paragraph))
		 (/= (org-element-property :begin elem-B)
		     (org-element-property :contents-begin elem-B))))
	(error "Cannot swap elements"))
    ;; In a special situation, ELEM-A will have no indentation.  We'll
    ;; give it ELEM-B's (which will in, in turn, have no indentation).
    (let* ((ind-B (when specialp
		    (goto-char (org-element-property :begin elem-B))
		    (org-get-indentation)))
	   (beg-A (org-element-property :begin elem-A))
	   (end-A (save-excursion
		    (goto-char (org-element-property :end elem-A))
		    (skip-chars-backward " \r\t\n")
		    (point-at-eol)))
	   (beg-B (org-element-property :begin elem-B))
	   (end-B (save-excursion
		    (goto-char (org-element-property :end elem-B))
		    (skip-chars-backward " \r\t\n")
		    (point-at-eol)))
	   ;; Store overlays responsible for visibility status.  We
	   ;; also need to store their boundaries as they will be
	   ;; removed from buffer.
	   (overlays
	    (cons
	     (mapcar (lambda (ov) (list ov (overlay-start ov) (overlay-end ov)))
		     (overlays-in beg-A end-A))
	     (mapcar (lambda (ov) (list ov (overlay-start ov) (overlay-end ov)))
		     (overlays-in beg-B end-B))))
	   ;; Get contents.
	   (body-A (buffer-substring beg-A end-A))
	   (body-B (delete-and-extract-region beg-B end-B)))
      (goto-char beg-B)
      (when specialp
	(setq body-B (replace-regexp-in-string "\\`[ \t]*" "" body-B))
	(org-indent-to-column ind-B))
      (insert body-A)
      ;; Restore ex ELEM-A overlays.
      (let ((offset (- beg-B beg-A)))
	(mapc (lambda (ov)
		(move-overlay
		 (car ov) (+ (nth 1 ov) offset) (+ (nth 2 ov) offset)))
	      (car overlays))
	(goto-char beg-A)
	(delete-region beg-A end-A)
	(insert body-B)
	;; Restore ex ELEM-B overlays.
	(mapc (lambda (ov)
		(move-overlay
		 (car ov) (- (nth 1 ov) offset) (- (nth 2 ov) offset)))
	      (cdr overlays)))
      (goto-char (org-element-property :end elem-B)))))

(provide 'org-element)

;; Local variables:
;; generated-autoload-file: "org-loaddefs.el"
;; End:

;;; org-element.el ends here

**** ox.el
;;; ox.el --- Generic Export Engine for Org Mode

;; Copyright (C) 2012-2014 Free Software Foundation, Inc.

;; Author: Nicolas Goaziou <n.goaziou at gmail dot com>
;; Keywords: outlines, hypermedia, calendar, wp

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This library implements a generic export engine for Org, built on
;; its syntactical parser: Org Elements.
;;
;; Besides that parser, the generic exporter is made of three distinct
;; parts:
;;
;; - The communication channel consists in a property list, which is
;;   created and updated during the process.  Its use is to offer
;;   every piece of information, would it be about initial environment
;;   or contextual data, all in a single place.  The exhaustive list
;;   of properties is given in "The Communication Channel" section of
;;   this file.
;;
;; - The transcoder walks the parse tree, ignores or treat as plain
;;   text elements and objects according to export options, and
;;   eventually calls back-end specific functions to do the real
;;   transcoding, concatenating their return value along the way.
;;
;; - The filter system is activated at the very beginning and the very
;;   end of the export process, and each time an element or an object
;;   has been converted.  It is the entry point to fine-tune standard
;;   output from back-end transcoders.  See "The Filter System"
;;   section for more information.
;;
;; The core function is `org-export-as'.  It returns the transcoded
;; buffer as a string.
;;
;; An export back-end is defined with `org-export-define-backend'.
;; This function can also support specific buffer keywords, OPTION
;; keyword's items and filters.  Refer to function's documentation for
;; more information.
;;
;; If the new back-end shares most properties with another one,
;; `org-export-define-derived-backend' can be used to simplify the
;; process.
;;
;; Any back-end can define its own variables.  Among them, those
;; customizable should belong to the `org-export-BACKEND' group.
;;
;; Tools for common tasks across back-ends are implemented in the
;; following part of the file.
;;
;; Then, a wrapper macro for asynchronous export,
;; `org-export-async-start', along with tools to display results. are
;; given in the penultimate part.
;;
;; Eventually, a dispatcher (`org-export-dispatch') for standard
;; back-ends is provided in the last one.

;;; Code:

(eval-when-compile (require 'cl))
(require 'org-element)
(require 'org-macro)
(require 'ob-exp)

(declare-function org-publish "ox-publish" (project &optional force async))
(declare-function org-publish-all "ox-publish" (&optional force async))
(declare-function
 org-publish-current-file "ox-publish" (&optional force async))
(declare-function org-publish-current-project "ox-publish"
		  (&optional force async))

(defvar org-publish-project-alist)
(defvar org-table-number-fraction)
(defvar org-table-number-regexp)



;;; Internal Variables
;;
;; Among internal variables, the most important is
;; `org-export-options-alist'.  This variable define the global export
;; options, shared between every exporter, and how they are acquired.

(defconst org-export-max-depth 19
  "Maximum nesting depth for headlines, counting from 0.")

(defconst org-export-options-alist
  '((:author "AUTHOR" nil user-full-name t)
    (:creator "CREATOR" nil org-export-creator-string)
    (:date "DATE" nil nil t)
    (:description "DESCRIPTION" nil nil newline)
    (:email "EMAIL" nil user-mail-address t)
    (:exclude-tags "EXCLUDE_TAGS" nil org-export-exclude-tags split)
    (:headline-levels nil "H" org-export-headline-levels)
    (:keywords "KEYWORDS" nil nil space)
    (:language "LANGUAGE" nil org-export-default-language t)
    (:preserve-breaks nil "\\n" org-export-preserve-breaks)
    (:section-numbers nil "num" org-export-with-section-numbers)
    (:select-tags "SELECT_TAGS" nil org-export-select-tags split)
    (:time-stamp-file nil "timestamp" org-export-time-stamp-file)
    (:title "TITLE" nil nil space)
    (:with-archived-trees nil "arch" org-export-with-archived-trees)
    (:with-author nil "author" org-export-with-author)
    (:with-clocks nil "c" org-export-with-clocks)
    (:with-creator nil "creator" org-export-with-creator)
    (:with-date nil "date" org-export-with-date)
    (:with-drawers nil "d" org-export-with-drawers)
    (:with-email nil "email" org-export-with-email)
    (:with-emphasize nil "*" org-export-with-emphasize)
    (:with-entities nil "e" org-export-with-entities)
    (:with-fixed-width nil ":" org-export-with-fixed-width)
    (:with-footnotes nil "f" org-export-with-footnotes)
    (:with-inlinetasks nil "inline" org-export-with-inlinetasks)
    (:with-latex nil "tex" org-export-with-latex)
    (:with-planning nil "p" org-export-with-planning)
    (:with-priority nil "pri" org-export-with-priority)
    (:with-smart-quotes nil "'" org-export-with-smart-quotes)
    (:with-special-strings nil "-" org-export-with-special-strings)
    (:with-statistics-cookies nil "stat" org-export-with-statistics-cookies)
    (:with-sub-superscript nil "^" org-export-with-sub-superscripts)
    (:with-toc nil "toc" org-export-with-toc)
    (:with-tables nil "|" org-export-with-tables)
    (:with-tags nil "tags" org-export-with-tags)
    (:with-tasks nil "tasks" org-export-with-tasks)
    (:with-timestamps nil "<" org-export-with-timestamps)
    (:with-todo-keywords nil "todo" org-export-with-todo-keywords))
  "Alist between export properties and ways to set them.

The CAR of the alist is the property name, and the CDR is a list
like (KEYWORD OPTION DEFAULT BEHAVIOR) where:

KEYWORD is a string representing a buffer keyword, or nil.  Each
  property defined this way can also be set, during subtree
  export, through a headline property named after the keyword
  with the \"EXPORT_\" prefix (i.e. DATE keyword and EXPORT_DATE
  property).
OPTION is a string that could be found in an #+OPTIONS: line.
DEFAULT is the default value for the property.
BEHAVIOR determines how Org should handle multiple keywords for
  the same property.  It is a symbol among:
  nil       Keep old value and discard the new one.
  t         Replace old value with the new one.
  `space'   Concatenate the values, separating them with a space.
  `newline' Concatenate the values, separating them with
	    a newline.
  `split'   Split values at white spaces, and cons them to the
	    previous list.

Values set through KEYWORD and OPTION have precedence over
DEFAULT.

All these properties should be back-end agnostic.  Back-end
specific properties are set through `org-export-define-backend'.
Properties redefined there have precedence over these.")

(defconst org-export-special-keywords '("FILETAGS" "SETUPFILE" "OPTIONS")
  "List of in-buffer keywords that require special treatment.
These keywords are not directly associated to a property.  The
way they are handled must be hard-coded into
`org-export--get-inbuffer-options' function.")

(defconst org-export-filters-alist
  '((:filter-bold . org-export-filter-bold-functions)
    (:filter-babel-call . org-export-filter-babel-call-functions)
    (:filter-center-block . org-export-filter-center-block-functions)
    (:filter-clock . org-export-filter-clock-functions)
    (:filter-code . org-export-filter-code-functions)
    (:filter-comment . org-export-filter-comment-functions)
    (:filter-comment-block . org-export-filter-comment-block-functions)
    (:filter-diary-sexp . org-export-filter-diary-sexp-functions)
    (:filter-drawer . org-export-filter-drawer-functions)
    (:filter-dynamic-block . org-export-filter-dynamic-block-functions)
    (:filter-entity . org-export-filter-entity-functions)
    (:filter-example-block . org-export-filter-example-block-functions)
    (:filter-export-block . org-export-filter-export-block-functions)
    (:filter-export-snippet . org-export-filter-export-snippet-functions)
    (:filter-final-output . org-export-filter-final-output-functions)
    (:filter-fixed-width . org-export-filter-fixed-width-functions)
    (:filter-footnote-definition . org-export-filter-footnote-definition-functions)
    (:filter-footnote-reference . org-export-filter-footnote-reference-functions)
    (:filter-headline . org-export-filter-headline-functions)
    (:filter-horizontal-rule . org-export-filter-horizontal-rule-functions)
    (:filter-inline-babel-call . org-export-filter-inline-babel-call-functions)
    (:filter-inline-src-block . org-export-filter-inline-src-block-functions)
    (:filter-inlinetask . org-export-filter-inlinetask-functions)
    (:filter-italic . org-export-filter-italic-functions)
    (:filter-item . org-export-filter-item-functions)
    (:filter-keyword . org-export-filter-keyword-functions)
    (:filter-latex-environment . org-export-filter-latex-environment-functions)
    (:filter-latex-fragment . org-export-filter-latex-fragment-functions)
    (:filter-line-break . org-export-filter-line-break-functions)
    (:filter-link . org-export-filter-link-functions)
    (:filter-node-property . org-export-filter-node-property-functions)
    (:filter-options . org-export-filter-options-functions)
    (:filter-paragraph . org-export-filter-paragraph-functions)
    (:filter-parse-tree . org-export-filter-parse-tree-functions)
    (:filter-plain-list . org-export-filter-plain-list-functions)
    (:filter-plain-text . org-export-filter-plain-text-functions)
    (:filter-planning . org-export-filter-planning-functions)
    (:filter-property-drawer . org-export-filter-property-drawer-functions)
    (:filter-quote-block . org-export-filter-quote-block-functions)
    (:filter-quote-section . org-export-filter-quote-section-functions)
    (:filter-radio-target . org-export-filter-radio-target-functions)
    (:filter-section . org-export-filter-section-functions)
    (:filter-special-block . org-export-filter-special-block-functions)
    (:filter-src-block . org-export-filter-src-block-functions)
    (:filter-statistics-cookie . org-export-filter-statistics-cookie-functions)
    (:filter-strike-through . org-export-filter-strike-through-functions)
    (:filter-subscript . org-export-filter-subscript-functions)
    (:filter-superscript . org-export-filter-superscript-functions)
    (:filter-table . org-export-filter-table-functions)
    (:filter-table-cell . org-export-filter-table-cell-functions)
    (:filter-table-row . org-export-filter-table-row-functions)
    (:filter-target . org-export-filter-target-functions)
    (:filter-timestamp . org-export-filter-timestamp-functions)
    (:filter-underline . org-export-filter-underline-functions)
    (:filter-verbatim . org-export-filter-verbatim-functions)
    (:filter-verse-block . org-export-filter-verse-block-functions))
  "Alist between filters properties and initial values.

The key of each association is a property name accessible through
the communication channel.  Its value is a configurable global
variable defining initial filters.

This list is meant to install user specified filters.  Back-end
developers may install their own filters using
`org-export-define-backend'.  Filters defined there will always
be prepended to the current list, so they always get applied
first.")

(defconst org-export-default-inline-image-rule
  `(("file" .
     ,(format "\\.%s\\'"
	      (regexp-opt
	       '("png" "jpeg" "jpg" "gif" "tiff" "tif" "xbm"
		 "xpm" "pbm" "pgm" "ppm") t))))
  "Default rule for link matching an inline image.
This rule applies to links with no description.  By default, it
will be considered as an inline image if it targets a local file
whose extension is either \"png\", \"jpeg\", \"jpg\", \"gif\",
\"tiff\", \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\" or \"ppm\".
See `org-export-inline-image-p' for more information about
rules.")

(defvar org-export-async-debug nil
  "Non-nil means asynchronous export process should leave data behind.

This data is found in the appropriate \"*Org Export Process*\"
buffer, and in files prefixed with \"org-export-process\" and
located in `temporary-file-directory'.

When non-nil, it will also set `debug-on-error' to a non-nil
value in the external process.")

(defvar org-export-stack-contents nil
  "Record asynchronously generated export results and processes.
This is an alist: its CAR is the source of the
result (destination file or buffer for a finished process,
original buffer for a running one) and its CDR is a list
containing the back-end used, as a symbol, and either a process
or the time at which it finished.  It is used to build the menu
from `org-export-stack'.")

(defvar org-export--registered-backends nil
  "List of backends currently available in the exporter.
This variable is set with `org-export-define-backend' and
`org-export-define-derived-backend' functions.")

(defvar org-export-dispatch-last-action nil
  "Last command called from the dispatcher.
The value should be a list.  Its CAR is the action, as a symbol,
and its CDR is a list of export options.")

(defvar org-export-dispatch-last-position (make-marker)
  "The position where the last export command was created using the dispatcher.
This marker will be used with `C-u C-c C-e' to make sure export repetition
uses the same subtree if the previous command was restricted to a subtree.")

;; For compatibility with Org < 8
(defvar org-export-current-backend nil
  "Name, if any, of the back-end used during an export process.

Its value is a symbol such as `html', `latex', `ascii', or nil if
the back-end is anonymous (see `org-export-create-backend') or if
there is no export process in progress.

It can be used to teach Babel blocks how to act differently
according to the back-end used.")


;;; User-configurable Variables
;;
;; Configuration for the masses.
;;
;; They should never be accessed directly, as their value is to be
;; stored in a property list (cf. `org-export-options-alist').
;; Back-ends will read their value from there instead.

(defgroup org-export nil
  "Options for exporting Org mode files."
  :tag "Org Export"
  :group 'org)

(defgroup org-export-general nil
  "General options for export engine."
  :tag "Org Export General"
  :group 'org-export)

(defcustom org-export-with-archived-trees 'headline
  "Whether sub-trees with the ARCHIVE tag should be exported.

This can have three different values:
nil         Do not export, pretend this tree is not present.
t           Do export the entire tree.
`headline'  Only export the headline, but skip the tree below it.

This option can also be set with the OPTIONS keyword,
e.g. \"arch:nil\"."
  :group 'org-export-general
  :type '(choice
	  (const :tag "Not at all" nil)
	  (const :tag "Headline only" headline)
	  (const :tag "Entirely" t)))

(defcustom org-export-with-author t
  "Non-nil means insert author name into the exported file.
This option can also be set with the OPTIONS keyword,
e.g. \"author:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-clocks nil
  "Non-nil means export CLOCK keywords.
This option can also be set with the OPTIONS keyword,
e.g. \"c:t\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-creator 'comment
  "Non-nil means the postamble should contain a creator sentence.

The sentence can be set in `org-export-creator-string' and
defaults to \"Generated by Org mode XX in Emacs XXX.\".

If the value is `comment' insert it as a comment."
  :group 'org-export-general
  :type '(choice
	  (const :tag "No creator sentence" nil)
	  (const :tag "Sentence as a comment" comment)
	  (const :tag "Insert the sentence" t)))

(defcustom org-export-with-date t
  "Non-nil means insert date in the exported document.
This option can also be set with the OPTIONS keyword,
e.g. \"date:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-date-timestamp-format nil
  "Time-stamp format string to use for DATE keyword.

The format string, when specified, only applies if date consists
in a single time-stamp.  Otherwise its value will be ignored.

See `format-time-string' for details on how to build this
string."
  :group 'org-export-general
  :type '(choice
	  (string :tag "Time-stamp format string")
	  (const :tag "No format string" nil)))

(defcustom org-export-creator-string
  (format "Emacs %s (Org mode %s)"
	  emacs-version
	  (if (fboundp 'org-version) (org-version) "unknown version"))
  "Information about the creator of the document.
This option can also be set on with the CREATOR keyword."
  :group 'org-export-general
  :type '(string :tag "Creator string"))

(defcustom org-export-with-drawers '(not "LOGBOOK")
  "Non-nil means export contents of standard drawers.

When t, all drawers are exported.  This may also be a list of
drawer names to export.  If that list starts with `not', only
drawers with such names will be ignored.

This variable doesn't apply to properties drawers.

This option can also be set with the OPTIONS keyword,
e.g. \"d:nil\"."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type '(choice
	  (const :tag "All drawers" t)
	  (const :tag "None" nil)
	  (repeat :tag "Selected drawers"
		  (string :tag "Drawer name"))
	  (list :tag "Ignored drawers"
		(const :format "" not)
		(repeat :tag "Specify names of drawers to ignore during export"
			:inline t
			(string :tag "Drawer name")))))

(defcustom org-export-with-email nil
  "Non-nil means insert author email into the exported file.
This option can also be set with the OPTIONS keyword,
e.g. \"email:t\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-emphasize t
  "Non-nil means interpret *word*, /word/, _word_ and +word+.

If the export target supports emphasizing text, the word will be
typeset in bold, italic, with an underline or strike-through,
respectively.

This option can also be set with the OPTIONS keyword,
e.g. \"*:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-exclude-tags '("noexport")
  "Tags that exclude a tree from export.

All trees carrying any of these tags will be excluded from
export.  This is without condition, so even subtrees inside that
carry one of the `org-export-select-tags' will be removed.

This option can also be set with the EXCLUDE_TAGS keyword."
  :group 'org-export-general
  :type '(repeat (string :tag "Tag")))

(defcustom org-export-with-fixed-width t
  "Non-nil means lines starting with \":\" will be in fixed width font.

This can be used to have pre-formatted text, fragments of code
etc.  For example:
  : ;; Some Lisp examples
  : (while (defc cnt)
  :   (ding))
will be looking just like this in also HTML.  See also the QUOTE
keyword.  Not all export backends support this.

This option can also be set with the OPTIONS keyword,
e.g. \"::nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-footnotes t
  "Non-nil means Org footnotes should be exported.
This option can also be set with the OPTIONS keyword,
e.g. \"f:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-latex t
  "Non-nil means process LaTeX environments and fragments.

This option can also be set with the OPTIONS line,
e.g. \"tex:verbatim\".  Allowed values are:

nil         Ignore math snippets.
`verbatim'  Keep everything in verbatim.
t           Allow export of math snippets."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type '(choice
	  (const :tag "Do not process math in any way" nil)
	  (const :tag "Interpret math snippets" t)
	  (const :tag "Leave math verbatim" verbatim)))

(defcustom org-export-headline-levels 3
  "The last level which is still exported as a headline.

Inferior levels will usually produce itemize or enumerate lists
when exported, but back-end behaviour may differ.

This option can also be set with the OPTIONS keyword,
e.g. \"H:2\"."
  :group 'org-export-general
  :type 'integer)

(defcustom org-export-default-language "en"
  "The default language for export and clocktable translations, as a string.
This may have an association in
`org-clock-clocktable-language-setup',
`org-export-smart-quotes-alist' and `org-export-dictionary'.
This option can also be set with the LANGUAGE keyword."
  :group 'org-export-general
  :type '(string :tag "Language"))

(defcustom org-export-preserve-breaks nil
  "Non-nil means preserve all line breaks when exporting.
This option can also be set with the OPTIONS keyword,
e.g. \"\\n:t\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-entities t
  "Non-nil means interpret entities when exporting.

For example, HTML export converts \\alpha to &alpha; and \\AA to
&Aring;.

For a list of supported names, see the constant `org-entities'
and the user option `org-entities-user'.

This option can also be set with the OPTIONS keyword,
e.g. \"e:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-inlinetasks t
  "Non-nil means inlinetasks should be exported.
This option can also be set with the OPTIONS keyword,
e.g. \"inline:nil\"."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)

(defcustom org-export-with-planning nil
  "Non-nil means include planning info in export.

Planning info is the line containing either SCHEDULED:,
DEADLINE:, CLOSED: time-stamps, or a combination of them.

This option can also be set with the OPTIONS keyword,
e.g. \"p:t\"."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)

(defcustom org-export-with-priority nil
  "Non-nil means include priority cookies in export.
This option can also be set with the OPTIONS keyword,
e.g. \"pri:t\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-section-numbers t
  "Non-nil means add section numbers to headlines when exporting.

When set to an integer n, numbering will only happen for
headlines whose relative level is higher or equal to n.

This option can also be set with the OPTIONS keyword,
e.g. \"num:t\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-select-tags '("export")
  "Tags that select a tree for export.

If any such tag is found in a buffer, all trees that do not carry
one of these tags will be ignored during export.  Inside trees
that are selected like this, you can still deselect a subtree by
tagging it with one of the `org-export-exclude-tags'.

This option can also be set with the SELECT_TAGS keyword."
  :group 'org-export-general
  :type '(repeat (string :tag "Tag")))

(defcustom org-export-with-smart-quotes nil
  "Non-nil means activate smart quotes during export.
This option can also be set with the OPTIONS keyword,
e.g., \"':t\".

When setting this to non-nil, you need to take care of
using the correct Babel package when exporting to LaTeX.
E.g., you can load Babel for french like this:

#+LATEX_HEADER: \\usepackage[french]{babel}"
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)

(defcustom org-export-with-special-strings t
  "Non-nil means interpret \"\\-\", \"--\" and \"---\" for export.

When this option is turned on, these strings will be exported as:

   Org     HTML     LaTeX    UTF-8
  -----+----------+--------+-------
   \\-    &shy;      \\-
   --    &ndash;    --         –
   ---   &mdash;    ---        —
   ...   &hellip;   \\ldots     …

This option can also be set with the OPTIONS keyword,
e.g. \"-:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-statistics-cookies t
  "Non-nil means include statistics cookies in export.
This option can also be set with the OPTIONS keyword,
e.g. \"stat:nil\""
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)

(defcustom org-export-with-sub-superscripts t
  "Non-nil means interpret \"_\" and \"^\" for export.

If you want to control how Org displays those characters, see
`org-use-sub-superscripts'.  `org-export-with-sub-superscripts'
used to be an alias for `org-use-sub-superscripts' in Org <8.0,
it is not anymore.

When this option is turned on, you can use TeX-like syntax for
sub- and superscripts and see them exported correctly.

You can also set the option with #+OPTIONS: ^:t

Several characters after \"_\" or \"^\" will be considered as a
single item - so grouping with {} is normally not needed.  For
example, the following things will be parsed as single sub- or
superscripts:

 10^24   or   10^tau     several digits will be considered 1 item.
 10^-12  or   10^-tau    a leading sign with digits or a word
 x^2-y^3                 will be read as x^2 - y^3, because items are
			 terminated by almost any nonword/nondigit char.
 x_{i^2} or   x^(2-i)    braces or parenthesis do grouping.

Still, ambiguity is possible.  So when in doubt, use {} to enclose
the sub/superscript.  If you set this variable to the symbol `{}',
the braces are *required* in order to trigger interpretations as
sub/superscript.  This can be helpful in documents that need \"_\"
frequently in plain text."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type '(choice
	  (const :tag "Interpret them" t)
	  (const :tag "Curly brackets only" {})
	  (const :tag "Do not interpret them" nil)))

(defcustom org-export-with-toc t
  "Non-nil means create a table of contents in exported files.

The TOC contains headlines with levels up
to`org-export-headline-levels'.  When an integer, include levels
up to N in the toc, this may then be different from
`org-export-headline-levels', but it will not be allowed to be
larger than the number of headline levels.  When nil, no table of
contents is made.

This option can also be set with the OPTIONS keyword,
e.g. \"toc:nil\" or \"toc:3\"."
  :group 'org-export-general
  :type '(choice
	  (const :tag "No Table of Contents" nil)
	  (const :tag "Full Table of Contents" t)
	  (integer :tag "TOC to level")))

(defcustom org-export-with-tables t
  "If non-nil, lines starting with \"|\" define a table.
For example:

  | Name        | Address  | Birthday  |
  |-------------+----------+-----------|
  | Arthur Dent | England  | 29.2.2100 |

This option can also be set with the OPTIONS keyword,
e.g. \"|:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-tags t
  "If nil, do not export tags, just remove them from headlines.

If this is the symbol `not-in-toc', tags will be removed from
table of contents entries, but still be shown in the headlines of
the document.

This option can also be set with the OPTIONS keyword,
e.g. \"tags:nil\"."
  :group 'org-export-general
  :type '(choice
	  (const :tag "Off" nil)
	  (const :tag "Not in TOC" not-in-toc)
	  (const :tag "On" t)))

(defcustom org-export-with-tasks t
  "Non-nil means include TODO items for export.

This may have the following values:
t                    include tasks independent of state.
`todo'               include only tasks that are not yet done.
`done'               include only tasks that are already done.
nil                  ignore all tasks.
list of keywords     include tasks with these keywords.

This option can also be set with the OPTIONS keyword,
e.g. \"tasks:nil\"."
  :group 'org-export-general
  :type '(choice
	  (const :tag "All tasks" t)
	  (const :tag "No tasks" nil)
	  (const :tag "Not-done tasks" todo)
	  (const :tag "Only done tasks" done)
	  (repeat :tag "Specific TODO keywords"
		  (string :tag "Keyword"))))

(defcustom org-export-time-stamp-file t
  "Non-nil means insert a time stamp into the exported file.
The time stamp shows when the file was created. This option can
also be set with the OPTIONS keyword, e.g. \"timestamp:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-with-timestamps t
  "Non nil means allow timestamps in export.

It can be set to any of the following values:
  t          export all timestamps.
  `active'   export active timestamps only.
  `inactive' export inactive timestamps only.
  nil        do not export timestamps

This only applies to timestamps isolated in a paragraph
containing only timestamps.  Other timestamps are always
exported.

This option can also be set with the OPTIONS keyword, e.g.
\"<:nil\"."
  :group 'org-export-general
  :type '(choice
	  (const :tag "All timestamps" t)
	  (const :tag "Only active timestamps" active)
	  (const :tag "Only inactive timestamps" inactive)
	  (const :tag "No timestamp" nil)))

(defcustom org-export-with-todo-keywords t
  "Non-nil means include TODO keywords in export.
When nil, remove all these keywords from the export.  This option
can also be set with the OPTIONS keyword, e.g.  \"todo:nil\"."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-allow-bind-keywords nil
  "Non-nil means BIND keywords can define local variable values.
This is a potential security risk, which is why the default value
is nil.  You can also allow them through local buffer variables."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)

(defcustom org-export-snippet-translation-alist nil
  "Alist between export snippets back-ends and exporter back-ends.

This variable allows to provide shortcuts for export snippets.

For example, with a value of '\(\(\"h\" . \"html\"\)\), the
HTML back-end will recognize the contents of \"@@h:<b>@@\" as
HTML code while every other back-end will ignore it."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type '(repeat
	  (cons (string :tag "Shortcut")
		(string :tag "Back-end"))))

(defcustom org-export-coding-system nil
  "Coding system for the exported file."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'coding-system)

(defcustom org-export-copy-to-kill-ring 'if-interactive
  "Non-nil means pushing export output to the kill ring.
This variable is ignored during asynchronous export."
  :group 'org-export-general
  :version "24.3"
  :type '(choice
	  (const :tag "Always" t)
	  (const :tag "When export is done interactively" if-interactive)
	  (const :tag "Never" nil)))

(defcustom org-export-initial-scope 'buffer
  "The initial scope when exporting with `org-export-dispatch'.
This variable can be either set to `buffer' or `subtree'."
  :group 'org-export-general
  :type '(choice
	  (const :tag "Export current buffer" buffer)
	  (const :tag "Export current subtree" subtree)))

(defcustom org-export-show-temporary-export-buffer t
  "Non-nil means show buffer after exporting to temp buffer.
When Org exports to a file, the buffer visiting that file is ever
shown, but remains buried.  However, when exporting to
a temporary buffer, that buffer is popped up in a second window.
When this variable is nil, the buffer remains buried also in
these cases."
  :group 'org-export-general
  :type 'boolean)

(defcustom org-export-in-background nil
  "Non-nil means export and publishing commands will run in background.
Results from an asynchronous export are never displayed
automatically.  But you can retrieve them with \\[org-export-stack]."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)

(defcustom org-export-async-init-file user-init-file
  "File used to initialize external export process.
Value must be an absolute file name.  It defaults to user's
initialization file.  Though, a specific configuration makes the
process faster and the export more portable."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type '(file :must-match t))

(defcustom org-export-dispatch-use-expert-ui nil
  "Non-nil means using a non-intrusive `org-export-dispatch'.
In that case, no help buffer is displayed.  Though, an indicator
for current export scope is added to the prompt (\"b\" when
output is restricted to body only, \"s\" when it is restricted to
the current subtree, \"v\" when only visible elements are
considered for export, \"f\" when publishing functions should be
passed the FORCE argument and \"a\" when the export should be
asynchronous).  Also, \[?] allows to switch back to standard
mode."
  :group 'org-export-general
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'boolean)



;;; Defining Back-ends
;;
;; An export back-end is a structure with `org-export-backend' type
;; and `name', `parent', `transcoders', `options', `filters', `blocks'
;; and `menu' slots.
;;
;; At the lowest level, a back-end is created with
;; `org-export-create-backend' function.
;;
;; A named back-end can be registered with
;; `org-export-register-backend' function.  A registered back-end can
;; later be referred to by its name, with `org-export-get-backend'
;; function.  Also, such a back-end can become the parent of a derived
;; back-end from which slot values will be inherited by default.
;; `org-export-derived-backend-p' can check if a given back-end is
;; derived from a list of back-end names.
;;
;; `org-export-get-all-transcoders', `org-export-get-all-options' and
;; `org-export-get-all-filters' return the full alist of transcoders,
;; options and filters, including those inherited from ancestors.
;;
;; At a higher level, `org-export-define-backend' is the standard way
;; to define an export back-end.  If the new back-end is similar to
;; a registered back-end, `org-export-define-derived-backend' may be
;; used instead.
;;
;; Eventually `org-export-barf-if-invalid-backend' returns an error
;; when a given back-end hasn't been registered yet.

(defstruct (org-export-backend (:constructor org-export-create-backend)
			       (:copier nil))
  name parent transcoders options filters blocks menu)

(defun org-export-get-backend (name)
  "Return export back-end named after NAME.
NAME is a symbol.  Return nil if no such back-end is found."
  (catch 'found
    (dolist (b org-export--registered-backends)
      (when (eq (org-export-backend-name b) name)
	(throw 'found b)))))

(defun org-export-register-backend (backend)
  "Register BACKEND as a known export back-end.
BACKEND is a structure with `org-export-backend' type."
  ;; Refuse to register an unnamed back-end.
  (unless (org-export-backend-name backend)
    (error "Cannot register a unnamed export back-end"))
  ;; Refuse to register a back-end with an unknown parent.
  (let ((parent (org-export-backend-parent backend)))
    (when (and parent (not (org-export-get-backend parent)))
      (error "Cannot use unknown \"%s\" back-end as a parent" parent)))
  ;; Register dedicated export blocks in the parser.
  (dolist (name (org-export-backend-blocks backend))
    (add-to-list 'org-element-block-name-alist
		 (cons name 'org-element-export-block-parser)))
  ;; If a back-end with the same name as BACKEND is already
  ;; registered, replace it with BACKEND.  Otherwise, simply add
  ;; BACKEND to the list of registered back-ends.
  (let ((old (org-export-get-backend (org-export-backend-name backend))))
    (if old (setcar (memq old org-export--registered-backends) backend)
      (push backend org-export--registered-backends))))

(defun org-export-barf-if-invalid-backend (backend)
  "Signal an error if BACKEND isn't defined."
  (unless (org-export-backend-p backend)
    (error "Unknown \"%s\" back-end: Aborting export" backend)))

(defun org-export-derived-backend-p (backend &rest backends)
  "Non-nil if BACKEND is derived from one of BACKENDS.
BACKEND is an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.  BACKENDS is constituted of symbols."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (catch 'exit
      (while (org-export-backend-parent backend)
	(when (memq (org-export-backend-name backend) backends)
	  (throw 'exit t))
	(setq backend
	      (org-export-get-backend (org-export-backend-parent backend))))
      (memq (org-export-backend-name backend) backends))))

(defun org-export-get-all-transcoders (backend)
  "Return full translation table for BACKEND.

BACKEND is an export back-end, as return by, e.g,,
`org-export-create-backend'.  Return value is an alist where
keys are element or object types, as symbols, and values are
transcoders.

Unlike to `org-export-backend-transcoders', this function
also returns transcoders inherited from parent back-ends,
if any."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (let ((transcoders (org-export-backend-transcoders backend))
	  parent)
      (while (setq parent (org-export-backend-parent backend))
	(setq backend (org-export-get-backend parent))
	(setq transcoders
	      (append transcoders (org-export-backend-transcoders backend))))
      transcoders)))

(defun org-export-get-all-options (backend)
  "Return export options for BACKEND.

BACKEND is an export back-end, as return by, e.g,,
`org-export-create-backend'.  See `org-export-options-alist'
for the shape of the return value.

Unlike to `org-export-backend-options', this function also
returns options inherited from parent back-ends, if any."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (let ((options (org-export-backend-options backend))
	  parent)
      (while (setq parent (org-export-backend-parent backend))
	(setq backend (org-export-get-backend parent))
	(setq options (append options (org-export-backend-options backend))))
      options)))

(defun org-export-get-all-filters (backend)
  "Return complete list of filters for BACKEND.

BACKEND is an export back-end, as return by, e.g,,
`org-export-create-backend'.  Return value is an alist where
keys are symbols and values lists of functions.

Unlike to `org-export-backend-filters', this function also
returns filters inherited from parent back-ends, if any."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (let ((filters (org-export-backend-filters backend))
	  parent)
      (while (setq parent (org-export-backend-parent backend))
	(setq backend (org-export-get-backend parent))
	(setq filters (append filters (org-export-backend-filters backend))))
      filters)))

(defun org-export-define-backend (backend transcoders &rest body)
  "Define a new back-end BACKEND.

TRANSCODERS is an alist between object or element types and
functions handling them.

These functions should return a string without any trailing
space, or nil.  They must accept three arguments: the object or
element itself, its contents or nil when it isn't recursive and
the property list used as a communication channel.

Contents, when not nil, are stripped from any global indentation
\(although the relative one is preserved).  They also always end
with a single newline character.

If, for a given type, no function is found, that element or
object type will simply be ignored, along with any blank line or
white space at its end.  The same will happen if the function
returns the nil value.  If that function returns the empty
string, the type will be ignored, but the blank lines or white
spaces will be kept.

In addition to element and object types, one function can be
associated to the `template' (or `inner-template') symbol and
another one to the `plain-text' symbol.

The former returns the final transcoded string, and can be used
to add a preamble and a postamble to document's body.  It must
accept two arguments: the transcoded string and the property list
containing export options.  A function associated to `template'
will not be applied if export has option \"body-only\".
A function associated to `inner-template' is always applied.

The latter, when defined, is to be called on every text not
recognized as an element or an object.  It must accept two
arguments: the text string and the information channel.  It is an
appropriate place to protect special chars relative to the
back-end.

BODY can start with pre-defined keyword arguments.  The following
keywords are understood:

  :export-block

    String, or list of strings, representing block names that
    will not be parsed.  This is used to specify blocks that will
    contain raw code specific to the back-end.  These blocks
    still have to be handled by the relative `export-block' type
    translator.

  :filters-alist

    Alist between filters and function, or list of functions,
    specific to the back-end.  See `org-export-filters-alist' for
    a list of all allowed filters.  Filters defined here
    shouldn't make a back-end test, as it may prevent back-ends
    derived from this one to behave properly.

  :menu-entry

    Menu entry for the export dispatcher.  It should be a list
    like:

      '(KEY DESCRIPTION-OR-ORDINAL ACTION-OR-MENU)

    where :

      KEY is a free character selecting the back-end.

      DESCRIPTION-OR-ORDINAL is either a string or a number.

      If it is a string, is will be used to name the back-end in
      its menu entry.  If it is a number, the following menu will
      be displayed as a sub-menu of the back-end with the same
      KEY.  Also, the number will be used to determine in which
      order such sub-menus will appear (lowest first).

      ACTION-OR-MENU is either a function or an alist.

      If it is an action, it will be called with four
      arguments (booleans): ASYNC, SUBTREEP, VISIBLE-ONLY and
      BODY-ONLY.  See `org-export-as' for further explanations on
      some of them.

      If it is an alist, associations should follow the
      pattern:

        '(KEY DESCRIPTION ACTION)

      where KEY, DESCRIPTION and ACTION are described above.

    Valid values include:

      '(?m \"My Special Back-end\" my-special-export-function)

      or

      '(?l \"Export to LaTeX\"
           \(?p \"As PDF file\" org-latex-export-to-pdf)
           \(?o \"As PDF file and open\"
               \(lambda (a s v b)
                 \(if a (org-latex-export-to-pdf t s v b)
                   \(org-open-file
                    \(org-latex-export-to-pdf nil s v b)))))))

      or the following, which will be added to the previous
      sub-menu,

      '(?l 1
          \((?B \"As TEX buffer (Beamer)\" org-beamer-export-as-latex)
           \(?P \"As PDF file (Beamer)\" org-beamer-export-to-pdf)))

  :options-alist

    Alist between back-end specific properties introduced in
    communication channel and how their value are acquired.  See
    `org-export-options-alist' for more information about
    structure of the values."
  (declare (indent 1))
  (let (blocks filters menu-entry options contents)
    (while (keywordp (car body))
      (case (pop body)
        (:export-block (let ((names (pop body)))
			 (setq blocks (if (consp names) (mapcar 'upcase names)
					(list (upcase names))))))
	(:filters-alist (setq filters (pop body)))
	(:menu-entry (setq menu-entry (pop body)))
        (:options-alist (setq options (pop body)))
        (t (pop body))))
    (org-export-register-backend
     (org-export-create-backend :name backend
				:transcoders transcoders
				:options options
				:filters filters
				:blocks blocks
				:menu menu-entry))))

(defun org-export-define-derived-backend (child parent &rest body)
  "Create a new back-end as a variant of an existing one.

CHILD is the name of the derived back-end.  PARENT is the name of
the parent back-end.

BODY can start with pre-defined keyword arguments.  The following
keywords are understood:

  :export-block

    String, or list of strings, representing block names that
    will not be parsed.  This is used to specify blocks that will
    contain raw code specific to the back-end.  These blocks
    still have to be handled by the relative `export-block' type
    translator.

  :filters-alist

    Alist of filters that will overwrite or complete filters
    defined in PARENT back-end.  See `org-export-filters-alist'
    for a list of allowed filters.

  :menu-entry

    Menu entry for the export dispatcher.  See
    `org-export-define-backend' for more information about the
    expected value.

  :options-alist

    Alist of back-end specific properties that will overwrite or
    complete those defined in PARENT back-end.  Refer to
    `org-export-options-alist' for more information about
    structure of the values.

  :translate-alist

    Alist of element and object types and transcoders that will
    overwrite or complete transcode table from PARENT back-end.
    Refer to `org-export-define-backend' for detailed information
    about transcoders.

As an example, here is how one could define \"my-latex\" back-end
as a variant of `latex' back-end with a custom template function:

  \(org-export-define-derived-backend 'my-latex 'latex
     :translate-alist '((template . my-latex-template-fun)))

The back-end could then be called with, for example:

  \(org-export-to-buffer 'my-latex \"*Test my-latex*\")"
  (declare (indent 2))
  (let (blocks filters menu-entry options transcoders contents)
    (while (keywordp (car body))
      (case (pop body)
	(:export-block (let ((names (pop body)))
			 (setq blocks (if (consp names) (mapcar 'upcase names)
					(list (upcase names))))))
        (:filters-alist (setq filters (pop body)))
	(:menu-entry (setq menu-entry (pop body)))
        (:options-alist (setq options (pop body)))
        (:translate-alist (setq transcoders (pop body)))
        (t (pop body))))
    (org-export-register-backend
     (org-export-create-backend :name child
				:parent parent
				:transcoders transcoders
				:options options
				:filters filters
				:blocks blocks
				:menu menu-entry))))



;;; The Communication Channel
;;
;; During export process, every function has access to a number of
;; properties.  They are of two types:
;;
;; 1. Environment options are collected once at the very beginning of
;;    the process, out of the original buffer and configuration.
;;    Collecting them is handled by `org-export-get-environment'
;;    function.
;;
;;    Most environment options are defined through the
;;    `org-export-options-alist' variable.
;;
;; 2. Tree properties are extracted directly from the parsed tree,
;;    just before export, by `org-export-collect-tree-properties'.
;;
;; Here is the full list of properties available during transcode
;; process, with their category and their value type.
;;
;; + `:author' :: Author's name.
;;   - category :: option
;;   - type :: string
;;
;; + `:back-end' :: Current back-end used for transcoding.
;;   - category :: tree
;;   - type :: symbol
;;
;; + `:creator' :: String to write as creation information.
;;   - category :: option
;;   - type :: string
;;
;; + `:date' :: String to use as date.
;;   - category :: option
;;   - type :: string
;;
;; + `:description' :: Description text for the current data.
;;   - category :: option
;;   - type :: string
;;
;; + `:email' :: Author's email.
;;   - category :: option
;;   - type :: string
;;
;; + `:exclude-tags' :: Tags for exclusion of subtrees from export
;;      process.
;;   - category :: option
;;   - type :: list of strings
;;
;; + `:export-options' :: List of export options available for current
;;      process.
;;   - category :: none
;;   - type :: list of symbols, among `subtree', `body-only' and
;;      `visible-only'.
;;
;; + `:exported-data' :: Hash table used for memoizing
;;     `org-export-data'.
;;   - category :: tree
;;   - type :: hash table
;;
;; + `:filetags' :: List of global tags for buffer.  Used by
;;   `org-export-get-tags' to get tags with inheritance.
;;   - category :: option
;;   - type :: list of strings
;;
;; + `:footnote-definition-alist' :: Alist between footnote labels and
;;      their definition, as parsed data.  Only non-inlined footnotes
;;      are represented in this alist.  Also, every definition isn't
;;      guaranteed to be referenced in the parse tree.  The purpose of
;;      this property is to preserve definitions from oblivion
;;      (i.e. when the parse tree comes from a part of the original
;;      buffer), it isn't meant for direct use in a back-end.  To
;;      retrieve a definition relative to a reference, use
;;      `org-export-get-footnote-definition' instead.
;;   - category :: option
;;   - type :: alist (STRING . LIST)
;;
;; + `:headline-levels' :: Maximum level being exported as an
;;      headline.  Comparison is done with the relative level of
;;      headlines in the parse tree, not necessarily with their
;;      actual level.
;;   - category :: option
;;   - type :: integer
;;
;; + `:headline-offset' :: Difference between relative and real level
;;      of headlines in the parse tree.  For example, a value of -1
;;      means a level 2 headline should be considered as level
;;      1 (cf. `org-export-get-relative-level').
;;   - category :: tree
;;   - type :: integer
;;
;; + `:headline-numbering' :: Alist between headlines and their
;;      numbering, as a list of numbers
;;      (cf. `org-export-get-headline-number').
;;   - category :: tree
;;   - type :: alist (INTEGER . LIST)
;;
;; + `:id-alist' :: Alist between ID strings and destination file's
;;      path, relative to current directory.  It is used by
;;      `org-export-resolve-id-link' to resolve ID links targeting an
;;      external file.
;;   - category :: option
;;   - type :: alist (STRING . STRING)
;;
;; + `:ignore-list' :: List of elements and objects that should be
;;      ignored during export.
;;   - category :: tree
;;   - type :: list of elements and objects
;;
;; + `:input-file' :: Full path to input file, if any.
;;   - category :: option
;;   - type :: string or nil
;;
;; + `:keywords' :: List of keywords attached to data.
;;   - category :: option
;;   - type :: string
;;
;; + `:language' :: Default language used for translations.
;;   - category :: option
;;   - type :: string
;;
;; + `:parse-tree' :: Whole parse tree, available at any time during
;;      transcoding.
;;   - category :: option
;;   - type :: list (as returned by `org-element-parse-buffer')
;;
;; + `:preserve-breaks' :: Non-nil means transcoding should preserve
;;      all line breaks.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:section-numbers' :: Non-nil means transcoding should add
;;      section numbers to headlines.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:select-tags' :: List of tags enforcing inclusion of sub-trees
;;      in transcoding.  When such a tag is present, subtrees without
;;      it are de facto excluded from the process.  See
;;      `use-select-tags'.
;;   - category :: option
;;   - type :: list of strings
;;
;; + `:time-stamp-file' :: Non-nil means transcoding should insert
;;      a time stamp in the output.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:translate-alist' :: Alist between element and object types and
;;      transcoding functions relative to the current back-end.
;;      Special keys `inner-template', `template' and `plain-text' are
;;      also possible.
;;   - category :: option
;;   - type :: alist (SYMBOL . FUNCTION)
;;
;; + `:with-archived-trees' :: Non-nil when archived subtrees should
;;      also be transcoded.  If it is set to the `headline' symbol,
;;      only the archived headline's name is retained.
;;   - category :: option
;;   - type :: symbol (nil, t, `headline')
;;
;; + `:with-author' :: Non-nil means author's name should be included
;;      in the output.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-clocks' :: Non-nil means clock keywords should be exported.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-creator' :: Non-nil means a creation sentence should be
;;      inserted at the end of the transcoded string.  If the value
;;      is `comment', it should be commented.
;;   - category :: option
;;   - type :: symbol (`comment', nil, t)
;;
;; + `:with-date' :: Non-nil means output should contain a date.
;;   - category :: option
;;   - type :. symbol (nil, t)
;;
;; + `:with-drawers' :: Non-nil means drawers should be exported.  If
;;      its value is a list of names, only drawers with such names
;;      will be transcoded.  If that list starts with `not', drawer
;;      with these names will be skipped.
;;   - category :: option
;;   - type :: symbol (nil, t) or list of strings
;;
;; + `:with-email' :: Non-nil means output should contain author's
;;                   email.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-emphasize' :: Non-nil means emphasized text should be
;;      interpreted.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-fixed-width' :: Non-nil if transcoder should interpret
;;      strings starting with a colon as a fixed-with (verbatim) area.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-footnotes' :: Non-nil if transcoder should interpret
;;      footnotes.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-latex' :: Non-nil means `latex-environment' elements and
;;    `latex-fragment' objects should appear in export output.  When
;;    this property is set to `verbatim', they will be left as-is.
;;   - category :: option
;;   - type :: symbol (`verbatim', nil, t)
;;
;; + `:with-planning' :: Non-nil means transcoding should include
;;      planning info.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-priority' :: Non-nil means transcoding should include
;;      priority cookies.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-smart-quotes' :: Non-nil means activate smart quotes in
;;      plain text.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-special-strings' :: Non-nil means transcoding should
;;      interpret special strings in plain text.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-sub-superscript' :: Non-nil means transcoding should
;;      interpret subscript and superscript.  With a value of "{}",
;;      only interpret those using curly brackets.
;;   - category :: option
;;   - type :: symbol (nil, {}, t)
;;
;; + `:with-tables' :: Non-nil means transcoding should interpret
;;      tables.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-tags' :: Non-nil means transcoding should keep tags in
;;      headlines.  A `not-in-toc' value will remove them from the
;;      table of contents, if any, nonetheless.
;;   - category :: option
;;   - type :: symbol (nil, t, `not-in-toc')
;;
;; + `:with-tasks' :: Non-nil means transcoding should include
;;      headlines with a TODO keyword.  A `todo' value will only
;;      include headlines with a todo type keyword while a `done'
;;      value will do the contrary.  If a list of strings is provided,
;;      only tasks with keywords belonging to that list will be kept.
;;   - category :: option
;;   - type :: symbol (t, todo, done, nil) or list of strings
;;
;; + `:with-timestamps' :: Non-nil means transcoding should include
;;      time stamps.  Special value `active' (resp. `inactive') ask to
;;      export only active (resp. inactive) timestamps.  Otherwise,
;;      completely remove them.
;;   - category :: option
;;   - type :: symbol: (`active', `inactive', t, nil)
;;
;; + `:with-toc' :: Non-nil means that a table of contents has to be
;;      added to the output.  An integer value limits its depth.
;;   - category :: option
;;   - type :: symbol (nil, t or integer)
;;
;; + `:with-todo-keywords' :: Non-nil means transcoding should
;;      include TODO keywords.
;;   - category :: option
;;   - type :: symbol (nil, t)


;;;; Environment Options
;;
;; Environment options encompass all parameters defined outside the
;; scope of the parsed data.  They come from five sources, in
;; increasing precedence order:
;;
;; - Global variables,
;; - Buffer's attributes,
;; - Options keyword symbols,
;; - Buffer keywords,
;; - Subtree properties.
;;
;; The central internal function with regards to environment options
;; is `org-export-get-environment'.  It updates global variables with
;; "#+BIND:" keywords, then retrieve and prioritize properties from
;; the different sources.
;;
;;  The internal functions doing the retrieval are:
;;  `org-export--get-global-options',
;;  `org-export--get-buffer-attributes',
;;  `org-export--parse-option-keyword',
;;  `org-export--get-subtree-options' and
;;  `org-export--get-inbuffer-options'
;;
;; Also, `org-export--list-bound-variables' collects bound variables
;; along with their value in order to set them as buffer local
;; variables later in the process.

(defun org-export-get-environment (&optional backend subtreep ext-plist)
  "Collect export options from the current buffer.

Optional argument BACKEND is an export back-end, as returned by
`org-export-create-backend'.

When optional argument SUBTREEP is non-nil, assume the export is
done against the current sub-tree.

Third optional argument EXT-PLIST is a property list with
external parameters overriding Org default settings, but still
inferior to file-local settings."
  ;; First install #+BIND variables since these must be set before
  ;; global options are read.
  (dolist (pair (org-export--list-bound-variables))
    (org-set-local (car pair) (nth 1 pair)))
  ;; Get and prioritize export options...
  (org-combine-plists
   ;; ... from global variables...
   (org-export--get-global-options backend)
   ;; ... from an external property list...
   ext-plist
   ;; ... from in-buffer settings...
   (org-export--get-inbuffer-options backend)
   ;; ... and from subtree, when appropriate.
   (and subtreep (org-export--get-subtree-options backend))
   ;; Eventually add misc. properties.
   (list
    :back-end
    backend
    :translate-alist (org-export-get-all-transcoders backend)
    :footnote-definition-alist
    ;; Footnotes definitions must be collected in the original
    ;; buffer, as there's no insurance that they will still be in
    ;; the parse tree, due to possible narrowing.
    (let (alist)
      (org-with-wide-buffer
       (goto-char (point-min))
       (while (re-search-forward org-footnote-definition-re nil t)
	 (let ((def (save-match-data (org-element-at-point))))
	   (when (eq (org-element-type def) 'footnote-definition)
	     (push
	      (cons (org-element-property :label def)
		    (let ((cbeg (org-element-property :contents-begin def)))
		      (when cbeg
			(org-element--parse-elements
			 cbeg (org-element-property :contents-end def)
			 nil nil nil nil (list 'org-data nil)))))
	      alist))))
       alist))
    :id-alist
    ;; Collect id references.
    (let (alist)
      (org-with-wide-buffer
       (goto-char (point-min))
       (while (re-search-forward "\\[\\[id:\\S-+?\\]" nil t)
	 (let ((link (org-element-context)))
	   (when (eq (org-element-type link) 'link)
	     (let* ((id (org-element-property :path link))
		    (file (org-id-find-id-file id)))
	       (when file
		 (push (cons id (file-relative-name file)) alist)))))))
      alist))))

(defun org-export--parse-option-keyword (options &optional backend)
  "Parse an OPTIONS line and return values as a plist.
Optional argument BACKEND is an export back-end, as returned by,
e.g., `org-export-create-backend'.  It specifies which back-end
specific items to read, if any."
  (let* ((all
	  ;; Priority is given to back-end specific options.
	  (append (and backend (org-export-get-all-options backend))
		  org-export-options-alist))
	 plist)
    (dolist (option all)
      (let ((property (car option))
	    (item (nth 2 option)))
	(when (and item
		   (not (plist-member plist property))
		   (string-match (concat "\\(\\`\\|[ \t]\\)"
					 (regexp-quote item)
					 ":\\(([^)\n]+)\\|[^ \t\n\r;,.]*\\)")
				 options))
	  (setq plist (plist-put plist
				 property
				 (car (read-from-string
				       (match-string 2 options))))))))
    plist))

(defun org-export--get-subtree-options (&optional backend)
  "Get export options in subtree at point.
Optional argument BACKEND is an export back-end, as returned by,
e.g., `org-export-create-backend'.  It specifies back-end used
for export.  Return options as a plist."
  ;; For each buffer keyword, create a headline property setting the
  ;; same property in communication channel. The name for the property
  ;; is the keyword with "EXPORT_" appended to it.
  (org-with-wide-buffer
   (let (prop plist)
     ;; Make sure point is at a heading.
     (if (org-at-heading-p) (org-up-heading-safe) (org-back-to-heading t))
     ;; Take care of EXPORT_TITLE. If it isn't defined, use headline's
     ;; title (with no todo keyword, priority cookie or tag) as its
     ;; fallback value.
     (when (setq prop (or (org-entry-get (point) "EXPORT_TITLE")
			  (progn (looking-at org-complex-heading-regexp)
				 (org-match-string-no-properties 4))))
       (setq plist
	     (plist-put
	      plist :title
	      (org-element-parse-secondary-string
	       prop (org-element-restriction 'keyword)))))
     ;; EXPORT_OPTIONS are parsed in a non-standard way.
     (when (setq prop (org-entry-get (point) "EXPORT_OPTIONS"))
       (setq plist
	     (nconc plist (org-export--parse-option-keyword prop backend))))
     ;; Handle other keywords.  TITLE keyword is excluded as it has
     ;; been handled already.
     (let ((seen '("TITLE")))
       (mapc
	(lambda (option)
	  (let ((property (car option))
		(keyword (nth 1 option)))
	    (when (and keyword (not (member keyword seen)))
	      (let* ((subtree-prop (concat "EXPORT_" keyword))
		     ;; Export properties are not case-sensitive.
		     (value (let ((case-fold-search t))
			      (org-entry-get (point) subtree-prop))))
		(push keyword seen)
		(when (and value (not (plist-member plist property)))
		  (setq plist
			(plist-put
			 plist
			 property
			 (cond
			  ;; Parse VALUE if required.
			  ((member keyword org-element-document-properties)
			   (org-element-parse-secondary-string
			    value (org-element-restriction 'keyword)))
			  ;; If BEHAVIOR is `split' expected value is
			  ;; a list of strings, not a string.
			  ((eq (nth 4 option) 'split) (org-split-string value))
			  (t value)))))))))
	;; Look for both general keywords and back-end specific
	;; options, with priority given to the latter.
	(append (and backend (org-export-get-all-options backend))
		org-export-options-alist)))
     ;; Return value.
     plist)))

(defun org-export--get-inbuffer-options (&optional backend)
  "Return current buffer export options, as a plist.

Optional argument BACKEND, when non-nil, is an export back-end,
as returned by, e.g., `org-export-create-backend'.  It specifies
which back-end specific options should also be read in the
process.

Assume buffer is in Org mode.  Narrowing, if any, is ignored."
  (let* (plist
	 get-options			; For byte-compiler.
	 (case-fold-search t)
	 (options (append
		   ;; Priority is given to back-end specific options.
		   (and backend (org-export-get-all-options backend))
		   org-export-options-alist))
	 (regexp (format "^[ \t]*#\\+%s:"
			 (regexp-opt (nconc (delq nil (mapcar 'cadr options))
					    org-export-special-keywords))))
	 (find-properties
	  (lambda (keyword)
	    ;; Return all properties associated to KEYWORD.
	    (let (properties)
	      (dolist (option options properties)
		(when (equal (nth 1 option) keyword)
		  (pushnew (car option) properties))))))
	 (get-options
	  (lambda (&optional files plist)
	    ;; Recursively read keywords in buffer.  FILES is a list
	    ;; of files read so far.  PLIST is the current property
	    ;; list obtained.
	    (org-with-wide-buffer
	     (goto-char (point-min))
	     (while (re-search-forward regexp nil t)
	       (let ((element (org-element-at-point)))
		 (when (eq (org-element-type element) 'keyword)
		   (let ((key (org-element-property :key element))
			 (val (org-element-property :value element)))
		     (cond
		      ;; Options in `org-export-special-keywords'.
		      ((equal key "SETUPFILE")
		       (let ((file (expand-file-name
				    (org-remove-double-quotes (org-trim val)))))
			 ;; Avoid circular dependencies.
			 (unless (member file files)
			   (with-temp-buffer
			     (insert (org-file-contents file 'noerror))
			     (let ((org-inhibit-startup t)) (org-mode))
			     (setq plist (funcall get-options
						  (cons file files) plist))))))
		      ((equal key "OPTIONS")
		       (setq plist
			     (org-combine-plists
			      plist
			      (org-export--parse-option-keyword val backend))))
		      ((equal key "FILETAGS")
		       (setq plist
			     (org-combine-plists
			      plist
			      (list :filetags
				    (org-uniquify
				     (append (org-split-string val ":")
					     (plist-get plist :filetags)))))))
		      (t
		       ;; Options in `org-export-options-alist'.
		       (dolist (property (funcall find-properties key))
			 (let ((behaviour (nth 4 (assq property options))))
			   (setq plist
				 (plist-put
				  plist property
				  ;; Handle value depending on specified
				  ;; BEHAVIOR.
				  (case behaviour
				    (space
				     (if (not (plist-get plist property))
					 (org-trim val)
				       (concat (plist-get plist property)
					       " "
					       (org-trim val))))
				    (newline
				     (org-trim
				      (concat (plist-get plist property)
					      "\n"
					      (org-trim val))))
				    (split `(,@(plist-get plist property)
					     ,@(org-split-string val)))
				    ('t val)
				    (otherwise
				     (if (not (plist-member plist property)) val
				       (plist-get plist property))))))))))))))
	     ;; Return final value.
	     plist))))
    ;; Read options in the current buffer.
    (setq plist (funcall get-options
			 (and buffer-file-name (list buffer-file-name)) nil))
    ;; Parse keywords specified in `org-element-document-properties'
    ;; and return PLIST.
    (dolist (keyword org-element-document-properties plist)
      (dolist (property (funcall find-properties keyword))
	(let ((value (plist-get plist property)))
	  (when (stringp value)
	    (setq plist
		  (plist-put plist property
			     (org-element-parse-secondary-string
			      value (org-element-restriction 'keyword))))))))))

(defun org-export--get-buffer-attributes ()
  "Return properties related to buffer attributes, as a plist."
  ;; Store full path of input file name, or nil.  For internal use.
  (let ((visited-file (buffer-file-name (buffer-base-buffer))))
    (list :input-file visited-file
	  :title (if (not visited-file) (buffer-name (buffer-base-buffer))
		   (file-name-sans-extension
		    (file-name-nondirectory visited-file))))))

(defun org-export--get-global-options (&optional backend)
  "Return global export options as a plist.
Optional argument BACKEND, if non-nil, is an export back-end, as
returned by, e.g., `org-export-create-backend'.  It specifies
which back-end specific export options should also be read in the
process."
  (let (plist
	;; Priority is given to back-end specific options.
	(all (append (and backend (org-export-get-all-options backend))
		     org-export-options-alist)))
    (dolist (cell all plist)
      (let ((prop (car cell))
	    (default-value (nth 3 cell)))
	(unless (or (not default-value) (plist-member plist prop))
	  (setq plist
		(plist-put
		 plist
		 prop
		 ;; Eval default value provided.  If keyword is
		 ;; a member of `org-element-document-properties',
		 ;; parse it as a secondary string before storing it.
		 (let ((value (eval (nth 3 cell))))
		   (if (not (stringp value)) value
		     (let ((keyword (nth 1 cell)))
		       (if (member keyword org-element-document-properties)
			   (org-element-parse-secondary-string
			    value (org-element-restriction 'keyword))
			 value)))))))))))

(defun org-export--list-bound-variables ()
  "Return variables bound from BIND keywords in current buffer.
Also look for BIND keywords in setup files.  The return value is
an alist where associations are (VARIABLE-NAME VALUE)."
  (when org-export-allow-bind-keywords
    (let* (collect-bind			; For byte-compiler.
	   (collect-bind
	    (lambda (files alist)
	      ;; Return an alist between variable names and their
	      ;; value.  FILES is a list of setup files names read so
	      ;; far, used to avoid circular dependencies.  ALIST is
	      ;; the alist collected so far.
	      (let ((case-fold-search t))
		(org-with-wide-buffer
		 (goto-char (point-min))
		 (while (re-search-forward
			 "^[ \t]*#\\+\\(BIND\\|SETUPFILE\\):" nil t)
		   (let ((element (org-element-at-point)))
		     (when (eq (org-element-type element) 'keyword)
		       (let ((val (org-element-property :value element)))
			 (if (equal (org-element-property :key element) "BIND")
			     (push (read (format "(%s)" val)) alist)
			   ;; Enter setup file.
			   (let ((file (expand-file-name
					(org-remove-double-quotes val))))
			     (unless (member file files)
			       (with-temp-buffer
				 (let ((org-inhibit-startup t)) (org-mode))
				 (insert (org-file-contents file 'noerror))
				 (setq alist
				       (funcall collect-bind
						(cons file files)
						alist))))))))))
		 alist)))))
      ;; Return value in appropriate order of appearance.
      (nreverse (funcall collect-bind nil nil)))))


;;;; Tree Properties
;;
;; Tree properties are information extracted from parse tree.  They
;; are initialized at the beginning of the transcoding process by
;; `org-export-collect-tree-properties'.
;;
;; Dedicated functions focus on computing the value of specific tree
;; properties during initialization.  Thus,
;; `org-export--populate-ignore-list' lists elements and objects that
;; should be skipped during export, `org-export--get-min-level' gets
;; the minimal exportable level, used as a basis to compute relative
;; level for headlines.  Eventually
;; `org-export--collect-headline-numbering' builds an alist between
;; headlines and their numbering.

(defun org-export-collect-tree-properties (data info)
  "Extract tree properties from parse tree.

DATA is the parse tree from which information is retrieved.  INFO
is a list holding export options.

Following tree properties are set or updated:

`:exported-data' Hash table used to memoize results from
                 `org-export-data'.

`:footnote-definition-alist' List of footnotes definitions in
                   original buffer and current parse tree.

`:headline-offset' Offset between true level of headlines and
		   local level.  An offset of -1 means a headline
		   of level 2 should be considered as a level
		   1 headline in the context.

`:headline-numbering' Alist of all headlines as key an the
		      associated numbering as value.

`:ignore-list'     List of elements that should be ignored during
                   export.

Return updated plist."
  ;; Install the parse tree in the communication channel, in order to
  ;; use `org-export-get-genealogy' and al.
  (setq info (plist-put info :parse-tree data))
  ;; Get the list of elements and objects to ignore, and put it into
  ;; `:ignore-list'.  Do not overwrite any user ignore that might have
  ;; been done during parse tree filtering.
  (setq info
	(plist-put info
		   :ignore-list
		   (append (org-export--populate-ignore-list data info)
			   (plist-get info :ignore-list))))
  ;; Compute `:headline-offset' in order to be able to use
  ;; `org-export-get-relative-level'.
  (setq info
	(plist-put info
		   :headline-offset
		   (- 1 (org-export--get-min-level data info))))
  ;; Update footnotes definitions list with definitions in parse tree.
  ;; This is required since buffer expansion might have modified
  ;; boundaries of footnote definitions contained in the parse tree.
  ;; This way, definitions in `footnote-definition-alist' are bound to
  ;; match those in the parse tree.
  (let ((defs (plist-get info :footnote-definition-alist)))
    (org-element-map data 'footnote-definition
      (lambda (fn)
	(push (cons (org-element-property :label fn)
		    `(org-data nil ,@(org-element-contents fn)))
	      defs)))
    (setq info (plist-put info :footnote-definition-alist defs)))
  ;; Properties order doesn't matter: get the rest of the tree
  ;; properties.
  (nconc
   `(:headline-numbering ,(org-export--collect-headline-numbering data info)
     :exported-data ,(make-hash-table :test 'eq :size 4001))
   info))

(defun org-export--get-min-level (data options)
  "Return minimum exportable headline's level in DATA.
DATA is parsed tree as returned by `org-element-parse-buffer'.
OPTIONS is a plist holding export options."
  (catch 'exit
    (let ((min-level 10000))
      (mapc
       (lambda (blob)
	 (when (and (eq (org-element-type blob) 'headline)
		    (not (org-element-property :footnote-section-p blob))
		    (not (memq blob (plist-get options :ignore-list))))
	   (setq min-level (min (org-element-property :level blob) min-level)))
	 (when (= min-level 1) (throw 'exit 1)))
       (org-element-contents data))
      ;; If no headline was found, for the sake of consistency, set
      ;; minimum level to 1 nonetheless.
      (if (= min-level 10000) 1 min-level))))

(defun org-export--collect-headline-numbering (data options)
  "Return numbering of all exportable headlines in a parse tree.

DATA is the parse tree.  OPTIONS is the plist holding export
options.

Return an alist whose key is a headline and value is its
associated numbering \(in the shape of a list of numbers\) or nil
for a footnotes section."
  (let ((numbering (make-vector org-export-max-depth 0)))
    (org-element-map data 'headline
      (lambda (headline)
	(unless (org-element-property :footnote-section-p headline)
	  (let ((relative-level
		 (1- (org-export-get-relative-level headline options))))
	    (cons
	     headline
	     (loop for n across numbering
		   for idx from 0 to org-export-max-depth
		   when (< idx relative-level) collect n
		   when (= idx relative-level) collect (aset numbering idx (1+ n))
		   when (> idx relative-level) do (aset numbering idx 0))))))
      options)))

(defun org-export--populate-ignore-list (data options)
  "Return list of elements and objects to ignore during export.
DATA is the parse tree to traverse.  OPTIONS is the plist holding
export options."
  (let* (ignore
	 walk-data
	 ;; First find trees containing a select tag, if any.
	 (selected (org-export--selected-trees data options))
	 (walk-data
	  (lambda (data)
	    ;; Collect ignored elements or objects into IGNORE-LIST.
	    (let ((type (org-element-type data)))
	      (if (org-export--skip-p data options selected) (push data ignore)
		(if (and (eq type 'headline)
			 (eq (plist-get options :with-archived-trees) 'headline)
			 (org-element-property :archivedp data))
		    ;; If headline is archived but tree below has
		    ;; to be skipped, add it to ignore list.
		    (mapc (lambda (e) (push e ignore))
			  (org-element-contents data))
		  ;; Move into secondary string, if any.
		  (let ((sec-prop
			 (cdr (assq type org-element-secondary-value-alist))))
		    (when sec-prop
		      (mapc walk-data (org-element-property sec-prop data))))
		  ;; Move into recursive objects/elements.
		  (mapc walk-data (org-element-contents data))))))))
    ;; Main call.
    (funcall walk-data data)
    ;; Return value.
    ignore))

(defun org-export--selected-trees (data info)
  "Return list of headlines and inlinetasks with a select tag in their tree.
DATA is parsed data as returned by `org-element-parse-buffer'.
INFO is a plist holding export options."
  (let* (selected-trees
	 walk-data			; For byte-compiler.
	 (walk-data
	  (function
	   (lambda (data genealogy)
	     (let ((type (org-element-type data)))
	       (cond
		((memq type '(headline inlinetask))
		 (let ((tags (org-element-property :tags data)))
		   (if (loop for tag in (plist-get info :select-tags)
			     thereis (member tag tags))
		       ;; When a select tag is found, mark full
		       ;; genealogy and every headline within the tree
		       ;; as acceptable.
		       (setq selected-trees
			     (append
			      genealogy
			      (org-element-map data '(headline inlinetask)
				'identity)
			      selected-trees))
		     ;; If at a headline, continue searching in tree,
		     ;; recursively.
		     (when (eq type 'headline)
		       (mapc (lambda (el)
			       (funcall walk-data el (cons data genealogy)))
			     (org-element-contents data))))))
		((or (eq type 'org-data)
		     (memq type org-element-greater-elements))
		 (mapc (lambda (el) (funcall walk-data el genealogy))
		       (org-element-contents data)))))))))
    (funcall walk-data data nil)
    selected-trees))

(defun org-export--skip-p (blob options selected)
  "Non-nil when element or object BLOB should be skipped during export.
OPTIONS is the plist holding export options.  SELECTED, when
non-nil, is a list of headlines or inlinetasks belonging to
a tree with a select tag."
  (case (org-element-type blob)
    (clock (not (plist-get options :with-clocks)))
    (drawer
     (let ((with-drawers-p (plist-get options :with-drawers)))
       (or (not with-drawers-p)
	   (and (consp with-drawers-p)
		;; If `:with-drawers' value starts with `not', ignore
		;; every drawer whose name belong to that list.
		;; Otherwise, ignore drawers whose name isn't in that
		;; list.
		(let ((name (org-element-property :drawer-name blob)))
		  (if (eq (car with-drawers-p) 'not)
		      (member-ignore-case name (cdr with-drawers-p))
		    (not (member-ignore-case name with-drawers-p))))))))
    ((footnote-definition footnote-reference)
     (not (plist-get options :with-footnotes)))
    ((headline inlinetask)
     (let ((with-tasks (plist-get options :with-tasks))
	   (todo (org-element-property :todo-keyword blob))
	   (todo-type (org-element-property :todo-type blob))
	   (archived (plist-get options :with-archived-trees))
	   (tags (org-element-property :tags blob)))
       (or
	(and (eq (org-element-type blob) 'inlinetask)
	     (not (plist-get options :with-inlinetasks)))
	;; Ignore subtrees with an exclude tag.
	(loop for k in (plist-get options :exclude-tags)
	      thereis (member k tags))
	;; When a select tag is present in the buffer, ignore any tree
	;; without it.
	(and selected (not (memq blob selected)))
	;; Ignore commented sub-trees.
	(org-element-property :commentedp blob)
	;; Ignore archived subtrees if `:with-archived-trees' is nil.
	(and (not archived) (org-element-property :archivedp blob))
	;; Ignore tasks, if specified by `:with-tasks' property.
	(and todo
	     (or (not with-tasks)
		 (and (memq with-tasks '(todo done))
		      (not (eq todo-type with-tasks)))
		 (and (consp with-tasks) (not (member todo with-tasks))))))))
    ((latex-environment latex-fragment) (not (plist-get options :with-latex)))
    (planning (not (plist-get options :with-planning)))
    (statistics-cookie (not (plist-get options :with-statistics-cookies)))
    (table-cell
     (and (org-export-table-has-special-column-p
	   (org-export-get-parent-table blob))
	  (not (org-export-get-previous-element blob options))))
    (table-row (org-export-table-row-is-special-p blob options))
    (timestamp
     ;; `:with-timestamps' only applies to isolated timestamps
     ;; objects, i.e. timestamp objects in a paragraph containing only
     ;; timestamps and whitespaces.
     (when (let ((parent (org-export-get-parent-element blob)))
	     (and (memq (org-element-type parent) '(paragraph verse-block))
		  (not (org-element-map parent
			   (cons 'plain-text
				 (remq 'timestamp org-element-all-objects))
			 (lambda (obj)
			   (or (not (stringp obj)) (org-string-nw-p obj)))
			 options t))))
       (case (plist-get options :with-timestamps)
	 ('nil t)
	 (active
	  (not (memq (org-element-property :type blob) '(active active-range))))
	 (inactive
	  (not (memq (org-element-property :type blob)
		     '(inactive inactive-range)))))))))


;;; The Transcoder
;;
;; `org-export-data' reads a parse tree (obtained with, i.e.
;; `org-element-parse-buffer') and transcodes it into a specified
;; back-end output.  It takes care of filtering out elements or
;; objects according to export options and organizing the output blank
;; lines and white space are preserved.  The function memoizes its
;; results, so it is cheap to call it within transcoders.
;;
;; It is possible to modify locally the back-end used by
;; `org-export-data' or even use a temporary back-end by using
;; `org-export-data-with-backend'.
;;
;; Internally, three functions handle the filtering of objects and
;; elements during the export.  In particular,
;; `org-export-ignore-element' marks an element or object so future
;; parse tree traversals skip it, `org-export--interpret-p' tells which
;; elements or objects should be seen as real Org syntax and
;; `org-export-expand' transforms the others back into their original
;; shape
;;
;; `org-export-transcoder' is an accessor returning appropriate
;; translator function for a given element or object.

(defun org-export-transcoder (blob info)
  "Return appropriate transcoder for BLOB.
INFO is a plist containing export directives."
  (let ((type (org-element-type blob)))
    ;; Return contents only for complete parse trees.
    (if (eq type 'org-data) (lambda (blob contents info) contents)
      (let ((transcoder (cdr (assq type (plist-get info :translate-alist)))))
	(and (functionp transcoder) transcoder)))))

(defun org-export-data (data info)
  "Convert DATA into current back-end format.

DATA is a parse tree, an element or an object or a secondary
string.  INFO is a plist holding export options.

Return a string."
  (or (gethash data (plist-get info :exported-data))
      (let* ((type (org-element-type data))
	     (results
	      (cond
	       ;; Ignored element/object.
	       ((memq data (plist-get info :ignore-list)) nil)
	       ;; Plain text.
	       ((eq type 'plain-text)
		(org-export-filter-apply-functions
		 (plist-get info :filter-plain-text)
		 (let ((transcoder (org-export-transcoder data info)))
		   (if transcoder (funcall transcoder data info) data))
		 info))
	       ;; Uninterpreted element/object: change it back to Org
	       ;; syntax and export again resulting raw string.
	       ((not (org-export--interpret-p data info))
		(org-export-data
		 (org-export-expand
		  data
		  (mapconcat (lambda (blob) (org-export-data blob info))
			     (org-element-contents data)
			     ""))
		 info))
	       ;; Secondary string.
	       ((not type)
		(mapconcat (lambda (obj) (org-export-data obj info)) data ""))
	       ;; Element/Object without contents or, as a special
	       ;; case, headline with archive tag and archived trees
	       ;; restricted to title only.
	       ((or (not (org-element-contents data))
		    (and (eq type 'headline)
			 (eq (plist-get info :with-archived-trees) 'headline)
			 (org-element-property :archivedp data)))
		(let ((transcoder (org-export-transcoder data info)))
		  (or (and (functionp transcoder)
			   (funcall transcoder data nil info))
		      ;; Export snippets never return a nil value so
		      ;; that white spaces following them are never
		      ;; ignored.
		      (and (eq type 'export-snippet) ""))))
	       ;; Element/Object with contents.
	       (t
		(let ((transcoder (org-export-transcoder data info)))
		  (when transcoder
		    (let* ((greaterp (memq type org-element-greater-elements))
			   (objectp
			    (and (not greaterp)
				 (memq type org-element-recursive-objects)))
			   (contents
			    (mapconcat
			     (lambda (element) (org-export-data element info))
			     (org-element-contents
			      (if (or greaterp objectp) data
				;; Elements directly containing
				;; objects must have their indentation
				;; normalized first.
				(org-element-normalize-contents
				 data
				 ;; When normalizing contents of the
				 ;; first paragraph in an item or
				 ;; a footnote definition, ignore
				 ;; first line's indentation: there is
				 ;; none and it might be misleading.
				 (when (eq type 'paragraph)
				   (let ((parent (org-export-get-parent data)))
				     (and
				      (eq (car (org-element-contents parent))
					  data)
				      (memq (org-element-type parent)
					    '(footnote-definition item))))))))
			     "")))
		      (funcall transcoder data
			       (if (not greaterp) contents
				 (org-element-normalize-string contents))
			       info))))))))
	;; Final result will be memoized before being returned.
	(puthash
	 data
	 (cond
	  ((not results) "")
	  ((memq type '(org-data plain-text nil)) results)
	  ;; Append the same white space between elements or objects
	  ;; as in the original buffer, and call appropriate filters.
	  (t
	   (let ((results
		  (org-export-filter-apply-functions
		   (plist-get info (intern (format ":filter-%s" type)))
		   (let ((post-blank (or (org-element-property :post-blank data)
					 0)))
		     (if (memq type org-element-all-elements)
			 (concat (org-element-normalize-string results)
				 (make-string post-blank ?\n))
		       (concat results (make-string post-blank ?\s))))
		   info)))
	     results)))
	 (plist-get info :exported-data)))))

(defun org-export-data-with-backend (data backend info)
  "Convert DATA into BACKEND format.

DATA is an element, an object, a secondary string or a string.
BACKEND is a symbol.  INFO is a plist used as a communication
channel.

Unlike to `org-export-with-backend', this function will
recursively convert DATA using BACKEND translation table."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (org-export-data
   data
   ;; Set-up a new communication channel with translations defined in
   ;; BACKEND as the translate table and a new hash table for
   ;; memoization.
   (org-combine-plists
    info
    (list :back-end backend
	  :translate-alist (org-export-get-all-transcoders backend)
	  ;; Size of the hash table is reduced since this function
	  ;; will probably be used on small trees.
	  :exported-data (make-hash-table :test 'eq :size 401)))))

(defun org-export--interpret-p (blob info)
  "Non-nil if element or object BLOB should be interpreted during export.
If nil, BLOB will appear as raw Org syntax.  Check is done
according to export options INFO, stored as a plist."
  (case (org-element-type blob)
    ;; ... entities...
    (entity (plist-get info :with-entities))
    ;; ... emphasis...
    ((bold italic strike-through underline)
     (plist-get info :with-emphasize))
    ;; ... fixed-width areas.
    (fixed-width (plist-get info :with-fixed-width))
    ;; ... LaTeX environments and fragments...
    ((latex-environment latex-fragment)
     (let ((with-latex-p (plist-get info :with-latex)))
       (and with-latex-p (not (eq with-latex-p 'verbatim)))))
    ;; ... sub/superscripts...
    ((subscript superscript)
     (let ((sub/super-p (plist-get info :with-sub-superscript)))
       (if (eq sub/super-p '{})
	   (org-element-property :use-brackets-p blob)
	 sub/super-p)))
    ;; ... tables...
    (table (plist-get info :with-tables))
    (otherwise t)))

(defun org-export-expand (blob contents &optional with-affiliated)
  "Expand a parsed element or object to its original state.

BLOB is either an element or an object.  CONTENTS is its
contents, as a string or nil.

When optional argument WITH-AFFILIATED is non-nil, add affiliated
keywords before output."
  (let ((type (org-element-type blob)))
    (concat (and with-affiliated (memq type org-element-all-elements)
		 (org-element--interpret-affiliated-keywords blob))
	    (funcall (intern (format "org-element-%s-interpreter" type))
		     blob contents))))

(defun org-export-ignore-element (element info)
  "Add ELEMENT to `:ignore-list' in INFO.

Any element in `:ignore-list' will be skipped when using
`org-element-map'.  INFO is modified by side effects."
  (plist-put info :ignore-list (cons element (plist-get info :ignore-list))))



;;; The Filter System
;;
;; Filters allow end-users to tweak easily the transcoded output.
;; They are the functional counterpart of hooks, as every filter in
;; a set is applied to the return value of the previous one.
;;
;; Every set is back-end agnostic.  Although, a filter is always
;; called, in addition to the string it applies to, with the back-end
;; used as argument, so it's easy for the end-user to add back-end
;; specific filters in the set.  The communication channel, as
;; a plist, is required as the third argument.
;;
;; From the developer side, filters sets can be installed in the
;; process with the help of `org-export-define-backend', which
;; internally stores filters as an alist.  Each association has a key
;; among the following symbols and a function or a list of functions
;; as value.
;;
;; - `:filter-options' applies to the property list containing export
;;   options.  Unlike to other filters, functions in this list accept
;;   two arguments instead of three: the property list containing
;;   export options and the back-end.  Users can set its value through
;;   `org-export-filter-options-functions' variable.
;;
;; - `:filter-parse-tree' applies directly to the complete parsed
;;   tree.  Users can set it through
;;   `org-export-filter-parse-tree-functions' variable.
;;
;; - `:filter-final-output' applies to the final transcoded string.
;;   Users can set it with `org-export-filter-final-output-functions'
;;   variable
;;
;; - `:filter-plain-text' applies to any string not recognized as Org
;;   syntax.  `org-export-filter-plain-text-functions' allows users to
;;   configure it.
;;
;; - `:filter-TYPE' applies on the string returned after an element or
;;   object of type TYPE has been transcoded.  A user can modify
;;   `org-export-filter-TYPE-functions'
;;
;; All filters sets are applied with
;; `org-export-filter-apply-functions' function.  Filters in a set are
;; applied in a LIFO fashion.  It allows developers to be sure that
;; their filters will be applied first.
;;
;; Filters properties are installed in communication channel with
;; `org-export-install-filters' function.
;;
;; Eventually, two hooks (`org-export-before-processing-hook' and
;; `org-export-before-parsing-hook') are run at the beginning of the
;; export process and just before parsing to allow for heavy structure
;; modifications.


;;;; Hooks

(defvar org-export-before-processing-hook nil
  "Hook run at the beginning of the export process.

This is run before include keywords and macros are expanded and
Babel code blocks executed, on a copy of the original buffer
being exported.  Visibility and narrowing are preserved.  Point
is at the beginning of the buffer.

Every function in this hook will be called with one argument: the
back-end currently used, as a symbol.")

(defvar org-export-before-parsing-hook nil
  "Hook run before parsing an export buffer.

This is run after include keywords and macros have been expanded
and Babel code blocks executed, on a copy of the original buffer
being exported.  Visibility and narrowing are preserved.  Point
is at the beginning of the buffer.

Every function in this hook will be called with one argument: the
back-end currently used, as a symbol.")


;;;; Special Filters

(defvar org-export-filter-options-functions nil
  "List of functions applied to the export options.
Each filter is called with two arguments: the export options, as
a plist, and the back-end, as a symbol.  It must return
a property list containing export options.")

(defvar org-export-filter-parse-tree-functions nil
  "List of functions applied to the parsed tree.
Each filter is called with three arguments: the parse tree, as
returned by `org-element-parse-buffer', the back-end, as
a symbol, and the communication channel, as a plist.  It must
return the modified parse tree to transcode.")

(defvar org-export-filter-plain-text-functions nil
  "List of functions applied to plain text.
Each filter is called with three arguments: a string which
contains no Org syntax, the back-end, as a symbol, and the
communication channel, as a plist.  It must return a string or
nil.")

(defvar org-export-filter-final-output-functions nil
  "List of functions applied to the transcoded string.
Each filter is called with three arguments: the full transcoded
string, the back-end, as a symbol, and the communication channel,
as a plist.  It must return a string that will be used as the
final export output.")


;;;; Elements Filters

(defvar org-export-filter-babel-call-functions nil
  "List of functions applied to a transcoded babel-call.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-center-block-functions nil
  "List of functions applied to a transcoded center block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-clock-functions nil
  "List of functions applied to a transcoded clock.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-comment-functions nil
  "List of functions applied to a transcoded comment.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-comment-block-functions nil
  "List of functions applied to a transcoded comment-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-diary-sexp-functions nil
  "List of functions applied to a transcoded diary-sexp.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-drawer-functions nil
  "List of functions applied to a transcoded drawer.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-dynamic-block-functions nil
  "List of functions applied to a transcoded dynamic-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-example-block-functions nil
  "List of functions applied to a transcoded example-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-export-block-functions nil
  "List of functions applied to a transcoded export-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-fixed-width-functions nil
  "List of functions applied to a transcoded fixed-width.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-footnote-definition-functions nil
  "List of functions applied to a transcoded footnote-definition.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-headline-functions nil
  "List of functions applied to a transcoded headline.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-horizontal-rule-functions nil
  "List of functions applied to a transcoded horizontal-rule.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-inlinetask-functions nil
  "List of functions applied to a transcoded inlinetask.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-item-functions nil
  "List of functions applied to a transcoded item.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-keyword-functions nil
  "List of functions applied to a transcoded keyword.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-latex-environment-functions nil
  "List of functions applied to a transcoded latex-environment.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-node-property-functions nil
  "List of functions applied to a transcoded node-property.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-paragraph-functions nil
  "List of functions applied to a transcoded paragraph.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-plain-list-functions nil
  "List of functions applied to a transcoded plain-list.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-planning-functions nil
  "List of functions applied to a transcoded planning.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-property-drawer-functions nil
  "List of functions applied to a transcoded property-drawer.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-quote-block-functions nil
  "List of functions applied to a transcoded quote block.
Each filter is called with three arguments: the transcoded quote
data, as a string, the back-end, as a symbol, and the
communication channel, as a plist.  It must return a string or
nil.")

(defvar org-export-filter-quote-section-functions nil
  "List of functions applied to a transcoded quote-section.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-section-functions nil
  "List of functions applied to a transcoded section.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-special-block-functions nil
  "List of functions applied to a transcoded special block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-src-block-functions nil
  "List of functions applied to a transcoded src-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-table-functions nil
  "List of functions applied to a transcoded table.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-table-cell-functions nil
  "List of functions applied to a transcoded table-cell.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-table-row-functions nil
  "List of functions applied to a transcoded table-row.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-verse-block-functions nil
  "List of functions applied to a transcoded verse block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")


;;;; Objects Filters

(defvar org-export-filter-bold-functions nil
  "List of functions applied to transcoded bold text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-code-functions nil
  "List of functions applied to transcoded code text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-entity-functions nil
  "List of functions applied to a transcoded entity.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-export-snippet-functions nil
  "List of functions applied to a transcoded export-snippet.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-footnote-reference-functions nil
  "List of functions applied to a transcoded footnote-reference.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-inline-babel-call-functions nil
  "List of functions applied to a transcoded inline-babel-call.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-inline-src-block-functions nil
  "List of functions applied to a transcoded inline-src-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-italic-functions nil
  "List of functions applied to transcoded italic text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-latex-fragment-functions nil
  "List of functions applied to a transcoded latex-fragment.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-line-break-functions nil
  "List of functions applied to a transcoded line-break.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-link-functions nil
  "List of functions applied to a transcoded link.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-radio-target-functions nil
  "List of functions applied to a transcoded radio-target.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-statistics-cookie-functions nil
  "List of functions applied to a transcoded statistics-cookie.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-strike-through-functions nil
  "List of functions applied to transcoded strike-through text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-subscript-functions nil
  "List of functions applied to a transcoded subscript.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-superscript-functions nil
  "List of functions applied to a transcoded superscript.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-target-functions nil
  "List of functions applied to a transcoded target.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-timestamp-functions nil
  "List of functions applied to a transcoded timestamp.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-underline-functions nil
  "List of functions applied to transcoded underline text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")

(defvar org-export-filter-verbatim-functions nil
  "List of functions applied to transcoded verbatim text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")


;;;; Filters Tools
;;
;; Internal function `org-export-install-filters' installs filters
;; hard-coded in back-ends (developer filters) and filters from global
;; variables (user filters) in the communication channel.
;;
;; Internal function `org-export-filter-apply-functions' takes care
;; about applying each filter in order to a given data.  It ignores
;; filters returning a nil value but stops whenever a filter returns
;; an empty string.

(defun org-export-filter-apply-functions (filters value info)
  "Call every function in FILTERS.

Functions are called with arguments VALUE, current export
back-end's name and INFO.  A function returning a nil value will
be skipped.  If it returns the empty string, the process ends and
VALUE is ignored.

Call is done in a LIFO fashion, to be sure that developer
specified filters, if any, are called first."
  (catch 'exit
    (let* ((backend (plist-get info :back-end))
	   (backend-name (and backend (org-export-backend-name backend))))
      (dolist (filter filters value)
	(let ((result (funcall filter value backend-name info)))
	  (cond ((not result) value)
		((equal value "") (throw 'exit nil))
		(t (setq value result))))))))

(defun org-export-install-filters (info)
  "Install filters properties in communication channel.
INFO is a plist containing the current communication channel.
Return the updated communication channel."
  (let (plist)
    ;; Install user-defined filters with `org-export-filters-alist'
    ;; and filters already in INFO (through ext-plist mechanism).
    (mapc (lambda (p)
	    (let* ((prop (car p))
		   (info-value (plist-get info prop))
		   (default-value (symbol-value (cdr p))))
	      (setq plist
		    (plist-put plist prop
			       ;; Filters in INFO will be called
			       ;; before those user provided.
			       (append (if (listp info-value) info-value
					 (list info-value))
				       default-value)))))
	  org-export-filters-alist)
    ;; Prepend back-end specific filters to that list.
    (mapc (lambda (p)
	    ;; Single values get consed, lists are appended.
	    (let ((key (car p)) (value (cdr p)))
	      (when value
		(setq plist
		      (plist-put
		       plist key
		       (if (atom value) (cons value (plist-get plist key))
			 (append value (plist-get plist key))))))))
	  (org-export-get-all-filters (plist-get info :back-end)))
    ;; Return new communication channel.
    (org-combine-plists info plist)))



;;; Core functions
;;
;; This is the room for the main function, `org-export-as', along with
;; its derivative, `org-export-string-as'.
;; `org-export--copy-to-kill-ring-p' determines if output of these
;; function should be added to kill ring.
;;
;; Note that `org-export-as' doesn't really parse the current buffer,
;; but a copy of it (with the same buffer-local variables and
;; visibility), where macros and include keywords are expanded and
;; Babel blocks are executed, if appropriate.
;; `org-export-with-buffer-copy' macro prepares that copy.
;;
;; File inclusion is taken care of by
;; `org-export-expand-include-keyword' and
;; `org-export--prepare-file-contents'.  Structure wise, including
;; a whole Org file in a buffer often makes little sense.  For
;; example, if the file contains a headline and the include keyword
;; was within an item, the item should contain the headline.  That's
;; why file inclusion should be done before any structure can be
;; associated to the file, that is before parsing.
;;
;; `org-export-insert-default-template' is a command to insert
;; a default template (or a back-end specific template) at point or in
;; current subtree.

(defun org-export-copy-buffer ()
  "Return a copy of the current buffer.
The copy preserves Org buffer-local variables, visibility and
narrowing."
  (let ((copy-buffer-fun (org-export--generate-copy-script (current-buffer)))
	(new-buf (generate-new-buffer (buffer-name))))
    (with-current-buffer new-buf
      (funcall copy-buffer-fun)
      (set-buffer-modified-p nil))
    new-buf))

(defmacro org-export-with-buffer-copy (&rest body)
  "Apply BODY in a copy of the current buffer.
The copy preserves local variables, visibility and contents of
the original buffer.  Point is at the beginning of the buffer
when BODY is applied."
  (declare (debug t))
  (org-with-gensyms (buf-copy)
    `(let ((,buf-copy (org-export-copy-buffer)))
       (unwind-protect
	   (with-current-buffer ,buf-copy
	     (goto-char (point-min))
	     (progn ,@body))
	 (and (buffer-live-p ,buf-copy)
	      ;; Kill copy without confirmation.
	      (progn (with-current-buffer ,buf-copy
		       (restore-buffer-modified-p nil))
		     (kill-buffer ,buf-copy)))))))

(defun org-export--generate-copy-script (buffer)
  "Generate a function duplicating BUFFER.

The copy will preserve local variables, visibility, contents and
narrowing of the original buffer.  If a region was active in
BUFFER, contents will be narrowed to that region instead.

The resulting function can be evaluated at a later time, from
another buffer, effectively cloning the original buffer there.

The function assumes BUFFER's major mode is `org-mode'."
  (with-current-buffer buffer
    `(lambda ()
       (let ((inhibit-modification-hooks t))
	 ;; Set major mode. Ignore `org-mode-hook' as it has been run
	 ;; already in BUFFER.
	 (let ((org-mode-hook nil) (org-inhibit-startup t)) (org-mode))
	 ;; Copy specific buffer local variables and variables set
	 ;; through BIND keywords.
	 ,@(let ((bound-variables (org-export--list-bound-variables))
		 vars)
	     (dolist (entry (buffer-local-variables (buffer-base-buffer)) vars)
	       (when (consp entry)
		 (let ((var (car entry))
		       (val (cdr entry)))
		   (and (not (eq var 'org-font-lock-keywords))
			(or (memq var
				  '(default-directory
				     buffer-file-name
				     buffer-file-coding-system))
			    (assq var bound-variables)
			    (string-match "^\\(org-\\|orgtbl-\\)"
					  (symbol-name var)))
			;; Skip unreadable values, as they cannot be
			;; sent to external process.
			(or (not val) (ignore-errors (read (format "%S" val))))
			(push `(set (make-local-variable (quote ,var))
				    (quote ,val))
			      vars))))))
	 ;; Whole buffer contents.
	 (insert
	  ,(org-with-wide-buffer
	    (buffer-substring-no-properties
	     (point-min) (point-max))))
	 ;; Narrowing.
	 ,(if (org-region-active-p)
	      `(narrow-to-region ,(region-beginning) ,(region-end))
	    `(narrow-to-region ,(point-min) ,(point-max)))
	 ;; Current position of point.
	 (goto-char ,(point))
	 ;; Overlays with invisible property.
	 ,@(let (ov-set)
	     (mapc
	      (lambda (ov)
		(let ((invis-prop (overlay-get ov 'invisible)))
		  (when invis-prop
		    (push `(overlay-put
			    (make-overlay ,(overlay-start ov)
					  ,(overlay-end ov))
			    'invisible (quote ,invis-prop))
			  ov-set))))
	      (overlays-in (point-min) (point-max)))
	     ov-set)))))

;;;###autoload
(defun org-export-as
  (backend &optional subtreep visible-only body-only ext-plist)
  "Transcode current Org buffer into BACKEND code.

BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.

If narrowing is active in the current buffer, only transcode its
narrowed part.

If a region is active, transcode that region.

When optional argument SUBTREEP is non-nil, transcode the
sub-tree at point, extracting information from the headline
properties first.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

When optional argument BODY-ONLY is non-nil, only return body
code, without surrounding template.

Optional argument EXT-PLIST, when provided, is a property list
with external parameters overriding Org default settings, but
still inferior to file-local settings.

Return code as a string."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (org-export-barf-if-invalid-backend backend)
  (save-excursion
    (save-restriction
      ;; Narrow buffer to an appropriate region or subtree for
      ;; parsing.  If parsing subtree, be sure to remove main headline
      ;; too.
      (cond ((org-region-active-p)
	     (narrow-to-region (region-beginning) (region-end)))
	    (subtreep
	     (org-narrow-to-subtree)
	     (goto-char (point-min))
	     (forward-line)
	     (narrow-to-region (point) (point-max))))
      ;; Initialize communication channel with original buffer
      ;; attributes, unavailable in its copy.
      (let* ((org-export-current-backend (org-export-backend-name backend))
	     (info (org-combine-plists
		    (list :export-options
			  (delq nil
				(list (and subtreep 'subtree)
				      (and visible-only 'visible-only)
				      (and body-only 'body-only))))
		    (org-export--get-buffer-attributes)))
	     tree)
	;; Update communication channel and get parse tree.  Buffer
	;; isn't parsed directly.  Instead, a temporary copy is
	;; created, where include keywords, macros are expanded and
	;; code blocks are evaluated.
	(org-export-with-buffer-copy
	 ;; Run first hook with current back-end's name as argument.
	 (run-hook-with-args 'org-export-before-processing-hook
			     (org-export-backend-name backend))
	 (org-export-expand-include-keyword)
	 ;; Update macro templates since #+INCLUDE keywords might have
	 ;; added some new ones.
	 (org-macro-initialize-templates)
	 (org-macro-replace-all org-macro-templates)
	 (org-export-execute-babel-code)
	 ;; Update radio targets since keyword inclusion might have
	 ;; added some more.
	 (org-update-radio-target-regexp)
	 ;; Run last hook with current back-end's name as argument.
	 (goto-char (point-min))
	 (save-excursion
	   (run-hook-with-args 'org-export-before-parsing-hook
			       (org-export-backend-name backend)))
	 ;; Update communication channel with environment.  Also
	 ;; install user's and developer's filters.
	 (setq info
	       (org-export-install-filters
		(org-combine-plists
		 info (org-export-get-environment backend subtreep ext-plist))))
	 ;; Expand export-specific set of macros: {{{author}}},
	 ;; {{{date}}}, {{{email}}} and {{{title}}}.  It must be done
	 ;; once regular macros have been expanded, since document
	 ;; keywords may contain one of them.
	 (org-macro-replace-all
	  (list (cons "author"
		      (org-element-interpret-data (plist-get info :author)))
		(cons "date"
		      (org-element-interpret-data (plist-get info :date)))
		;; EMAIL is not a parsed keyword: store it as-is.
		(cons "email" (or (plist-get info :email) ""))
		(cons "title"
		      (org-element-interpret-data (plist-get info :title)))))
	 ;; Call options filters and update export options.  We do not
	 ;; use `org-export-filter-apply-functions' here since the
	 ;; arity of such filters is different.
	 (let ((backend-name (org-export-backend-name backend)))
	   (dolist (filter (plist-get info :filter-options))
	     (let ((result (funcall filter info backend-name)))
	       (when result (setq info result)))))
	 ;; Parse buffer and call parse-tree filter on it.
	 (setq tree
	       (org-export-filter-apply-functions
		(plist-get info :filter-parse-tree)
		(org-element-parse-buffer nil visible-only) info))
	 ;; Now tree is complete, compute its properties and add them
	 ;; to communication channel.
	 (setq info
	       (org-combine-plists
		info (org-export-collect-tree-properties tree info)))
	 ;; Eventually transcode TREE.  Wrap the resulting string into
	 ;; a template.
	 (let* ((body (org-element-normalize-string
		       (or (org-export-data tree info) "")))
		(inner-template (cdr (assq 'inner-template
					   (plist-get info :translate-alist))))
		(full-body (if (not (functionp inner-template)) body
			     (funcall inner-template body info)))
		(template (cdr (assq 'template
				     (plist-get info :translate-alist)))))
	   ;; Remove all text properties since they cannot be
	   ;; retrieved from an external process.  Finally call
	   ;; final-output filter and return result.
	   (org-no-properties
	    (org-export-filter-apply-functions
	     (plist-get info :filter-final-output)
	     (if (or (not (functionp template)) body-only) full-body
	       (funcall template full-body info))
	     info))))))))

;;;###autoload
(defun org-export-string-as (string backend &optional body-only ext-plist)
  "Transcode STRING into BACKEND code.

BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.

When optional argument BODY-ONLY is non-nil, only return body
code, without preamble nor postamble.

Optional argument EXT-PLIST, when provided, is a property list
with external parameters overriding Org default settings, but
still inferior to file-local settings.

Return code as a string."
  (with-temp-buffer
    (insert string)
    (let ((org-inhibit-startup t)) (org-mode))
    (org-export-as backend nil nil body-only ext-plist)))

;;;###autoload
(defun org-export-replace-region-by (backend)
  "Replace the active region by its export to BACKEND.
BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end."
  (if (not (org-region-active-p))
      (user-error "No active region to replace")
    (let* ((beg (region-beginning))
	   (end (region-end))
	   (str (buffer-substring beg end)) rpl)
      (setq rpl (org-export-string-as str backend t))
      (delete-region beg end)
      (insert rpl))))

;;;###autoload
(defun org-export-insert-default-template (&optional backend subtreep)
  "Insert all export keywords with default values at beginning of line.

BACKEND is a symbol referring to the name of a registered export
back-end, for which specific export options should be added to
the template, or `default' for default template.  When it is nil,
the user will be prompted for a category.

If SUBTREEP is non-nil, export configuration will be set up
locally for the subtree through node properties."
  (interactive)
  (unless (derived-mode-p 'org-mode) (user-error "Not in an Org mode buffer"))
  (when (and subtreep (org-before-first-heading-p))
    (user-error "No subtree to set export options for"))
  (let ((node (and subtreep (save-excursion (org-back-to-heading t) (point))))
	(backend
	 (or backend
	     (intern
	      (org-completing-read
	       "Options category: "
	       (cons "default"
		     (mapcar (lambda (b)
			       (symbol-name (org-export-backend-name b)))
			     org-export--registered-backends))))))
	options keywords)
    ;; Populate OPTIONS and KEYWORDS.
    (dolist (entry (cond ((eq backend 'default) org-export-options-alist)
			 ((org-export-backend-p backend)
			  (org-export-backend-options backend))
			 (t (org-export-backend-options
			     (org-export-get-backend backend)))))
      (let ((keyword (nth 1 entry))
            (option (nth 2 entry)))
        (cond
         (keyword (unless (assoc keyword keywords)
                    (let ((value
                           (if (eq (nth 4 entry) 'split)
                               (mapconcat 'identity (eval (nth 3 entry)) " ")
                             (eval (nth 3 entry)))))
                      (push (cons keyword value) keywords))))
         (option (unless (assoc option options)
                   (push (cons option (eval (nth 3 entry))) options))))))
    ;; Move to an appropriate location in order to insert options.
    (unless subtreep (beginning-of-line))
    ;; First get TITLE, DATE, AUTHOR and EMAIL if they belong to the
    ;; list of available keywords.
    (when (assoc "TITLE" keywords)
      (let ((title
	     (or (let ((visited-file (buffer-file-name (buffer-base-buffer))))
		   (and visited-file
			(file-name-sans-extension
			 (file-name-nondirectory visited-file))))
		 (buffer-name (buffer-base-buffer)))))
	(if (not subtreep) (insert (format "#+TITLE: %s\n" title))
	  (org-entry-put node "EXPORT_TITLE" title))))
    (when (assoc "DATE" keywords)
      (let ((date (with-temp-buffer (org-insert-time-stamp (current-time)))))
	(if (not subtreep) (insert "#+DATE: " date "\n")
	  (org-entry-put node "EXPORT_DATE" date))))
    (when (assoc "AUTHOR" keywords)
      (let ((author (cdr (assoc "AUTHOR" keywords))))
	(if subtreep (org-entry-put node "EXPORT_AUTHOR" author)
	  (insert
	   (format "#+AUTHOR:%s\n"
		   (if (not (org-string-nw-p author)) ""
		     (concat " " author)))))))
    (when (assoc "EMAIL" keywords)
      (let ((email (cdr (assoc "EMAIL" keywords))))
	(if subtreep (org-entry-put node "EXPORT_EMAIL" email)
	  (insert
	   (format "#+EMAIL:%s\n"
		   (if (not (org-string-nw-p email)) ""
		     (concat " " email)))))))
    ;; Then (multiple) OPTIONS lines.  Never go past fill-column.
    (when options
      (let ((items
	     (mapcar
	      #'(lambda (opt) (format "%s:%S" (car opt) (cdr opt)))
	      (sort options (lambda (k1 k2) (string< (car k1) (car k2)))))))
	(if subtreep
	    (org-entry-put
	     node "EXPORT_OPTIONS" (mapconcat 'identity items " "))
	  (while items
	    (insert "#+OPTIONS:")
	    (let ((width 10))
	      (while (and items
			  (< (+ width (length (car items)) 1) fill-column))
		(let ((item (pop items)))
		  (insert " " item)
		  (incf width (1+ (length item))))))
	    (insert "\n")))))
    ;; And the rest of keywords.
    (dolist (key (sort keywords (lambda (k1 k2) (string< (car k1) (car k2)))))
      (unless (member (car key) '("TITLE" "DATE" "AUTHOR" "EMAIL"))
        (let ((val (cdr key)))
          (if subtreep (org-entry-put node (concat "EXPORT_" (car key)) val)
            (insert
             (format "#+%s:%s\n"
                     (car key)
                     (if (org-string-nw-p val) (format " %s" val) "")))))))))

(defun org-export-expand-include-keyword (&optional included dir)
  "Expand every include keyword in buffer.
Optional argument INCLUDED is a list of included file names along
with their line restriction, when appropriate.  It is used to
avoid infinite recursion.  Optional argument DIR is the current
working directory.  It is used to properly resolve relative
paths."
  (let ((case-fold-search t))
    (goto-char (point-min))
    (while (re-search-forward "^[ \t]*#\\+INCLUDE:" nil t)
      (let ((element (save-match-data (org-element-at-point))))
	(when (eq (org-element-type element) 'keyword)
	  (beginning-of-line)
	  ;; Extract arguments from keyword's value.
	  (let* ((value (org-element-property :value element))
		 (ind (org-get-indentation))
		 (file (and (string-match
			     "^\\(\".+?\"\\|\\S-+\\)\\(?:\\s-+\\|$\\)" value)
			    (prog1 (expand-file-name
				    (org-remove-double-quotes
				     (match-string 1 value))
				    dir)
			      (setq value (replace-match "" nil nil value)))))
		 (lines
		  (and (string-match
			":lines +\"\\(\\(?:[0-9]+\\)?-\\(?:[0-9]+\\)?\\)\""
			value)
		       (prog1 (match-string 1 value)
			 (setq value (replace-match "" nil nil value)))))
		 (env (cond ((string-match "\\<example\\>" value) 'example)
			    ((string-match "\\<src\\(?: +\\(.*\\)\\)?" value)
			     (match-string 1 value))))
		 ;; Minimal level of included file defaults to the child
		 ;; level of the current headline, if any, or one.  It
		 ;; only applies is the file is meant to be included as
		 ;; an Org one.
		 (minlevel
		  (and (not env)
		       (if (string-match ":minlevel +\\([0-9]+\\)" value)
			   (prog1 (string-to-number (match-string 1 value))
			     (setq value (replace-match "" nil nil value)))
			 (let ((cur (org-current-level)))
			   (if cur (1+ (org-reduced-level cur)) 1))))))
	    ;; Remove keyword.
	    (delete-region (point) (progn (forward-line) (point)))
	    (cond
	     ((not file) nil)
	     ((not (file-readable-p file))
	      (error "Cannot include file %s" file))
	     ;; Check if files has already been parsed.  Look after
	     ;; inclusion lines too, as different parts of the same file
	     ;; can be included too.
	     ((member (list file lines) included)
	      (error "Recursive file inclusion: %s" file))
	     (t
	      (cond
	       ((eq env 'example)
		(insert
		 (let ((ind-str (make-string ind ? ))
		       (contents
			(org-escape-code-in-string
			 (org-export--prepare-file-contents file lines))))
		   (format "%s#+BEGIN_EXAMPLE\n%s%s#+END_EXAMPLE\n"
			   ind-str contents ind-str))))
	       ((stringp env)
		(insert
		 (let ((ind-str (make-string ind ? ))
		       (contents
			(org-escape-code-in-string
			 (org-export--prepare-file-contents file lines))))
		   (format "%s#+BEGIN_SRC %s\n%s%s#+END_SRC\n"
			   ind-str env contents ind-str))))
	       (t
		(insert
		 (with-temp-buffer
		   (let ((org-inhibit-startup t)) (org-mode))
		   (insert
		    (org-export--prepare-file-contents file lines ind minlevel))
		   (org-export-expand-include-keyword
		    (cons (list file lines) included)
		    (file-name-directory file))
		   (buffer-string)))))))))))))

(defun org-export--prepare-file-contents (file &optional lines ind minlevel)
  "Prepare the contents of FILE for inclusion and return them as a string.

When optional argument LINES is a string specifying a range of
lines, include only those lines.

Optional argument IND, when non-nil, is an integer specifying the
global indentation of returned contents.  Since its purpose is to
allow an included file to stay in the same environment it was
created \(i.e. a list item), it doesn't apply past the first
headline encountered.

Optional argument MINLEVEL, when non-nil, is an integer
specifying the level that any top-level headline in the included
file should have."
  (with-temp-buffer
    (insert-file-contents file)
    (when lines
      (let* ((lines (split-string lines "-"))
	     (lbeg (string-to-number (car lines)))
	     (lend (string-to-number (cadr lines)))
	     (beg (if (zerop lbeg) (point-min)
		    (goto-char (point-min))
		    (forward-line (1- lbeg))
		    (point)))
	     (end (if (zerop lend) (point-max)
		    (goto-char (point-min))
		    (forward-line (1- lend))
		    (point))))
	(narrow-to-region beg end)))
    ;; Remove blank lines at beginning and end of contents.  The logic
    ;; behind that removal is that blank lines around include keyword
    ;; override blank lines in included file.
    (goto-char (point-min))
    (org-skip-whitespace)
    (beginning-of-line)
    (delete-region (point-min) (point))
    (goto-char (point-max))
    (skip-chars-backward " \r\t\n")
    (forward-line)
    (delete-region (point) (point-max))
    ;; If IND is set, preserve indentation of include keyword until
    ;; the first headline encountered.
    (when ind
      (unless (eq major-mode 'org-mode)
	(let ((org-inhibit-startup t)) (org-mode)))
      (goto-char (point-min))
      (let ((ind-str (make-string ind ? )))
	(while (not (or (eobp) (looking-at org-outline-regexp-bol)))
	  ;; Do not move footnote definitions out of column 0.
	  (unless (and (looking-at org-footnote-definition-re)
		       (eq (org-element-type (org-element-at-point))
			   'footnote-definition))
	    (insert ind-str))
	  (forward-line))))
    ;; When MINLEVEL is specified, compute minimal level for headlines
    ;; in the file (CUR-MIN), and remove stars to each headline so
    ;; that headlines with minimal level have a level of MINLEVEL.
    (when minlevel
      (unless (eq major-mode 'org-mode)
	(let ((org-inhibit-startup t)) (org-mode)))
      (org-with-limited-levels
       (let ((levels (org-map-entries
		      (lambda () (org-reduced-level (org-current-level))))))
	 (when levels
	   (let ((offset (- minlevel (apply 'min levels))))
	     (unless (zerop offset)
	       (when org-odd-levels-only (setq offset (* offset 2)))
	       ;; Only change stars, don't bother moving whole
	       ;; sections.
	       (org-map-entries
		(lambda () (if (< offset 0) (delete-char (abs offset))
			(insert (make-string offset ?*)))))))))))
    (org-element-normalize-string (buffer-string))))

(defun org-export-execute-babel-code ()
  "Execute every Babel code in the visible part of current buffer."
  ;; Get a pristine copy of current buffer so Babel references can be
  ;; properly resolved.
  (let ((reference (org-export-copy-buffer)))
    (unwind-protect (let ((org-current-export-file reference))
		      (org-babel-exp-process-buffer))
      (kill-buffer reference))))

(defun org-export--copy-to-kill-ring-p ()
  "Return a non-nil value when output should be added to the kill ring.
See also `org-export-copy-to-kill-ring'."
  (if (eq org-export-copy-to-kill-ring 'if-interactive)
      (not (or executing-kbd-macro noninteractive))
    (eq org-export-copy-to-kill-ring t)))



;;; Tools For Back-Ends
;;
;; A whole set of tools is available to help build new exporters.  Any
;; function general enough to have its use across many back-ends
;; should be added here.

;;;; For Affiliated Keywords
;;
;; `org-export-read-attribute' reads a property from a given element
;;  as a plist.  It can be used to normalize affiliated keywords'
;;  syntax.
;;
;; Since captions can span over multiple lines and accept dual values,
;; their internal representation is a bit tricky.  Therefore,
;; `org-export-get-caption' transparently returns a given element's
;; caption as a secondary string.

(defun org-export-read-attribute (attribute element &optional property)
  "Turn ATTRIBUTE property from ELEMENT into a plist.

When optional argument PROPERTY is non-nil, return the value of
that property within attributes.

This function assumes attributes are defined as \":keyword
value\" pairs.  It is appropriate for `:attr_html' like
properties.

All values will become strings except the empty string and
\"nil\", which will become nil.  Also, values containing only
double quotes will be read as-is, which means that \"\" value
will become the empty string."
  (let* ((prepare-value
	  (lambda (str)
	    (save-match-data
	      (cond ((member str '(nil "" "nil")) nil)
		    ((string-match "^\"\\(\"+\\)?\"$" str)
		     (or (match-string 1 str) ""))
		    (t str)))))
	 (attributes
	  (let ((value (org-element-property attribute element)))
	    (when value
	      (let ((s (mapconcat 'identity value " ")) result)
		(while (string-match
			"\\(?:^\\|[ \t]+\\)\\(:[-a-zA-Z0-9_]+\\)\\([ \t]+\\|$\\)"
			s)
		  (let ((value (substring s 0 (match-beginning 0))))
		    (push (funcall prepare-value value) result))
		  (push (intern (match-string 1 s)) result)
		  (setq s (substring s (match-end 0))))
		;; Ignore any string before first property with `cdr'.
		(cdr (nreverse (cons (funcall prepare-value s) result))))))))
    (if property (plist-get attributes property) attributes)))

(defun org-export-get-caption (element &optional shortp)
  "Return caption from ELEMENT as a secondary string.

When optional argument SHORTP is non-nil, return short caption,
as a secondary string, instead.

Caption lines are separated by a white space."
  (let ((full-caption (org-element-property :caption element)) caption)
    (dolist (line full-caption (cdr caption))
      (let ((cap (funcall (if shortp 'cdr 'car) line)))
	(when cap
	  (setq caption (nconc (list " ") (copy-sequence cap) caption)))))))


;;;; For Derived Back-ends
;;
;; `org-export-with-backend' is a function allowing to locally use
;; another back-end to transcode some object or element.  In a derived
;; back-end, it may be used as a fall-back function once all specific
;; cases have been treated.

(defun org-export-with-backend (backend data &optional contents info)
  "Call a transcoder from BACKEND on DATA.
BACKEND is an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.  DATA is an Org element, object, secondary
string or string.  CONTENTS, when non-nil, is the transcoded
contents of DATA element, as a string.  INFO, when non-nil, is
the communication channel used for export, as a plist."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (org-export-barf-if-invalid-backend backend)
  (let ((type (org-element-type data)))
    (if (memq type '(nil org-data)) (error "No foreign transcoder available")
      (let* ((all-transcoders (org-export-get-all-transcoders backend))
	     (transcoder (cdr (assq type all-transcoders))))
	(if (not (functionp transcoder))
	    (error "No foreign transcoder available")
	  (funcall
	   transcoder data contents
	   (org-combine-plists
	    info (list :back-end backend
		       :translate-alist all-transcoders
		       :exported-data (make-hash-table :test 'eq :size 401)))))))))


;;;; For Export Snippets
;;
;; Every export snippet is transmitted to the back-end.  Though, the
;; latter will only retain one type of export-snippet, ignoring
;; others, based on the former's target back-end.  The function
;; `org-export-snippet-backend' returns that back-end for a given
;; export-snippet.

(defun org-export-snippet-backend (export-snippet)
  "Return EXPORT-SNIPPET targeted back-end as a symbol.
Translation, with `org-export-snippet-translation-alist', is
applied."
  (let ((back-end (org-element-property :back-end export-snippet)))
    (intern
     (or (cdr (assoc back-end org-export-snippet-translation-alist))
	 back-end))))


;;;; For Footnotes
;;
;; `org-export-collect-footnote-definitions' is a tool to list
;; actually used footnotes definitions in the whole parse tree, or in
;; a headline, in order to add footnote listings throughout the
;; transcoded data.
;;
;; `org-export-footnote-first-reference-p' is a predicate used by some
;; back-ends, when they need to attach the footnote definition only to
;; the first occurrence of the corresponding label.
;;
;; `org-export-get-footnote-definition' and
;; `org-export-get-footnote-number' provide easier access to
;; additional information relative to a footnote reference.

(defun org-export-collect-footnote-definitions (data info)
  "Return an alist between footnote numbers, labels and definitions.

DATA is the parse tree from which definitions are collected.
INFO is the plist used as a communication channel.

Definitions are sorted by order of references.  They either
appear as Org data or as a secondary string for inlined
footnotes.  Unreferenced definitions are ignored."
  (let* (num-alist
	 collect-fn			; for byte-compiler.
	 (collect-fn
	  (function
	   (lambda (data)
	     ;; Collect footnote number, label and definition in DATA.
	     (org-element-map data 'footnote-reference
	       (lambda (fn)
		 (when (org-export-footnote-first-reference-p fn info)
		   (let ((def (org-export-get-footnote-definition fn info)))
		     (push
		      (list (org-export-get-footnote-number fn info)
			    (org-element-property :label fn)
			    def)
		      num-alist)
		     ;; Also search in definition for nested footnotes.
		     (when (eq (org-element-property :type fn) 'standard)
		       (funcall collect-fn def)))))
	       ;; Don't enter footnote definitions since it will happen
	       ;; when their first reference is found.
	       info nil 'footnote-definition)))))
    (funcall collect-fn (plist-get info :parse-tree))
    (reverse num-alist)))

(defun org-export-footnote-first-reference-p (footnote-reference info)
  "Non-nil when a footnote reference is the first one for its label.

FOOTNOTE-REFERENCE is the footnote reference being considered.
INFO is the plist used as a communication channel."
  (let ((label (org-element-property :label footnote-reference)))
    ;; Anonymous footnotes are always a first reference.
    (if (not label) t
      ;; Otherwise, return the first footnote with the same LABEL and
      ;; test if it is equal to FOOTNOTE-REFERENCE.
      (let* (search-refs		; for byte-compiler.
	     (search-refs
	      (function
	       (lambda (data)
		 (org-element-map data 'footnote-reference
		   (lambda (fn)
		     (cond
		      ((string= (org-element-property :label fn) label)
		       (throw 'exit fn))
		      ;; If FN isn't inlined, be sure to traverse its
		      ;; definition before resuming search.  See
		      ;; comments in `org-export-get-footnote-number'
		      ;; for more information.
		      ((eq (org-element-property :type fn) 'standard)
		       (funcall search-refs
				(org-export-get-footnote-definition fn info)))))
		   ;; Don't enter footnote definitions since it will
		   ;; happen when their first reference is found.
		   info 'first-match 'footnote-definition)))))
	(eq (catch 'exit (funcall search-refs (plist-get info :parse-tree)))
	    footnote-reference)))))

(defun org-export-get-footnote-definition (footnote-reference info)
  "Return definition of FOOTNOTE-REFERENCE as parsed data.
INFO is the plist used as a communication channel.  If no such
definition can be found, return the \"DEFINITION NOT FOUND\"
string."
  (let ((label (org-element-property :label footnote-reference)))
    (or (org-element-property :inline-definition footnote-reference)
        (cdr (assoc label (plist-get info :footnote-definition-alist)))
	"DEFINITION NOT FOUND.")))

(defun org-export-get-footnote-number (footnote info)
  "Return number associated to a footnote.

FOOTNOTE is either a footnote reference or a footnote definition.
INFO is the plist used as a communication channel."
  (let* ((label (org-element-property :label footnote))
	 seen-refs
	 search-ref			; For byte-compiler.
	 (search-ref
	  (function
	   (lambda (data)
	     ;; Search footnote references through DATA, filling
	     ;; SEEN-REFS along the way.
	     (org-element-map data 'footnote-reference
	       (lambda (fn)
		 (let ((fn-lbl (org-element-property :label fn)))
		   (cond
		    ;; Anonymous footnote match: return number.
		    ((and (not fn-lbl) (eq fn footnote))
		     (throw 'exit (1+ (length seen-refs))))
		    ;; Labels match: return number.
		    ((and label (string= label fn-lbl))
		     (throw 'exit (1+ (length seen-refs))))
		    ;; Anonymous footnote: it's always a new one.
		    ;; Also, be sure to return nil from the `cond' so
		    ;; `first-match' doesn't get us out of the loop.
		    ((not fn-lbl) (push 'inline seen-refs) nil)
		    ;; Label not seen so far: add it so SEEN-REFS.
		    ;;
		    ;; Also search for subsequent references in
		    ;; footnote definition so numbering follows
		    ;; reading logic.  Note that we don't have to care
		    ;; about inline definitions, since
		    ;; `org-element-map' already traverses them at the
		    ;; right time.
		    ;;
		    ;; Once again, return nil to stay in the loop.
		    ((not (member fn-lbl seen-refs))
		     (push fn-lbl seen-refs)
		     (funcall search-ref
			      (org-export-get-footnote-definition fn info))
		     nil))))
	       ;; Don't enter footnote definitions since it will
	       ;; happen when their first reference is found.
	       info 'first-match 'footnote-definition)))))
    (catch 'exit (funcall search-ref (plist-get info :parse-tree)))))


;;;; For Headlines
;;
;; `org-export-get-relative-level' is a shortcut to get headline
;; level, relatively to the lower headline level in the parsed tree.
;;
;; `org-export-get-headline-number' returns the section number of an
;; headline, while `org-export-number-to-roman' allows to convert it
;; to roman numbers.
;;
;; `org-export-low-level-p', `org-export-first-sibling-p' and
;; `org-export-last-sibling-p' are three useful predicates when it
;; comes to fulfill the `:headline-levels' property.
;;
;; `org-export-get-tags', `org-export-get-category' and
;; `org-export-get-node-property' extract useful information from an
;; headline or a parent headline.  They all handle inheritance.
;;
;; `org-export-get-alt-title' tries to retrieve an alternative title,
;; as a secondary string, suitable for table of contents.  It falls
;; back onto default title.

(defun org-export-get-relative-level (headline info)
  "Return HEADLINE relative level within current parsed tree.
INFO is a plist holding contextual information."
  (+ (org-element-property :level headline)
     (or (plist-get info :headline-offset) 0)))

(defun org-export-low-level-p (headline info)
  "Non-nil when HEADLINE is considered as low level.

INFO is a plist used as a communication channel.

A low level headlines has a relative level greater than
`:headline-levels' property value.

Return value is the difference between HEADLINE relative level
and the last level being considered as high enough, or nil."
  (let ((limit (plist-get info :headline-levels)))
    (when (wholenump limit)
      (let ((level (org-export-get-relative-level headline info)))
        (and (> level limit) (- level limit))))))

(defun org-export-get-headline-number (headline info)
  "Return HEADLINE numbering as a list of numbers.
INFO is a plist holding contextual information."
  (cdr (assoc headline (plist-get info :headline-numbering))))

(defun org-export-numbered-headline-p (headline info)
  "Return a non-nil value if HEADLINE element should be numbered.
INFO is a plist used as a communication channel."
  (let ((sec-num (plist-get info :section-numbers))
	(level (org-export-get-relative-level headline info)))
    (if (wholenump sec-num) (<= level sec-num) sec-num)))

(defun org-export-number-to-roman (n)
  "Convert integer N into a roman numeral."
  (let ((roman '((1000 . "M") (900 . "CM") (500 . "D") (400 . "CD")
		 ( 100 . "C") ( 90 . "XC") ( 50 . "L") ( 40 . "XL")
		 (  10 . "X") (  9 . "IX") (  5 . "V") (  4 . "IV")
		 (   1 . "I")))
	(res ""))
    (if (<= n 0)
	(number-to-string n)
      (while roman
	(if (>= n (caar roman))
	    (setq n (- n (caar roman))
		  res (concat res (cdar roman)))
	  (pop roman)))
      res)))

(defun org-export-get-tags (element info &optional tags inherited)
  "Return list of tags associated to ELEMENT.

ELEMENT has either an `headline' or an `inlinetask' type.  INFO
is a plist used as a communication channel.

Select tags (see `org-export-select-tags') and exclude tags (see
`org-export-exclude-tags') are removed from the list.

When non-nil, optional argument TAGS should be a list of strings.
Any tag belonging to this list will also be removed.

When optional argument INHERITED is non-nil, tags can also be
inherited from parent headlines and FILETAGS keywords."
  (org-remove-if
   (lambda (tag) (or (member tag (plist-get info :select-tags))
		(member tag (plist-get info :exclude-tags))
		(member tag tags)))
   (if (not inherited) (org-element-property :tags element)
     ;; Build complete list of inherited tags.
     (let ((current-tag-list (org-element-property :tags element)))
       (mapc
	(lambda (parent)
	  (mapc
	   (lambda (tag)
	     (when (and (memq (org-element-type parent) '(headline inlinetask))
			(not (member tag current-tag-list)))
	       (push tag current-tag-list)))
	   (org-element-property :tags parent)))
	(org-export-get-genealogy element))
       ;; Add FILETAGS keywords and return results.
       (org-uniquify (append (plist-get info :filetags) current-tag-list))))))

(defun org-export-get-node-property (property blob &optional inherited)
  "Return node PROPERTY value for BLOB.

PROPERTY is an upcase symbol (i.e. `:COOKIE_DATA').  BLOB is an
element or object.

If optional argument INHERITED is non-nil, the value can be
inherited from a parent headline.

Return value is a string or nil."
  (let ((headline (if (eq (org-element-type blob) 'headline) blob
		    (org-export-get-parent-headline blob))))
    (if (not inherited) (org-element-property property blob)
      (let ((parent headline) value)
	(catch 'found
	  (while parent
	    (when (plist-member (nth 1 parent) property)
	      (throw 'found (org-element-property property parent)))
	    (setq parent (org-element-property :parent parent))))))))

(defun org-export-get-category (blob info)
  "Return category for element or object BLOB.

INFO is a plist used as a communication channel.

CATEGORY is automatically inherited from a parent headline, from
#+CATEGORY: keyword or created out of original file name.  If all
fail, the fall-back value is \"???\"."
  (or (let ((headline (if (eq (org-element-type blob) 'headline) blob
			(org-export-get-parent-headline blob))))
	;; Almost like `org-export-node-property', but we cannot trust
	;; `plist-member' as every headline has a `:CATEGORY'
	;; property, would it be nil or equal to "???" (which has the
	;; same meaning).
	(let ((parent headline) value)
	  (catch 'found
	    (while parent
	      (let ((category (org-element-property :CATEGORY parent)))
		(and category (not (equal "???" category))
		     (throw 'found category)))
	      (setq parent (org-element-property :parent parent))))))
      (org-element-map (plist-get info :parse-tree) 'keyword
	(lambda (kwd)
	  (when (equal (org-element-property :key kwd) "CATEGORY")
	    (org-element-property :value kwd)))
	info 'first-match)
      (let ((file (plist-get info :input-file)))
	(and file (file-name-sans-extension (file-name-nondirectory file))))
      "???"))

(defun org-export-get-alt-title (headline info)
  "Return alternative title for HEADLINE, as a secondary string.
INFO is a plist used as a communication channel.  If no optional
title is defined, fall-back to the regular title."
  (or (org-element-property :alt-title headline)
      (org-element-property :title headline)))

(defun org-export-first-sibling-p (headline info)
  "Non-nil when HEADLINE is the first sibling in its sub-tree.
INFO is a plist used as a communication channel."
  (not (eq (org-element-type (org-export-get-previous-element headline info))
	   'headline)))

(defun org-export-last-sibling-p (headline info)
  "Non-nil when HEADLINE is the last sibling in its sub-tree.
INFO is a plist used as a communication channel."
  (not (org-export-get-next-element headline info)))


;;;; For Keywords
;;
;; `org-export-get-date' returns a date appropriate for the document
;;  to about to be exported.  In particular, it takes care of
;;  `org-export-date-timestamp-format'.

(defun org-export-get-date (info &optional fmt)
  "Return date value for the current document.

INFO is a plist used as a communication channel.  FMT, when
non-nil, is a time format string that will be applied on the date
if it consists in a single timestamp object.  It defaults to
`org-export-date-timestamp-format' when nil.

A proper date can be a secondary string, a string or nil.  It is
meant to be translated with `org-export-data' or alike."
  (let ((date (plist-get info :date))
	(fmt (or fmt org-export-date-timestamp-format)))
    (cond ((not date) nil)
	  ((and fmt
		(not (cdr date))
		(eq (org-element-type (car date)) 'timestamp))
	   (org-timestamp-format (car date) fmt))
	  (t date))))


;;;; For Links
;;
;; `org-export-solidify-link-text' turns a string into a safer version
;; for links, replacing most non-standard characters with hyphens.
;;
;; `org-export-get-coderef-format' returns an appropriate format
;; string for coderefs.
;;
;; `org-export-inline-image-p' returns a non-nil value when the link
;; provided should be considered as an inline image.
;;
;; `org-export-resolve-fuzzy-link' searches destination of fuzzy links
;; (i.e. links with "fuzzy" as type) within the parsed tree, and
;; returns an appropriate unique identifier when found, or nil.
;;
;; `org-export-resolve-id-link' returns the first headline with
;; specified id or custom-id in parse tree, the path to the external
;; file with the id or nil when neither was found.
;;
;; `org-export-resolve-coderef' associates a reference to a line
;; number in the element it belongs, or returns the reference itself
;; when the element isn't numbered.

(defun org-export-solidify-link-text (s)
  "Take link text S and make a safe target out of it."
  (save-match-data
    (mapconcat 'identity (org-split-string s "[^a-zA-Z0-9_.-:]+") "-")))

(defun org-export-get-coderef-format (path desc)
  "Return format string for code reference link.
PATH is the link path.  DESC is its description."
  (save-match-data
    (cond ((not desc) "%s")
	  ((string-match (regexp-quote (concat "(" path ")")) desc)
	   (replace-match "%s" t t desc))
	  (t desc))))

(defun org-export-inline-image-p (link &optional rules)
  "Non-nil if LINK object points to an inline image.

Optional argument is a set of RULES defining inline images.  It
is an alist where associations have the following shape:

  \(TYPE . REGEXP)

Applying a rule means apply REGEXP against LINK's path when its
type is TYPE.  The function will return a non-nil value if any of
the provided rules is non-nil.  The default rule is
`org-export-default-inline-image-rule'.

This only applies to links without a description."
  (and (not (org-element-contents link))
       (let ((case-fold-search t)
	     (rules (or rules org-export-default-inline-image-rule)))
	 (catch 'exit
	   (mapc
	    (lambda (rule)
	      (and (string= (org-element-property :type link) (car rule))
		   (string-match (cdr rule)
				 (org-element-property :path link))
		   (throw 'exit t)))
	    rules)
	   ;; Return nil if no rule matched.
	   nil))))

(defun org-export-resolve-coderef (ref info)
  "Resolve a code reference REF.

INFO is a plist used as a communication channel.

Return associated line number in source code, or REF itself,
depending on src-block or example element's switches."
  (org-element-map (plist-get info :parse-tree) '(example-block src-block)
    (lambda (el)
      (with-temp-buffer
	(insert (org-trim (org-element-property :value el)))
	(let* ((label-fmt (regexp-quote
			   (or (org-element-property :label-fmt el)
			       org-coderef-label-format)))
	       (ref-re
		(format "^.*?\\S-.*?\\([ \t]*\\(%s\\)\\)[ \t]*$"
			(replace-regexp-in-string "%s" ref label-fmt nil t))))
	  ;; Element containing REF is found.  Resolve it to either
	  ;; a label or a line number, as needed.
	  (when (re-search-backward ref-re nil t)
	    (cond
	     ((org-element-property :use-labels el) ref)
	     ((eq (org-element-property :number-lines el) 'continued)
	      (+ (org-export-get-loc el info) (line-number-at-pos)))
	     (t (line-number-at-pos)))))))
    info 'first-match))

(defun org-export-resolve-fuzzy-link (link info)
  "Return LINK destination.

INFO is a plist holding contextual information.

Return value can be an object, an element, or nil:

- If LINK path matches a target object (i.e. <<path>>) return it.

- If LINK path exactly matches the name affiliated keyword
  \(i.e. #+NAME: path) of an element, return that element.

- If LINK path exactly matches any headline name, return that
  element.  If more than one headline share that name, priority
  will be given to the one with the closest common ancestor, if
  any, or the first one in the parse tree otherwise.

- Otherwise, return nil.

Assume LINK type is \"fuzzy\".  White spaces are not
significant."
  (let* ((raw-path (org-element-property :path link))
	 (match-title-p (eq (aref raw-path 0) ?*))
	 ;; Split PATH at white spaces so matches are space
	 ;; insensitive.
	 (path (org-split-string
		(if match-title-p (substring raw-path 1) raw-path)))
	 ;; Cache for destinations that are not position dependent.
	 (link-cache
	  (or (plist-get info :resolve-fuzzy-link-cache)
	      (plist-get (setq info (plist-put info :resolve-fuzzy-link-cache
					       (make-hash-table :test 'equal)))
			 :resolve-fuzzy-link-cache)))
	 (cached (gethash path link-cache 'not-found)))
    (cond
     ;; Destination is not position dependent: use cached value.
     ((and (not match-title-p) (not (eq cached 'not-found))) cached)
     ;; First try to find a matching "<<path>>" unless user specified
     ;; he was looking for a headline (path starts with a "*"
     ;; character).
     ((and (not match-title-p)
	   (let ((match (org-element-map (plist-get info :parse-tree) 'target
			  (lambda (blob)
			    (and (equal (org-split-string
					 (org-element-property :value blob))
					path)
				 blob))
			  info 'first-match)))
	     (and match (puthash path match link-cache)))))
     ;; Then try to find an element with a matching "#+NAME: path"
     ;; affiliated keyword.
     ((and (not match-title-p)
	   (let ((match (org-element-map (plist-get info :parse-tree)
			    org-element-all-elements
			  (lambda (el)
			    (let ((name (org-element-property :name el)))
			      (when (and name
					 (equal (org-split-string name) path))
				el)))
			  info 'first-match)))
	     (and match (puthash path match link-cache)))))
     ;; Last case: link either points to a headline or to nothingness.
     ;; Try to find the source, with priority given to headlines with
     ;; the closest common ancestor.  If such candidate is found,
     ;; return it, otherwise return nil.
     (t
      (let ((find-headline
	     (function
	      ;; Return first headline whose `:raw-value' property is
	      ;; NAME in parse tree DATA, or nil.  Statistics cookies
	      ;; are ignored.
	      (lambda (name data)
		(org-element-map data 'headline
		  (lambda (headline)
		    (when (equal (org-split-string
				  (replace-regexp-in-string
				   "\\[[0-9]+%\\]\\|\\[[0-9]+/[0-9]+\\]" ""
				   (org-element-property :raw-value headline)))
				 name)
		      headline))
		  info 'first-match)))))
	;; Search among headlines sharing an ancestor with link, from
	;; closest to farthest.
	(catch 'exit
	  (mapc
	   (lambda (parent)
	     (let ((foundp (funcall find-headline path parent)))
	       (when foundp (throw 'exit foundp))))
	   (let ((parent-hl (org-export-get-parent-headline link)))
	     (if (not parent-hl) (list (plist-get info :parse-tree))
	       (cons parent-hl (org-export-get-genealogy parent-hl)))))
	  ;; No destination found: return nil.
	  (and (not match-title-p) (puthash path nil link-cache))))))))

(defun org-export-resolve-id-link (link info)
  "Return headline referenced as LINK destination.

INFO is a plist used as a communication channel.

Return value can be the headline element matched in current parse
tree, a file name or nil.  Assume LINK type is either \"id\" or
\"custom-id\"."
  (let ((id (org-element-property :path link)))
    ;; First check if id is within the current parse tree.
    (or (org-element-map (plist-get info :parse-tree) 'headline
	  (lambda (headline)
	    (when (or (string= (org-element-property :ID headline) id)
		      (string= (org-element-property :CUSTOM_ID headline) id))
	      headline))
	  info 'first-match)
	;; Otherwise, look for external files.
	(cdr (assoc id (plist-get info :id-alist))))))

(defun org-export-resolve-radio-link (link info)
  "Return radio-target object referenced as LINK destination.

INFO is a plist used as a communication channel.

Return value can be a radio-target object or nil.  Assume LINK
has type \"radio\"."
  (let ((path (replace-regexp-in-string
	       "[ \r\t\n]+" " " (org-element-property :path link))))
    (org-element-map (plist-get info :parse-tree) 'radio-target
      (lambda (radio)
	(and (eq (compare-strings
		  (replace-regexp-in-string
		   "[ \r\t\n]+" " " (org-element-property :value radio))
		  nil nil path nil nil t)
		 t)
	     radio))
      info 'first-match)))


;;;; For References
;;
;; `org-export-get-ordinal' associates a sequence number to any object
;; or element.

(defun org-export-get-ordinal (element info &optional types predicate)
  "Return ordinal number of an element or object.

ELEMENT is the element or object considered.  INFO is the plist
used as a communication channel.

Optional argument TYPES, when non-nil, is a list of element or
object types, as symbols, that should also be counted in.
Otherwise, only provided element's type is considered.

Optional argument PREDICATE is a function returning a non-nil
value if the current element or object should be counted in.  It
accepts two arguments: the element or object being considered and
the plist used as a communication channel.  This allows to count
only a certain type of objects (i.e. inline images).

Return value is a list of numbers if ELEMENT is a headline or an
item.  It is nil for keywords.  It represents the footnote number
for footnote definitions and footnote references.  If ELEMENT is
a target, return the same value as if ELEMENT was the closest
table, item or headline containing the target.  In any other
case, return the sequence number of ELEMENT among elements or
objects of the same type."
  ;; Ordinal of a target object refer to the ordinal of the closest
  ;; table, item, or headline containing the object.
  (when (eq (org-element-type element) 'target)
    (setq element
	  (loop for parent in (org-export-get-genealogy element)
		when
		(memq
		 (org-element-type parent)
		 '(footnote-definition footnote-reference headline item
				       table))
		return parent)))
  (case (org-element-type element)
    ;; Special case 1: A headline returns its number as a list.
    (headline (org-export-get-headline-number element info))
    ;; Special case 2: An item returns its number as a list.
    (item (let ((struct (org-element-property :structure element)))
	    (org-list-get-item-number
	     (org-element-property :begin element)
	     struct
	     (org-list-prevs-alist struct)
	     (org-list-parents-alist struct))))
    ((footnote-definition footnote-reference)
     (org-export-get-footnote-number element info))
    (otherwise
     (let ((counter 0))
       ;; Increment counter until ELEMENT is found again.
       (org-element-map (plist-get info :parse-tree)
	   (or types (org-element-type element))
	 (lambda (el)
	   (cond
	    ((eq element el) (1+ counter))
	    ((not predicate) (incf counter) nil)
	    ((funcall predicate el info) (incf counter) nil)))
	 info 'first-match)))))


;;;; For Src-Blocks
;;
;; `org-export-get-loc' counts number of code lines accumulated in
;; src-block or example-block elements with a "+n" switch until
;; a given element, excluded.  Note: "-n" switches reset that count.
;;
;; `org-export-unravel-code' extracts source code (along with a code
;; references alist) from an `element-block' or `src-block' type
;; element.
;;
;; `org-export-format-code' applies a formatting function to each line
;; of code, providing relative line number and code reference when
;; appropriate.  Since it doesn't access the original element from
;; which the source code is coming, it expects from the code calling
;; it to know if lines should be numbered and if code references
;; should appear.
;;
;; Eventually, `org-export-format-code-default' is a higher-level
;; function (it makes use of the two previous functions) which handles
;; line numbering and code references inclusion, and returns source
;; code in a format suitable for plain text or verbatim output.

(defun org-export-get-loc (element info)
  "Return accumulated lines of code up to ELEMENT.

INFO is the plist used as a communication channel.

ELEMENT is excluded from count."
  (let ((loc 0))
    (org-element-map (plist-get info :parse-tree)
	`(src-block example-block ,(org-element-type element))
      (lambda (el)
	(cond
	 ;; ELEMENT is reached: Quit the loop.
	 ((eq el element))
	 ;; Only count lines from src-block and example-block elements
	 ;; with a "+n" or "-n" switch.  A "-n" switch resets counter.
	 ((not (memq (org-element-type el) '(src-block example-block))) nil)
	 ((let ((linums (org-element-property :number-lines el)))
	    (when linums
	      ;; Accumulate locs or reset them.
	      (let ((lines (org-count-lines
			    (org-trim (org-element-property :value el)))))
		(setq loc (if (eq linums 'new) lines (+ loc lines))))))
	  ;; Return nil to stay in the loop.
	  nil)))
      info 'first-match)
    ;; Return value.
    loc))

(defun org-export-unravel-code (element)
  "Clean source code and extract references out of it.

ELEMENT has either a `src-block' an `example-block' type.

Return a cons cell whose CAR is the source code, cleaned from any
reference and protective comma and CDR is an alist between
relative line number (integer) and name of code reference on that
line (string)."
  (let* ((line 0) refs
	 ;; Get code and clean it.  Remove blank lines at its
	 ;; beginning and end.
	 (code (replace-regexp-in-string
		"\\`\\([ \t]*\n\\)+" ""
		(replace-regexp-in-string
		 "\\([ \t]*\n\\)*[ \t]*\\'" "\n"
		 (org-element-property :value element))))
	 ;; Get format used for references.
	 (label-fmt (regexp-quote
		     (or (org-element-property :label-fmt element)
			 org-coderef-label-format)))
	 ;; Build a regexp matching a loc with a reference.
	 (with-ref-re
	  (format "^.*?\\S-.*?\\([ \t]*\\(%s\\)[ \t]*\\)$"
		  (replace-regexp-in-string
		   "%s" "\\([-a-zA-Z0-9_ ]+\\)" label-fmt nil t))))
    ;; Return value.
    (cons
     ;; Code with references removed.
     (org-element-normalize-string
      (mapconcat
       (lambda (loc)
	 (incf line)
	 (if (not (string-match with-ref-re loc)) loc
	   ;; Ref line: remove ref, and signal its position in REFS.
	   (push (cons line (match-string 3 loc)) refs)
	   (replace-match "" nil nil loc 1)))
       (org-split-string code "\n") "\n"))
     ;; Reference alist.
     refs)))

(defun org-export-format-code (code fun &optional num-lines ref-alist)
  "Format CODE by applying FUN line-wise and return it.

CODE is a string representing the code to format.  FUN is
a function.  It must accept three arguments: a line of
code (string), the current line number (integer) or nil and the
reference associated to the current line (string) or nil.

Optional argument NUM-LINES can be an integer representing the
number of code lines accumulated until the current code.  Line
numbers passed to FUN will take it into account.  If it is nil,
FUN's second argument will always be nil.  This number can be
obtained with `org-export-get-loc' function.

Optional argument REF-ALIST can be an alist between relative line
number (i.e. ignoring NUM-LINES) and the name of the code
reference on it.  If it is nil, FUN's third argument will always
be nil.  It can be obtained through the use of
`org-export-unravel-code' function."
  (let ((--locs (org-split-string code "\n"))
	(--line 0))
    (org-element-normalize-string
     (mapconcat
      (lambda (--loc)
	(incf --line)
	(let ((--ref (cdr (assq --line ref-alist))))
	  (funcall fun --loc (and num-lines (+ num-lines --line)) --ref)))
      --locs "\n"))))

(defun org-export-format-code-default (element info)
  "Return source code from ELEMENT, formatted in a standard way.

ELEMENT is either a `src-block' or `example-block' element.  INFO
is a plist used as a communication channel.

This function takes care of line numbering and code references
inclusion.  Line numbers, when applicable, appear at the
beginning of the line, separated from the code by two white
spaces.  Code references, on the other hand, appear flushed to
the right, separated by six white spaces from the widest line of
code."
  ;; Extract code and references.
  (let* ((code-info (org-export-unravel-code element))
         (code (car code-info))
	 (code-lines (org-split-string code "\n")))
    (if (null code-lines) ""
      (let* ((refs (and (org-element-property :retain-labels element)
			(cdr code-info)))
	     ;; Handle line numbering.
	     (num-start (case (org-element-property :number-lines element)
			  (continued (org-export-get-loc element info))
			  (new 0)))
	     (num-fmt
	      (and num-start
		   (format "%%%ds  "
			   (length (number-to-string
				    (+ (length code-lines) num-start))))))
	     ;; Prepare references display, if required.  Any reference
	     ;; should start six columns after the widest line of code,
	     ;; wrapped with parenthesis.
	     (max-width
	      (+ (apply 'max (mapcar 'length code-lines))
		 (if (not num-start) 0 (length (format num-fmt num-start))))))
	(org-export-format-code
	 code
	 (lambda (loc line-num ref)
	   (let ((number-str (and num-fmt (format num-fmt line-num))))
	     (concat
	      number-str
	      loc
	      (and ref
		   (concat (make-string
			    (- (+ 6 max-width)
			       (+ (length loc) (length number-str))) ? )
			   (format "(%s)" ref))))))
	 num-start refs)))))


;;;; For Tables
;;
;; `org-export-table-has-special-column-p' and and
;; `org-export-table-row-is-special-p' are predicates used to look for
;; meta-information about the table structure.
;;
;; `org-table-has-header-p' tells when the rows before the first rule
;;  should be considered as table's header.
;;
;; `org-export-table-cell-width', `org-export-table-cell-alignment'
;; and `org-export-table-cell-borders' extract information from
;; a table-cell element.
;;
;; `org-export-table-dimensions' gives the number on rows and columns
;; in the table, ignoring horizontal rules and special columns.
;; `org-export-table-cell-address', given a table-cell object, returns
;; the absolute address of a cell. On the other hand,
;; `org-export-get-table-cell-at' does the contrary.
;;
;; `org-export-table-cell-starts-colgroup-p',
;; `org-export-table-cell-ends-colgroup-p',
;; `org-export-table-row-starts-rowgroup-p',
;; `org-export-table-row-ends-rowgroup-p',
;; `org-export-table-row-starts-header-p' and
;; `org-export-table-row-ends-header-p' indicate position of current
;; row or cell within the table.

(defun org-export-table-has-special-column-p (table)
  "Non-nil when TABLE has a special column.
All special columns will be ignored during export."
  ;; The table has a special column when every first cell of every row
  ;; has an empty value or contains a symbol among "/", "#", "!", "$",
  ;; "*" "_" and "^".  Though, do not consider a first row containing
  ;; only empty cells as special.
  (let ((special-column-p 'empty))
    (catch 'exit
      (mapc
       (lambda (row)
	 (when (eq (org-element-property :type row) 'standard)
	   (let ((value (org-element-contents
			 (car (org-element-contents row)))))
	     (cond ((member value '(("/") ("#") ("!") ("$") ("*") ("_") ("^")))
		    (setq special-column-p 'special))
		   ((not value))
		   (t (throw 'exit nil))))))
       (org-element-contents table))
      (eq special-column-p 'special))))

(defun org-export-table-has-header-p (table info)
  "Non-nil when TABLE has a header.

INFO is a plist used as a communication channel.

A table has a header when it contains at least two row groups."
  (let ((cache (or (plist-get info :table-header-cache)
		   (plist-get (setq info
				    (plist-put info :table-header-cache
					       (make-hash-table :test 'eq)))
			      :table-header-cache))))
    (or (gethash table cache)
	(let ((rowgroup 1) row-flag)
	  (puthash
	   table
	   (org-element-map table 'table-row
	     (lambda (row)
	       (cond
		((> rowgroup 1) t)
		((and row-flag (eq (org-element-property :type row) 'rule))
		 (incf rowgroup) (setq row-flag nil))
		((and (not row-flag) (eq (org-element-property :type row)
					 'standard))
		 (setq row-flag t) nil)))
	     info 'first-match)
	   cache)))))

(defun org-export-table-row-is-special-p (table-row info)
  "Non-nil if TABLE-ROW is considered special.

INFO is a plist used as the communication channel.

All special rows will be ignored during export."
  (when (eq (org-element-property :type table-row) 'standard)
    (let ((first-cell (org-element-contents
		       (car (org-element-contents table-row)))))
      ;; A row is special either when...
      (or
       ;; ... it starts with a field only containing "/",
       (equal first-cell '("/"))
       ;; ... the table contains a special column and the row start
       ;; with a marking character among, "^", "_", "$" or "!",
       (and (org-export-table-has-special-column-p
	     (org-export-get-parent table-row))
	    (member first-cell '(("^") ("_") ("$") ("!"))))
       ;; ... it contains only alignment cookies and empty cells.
       (let ((special-row-p 'empty))
	 (catch 'exit
	   (mapc
	    (lambda (cell)
	      (let ((value (org-element-contents cell)))
		;; Since VALUE is a secondary string, the following
		;; checks avoid expanding it with `org-export-data'.
		(cond ((not value))
		      ((and (not (cdr value))
			    (stringp (car value))
			    (string-match "\\`<[lrc]?\\([0-9]+\\)?>\\'"
					  (car value)))
		       (setq special-row-p 'cookie))
		      (t (throw 'exit nil)))))
	    (org-element-contents table-row))
	   (eq special-row-p 'cookie)))))))

(defun org-export-table-row-group (table-row info)
  "Return TABLE-ROW's group number, as an integer.

INFO is a plist used as the communication channel.

Return value is the group number, as an integer, or nil for
special rows and rows separators.  First group is also table's
header."
  (let ((cache (or (plist-get info :table-row-group-cache)
		   (plist-get (setq info
				    (plist-put info :table-row-group-cache
					       (make-hash-table :test 'eq)))
			      :table-row-group-cache))))
    (cond ((gethash table-row cache))
	  ((eq (org-element-property :type table-row) 'rule) nil)
	  (t (let ((group 0) row-flag)
	       (org-element-map (org-export-get-parent table-row) 'table-row
		 (lambda (row)
		   (if (eq (org-element-property :type row) 'rule)
		       (setq row-flag nil)
		     (unless row-flag (incf group) (setq row-flag t)))
		   (when (eq table-row row) (puthash table-row group cache)))
		 info 'first-match))))))

(defun org-export-table-cell-width (table-cell info)
  "Return TABLE-CELL contents width.

INFO is a plist used as the communication channel.

Return value is the width given by the last width cookie in the
same column as TABLE-CELL, or nil."
  (let* ((row (org-export-get-parent table-cell))
	 (table (org-export-get-parent row))
	 (cells (org-element-contents row))
	 (columns (length cells))
	 (column (- columns (length (memq table-cell cells))))
	 (cache (or (plist-get info :table-cell-width-cache)
		    (plist-get (setq info
				     (plist-put info :table-cell-width-cache
						(make-hash-table :test 'eq)))
			       :table-cell-width-cache)))
	 (width-vector (or (gethash table cache)
			   (puthash table (make-vector columns 'empty) cache)))
	 (value (aref width-vector column)))
    (if (not (eq value 'empty)) value
      (let (cookie-width)
	(dolist (row (org-element-contents table)
		     (aset width-vector column cookie-width))
	  (when (org-export-table-row-is-special-p row info)
	    ;; In a special row, try to find a width cookie at COLUMN.
	    (let* ((value (org-element-contents
			   (elt (org-element-contents row) column)))
		   (cookie (car value)))
	      ;; The following checks avoid expanding unnecessarily
	      ;; the cell with `org-export-data'.
	      (when (and value
			 (not (cdr value))
			 (stringp cookie)
			 (string-match "\\`<[lrc]?\\([0-9]+\\)?>\\'" cookie)
			 (match-string 1 cookie))
		(setq cookie-width
		      (string-to-number (match-string 1 cookie)))))))))))

(defun org-export-table-cell-alignment (table-cell info)
  "Return TABLE-CELL contents alignment.

INFO is a plist used as the communication channel.

Return alignment as specified by the last alignment cookie in the
same column as TABLE-CELL.  If no such cookie is found, a default
alignment value will be deduced from fraction of numbers in the
column (see `org-table-number-fraction' for more information).
Possible values are `left', `right' and `center'."
  ;; Load `org-table-number-fraction' and `org-table-number-regexp'.
  (require 'org-table)
  (let* ((row (org-export-get-parent table-cell))
	 (table (org-export-get-parent row))
	 (cells (org-element-contents row))
	 (columns (length cells))
	 (column (- columns (length (memq table-cell cells))))
	 (cache (or (plist-get info :table-cell-alignment-cache)
		    (plist-get (setq info
				     (plist-put info :table-cell-alignment-cache
						(make-hash-table :test 'eq)))
			       :table-cell-alignment-cache)))
	 (align-vector (or (gethash table cache)
			   (puthash table (make-vector columns nil) cache))))
    (or (aref align-vector column)
	(let ((number-cells 0)
	      (total-cells 0)
	      cookie-align
	      previous-cell-number-p)
	  (dolist (row (org-element-contents (org-export-get-parent row)))
	    (cond
	     ;; In a special row, try to find an alignment cookie at
	     ;; COLUMN.
	     ((org-export-table-row-is-special-p row info)
	      (let ((value (org-element-contents
			    (elt (org-element-contents row) column))))
		;; Since VALUE is a secondary string, the following
		;; checks avoid useless expansion through
		;; `org-export-data'.
		(when (and value
			   (not (cdr value))
			   (stringp (car value))
			   (string-match "\\`<\\([lrc]\\)?\\([0-9]+\\)?>\\'"
					 (car value))
			   (match-string 1 (car value)))
		  (setq cookie-align (match-string 1 (car value))))))
	     ;; Ignore table rules.
	     ((eq (org-element-property :type row) 'rule))
	     ;; In a standard row, check if cell's contents are
	     ;; expressing some kind of number.  Increase NUMBER-CELLS
	     ;; accordingly.  Though, don't bother if an alignment
	     ;; cookie has already defined cell's alignment.
	     ((not cookie-align)
	      (let ((value (org-export-data
			    (org-element-contents
			     (elt (org-element-contents row) column))
			    info)))
		(incf total-cells)
		;; Treat an empty cell as a number if it follows
		;; a number.
		(if (not (or (string-match org-table-number-regexp value)
			     (and (string= value "") previous-cell-number-p)))
		    (setq previous-cell-number-p nil)
		  (setq previous-cell-number-p t)
		  (incf number-cells))))))
	  ;; Return value.  Alignment specified by cookies has
	  ;; precedence over alignment deduced from cell's contents.
	  (aset align-vector
		column
		(cond ((equal cookie-align "l") 'left)
		      ((equal cookie-align "r") 'right)
		      ((equal cookie-align "c") 'center)
		      ((>= (/ (float number-cells) total-cells)
			   org-table-number-fraction)
		       'right)
		      (t 'left)))))))

(defun org-export-table-cell-borders (table-cell info)
  "Return TABLE-CELL borders.

INFO is a plist used as a communication channel.

Return value is a list of symbols, or nil.  Possible values are:
`top', `bottom', `above', `below', `left' and `right'.  Note:
`top' (resp. `bottom') only happen for a cell in the first
row (resp. last row) of the table, ignoring table rules, if any.

Returned borders ignore special rows."
  (let* ((row (org-export-get-parent table-cell))
	 (table (org-export-get-parent-table table-cell))
	 borders)
    ;; Top/above border?  TABLE-CELL has a border above when a rule
    ;; used to demarcate row groups can be found above.  Hence,
    ;; finding a rule isn't sufficient to push `above' in BORDERS:
    ;; another regular row has to be found above that rule.
    (let (rule-flag)
      (catch 'exit
	(mapc (lambda (row)
		(cond ((eq (org-element-property :type row) 'rule)
		       (setq rule-flag t))
		      ((not (org-export-table-row-is-special-p row info))
		       (if rule-flag (throw 'exit (push 'above borders))
			 (throw 'exit nil)))))
	      ;; Look at every row before the current one.
	      (cdr (memq row (reverse (org-element-contents table)))))
	;; No rule above, or rule found starts the table (ignoring any
	;; special row): TABLE-CELL is at the top of the table.
	(when rule-flag (push 'above borders))
	(push 'top borders)))
    ;; Bottom/below border? TABLE-CELL has a border below when next
    ;; non-regular row below is a rule.
    (let (rule-flag)
      (catch 'exit
	(mapc (lambda (row)
		(cond ((eq (org-element-property :type row) 'rule)
		       (setq rule-flag t))
		      ((not (org-export-table-row-is-special-p row info))
		       (if rule-flag (throw 'exit (push 'below borders))
			 (throw 'exit nil)))))
	      ;; Look at every row after the current one.
	      (cdr (memq row (org-element-contents table))))
	;; No rule below, or rule found ends the table (modulo some
	;; special row): TABLE-CELL is at the bottom of the table.
	(when rule-flag (push 'below borders))
	(push 'bottom borders)))
    ;; Right/left borders?  They can only be specified by column
    ;; groups.  Column groups are defined in a row starting with "/".
    ;; Also a column groups row only contains "<", "<>", ">" or blank
    ;; cells.
    (catch 'exit
      (let ((column (let ((cells (org-element-contents row)))
		      (- (length cells) (length (memq table-cell cells))))))
	(mapc
	 (lambda (row)
	   (unless (eq (org-element-property :type row) 'rule)
	     (when (equal (org-element-contents
			   (car (org-element-contents row)))
			  '("/"))
	       (let ((column-groups
		      (mapcar
		       (lambda (cell)
			 (let ((value (org-element-contents cell)))
			   (when (member value '(("<") ("<>") (">") nil))
			     (car value))))
		       (org-element-contents row))))
		 ;; There's a left border when previous cell, if
		 ;; any, ends a group, or current one starts one.
		 (when (or (and (not (zerop column))
				(member (elt column-groups (1- column))
					'(">" "<>")))
			   (member (elt column-groups column) '("<" "<>")))
		   (push 'left borders))
		 ;; There's a right border when next cell, if any,
		 ;; starts a group, or current one ends one.
		 (when (or (and (/= (1+ column) (length column-groups))
				(member (elt column-groups (1+ column))
					'("<" "<>")))
			   (member (elt column-groups column) '(">" "<>")))
		   (push 'right borders))
		 (throw 'exit nil)))))
	 ;; Table rows are read in reverse order so last column groups
	 ;; row has precedence over any previous one.
	 (reverse (org-element-contents table)))))
    ;; Return value.
    borders))

(defun org-export-table-cell-starts-colgroup-p (table-cell info)
  "Non-nil when TABLE-CELL is at the beginning of a row group.
INFO is a plist used as a communication channel."
  ;; A cell starts a column group either when it is at the beginning
  ;; of a row (or after the special column, if any) or when it has
  ;; a left border.
  (or (eq (org-element-map (org-export-get-parent table-cell) 'table-cell
	    'identity info 'first-match)
	  table-cell)
      (memq 'left (org-export-table-cell-borders table-cell info))))

(defun org-export-table-cell-ends-colgroup-p (table-cell info)
  "Non-nil when TABLE-CELL is at the end of a row group.
INFO is a plist used as a communication channel."
  ;; A cell ends a column group either when it is at the end of a row
  ;; or when it has a right border.
  (or (eq (car (last (org-element-contents
			 (org-export-get-parent table-cell))))
	     table-cell)
      (memq 'right (org-export-table-cell-borders table-cell info))))

(defun org-export-table-row-starts-rowgroup-p (table-row info)
  "Non-nil when TABLE-ROW is at the beginning of a column group.
INFO is a plist used as a communication channel."
  (unless (or (eq (org-element-property :type table-row) 'rule)
	      (org-export-table-row-is-special-p table-row info))
    (let ((borders (org-export-table-cell-borders
		    (car (org-element-contents table-row)) info)))
      (or (memq 'top borders) (memq 'above borders)))))

(defun org-export-table-row-ends-rowgroup-p (table-row info)
  "Non-nil when TABLE-ROW is at the end of a column group.
INFO is a plist used as a communication channel."
  (unless (or (eq (org-element-property :type table-row) 'rule)
	      (org-export-table-row-is-special-p table-row info))
    (let ((borders (org-export-table-cell-borders
		    (car (org-element-contents table-row)) info)))
      (or (memq 'bottom borders) (memq 'below borders)))))

(defun org-export-table-row-starts-header-p (table-row info)
  "Non-nil when TABLE-ROW is the first table header's row.
INFO is a plist used as a communication channel."
  (and (org-export-table-has-header-p
	(org-export-get-parent-table table-row) info)
       (org-export-table-row-starts-rowgroup-p table-row info)
       (= (org-export-table-row-group table-row info) 1)))

(defun org-export-table-row-ends-header-p (table-row info)
  "Non-nil when TABLE-ROW is the last table header's row.
INFO is a plist used as a communication channel."
  (and (org-export-table-has-header-p
	(org-export-get-parent-table table-row) info)
       (org-export-table-row-ends-rowgroup-p table-row info)
       (= (org-export-table-row-group table-row info) 1)))

(defun org-export-table-row-number (table-row info)
  "Return TABLE-ROW number.
INFO is a plist used as a communication channel.  Return value is
zero-based and ignores separators.  The function returns nil for
special columns and separators."
  (when (and (eq (org-element-property :type table-row) 'standard)
	     (not (org-export-table-row-is-special-p table-row info)))
    (let ((number 0))
      (org-element-map (org-export-get-parent-table table-row) 'table-row
	(lambda (row)
	  (cond ((eq row table-row) number)
		((eq (org-element-property :type row) 'standard)
		 (incf number) nil)))
	info 'first-match))))

(defun org-export-table-dimensions (table info)
  "Return TABLE dimensions.

INFO is a plist used as a communication channel.

Return value is a CONS like (ROWS . COLUMNS) where
ROWS (resp. COLUMNS) is the number of exportable
rows (resp. columns)."
  (let (first-row (columns 0) (rows 0))
    ;; Set number of rows, and extract first one.
    (org-element-map table 'table-row
      (lambda (row)
	(when (eq (org-element-property :type row) 'standard)
	  (incf rows)
	  (unless first-row (setq first-row row)))) info)
    ;; Set number of columns.
    (org-element-map first-row 'table-cell (lambda (cell) (incf columns)) info)
    ;; Return value.
    (cons rows columns)))

(defun org-export-table-cell-address (table-cell info)
  "Return address of a regular TABLE-CELL object.

TABLE-CELL is the cell considered.  INFO is a plist used as
a communication channel.

Address is a CONS cell (ROW . COLUMN), where ROW and COLUMN are
zero-based index.  Only exportable cells are considered.  The
function returns nil for other cells."
  (let* ((table-row (org-export-get-parent table-cell))
	 (row-number (org-export-table-row-number table-row info)))
    (when row-number
      (cons row-number
	    (let ((col-count 0))
	      (org-element-map table-row 'table-cell
		(lambda (cell)
		  (if (eq cell table-cell) col-count (incf col-count) nil))
		info 'first-match))))))

(defun org-export-get-table-cell-at (address table info)
  "Return regular table-cell object at ADDRESS in TABLE.

Address is a CONS cell (ROW . COLUMN), where ROW and COLUMN are
zero-based index.  TABLE is a table type element.  INFO is
a plist used as a communication channel.

If no table-cell, among exportable cells, is found at ADDRESS,
return nil."
  (let ((column-pos (cdr address)) (column-count 0))
    (org-element-map
	;; Row at (car address) or nil.
	(let ((row-pos (car address)) (row-count 0))
	  (org-element-map table 'table-row
	    (lambda (row)
	      (cond ((eq (org-element-property :type row) 'rule) nil)
		    ((= row-count row-pos) row)
		    (t (incf row-count) nil)))
	    info 'first-match))
	'table-cell
      (lambda (cell)
	(if (= column-count column-pos) cell
	  (incf column-count) nil))
      info 'first-match)))


;;;; For Tables Of Contents
;;
;; `org-export-collect-headlines' builds a list of all exportable
;; headline elements, maybe limited to a certain depth.  One can then
;; easily parse it and transcode it.
;;
;; Building lists of tables, figures or listings is quite similar.
;; Once the generic function `org-export-collect-elements' is defined,
;; `org-export-collect-tables', `org-export-collect-figures' and
;; `org-export-collect-listings' can be derived from it.

(defun org-export-collect-headlines (info &optional n)
  "Collect headlines in order to build a table of contents.

INFO is a plist used as a communication channel.

When optional argument N is an integer, it specifies the depth of
the table of contents.  Otherwise, it is set to the value of the
last headline level.  See `org-export-headline-levels' for more
information.

Return a list of all exportable headlines as parsed elements.
Footnote sections, if any, will be ignored."
  (let ((limit (plist-get info :headline-levels)))
    (setq n (if (wholenump n) (min n limit) limit))
    (org-element-map (plist-get info :parse-tree) 'headline
      #'(lambda (headline)
	  (unless (org-element-property :footnote-section-p headline)
	    (let ((level (org-export-get-relative-level headline info)))
	      (and (<= level n) headline))))
      info)))

(defun org-export-collect-elements (type info &optional predicate)
  "Collect referenceable elements of a determined type.

TYPE can be a symbol or a list of symbols specifying element
types to search.  Only elements with a caption are collected.

INFO is a plist used as a communication channel.

When non-nil, optional argument PREDICATE is a function accepting
one argument, an element of type TYPE.  It returns a non-nil
value when that element should be collected.

Return a list of all elements found, in order of appearance."
  (org-element-map (plist-get info :parse-tree) type
    (lambda (element)
      (and (org-element-property :caption element)
	   (or (not predicate) (funcall predicate element))
	   element))
    info))

(defun org-export-collect-tables (info)
  "Build a list of tables.
INFO is a plist used as a communication channel.

Return a list of table elements with a caption."
  (org-export-collect-elements 'table info))

(defun org-export-collect-figures (info predicate)
  "Build a list of figures.

INFO is a plist used as a communication channel.  PREDICATE is
a function which accepts one argument: a paragraph element and
whose return value is non-nil when that element should be
collected.

A figure is a paragraph type element, with a caption, verifying
PREDICATE.  The latter has to be provided since a \"figure\" is
a vague concept that may depend on back-end.

Return a list of elements recognized as figures."
  (org-export-collect-elements 'paragraph info predicate))

(defun org-export-collect-listings (info)
  "Build a list of src blocks.

INFO is a plist used as a communication channel.

Return a list of src-block elements with a caption."
  (org-export-collect-elements 'src-block info))


;;;; Smart Quotes
;;
;; The main function for the smart quotes sub-system is
;; `org-export-activate-smart-quotes', which replaces every quote in
;; a given string from the parse tree with its "smart" counterpart.
;;
;; Dictionary for smart quotes is stored in
;; `org-export-smart-quotes-alist'.
;;
;; Internally, regexps matching potential smart quotes (checks at
;; string boundaries are also necessary) are defined in
;; `org-export-smart-quotes-regexps'.

(defconst org-export-smart-quotes-alist
  '(("da"
     ;; one may use: »...«, "...", ›...‹, or '...'.
     ;; http://sproget.dk/raad-og-regler/retskrivningsregler/retskrivningsregler/a7-40-60/a7-58-anforselstegn/
     ;; LaTeX quotes require Babel!
     (opening-double-quote :utf-8 "»" :html "&raquo;" :latex ">>"
			   :texinfo "@guillemetright{}")
     (closing-double-quote :utf-8 "«" :html "&laquo;" :latex "<<"
			   :texinfo "@guillemetleft{}")
     (opening-single-quote :utf-8 "›" :html "&rsaquo;" :latex "\\frq{}"
			   :texinfo "@guilsinglright{}")
     (closing-single-quote :utf-8 "‹" :html "&lsaquo;" :latex "\\flq{}"
			   :texinfo "@guilsingleft{}")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("de"
     (opening-double-quote :utf-8 "„" :html "&bdquo;" :latex "\"`"
			   :texinfo "@quotedblbase{}")
     (closing-double-quote :utf-8 "“" :html "&ldquo;" :latex "\"'"
			   :texinfo "@quotedblleft{}")
     (opening-single-quote :utf-8 "‚" :html "&sbquo;" :latex "\\glq{}"
			   :texinfo "@quotesinglbase{}")
     (closing-single-quote :utf-8 "‘" :html "&lsquo;" :latex "\\grq{}"
			   :texinfo "@quoteleft{}")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("en"
     (opening-double-quote :utf-8 "“" :html "&ldquo;" :latex "``" :texinfo "``")
     (closing-double-quote :utf-8 "”" :html "&rdquo;" :latex "''" :texinfo "''")
     (opening-single-quote :utf-8 "‘" :html "&lsquo;" :latex "`" :texinfo "`")
     (closing-single-quote :utf-8 "’" :html "&rsquo;" :latex "'" :texinfo "'")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("es"
     (opening-double-quote :utf-8 "«" :html "&laquo;" :latex "\\guillemotleft{}"
			   :texinfo "@guillemetleft{}")
     (closing-double-quote :utf-8 "»" :html "&raquo;" :latex "\\guillemotright{}"
			   :texinfo "@guillemetright{}")
     (opening-single-quote :utf-8 "“" :html "&ldquo;" :latex "``" :texinfo "``")
     (closing-single-quote :utf-8 "”" :html "&rdquo;" :latex "''" :texinfo "''")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("fr"
     (opening-double-quote :utf-8 "« " :html "&laquo;&nbsp;" :latex "\\og "
			   :texinfo "@guillemetleft{}@tie{}")
     (closing-double-quote :utf-8 " »" :html "&nbsp;&raquo;" :latex "\\fg{}"
			   :texinfo "@tie{}@guillemetright{}")
     (opening-single-quote :utf-8 "« " :html "&laquo;&nbsp;" :latex "\\og "
			   :texinfo "@guillemetleft{}@tie{}")
     (closing-single-quote :utf-8 " »" :html "&nbsp;&raquo;" :latex "\\fg{}"
			   :texinfo "@tie{}@guillemetright{}")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("no"
     ;; https://nn.wikipedia.org/wiki/Sitatteikn
     (opening-double-quote :utf-8 "«" :html "&laquo;" :latex "\\guillemotleft{}"
			   :texinfo "@guillemetleft{}")
     (closing-double-quote :utf-8 "»" :html "&raquo;" :latex "\\guillemotright{}"
			   :texinfo "@guillemetright{}")
     (opening-single-quote :utf-8 "‘" :html "&lsquo;" :latex "`" :texinfo "`")
     (closing-single-quote :utf-8 "’" :html "&rsquo;" :latex "'" :texinfo "'")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("nb"
     ;; https://nn.wikipedia.org/wiki/Sitatteikn
     (opening-double-quote :utf-8 "«" :html "&laquo;" :latex "\\guillemotleft{}"
			   :texinfo "@guillemetleft{}")
     (closing-double-quote :utf-8 "»" :html "&raquo;" :latex "\\guillemotright{}"
			   :texinfo "@guillemetright{}")
     (opening-single-quote :utf-8 "‘" :html "&lsquo;" :latex "`" :texinfo "`")
     (closing-single-quote :utf-8 "’" :html "&rsquo;" :latex "'" :texinfo "'")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("nn"
     ;; https://nn.wikipedia.org/wiki/Sitatteikn
     (opening-double-quote :utf-8 "«" :html "&laquo;" :latex "\\guillemotleft{}"
			   :texinfo "@guillemetleft{}")
     (closing-double-quote :utf-8 "»" :html "&raquo;" :latex "\\guillemotright{}"
			   :texinfo "@guillemetright{}")
     (opening-single-quote :utf-8 "‘" :html "&lsquo;" :latex "`" :texinfo "`")
     (closing-single-quote :utf-8 "’" :html "&rsquo;" :latex "'" :texinfo "'")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    ("sv"
     ;; based on https://sv.wikipedia.org/wiki/Citattecken
     (opening-double-quote :utf-8 "”" :html "&rdquo;" :latex "’’" :texinfo "’’")
     (closing-double-quote :utf-8 "”" :html "&rdquo;" :latex "’’" :texinfo "’’")
     (opening-single-quote :utf-8 "’" :html "&rsquo;" :latex "’" :texinfo "`")
     (closing-single-quote :utf-8 "’" :html "&rsquo;" :latex "’" :texinfo "'")
     (apostrophe :utf-8 "’" :html "&rsquo;"))
    )
  "Smart quotes translations.

Alist whose CAR is a language string and CDR is an alist with
quote type as key and a plist associating various encodings to
their translation as value.

A quote type can be any symbol among `opening-double-quote',
`closing-double-quote', `opening-single-quote',
`closing-single-quote' and `apostrophe'.

Valid encodings include `:utf-8', `:html', `:latex' and
`:texinfo'.

If no translation is found, the quote character is left as-is.")

(defconst org-export-smart-quotes-regexps
  (list
   ;; Possible opening quote at beginning of string.
   "\\`\\([\"']\\)\\(\\w\\|\\s.\\|\\s_\\|\\s(\\)"
   ;; Possible closing quote at beginning of string.
   "\\`\\([\"']\\)\\(\\s-\\|\\s)\\|\\s.\\)"
   ;; Possible apostrophe at beginning of string.
   "\\`\\('\\)\\S-"
   ;; Opening single and double quotes.
   "\\(?:\\s-\\|\\s(\\)\\([\"']\\)\\(?:\\w\\|\\s.\\|\\s_\\)"
   ;; Closing single and double quotes.
   "\\(?:\\w\\|\\s.\\|\\s_\\)\\([\"']\\)\\(?:\\s-\\|\\s)\\|\\s.\\)"
   ;; Apostrophe.
   "\\S-\\('\\)\\S-"
   ;; Possible opening quote at end of string.
   "\\(?:\\s-\\|\\s(\\)\\([\"']\\)\\'"
   ;; Possible closing quote at end of string.
   "\\(?:\\w\\|\\s.\\|\\s_\\)\\([\"']\\)\\'"
   ;; Possible apostrophe at end of string.
   "\\S-\\('\\)\\'")
  "List of regexps matching a quote or an apostrophe.
In every regexp, quote or apostrophe matched is put in group 1.")

(defun org-export-activate-smart-quotes (s encoding info &optional original)
  "Replace regular quotes with \"smart\" quotes in string S.

ENCODING is a symbol among `:html', `:latex', `:texinfo' and
`:utf-8'.  INFO is a plist used as a communication channel.

The function has to retrieve information about string
surroundings in parse tree.  It can only happen with an
unmodified string.  Thus, if S has already been through another
process, a non-nil ORIGINAL optional argument will provide that
original string.

Return the new string."
  (if (equal s "") ""
    (let* ((prev (org-export-get-previous-element (or original s) info))
	   ;; Try to be flexible when computing number of blanks
	   ;; before object.  The previous object may be a string
	   ;; introduced by the back-end and not completely parsed.
	   (pre-blank (and prev
			   (or (org-element-property :post-blank prev)
			       ;; A string with missing `:post-blank'
			       ;; property.
			       (and (stringp prev)
				    (string-match " *\\'" prev)
				    (length (match-string 0 prev)))
			       ;; Fallback value.
			       0)))
	   (next (org-export-get-next-element (or original s) info))
	   (get-smart-quote
	    (lambda (q type)
	      ;; Return smart quote associated to a give quote Q, as
	      ;; a string.  TYPE is a symbol among `open', `close' and
	      ;; `apostrophe'.
	      (let ((key (case type
			   (apostrophe 'apostrophe)
			   (open (if (equal "'" q) 'opening-single-quote
				   'opening-double-quote))
			   (otherwise (if (equal "'" q) 'closing-single-quote
					'closing-double-quote)))))
		(or (plist-get
		     (cdr (assq key
				(cdr (assoc (plist-get info :language)
					    org-export-smart-quotes-alist))))
		     encoding)
		    q)))))
      (if (or (equal "\"" s) (equal "'" s))
	  ;; Only a quote: no regexp can match.  We have to check both
	  ;; sides and decide what to do.
	  (cond ((and (not prev) (not next)) s)
		((not prev) (funcall get-smart-quote s 'open))
		((and (not next) (zerop pre-blank))
		 (funcall get-smart-quote s 'close))
		((not next) s)
		((zerop pre-blank) (funcall get-smart-quote s 'apostrophe))
		(t (funcall get-smart-quote 'open)))
	;; 1. Replace quote character at the beginning of S.
	(cond
	 ;; Apostrophe?
	 ((and prev (zerop pre-blank)
	       (string-match (nth 2 org-export-smart-quotes-regexps) s))
	  (setq s (replace-match
		   (funcall get-smart-quote (match-string 1 s) 'apostrophe)
		   nil t s 1)))
	 ;; Closing quote?
	 ((and prev (zerop pre-blank)
	       (string-match (nth 1 org-export-smart-quotes-regexps) s))
	  (setq s (replace-match
		   (funcall get-smart-quote (match-string 1 s) 'close)
		   nil t s 1)))
	 ;; Opening quote?
	 ((and (or (not prev) (> pre-blank 0))
	       (string-match (nth 0 org-export-smart-quotes-regexps) s))
	  (setq s (replace-match
		   (funcall get-smart-quote (match-string 1 s) 'open)
		   nil t s 1))))
	;; 2. Replace quotes in the middle of the string.
	(setq s (replace-regexp-in-string
		 ;; Opening quotes.
		 (nth 3 org-export-smart-quotes-regexps)
		 (lambda (text)
		   (funcall get-smart-quote (match-string 1 text) 'open))
		 s nil t 1))
	(setq s (replace-regexp-in-string
		 ;; Closing quotes.
		 (nth 4 org-export-smart-quotes-regexps)
		 (lambda (text)
		   (funcall get-smart-quote (match-string 1 text) 'close))
		 s nil t 1))
	(setq s (replace-regexp-in-string
		 ;; Apostrophes.
		 (nth 5 org-export-smart-quotes-regexps)
		 (lambda (text)
		   (funcall get-smart-quote (match-string 1 text) 'apostrophe))
		 s nil t 1))
	;; 3. Replace quote character at the end of S.
	(cond
	 ;; Apostrophe?
	 ((and next (string-match (nth 8 org-export-smart-quotes-regexps) s))
	  (setq s (replace-match
		   (funcall get-smart-quote (match-string 1 s) 'apostrophe)
		   nil t s 1)))
	 ;; Closing quote?
	 ((and (not next)
	       (string-match (nth 7 org-export-smart-quotes-regexps) s))
	  (setq s (replace-match
		   (funcall get-smart-quote (match-string 1 s) 'close)
		   nil t s 1)))
	 ;; Opening quote?
	 ((and next (string-match (nth 6 org-export-smart-quotes-regexps) s))
	  (setq s (replace-match
		   (funcall get-smart-quote (match-string 1 s) 'open)
		   nil t s 1))))
	;; Return string with smart quotes.
	s))))

;;;; Topology
;;
;; Here are various functions to retrieve information about the
;; neighborhood of a given element or object.  Neighbors of interest
;; are direct parent (`org-export-get-parent'), parent headline
;; (`org-export-get-parent-headline'), first element containing an
;; object, (`org-export-get-parent-element'), parent table
;; (`org-export-get-parent-table'), previous element or object
;; (`org-export-get-previous-element') and next element or object
;; (`org-export-get-next-element').
;;
;; `org-export-get-genealogy' returns the full genealogy of a given
;; element or object, from closest parent to full parse tree.

(defsubst org-export-get-parent (blob)
  "Return BLOB parent or nil.
BLOB is the element or object considered."
  (org-element-property :parent blob))

(defun org-export-get-genealogy (blob)
  "Return full genealogy relative to a given element or object.

BLOB is the element or object being considered.

Ancestors are returned from closest to farthest, the last one
being the full parse tree."
  (let (genealogy (parent blob))
    (while (setq parent (org-element-property :parent parent))
      (push parent genealogy))
    (nreverse genealogy)))

(defun org-export-get-parent-headline (blob)
  "Return BLOB parent headline or nil.
BLOB is the element or object being considered."
  (let ((parent blob))
    (while (and (setq parent (org-element-property :parent parent))
		(not (eq (org-element-type parent) 'headline))))
    parent))

(defun org-export-get-parent-element (object)
  "Return first element containing OBJECT or nil.
OBJECT is the object to consider."
  (let ((parent object))
    (while (and (setq parent (org-element-property :parent parent))
		(memq (org-element-type parent) org-element-all-objects)))
    parent))

(defun org-export-get-parent-table (object)
  "Return OBJECT parent table or nil.
OBJECT is either a `table-cell' or `table-element' type object."
  (let ((parent object))
    (while (and (setq parent (org-element-property :parent parent))
		(not (eq (org-element-type parent) 'table))))
    parent))

(defun org-export-get-previous-element (blob info &optional n)
  "Return previous element or object.

BLOB is an element or object.  INFO is a plist used as
a communication channel.  Return previous exportable element or
object, a string, or nil.

When optional argument N is a positive integer, return a list
containing up to N siblings before BLOB, from farthest to
closest.  With any other non-nil value, return a list containing
all of them."
  (let ((siblings
	 ;; An object can belong to the contents of its parent or
	 ;; to a secondary string.  We check the latter option
	 ;; first.
	 (let ((parent (org-export-get-parent blob)))
	   (or (let ((sec-value (org-element-property
				 (cdr (assq (org-element-type parent)
					    org-element-secondary-value-alist))
				 parent)))
		 (and (memq blob sec-value) sec-value))
	       (org-element-contents parent))))
	prev)
    (catch 'exit
      (mapc (lambda (obj)
	      (cond ((memq obj (plist-get info :ignore-list)))
		    ((null n) (throw 'exit obj))
		    ((not (wholenump n)) (push obj prev))
		    ((zerop n) (throw 'exit prev))
		    (t (decf n) (push obj prev))))
	    (cdr (memq blob (reverse siblings))))
      prev)))

(defun org-export-get-next-element (blob info &optional n)
  "Return next element or object.

BLOB is an element or object.  INFO is a plist used as
a communication channel.  Return next exportable element or
object, a string, or nil.

When optional argument N is a positive integer, return a list
containing up to N siblings after BLOB, from closest to farthest.
With any other non-nil value, return a list containing all of
them."
  (let ((siblings
	 ;; An object can belong to the contents of its parent or to
	 ;; a secondary string.  We check the latter option first.
	 (let ((parent (org-export-get-parent blob)))
	   (or (let ((sec-value (org-element-property
				 (cdr (assq (org-element-type parent)
					    org-element-secondary-value-alist))
				 parent)))
		 (cdr (memq blob sec-value)))
	       (cdr (memq blob (org-element-contents parent))))))
	next)
    (catch 'exit
      (mapc (lambda (obj)
	      (cond ((memq obj (plist-get info :ignore-list)))
		    ((null n) (throw 'exit obj))
		    ((not (wholenump n)) (push obj next))
		    ((zerop n) (throw 'exit (nreverse next)))
		    (t (decf n) (push obj next))))
	    siblings)
      (nreverse next))))


;;;; Translation
;;
;; `org-export-translate' translates a string according to the language
;; specified by the LANGUAGE keyword.  `org-export-dictionary' contains
;; the dictionary used for the translation.

(defconst org-export-dictionary
  '(("%e %n: %c"
     ("fr" :default "%e %n : %c" :html "%e&nbsp;%n&nbsp;: %c"))
    ("Author"
     ("ca" :default "Autor")
     ("cs" :default "Autor")
     ("da" :default "Forfatter")
     ("de" :default "Autor")
     ("eo" :html "A&#365;toro")
     ("es" :default "Autor")
     ("fi" :html "Tekij&auml;")
     ("fr" :default "Auteur")
     ("hu" :default "Szerz&otilde;")
     ("is" :html "H&ouml;fundur")
     ("it" :default "Autore")
     ("ja" :html "&#33879;&#32773;" :utf-8 "著者")
     ("nl" :default "Auteur")
     ("no" :default "Forfatter")
     ("nb" :default "Forfatter")
     ("nn" :default "Forfattar")
     ("pl" :default "Autor")
     ("ru" :html "&#1040;&#1074;&#1090;&#1086;&#1088;" :utf-8 "Автор")
     ("sv" :html "F&ouml;rfattare")
     ("uk" :html "&#1040;&#1074;&#1090;&#1086;&#1088;" :utf-8 "Автор")
     ("zh-CN" :html "&#20316;&#32773;" :utf-8 "作者")
     ("zh-TW" :html "&#20316;&#32773;" :utf-8 "作者"))
    ("Date"
     ("ca" :default "Data")
     ("cs" :default "Datum")
     ("da" :default "Dato")
     ("de" :default "Datum")
     ("eo" :default "Dato")
     ("es" :default "Fecha")
     ("fi" :html "P&auml;iv&auml;m&auml;&auml;r&auml;")
     ("hu" :html "D&aacute;tum")
     ("is" :default "Dagsetning")
     ("it" :default "Data")
     ("ja" :html "&#26085;&#20184;" :utf-8 "日付")
     ("nl" :default "Datum")
     ("no" :default "Dato")
     ("nb" :default "Dato")
     ("nn" :default "Dato")
     ("pl" :default "Data")
     ("ru" :html "&#1044;&#1072;&#1090;&#1072;" :utf-8 "Дата")
     ("sv" :default "Datum")
     ("uk" :html "&#1044;&#1072;&#1090;&#1072;" :utf-8 "Дата")
     ("zh-CN" :html "&#26085;&#26399;" :utf-8 "日期")
     ("zh-TW" :html "&#26085;&#26399;" :utf-8 "日期"))
    ("Equation"
     ("da" :default "Ligning")
     ("de" :default "Gleichung")
     ("es" :html "Ecuaci&oacute;n" :default "Ecuación")
     ("fr" :ascii "Equation" :default "Équation")
     ("no" :default "Ligning")
     ("nb" :default "Ligning")
     ("nn" :default "Likning")
     ("sv" :default "Ekvation")
     ("zh-CN" :html "&#26041;&#31243;" :utf-8 "方程"))
    ("Figure"
     ("da" :default "Figur")
     ("de" :default "Abbildung")
     ("es" :default "Figura")
     ("ja" :html "&#22259;" :utf-8 "図")
     ("no" :default "Illustrasjon")
     ("nb" :default "Illustrasjon")
     ("nn" :default "Illustrasjon")
     ("sv" :default "Illustration")
     ("zh-CN" :html "&#22270;" :utf-8 "图"))
    ("Figure %d:"
     ("da" :default "Figur %d")
     ("de" :default "Abbildung %d:")
     ("es" :default "Figura %d:")
     ("fr" :default "Figure %d :" :html "Figure&nbsp;%d&nbsp;:")
     ("ja" :html "&#22259;%d: " :utf-8 "図%d: ")
     ("no" :default "Illustrasjon %d")
     ("nb" :default "Illustrasjon %d")
     ("nn" :default "Illustrasjon %d")
     ("sv" :default "Illustration %d")
     ("zh-CN" :html "&#22270;%d&nbsp;" :utf-8 "图%d "))
    ("Footnotes"
     ("ca" :html "Peus de p&agrave;gina")
     ("cs" :default "Pozn\xe1mky pod carou")
     ("da" :default "Fodnoter")
     ("de" :html "Fu&szlig;noten" :default "Fußnoten")
     ("eo" :default "Piednotoj")
     ("es" :html "Nota al pie de p&aacute;gina" :default "Nota al pie de página")
     ("fi" :default "Alaviitteet")
     ("fr" :default "Notes de bas de page")
     ("hu" :html "L&aacute;bjegyzet")
     ("is" :html "Aftanm&aacute;lsgreinar")
     ("it" :html "Note a pi&egrave; di pagina")
     ("ja" :html "&#33050;&#27880;" :utf-8 "脚注")
     ("nl" :default "Voetnoten")
     ("no" :default "Fotnoter")
     ("nb" :default "Fotnoter")
     ("nn" :default "Fotnotar")
     ("pl" :default "Przypis")
     ("ru" :html "&#1057;&#1085;&#1086;&#1089;&#1082;&#1080;" :utf-8 "Сноски")
     ("sv" :default "Fotnoter")
     ("uk" :html "&#1055;&#1088;&#1080;&#1084;&#1110;&#1090;&#1082;&#1080;"
      :utf-8 "Примітки")
     ("zh-CN" :html "&#33050;&#27880;" :utf-8 "脚注")
     ("zh-TW" :html "&#33139;&#35387;" :utf-8 "腳註"))
    ("List of Listings"
     ("da" :default "Programmer")
     ("de" :default "Programmauflistungsverzeichnis")
     ("es" :default "Indice de Listados de programas")
     ("fr" :default "Liste des programmes")
     ("no" :default "Dataprogrammer")
     ("nb" :default "Dataprogrammer")
     ("zh-CN" :html "&#20195;&#30721;&#30446;&#24405;" :utf-8 "代码目录"))
    ("List of Tables"
     ("da" :default "Tabeller")
     ("de" :default "Tabellenverzeichnis")
     ("es" :default "Indice de tablas")
     ("fr" :default "Liste des tableaux")
     ("no" :default "Tabeller")
     ("nb" :default "Tabeller")
     ("nn" :default "Tabeller")
     ("sv" :default "Tabeller")
     ("zh-CN" :html "&#34920;&#26684;&#30446;&#24405;" :utf-8 "表格目录"))
    ("Listing %d:"
     ("da" :default "Program %d")
     ("de" :default "Programmlisting %d")
     ("es" :default "Listado de programa %d")
     ("fr" :default "Programme %d :" :html "Programme&nbsp;%d&nbsp;:")
     ("no" :default "Dataprogram")
     ("nb" :default "Dataprogram")
     ("zh-CN" :html "&#20195;&#30721;%d&nbsp;" :utf-8 "代码%d "))
    ("See section %s"
     ("da" :default "jævnfør afsnit %s")
     ("de" :default "siehe Abschnitt %s")
     ("es" :default "vea seccion %s")
     ("fr" :default "cf. section %s")
     ("zh-CN" :html "&#21442;&#35265;&#31532;%d&#33410;" :utf-8 "参见第%s节"))
    ("Table"
     ("de" :default "Tabelle")
     ("es" :default "Tabla")
     ("fr" :default "Tableau")
     ("ja" :html "&#34920;" :utf-8 "表")
     ("zh-CN" :html "&#34920;" :utf-8 "表"))
    ("Table %d:"
     ("da" :default "Tabel %d")
     ("de" :default "Tabelle %d")
     ("es" :default "Tabla %d")
     ("fr" :default "Tableau %d :")
     ("ja" :html "&#34920;%d:" :utf-8 "表%d:")
     ("no" :default "Tabell %d")
     ("nb" :default "Tabell %d")
     ("nn" :default "Tabell %d")
     ("sv" :default "Tabell %d")
     ("zh-CN" :html "&#34920;%d&nbsp;" :utf-8 "表%d "))
    ("Table of Contents"
     ("ca" :html "&Iacute;ndex")
     ("cs" :default "Obsah")
     ("da" :default "Indhold")
     ("de" :default "Inhaltsverzeichnis")
     ("eo" :default "Enhavo")
     ("es" :html "&Iacute;ndice")
     ("fi" :html "Sis&auml;llysluettelo")
     ("fr" :ascii "Sommaire" :default "Table des matières")
     ("hu" :html "Tartalomjegyz&eacute;k")
     ("is" :default "Efnisyfirlit")
     ("it" :default "Indice")
     ("ja" :html "&#30446;&#27425;" :utf-8 "目次")
     ("nl" :default "Inhoudsopgave")
     ("no" :default "Innhold")
     ("nb" :default "Innhold")
     ("nn" :default "Innhald")
     ("pl" :html "Spis tre&#x015b;ci")
     ("ru" :html "&#1057;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1085;&#1080;&#1077;"
      :utf-8 "Содержание")
     ("sv" :html "Inneh&aring;ll")
     ("uk" :html "&#1047;&#1084;&#1110;&#1089;&#1090;" :utf-8 "Зміст")
     ("zh-CN" :html "&#30446;&#24405;" :utf-8 "目录")
     ("zh-TW" :html "&#30446;&#37636;" :utf-8 "目錄"))
    ("Unknown reference"
     ("da" :default "ukendt reference")
     ("de" :default "Unbekannter Verweis")
     ("es" :default "referencia desconocida")
     ("fr" :ascii "Destination inconnue" :default "Référence inconnue")
     ("zh-CN" :html "&#26410;&#30693;&#24341;&#29992;" :utf-8 "未知引用")))
  "Dictionary for export engine.

Alist whose CAR is the string to translate and CDR is an alist
whose CAR is the language string and CDR is a plist whose
properties are possible charsets and values translated terms.

It is used as a database for `org-export-translate'. Since this
function returns the string as-is if no translation was found,
the variable only needs to record values different from the
entry.")

(defun org-export-translate (s encoding info)
  "Translate string S according to language specification.

ENCODING is a symbol among `:ascii', `:html', `:latex', `:latin1'
and `:utf-8'.  INFO is a plist used as a communication channel.

Translation depends on `:language' property. Return the
translated string. If no translation is found, try to fall back
to `:default' encoding. If it fails, return S."
  (let* ((lang (plist-get info :language))
	 (translations (cdr (assoc lang
				   (cdr (assoc s org-export-dictionary))))))
    (or (plist-get translations encoding)
	(plist-get translations :default)
	s)))



;;; Asynchronous Export
;;
;; `org-export-async-start' is the entry point for asynchronous
;; export.  It recreates current buffer (including visibility,
;; narrowing and visited file) in an external Emacs process, and
;; evaluates a command there.  It then applies a function on the
;; returned results in the current process.
;;
;; At a higher level, `org-export-to-buffer' and `org-export-to-file'
;; allow to export to a buffer or a file, asynchronously or not.
;;
;; `org-export-output-file-name' is an auxiliary function meant to be
;; used with `org-export-to-file'.  With a given extension, it tries
;; to provide a canonical file name to write export output to.
;;
;; Asynchronously generated results are never displayed directly.
;; Instead, they are stored in `org-export-stack-contents'.  They can
;; then be retrieved by calling `org-export-stack'.
;;
;; Export Stack is viewed through a dedicated major mode
;;`org-export-stack-mode' and tools: `org-export-stack-refresh',
;;`org-export-stack-delete', `org-export-stack-view' and
;;`org-export-stack-clear'.
;;
;; For back-ends, `org-export-add-to-stack' add a new source to stack.
;; It should be used whenever `org-export-async-start' is called.

(defmacro org-export-async-start  (fun &rest body)
  "Call function FUN on the results returned by BODY evaluation.

BODY evaluation happens in an asynchronous process, from a buffer
which is an exact copy of the current one.

Use `org-export-add-to-stack' in FUN in order to register results
in the stack.

This is a low level function.  See also `org-export-to-buffer'
and `org-export-to-file' for more specialized functions."
  (declare (indent 1) (debug t))
  (org-with-gensyms (process temp-file copy-fun proc-buffer coding)
    ;; Write the full sexp evaluating BODY in a copy of the current
    ;; buffer to a temporary file, as it may be too long for program
    ;; args in `start-process'.
    `(with-temp-message "Initializing asynchronous export process"
       (let ((,copy-fun (org-export--generate-copy-script (current-buffer)))
             (,temp-file (make-temp-file "org-export-process"))
             (,coding buffer-file-coding-system))
         (with-temp-file ,temp-file
           (insert
            ;; Null characters (from variable values) are inserted
            ;; within the file.  As a consequence, coding system for
            ;; buffer contents will not be recognized properly.  So,
            ;; we make sure it is the same as the one used to display
            ;; the original buffer.
            (format ";; -*- coding: %s; -*-\n%S"
                    ,coding
                    `(with-temp-buffer
                       (when org-export-async-debug '(setq debug-on-error t))
                       ;; Ignore `kill-emacs-hook' and code evaluation
                       ;; queries from Babel as we need a truly
                       ;; non-interactive process.
                       (setq kill-emacs-hook nil
                             org-babel-confirm-evaluate-answer-no t)
                       ;; Initialize export framework.
                       (require 'ox)
                       ;; Re-create current buffer there.
                       (funcall ,,copy-fun)
                       (restore-buffer-modified-p nil)
                       ;; Sexp to evaluate in the buffer.
                       (print (progn ,,@body))))))
         ;; Start external process.
         (let* ((process-connection-type nil)
                (,proc-buffer (generate-new-buffer-name "*Org Export Process*"))
                (,process
                 (start-process
                  "org-export-process" ,proc-buffer
                  (expand-file-name invocation-name invocation-directory)
                  "-Q" "--batch"
                  "-l" org-export-async-init-file
                  "-l" ,temp-file)))
           ;; Register running process in stack.
           (org-export-add-to-stack (get-buffer ,proc-buffer) nil ,process)
           ;; Set-up sentinel in order to catch results.
           (let ((handler ,fun))
             (set-process-sentinel
              ,process
              `(lambda (p status)
                 (let ((proc-buffer (process-buffer p)))
                   (when (eq (process-status p) 'exit)
                     (unwind-protect
                         (if (zerop (process-exit-status p))
                             (unwind-protect
                                 (let ((results
                                        (with-current-buffer proc-buffer
                                          (goto-char (point-max))
                                          (backward-sexp)
                                          (read (current-buffer)))))
                                   (funcall ,handler results))
                               (unless org-export-async-debug
                                 (and (get-buffer proc-buffer)
                                      (kill-buffer proc-buffer))))
                           (org-export-add-to-stack proc-buffer nil p)
                           (ding)
                           (message "Process '%s' exited abnormally" p))
                       (unless org-export-async-debug
                         (delete-file ,,temp-file)))))))))))))

;;;###autoload
(defun org-export-to-buffer
  (backend buffer
	   &optional async subtreep visible-only body-only ext-plist
	   post-process)
  "Call `org-export-as' with output to a specified buffer.

BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.

BUFFER is the name of the output buffer.  If it already exists,
it will be erased first, otherwise, it will be created.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting buffer should then be accessible
through the `org-export-stack' interface.  When ASYNC is nil, the
buffer is displayed if `org-export-show-temporary-export-buffer'
is non-nil.

Optional arguments SUBTREEP, VISIBLE-ONLY, BODY-ONLY and
EXT-PLIST are similar to those used in `org-export-as', which
see.

Optional argument POST-PROCESS is a function which should accept
no argument.  It is always called within the current process,
from BUFFER, with point at its beginning.  Export back-ends can
use it to set a major mode there, e.g,

  \(defun org-latex-export-as-latex
    \(&optional async subtreep visible-only body-only ext-plist)
    \(interactive)
    \(org-export-to-buffer 'latex \"*Org LATEX Export*\"
      async subtreep visible-only body-only ext-plist (lambda () (LaTeX-mode))))

This function returns BUFFER."
  (declare (indent 2))
  (if async
      (org-export-async-start
	  `(lambda (output)
	     (with-current-buffer (get-buffer-create ,buffer)
	       (erase-buffer)
	       (setq buffer-file-coding-system ',buffer-file-coding-system)
	       (insert output)
	       (goto-char (point-min))
	       (org-export-add-to-stack (current-buffer) ',backend)
	       (ignore-errors (funcall ,post-process))))
	`(org-export-as
	  ',backend ,subtreep ,visible-only ,body-only ',ext-plist))
    (let ((output
	   (org-export-as backend subtreep visible-only body-only ext-plist))
	  (buffer (get-buffer-create buffer))
	  (encoding buffer-file-coding-system))
      (when (and (org-string-nw-p output) (org-export--copy-to-kill-ring-p))
	(org-kill-new output))
      (with-current-buffer buffer
	(erase-buffer)
	(setq buffer-file-coding-system encoding)
	(insert output)
	(goto-char (point-min))
	(and (functionp post-process) (funcall post-process)))
      (when org-export-show-temporary-export-buffer
	(switch-to-buffer-other-window buffer))
      buffer)))

;;;###autoload
(defun org-export-to-file
  (backend file &optional async subtreep visible-only body-only ext-plist
	   post-process)
  "Call `org-export-as' with output to a specified file.

BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.  FILE is the name of the output file, as
a string.

A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting buffer will then be accessible
through the `org-export-stack' interface.

Optional arguments SUBTREEP, VISIBLE-ONLY, BODY-ONLY and
EXT-PLIST are similar to those used in `org-export-as', which
see.

Optional argument POST-PROCESS is called with FILE as its
argument and happens asynchronously when ASYNC is non-nil.  It
has to return a file name, or nil.  Export back-ends can use this
to send the output file through additional processing, e.g,

  \(defun org-latex-export-to-latex
    \(&optional async subtreep visible-only body-only ext-plist)
    \(interactive)
    \(let ((outfile (org-export-output-file-name \".tex\" subtreep)))
      \(org-export-to-file 'latex outfile
        async subtreep visible-only body-only ext-plist
        \(lambda (file) (org-latex-compile file)))

The function returns either a file name returned by POST-PROCESS,
or FILE."
  (declare (indent 2))
  (if (not (file-writable-p file)) (error "Output file not writable")
    (let ((encoding (or org-export-coding-system buffer-file-coding-system)))
      (if async
          (org-export-async-start
	      `(lambda (file)
		 (org-export-add-to-stack (expand-file-name file) ',backend))
	    `(let ((output
		    (org-export-as
		     ',backend ,subtreep ,visible-only ,body-only
		     ',ext-plist)))
	       (with-temp-buffer
		 (insert output)
		 (let ((coding-system-for-write ',encoding))
		   (write-file ,file)))
	       (or (ignore-errors (funcall ',post-process ,file)) ,file)))
        (let ((output (org-export-as
                       backend subtreep visible-only body-only ext-plist)))
          (with-temp-buffer
            (insert output)
            (let ((coding-system-for-write encoding))
	      (write-file file)))
          (when (and (org-export--copy-to-kill-ring-p) (org-string-nw-p output))
            (org-kill-new output))
          ;; Get proper return value.
          (or (and (functionp post-process) (funcall post-process file))
	      file))))))

(defun org-export-output-file-name (extension &optional subtreep pub-dir)
  "Return output file's name according to buffer specifications.

EXTENSION is a string representing the output file extension,
with the leading dot.

With a non-nil optional argument SUBTREEP, try to determine
output file's name by looking for \"EXPORT_FILE_NAME\" property
of subtree at point.

When optional argument PUB-DIR is set, use it as the publishing
directory.

When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.

Return file name as a string."
  (let* ((visited-file (buffer-file-name (buffer-base-buffer)))
	 (base-name
	  ;; File name may come from EXPORT_FILE_NAME subtree
	  ;; property, assuming point is at beginning of said
	  ;; sub-tree.
	  (file-name-sans-extension
	   (or (and subtreep
		    (org-entry-get
		     (save-excursion
		       (ignore-errors (org-back-to-heading) (point)))
		     "EXPORT_FILE_NAME" t))
	       ;; File name may be extracted from buffer's associated
	       ;; file, if any.
	       (and visited-file (file-name-nondirectory visited-file))
	       ;; Can't determine file name on our own: Ask user.
	       (let ((read-file-name-function
		      (and org-completion-use-ido 'ido-read-file-name)))
		 (read-file-name
		  "Output file: " pub-dir nil nil nil
		  (lambda (name)
		    (string= (file-name-extension name t) extension)))))))
	 (output-file
	  ;; Build file name.  Enforce EXTENSION over whatever user
	  ;; may have come up with.  PUB-DIR, if defined, always has
	  ;; precedence over any provided path.
	  (cond
	   (pub-dir
	    (concat (file-name-as-directory pub-dir)
		    (file-name-nondirectory base-name)
		    extension))
	   ((file-name-absolute-p base-name) (concat base-name extension))
	   (t (concat (file-name-as-directory ".") base-name extension)))))
    ;; If writing to OUTPUT-FILE would overwrite original file, append
    ;; EXTENSION another time to final name.
    (if (and visited-file (org-file-equal-p visited-file output-file))
	(concat output-file extension)
      output-file)))

(defun org-export-add-to-stack (source backend &optional process)
  "Add a new result to export stack if not present already.

SOURCE is a buffer or a file name containing export results.
BACKEND is a symbol representing export back-end used to generate
it.

Entries already pointing to SOURCE and unavailable entries are
removed beforehand.  Return the new stack."
  (setq org-export-stack-contents
	(cons (list source backend (or process (current-time)))
	      (org-export-stack-remove source))))

(defun org-export-stack ()
  "Menu for asynchronous export results and running processes."
  (interactive)
  (let ((buffer (get-buffer-create "*Org Export Stack*")))
    (set-buffer buffer)
    (when (zerop (buffer-size)) (org-export-stack-mode))
    (org-export-stack-refresh)
    (pop-to-buffer buffer))
  (message "Type \"q\" to quit, \"?\" for help"))

(defun org-export--stack-source-at-point ()
  "Return source from export results at point in stack."
  (let ((source (car (nth (1- (org-current-line)) org-export-stack-contents))))
    (if (not source) (error "Source unavailable, please refresh buffer")
      (let ((source-name (if (stringp source) source (buffer-name source))))
	(if (save-excursion
	      (beginning-of-line)
	      (looking-at (concat ".* +" (regexp-quote source-name) "$")))
	    source
	  ;; SOURCE is not consistent with current line.  The stack
	  ;; view is outdated.
	  (error "Source unavailable; type `g' to update buffer"))))))

(defun org-export-stack-clear ()
  "Remove all entries from export stack."
  (interactive)
  (setq org-export-stack-contents nil))

(defun org-export-stack-refresh (&rest dummy)
  "Refresh the asynchronous export stack.
DUMMY is ignored.  Unavailable sources are removed from the list.
Return the new stack."
  (let ((inhibit-read-only t))
    (org-preserve-lc
     (erase-buffer)
     (insert (concat
	      (let ((counter 0))
		(mapconcat
		 (lambda (entry)
		   (let ((proc-p (processp (nth 2 entry))))
		     (concat
		      ;; Back-end.
		      (format " %-12s  " (or (nth 1 entry) ""))
		      ;; Age.
		      (let ((data (nth 2 entry)))
			(if proc-p (format " %6s  " (process-status data))
			  ;; Compute age of the results.
			  (org-format-seconds
			   "%4h:%.2m  "
			   (float-time (time-since data)))))
		      ;; Source.
		      (format " %s"
			      (let ((source (car entry)))
				(if (stringp source) source
				  (buffer-name source)))))))
		 ;; Clear stack from exited processes, dead buffers or
		 ;; non-existent files.
		 (setq org-export-stack-contents
		       (org-remove-if-not
			(lambda (el)
			  (if (processp (nth 2 el))
			      (buffer-live-p (process-buffer (nth 2 el)))
			    (let ((source (car el)))
			      (if (bufferp source) (buffer-live-p source)
				(file-exists-p source)))))
			org-export-stack-contents)) "\n")))))))

(defun org-export-stack-remove (&optional source)
  "Remove export results at point from stack.
If optional argument SOURCE is non-nil, remove it instead."
  (interactive)
  (let ((source (or source (org-export--stack-source-at-point))))
    (setq org-export-stack-contents
	  (org-remove-if (lambda (el) (equal (car el) source))
			 org-export-stack-contents))))

(defun org-export-stack-view (&optional in-emacs)
  "View export results at point in stack.
With an optional prefix argument IN-EMACS, force viewing files
within Emacs."
  (interactive "P")
  (let ((source (org-export--stack-source-at-point)))
    (cond ((processp source)
	   (org-switch-to-buffer-other-window (process-buffer source)))
	  ((bufferp source) (org-switch-to-buffer-other-window source))
	  (t (org-open-file source in-emacs)))))

(defvar org-export-stack-mode-map
  (let ((km (make-sparse-keymap)))
    (define-key km " " 'next-line)
    (define-key km "n" 'next-line)
    (define-key km "\C-n" 'next-line)
    (define-key km [down] 'next-line)
    (define-key km "p" 'previous-line)
    (define-key km "\C-p" 'previous-line)
    (define-key km "\C-?" 'previous-line)
    (define-key km [up] 'previous-line)
    (define-key km "C" 'org-export-stack-clear)
    (define-key km "v" 'org-export-stack-view)
    (define-key km (kbd "RET") 'org-export-stack-view)
    (define-key km "d" 'org-export-stack-remove)
    km)
  "Keymap for Org Export Stack.")

(define-derived-mode org-export-stack-mode special-mode "Org-Stack"
  "Mode for displaying asynchronous export stack.

Type \\[org-export-stack] to visualize the asynchronous export
stack.

In an Org Export Stack buffer, use \\<org-export-stack-mode-map>\\[org-export-stack-view] to view export output
on current line, \\[org-export-stack-remove] to remove it from the stack and \\[org-export-stack-clear] to clear
stack completely.

Removing entries in an Org Export Stack buffer doesn't affect
files or buffers, only the display.

\\{org-export-stack-mode-map}"
  (abbrev-mode 0)
  (auto-fill-mode 0)
  (setq buffer-read-only t
	buffer-undo-list t
	truncate-lines t
	header-line-format
	'(:eval
	  (format "  %-12s | %6s | %s" "Back-End" "Age" "Source")))
  (org-add-hook 'post-command-hook 'org-export-stack-refresh nil t)
  (set (make-local-variable 'revert-buffer-function)
       'org-export-stack-refresh))



;;; The Dispatcher
;;
;; `org-export-dispatch' is the standard interactive way to start an
;; export process.  It uses `org-export--dispatch-ui' as a subroutine
;; for its interface, which, in turn, delegates response to key
;; pressed to `org-export--dispatch-action'.

;;;###autoload
(defun org-export-dispatch (&optional arg)
  "Export dispatcher for Org mode.

It provides an access to common export related tasks in a buffer.
Its interface comes in two flavors: standard and expert.

While both share the same set of bindings, only the former
displays the valid keys associations in a dedicated buffer.
Scrolling (resp. line-wise motion) in this buffer is done with
SPC and DEL (resp. C-n and C-p) keys.

Set variable `org-export-dispatch-use-expert-ui' to switch to one
flavor or the other.

When ARG is \\[universal-argument], repeat the last export action, with the same set
of options used back then, on the current buffer.

When ARG is \\[universal-argument] \\[universal-argument], display the asynchronous export stack."
  (interactive "P")
  (let* ((input
	  (cond ((equal arg '(16)) '(stack))
		((and arg org-export-dispatch-last-action))
		(t (save-window-excursion
		     (unwind-protect
			 (progn
			   ;; Remember where we are
			   (move-marker org-export-dispatch-last-position
					(point)
					(org-base-buffer (current-buffer)))
			   ;; Get and store an export command
			   (setq org-export-dispatch-last-action
				 (org-export--dispatch-ui
				  (list org-export-initial-scope
					(and org-export-in-background 'async))
				  nil
				  org-export-dispatch-use-expert-ui)))
		       (and (get-buffer "*Org Export Dispatcher*")
			    (kill-buffer "*Org Export Dispatcher*")))))))
	 (action (car input))
	 (optns (cdr input)))
    (unless (memq 'subtree optns)
      (move-marker org-export-dispatch-last-position nil))
    (case action
      ;; First handle special hard-coded actions.
      (template (org-export-insert-default-template nil optns))
      (stack (org-export-stack))
      (publish-current-file
       (org-publish-current-file (memq 'force optns) (memq 'async optns)))
      (publish-current-project
       (org-publish-current-project (memq 'force optns) (memq 'async optns)))
      (publish-choose-project
       (org-publish (assoc (org-icompleting-read
			    "Publish project: "
			    org-publish-project-alist nil t)
			   org-publish-project-alist)
		    (memq 'force optns)
		    (memq 'async optns)))
      (publish-all (org-publish-all (memq 'force optns) (memq 'async optns)))
      (otherwise
       (save-excursion
	 (when arg
	   ;; Repeating command, maybe move cursor to restore subtree
	   ;; context.
	   (if (eq (marker-buffer org-export-dispatch-last-position)
		   (org-base-buffer (current-buffer)))
	       (goto-char org-export-dispatch-last-position)
	     ;; We are in a different buffer, forget position.
	     (move-marker org-export-dispatch-last-position nil)))
	 (funcall action
		  ;; Return a symbol instead of a list to ease
		  ;; asynchronous export macro use.
		  (and (memq 'async optns) t)
		  (and (memq 'subtree optns) t)
		  (and (memq 'visible optns) t)
		  (and (memq 'body optns) t)))))))

(defun org-export--dispatch-ui (options first-key expertp)
  "Handle interface for `org-export-dispatch'.

OPTIONS is a list containing current interactive options set for
export.  It can contain any of the following symbols:
`body'    toggles a body-only export
`subtree' restricts export to current subtree
`visible' restricts export to visible part of buffer.
`force'   force publishing files.
`async'   use asynchronous export process

FIRST-KEY is the key pressed to select the first level menu.  It
is nil when this menu hasn't been selected yet.

EXPERTP, when non-nil, triggers expert UI.  In that case, no help
buffer is provided, but indications about currently active
options are given in the prompt.  Moreover, \[?] allows to switch
back to standard interface."
  (let* ((fontify-key
	  (lambda (key &optional access-key)
	    ;; Fontify KEY string.  Optional argument ACCESS-KEY, when
	    ;; non-nil is the required first-level key to activate
	    ;; KEY.  When its value is t, activate KEY independently
	    ;; on the first key, if any.  A nil value means KEY will
	    ;; only be activated at first level.
	    (if (or (eq access-key t) (eq access-key first-key))
		(org-propertize key 'face 'org-warning)
	      key)))
	 (fontify-value
	  (lambda (value)
	    ;; Fontify VALUE string.
	    (org-propertize value 'face 'font-lock-variable-name-face)))
	 ;; Prepare menu entries by extracting them from registered
	 ;; back-ends and sorting them by access key and by ordinal,
	 ;; if any.
	 (entries
	  (sort (sort (delq nil
			    (mapcar 'org-export-backend-menu
				    org-export--registered-backends))
		      (lambda (a b)
			(let ((key-a (nth 1 a))
			      (key-b (nth 1 b)))
			  (cond ((and (numberp key-a) (numberp key-b))
				 (< key-a key-b))
				((numberp key-b) t)))))
		'car-less-than-car))
	 ;; Compute a list of allowed keys based on the first key
	 ;; pressed, if any.  Some keys
	 ;; (?^B, ?^V, ?^S, ?^F, ?^A, ?&, ?# and ?q) are always
	 ;; available.
	 (allowed-keys
	  (nconc (list 2 22 19 6 1)
		 (if (not first-key) (org-uniquify (mapcar 'car entries))
		   (let (sub-menu)
		     (dolist (entry entries (sort (mapcar 'car sub-menu) '<))
		       (when (eq (car entry) first-key)
			 (setq sub-menu (append (nth 2 entry) sub-menu))))))
		 (cond ((eq first-key ?P) (list ?f ?p ?x ?a))
		       ((not first-key) (list ?P)))
		 (list ?& ?#)
		 (when expertp (list ??))
		 (list ?q)))
	 ;; Build the help menu for standard UI.
	 (help
	  (unless expertp
	    (concat
	     ;; Options are hard-coded.
	     (format "[%s] Body only:    %s           [%s] Visible only:     %s
\[%s] Export scope: %s       [%s] Force publishing: %s
\[%s] Async export: %s\n\n"
		     (funcall fontify-key "C-b" t)
		     (funcall fontify-value
			      (if (memq 'body options) "On " "Off"))
		     (funcall fontify-key "C-v" t)
		     (funcall fontify-value
			      (if (memq 'visible options) "On " "Off"))
		     (funcall fontify-key "C-s" t)
		     (funcall fontify-value
			      (if (memq 'subtree options) "Subtree" "Buffer "))
		     (funcall fontify-key "C-f" t)
		     (funcall fontify-value
			      (if (memq 'force options) "On " "Off"))
		     (funcall fontify-key "C-a" t)
		     (funcall fontify-value
			      (if (memq 'async options) "On " "Off")))
	     ;; Display registered back-end entries.  When a key
	     ;; appears for the second time, do not create another
	     ;; entry, but append its sub-menu to existing menu.
	     (let (last-key)
	       (mapconcat
		(lambda (entry)
		  (let ((top-key (car entry)))
		    (concat
		     (unless (eq top-key last-key)
		       (setq last-key top-key)
		       (format "\n[%s] %s\n"
			       (funcall fontify-key (char-to-string top-key))
			       (nth 1 entry)))
		     (let ((sub-menu (nth 2 entry)))
		       (unless (functionp sub-menu)
			 ;; Split sub-menu into two columns.
			 (let ((index -1))
			   (concat
			    (mapconcat
			     (lambda (sub-entry)
			       (incf index)
			       (format
				(if (zerop (mod index 2)) "    [%s] %-26s"
				  "[%s] %s\n")
				(funcall fontify-key
					 (char-to-string (car sub-entry))
					 top-key)
				(nth 1 sub-entry)))
			     sub-menu "")
			    (when (zerop (mod index 2)) "\n"))))))))
		entries ""))
	     ;; Publishing menu is hard-coded.
	     (format "\n[%s] Publish
    [%s] Current file              [%s] Current project
    [%s] Choose project            [%s] All projects\n\n\n"
		     (funcall fontify-key "P")
		     (funcall fontify-key "f" ?P)
		     (funcall fontify-key "p" ?P)
		     (funcall fontify-key "x" ?P)
		     (funcall fontify-key "a" ?P))
	     (format "[%s] Export stack                  [%s] Insert template\n"
		     (funcall fontify-key "&" t)
		     (funcall fontify-key "#" t))
	     (format "[%s] %s"
		     (funcall fontify-key "q" t)
		     (if first-key "Main menu" "Exit")))))
	 ;; Build prompts for both standard and expert UI.
	 (standard-prompt (unless expertp "Export command: "))
	 (expert-prompt
	  (when expertp
	    (format
	     "Export command (C-%s%s%s%s%s) [%s]: "
	     (if (memq 'body options) (funcall fontify-key "b" t) "b")
	     (if (memq 'visible options) (funcall fontify-key "v" t) "v")
	     (if (memq 'subtree options) (funcall fontify-key "s" t) "s")
	     (if (memq 'force options) (funcall fontify-key "f" t) "f")
	     (if (memq 'async options) (funcall fontify-key "a" t) "a")
	     (mapconcat (lambda (k)
			  ;; Strip control characters.
			  (unless (< k 27) (char-to-string k)))
			allowed-keys "")))))
    ;; With expert UI, just read key with a fancy prompt.  In standard
    ;; UI, display an intrusive help buffer.
    (if expertp
	(org-export--dispatch-action
	 expert-prompt allowed-keys entries options first-key expertp)
      ;; At first call, create frame layout in order to display menu.
      (unless (get-buffer "*Org Export Dispatcher*")
	(delete-other-windows)
	(org-switch-to-buffer-other-window
	 (get-buffer-create "*Org Export Dispatcher*"))
	(setq cursor-type nil
	      header-line-format "Use SPC, DEL, C-n or C-p to navigate.")
	;; Make sure that invisible cursor will not highlight square
	;; brackets.
	(set-syntax-table (copy-syntax-table))
	(modify-syntax-entry ?\[ "w"))
      ;; At this point, the buffer containing the menu exists and is
      ;; visible in the current window.  So, refresh it.
      (with-current-buffer "*Org Export Dispatcher*"
	;; Refresh help.  Maintain display continuity by re-visiting
	;; previous window position.
	(let ((pos (window-start)))
	  (erase-buffer)
	  (insert help)
	  (set-window-start nil pos)))
      (org-fit-window-to-buffer)
      (org-export--dispatch-action
       standard-prompt allowed-keys entries options first-key expertp))))

(defun org-export--dispatch-action
  (prompt allowed-keys entries options first-key expertp)
  "Read a character from command input and act accordingly.

PROMPT is the displayed prompt, as a string.  ALLOWED-KEYS is
a list of characters available at a given step in the process.
ENTRIES is a list of menu entries.  OPTIONS, FIRST-KEY and
EXPERTP are the same as defined in `org-export--dispatch-ui',
which see.

Toggle export options when required.  Otherwise, return value is
a list with action as CAR and a list of interactive export
options as CDR."
  (let (key)
    ;; Scrolling: when in non-expert mode, act on motion keys (C-n,
    ;; C-p, SPC, DEL).
    (while (and (setq key (read-char-exclusive prompt))
		(not expertp)
		(memq key '(14 16 ?\s ?\d)))
      (case key
	(14 (if (not (pos-visible-in-window-p (point-max)))
		(ignore-errors (scroll-up 1))
	      (message "End of buffer")
	      (sit-for 1)))
	(16 (if (not (pos-visible-in-window-p (point-min)))
		(ignore-errors (scroll-down 1))
	      (message "Beginning of buffer")
	      (sit-for 1)))
	(?\s (if (not (pos-visible-in-window-p (point-max)))
		 (scroll-up nil)
	       (message "End of buffer")
	       (sit-for 1)))
	(?\d (if (not (pos-visible-in-window-p (point-min)))
		 (scroll-down nil)
	       (message "Beginning of buffer")
	       (sit-for 1)))))
    (cond
     ;; Ignore undefined associations.
     ((not (memq key allowed-keys))
      (ding)
      (unless expertp (message "Invalid key") (sit-for 1))
      (org-export--dispatch-ui options first-key expertp))
     ;; q key at first level aborts export.  At second level, cancel
     ;; first key instead.
     ((eq key ?q) (if (not first-key) (error "Export aborted")
		    (org-export--dispatch-ui options nil expertp)))
     ;; Help key: Switch back to standard interface if expert UI was
     ;; active.
     ((eq key ??) (org-export--dispatch-ui options first-key nil))
     ;; Send request for template insertion along with export scope.
     ((eq key ?#) (cons 'template (memq 'subtree options)))
     ;; Switch to asynchronous export stack.
     ((eq key ?&) '(stack))
     ;; Toggle options: C-b (2) C-v (22) C-s (19) C-f (6) C-a (1).
     ((memq key '(2 22 19 6 1))
      (org-export--dispatch-ui
       (let ((option (case key (2 'body) (22 'visible) (19 'subtree)
			   (6 'force) (1 'async))))
	 (if (memq option options) (remq option options)
	   (cons option options)))
       first-key expertp))
     ;; Action selected: Send key and options back to
     ;; `org-export-dispatch'.
     ((or first-key (functionp (nth 2 (assq key entries))))
      (cons (cond
	     ((not first-key) (nth 2 (assq key entries)))
	     ;; Publishing actions are hard-coded.  Send a special
	     ;; signal to `org-export-dispatch'.
	     ((eq first-key ?P)
	      (case key
		(?f 'publish-current-file)
		(?p 'publish-current-project)
		(?x 'publish-choose-project)
		(?a 'publish-all)))
	     ;; Return first action associated to FIRST-KEY + KEY
	     ;; path. Indeed, derived backends can share the same
	     ;; FIRST-KEY.
	     (t (catch 'found
		  (mapc (lambda (entry)
			  (let ((match (assq key (nth 2 entry))))
			    (when match (throw 'found (nth 2 match)))))
			(member (assq first-key entries) entries)))))
	    options))
     ;; Otherwise, enter sub-menu.
     (t (org-export--dispatch-ui options key expertp)))))



(provide 'ox)

;; Local variables:
;; generated-autoload-file: "org-loaddefs.el"
;; End:

;;; ox.el ends here
**** keybinding notes
     kwin calls the super-key meta
     emacs calls the alt-key meta
**** prefix keys
***** menu
***** mouse
***** TODO org capture templates needs some work
      Captured [2014-05-26 Mon 12:18]
     
      [[file:~/.emacs::"*%20%25?\nCaptured%20%25U\n%20%25i\n%20%25a")))][file:~/.emacs::"* %?\nCaptured %U\n %i\n %a")))]]

****** test org-capture
Captured [2014-05-26 Mon 22:01]
**** TODO buffer, window and frame switching 
***** ace-window post
     Title: Irreal: Some Notes On ace-window
     Date: Thu, 22 May 2014 03:58:00 PDT
     Feed: Planet Emacsen
     Link: http://irreal.org/blog/?p=2699
     
     The other day, I wrote about ace-window, a really nice way of quickly
     jumping from one window to another. I used the suggested key sequence
     【Meta+p】to trigger it so it seemed pretty fast. 
     
     After using it for a while, I noticed that it didn’t work with ibuffer
     because ibuffer uses 【Meta+p】to move through filters. Since I very
     often have an ibuffer buffer open, I decided to change the triggering
     key sequence. 
     
     One further thing you should know about ace-window is that if there
     are only two windows, it simply switches to the window that doesn’t
     have focus (exactly as if you had typed 【Ctrl+x o】). I remembered
     that Mathias Dahl had commented that he used 【F1】and 【F2】to move
     between windows because it was a single key and very quick so I
     decided to use a function key. I chose 【F11】because I find it easy
     to reach. Now things are even better. If I have two windows open I can
     switch between them with 【F11】and if there are more than two
     windows, ace-window gets triggered with the same key. A definite win.
*****  popwin.el post 
Title: Grant Rettke: Avoiding window takeover in Emacs
Date: Thu,  8 May 2014 15:54:16 PDT
Feed: Planet Emacsen
Link: http://www.wisd[...]keover-in-emacs

This post talks about how buffers takings over
windows in Emacs is very horrible behavior. Based
upon that feedback, it might be interesting to try
out popwin.el.
*** grammar							   :meta:rdf:
    a set of production rules for strings
    grammar shapes language
    languages define the terrain of computing
**** formal grammar
Location: file:///home/xk05/.mozilla/firefox/8pk8p0lx.default/ScrapBook/data/20140128153927/index.html

Formal grammar

From Wikipedia, the free encyclopedia
Jump to: navigation, search

In formal language theory, a grammar (when the context is not given, often called
a formal grammar for clarity) is a set of production rules for strings in a formal
language. The rules describe how to form strings from the language's alphabet that
are valid according to the language's syntax. A grammar does not describe the 
meaning of the strings or what can be done with them in whatever context—only
their form.

Formal language theory, the discipline which studies formal grammars and
languages, is a branch of applied mathematics. Its applications are found in 
theoretical computer science, theoretical linguistics, formal semantics, 
mathematical logic, and other areas.

A formal grammar is a set of rules for rewriting strings, along with a "start
symbol" from which rewriting starts. Therefore, a grammar is usually thought of as
a language generator. However, it can also sometimes be used as the basis for a "
recognizer"—a function in computing that determines whether a given string belongs
to the language or is grammatically incorrect. To describe such recognizers,
formal language theory uses separate formalisms, known as automata theory. One of
the interesting results of automata theory is that it is not possible to design a
recognizer for certain formal languages.

Parsing is the process of recognizing an utterance (a string in natural languages)
by breaking it down to a set of symbols and analyzing each one against the grammar
of the language. Most languages have the meanings of their utterances structured
according to their syntax—a practice known as compositional semantics. As a
result, the first step to describing the meaning of an utterance in language is to
break it down part by part and look at its analyzed form (known as its parse tree
in computer science, and as its deep structure in generative grammar).

***** Contents

    [hide] 

     * 1 Introductory example
     * 2 Formal definition
       	 + 2.1 The syntax of grammars
       	 + 2.2 The semantics of grammars
       	 + 2.3 Example
     * 3 The Chomsky hierarchy
       	 + 3.1 Context-free grammars
       	 + 3.2 Regular grammars
       	 + 3.3 Other forms of generative grammars
       	 + 3.4 Recursive grammars
     * 4 Analytic grammars
     * 5 See also
     * 6 References
     * 7 External links

***** Introductory example[edit]

A grammar mainly consists of a set of rules for transforming strings. (If it only
consisted of these rules, it would be a semi-Thue system.) To generate a string in
the language, one begins with a string consisting of only a single start symbol.
The production rules are then applied in any order, until a string that contains
neither the start symbol nor designated nonterminal symbols is produced. A
production rule is applied to a string by replacing one occurrence of its
left-hand side in the string by its right-hand side (cf. the operation of the
theoretical Turing machine). The language formed by the grammar consists of all
distinct strings that can be generated in this manner. Any particular sequence of
production rules on the start symbol yields a distinct string in the language. If
there are multiple ways of generating the same single string, the grammar is said
to be ambiguous.

For example, assume the alphabet consists of a and b, the start symbol is S, and
we have the following production rules:

    1. S \right
    2. S \right

then we start with S, and can choose a rule to apply to it. If we choose rule 1,
we obtain the string aSb. If we then choose rule 1 again, we replace S with aSb
and obtain the string aaSbb. If we now choose rule 2, we replace S with ba and
obtain the string aababb, and are done. We can write this series of choices more
briefly, using symbols: S \Right. The language of the grammar is then the infinite
set \{a^nbab, where a^k      is a        repeated k        times (and n        in
particular represents the number of times production rule 1 has been applied).

***** Formal definition[edit]
****** The syntax of grammars[edit]

In the classic formalization of generative grammars first proposed by Noam Chomsky
in the 1950s,^[1]^[2] a grammar G consists of the following components:

  * A finite set N of nonterminal symbols, that is disjoint with the strings
    formed from G.
  * A finite set \Sigma   of terminal symbols that is disjoint from N.
  * A finite set P of production rules, each rule of the form

        (\Sigma 
   
    where {*}      is the Kleene star operator and \cup     denotes set union.
    That is, each production rule maps from one string of symbols to another,
    where the first string (the "head") contains an arbitrary number of symbols
    provided at least one of them is a nonterminal. In the case that the second
    string (the "body") consists solely of the empty string – i.e., that it
    contains no symbols at all – it may be denoted with a special notation (often
    \Lambda , e or \epsilon) in order to avoid confusion.

  * A distinguished symbol S \in N  that is the start symbol.

A grammar is formally defined as the tuple (N, \Sig. Such a formal grammar is
often called a rewriting system or a phrase structure grammar in the literature.^[
3]^[4]

****** The semantics of grammars[edit]

The operation of a grammar can be defined in terms of relations on strings:

  * Given a grammar G = (N, , the binary relation \Rightar (pronounced as "G
    derives in one step") on strings in (\Sigma  is defined by:

x \Right

  * the relation {\Righta (pronounced as G derives in zero or more steps) is
    defined as the reflexive transitive closure of \Rightar
  * a sentential form is a member of (\Sigma  that can be derived in a finite
    number of steps from the start symbol S       ; that is, a sentential form is
    a member of \{ w \in. A sentential form that contains no nonterminal symbols
    (i.e. is a member of \Sigma^*) is called a sentence.^[5]
  * the language of G       , denoted as \boldsym, is defined as all those
    sentences that can be derived in a finite number of steps from the start
    symbol S       ; that is, the set \{ w \in.

Note that the grammar G = (N,  is effectively the semi-Thue system (N \cup ,
rewriting strings in exactly the same way; the only difference is in that we
distinguish specific nonterminal symbols which must be rewritten in rewrite rules,
and are only interested in rewritings from the designated start symbol S        to
strings without nonterminal symbols.

****** Example[edit]

For these examples, formal languages are specified using set-builder notation.

Consider the grammar G        where N = \lef, \Sigma =, S        is the start
symbol, and P        consists of the following production rules:

    1. S \right
    2. S \right
    3. Ba \righ
    4. Bb \righ

This grammar defines the language L(G) = \ where a^{n}    denotes a string of n
consecutive a       's. Thus, the language is the set of strings that consist of 1
or more a       's, followed by the same number of b       's, followed by the
same number of c       's.

Some examples of the derivation of strings in L(G)     are:

  * \boldsym
  * \boldsym
  * \boldsym \Righta

    (Note on notation: P \Right reads "String P generates string Q by means of
    production i", and the generated part is each time indicated in bold type.)

***** The Chomsky hierarchy[edit]

Main article: Chomsky hierarchy

When Noam Chomsky first formalized generative grammars in 1956,^[1] he classified
them into types now known as the Chomsky hierarchy. The difference between these
types is that they have increasingly strict production rules and can express fewer
formal languages. Two important types are context-free grammars (Type 2) and 
regular grammars (Type 3). The languages that can be described with such a grammar
are called context-free languages and regular languages, respectively. Although
much less powerful than unrestricted grammars (Type 0), which can in fact express
any language that can be accepted by a Turing machine, these two restricted types
of grammars are most often used because parsers for them can be efficiently
implemented.^[6] For example, all regular languages can be recognized by a finite
state machine, and for useful subsets of context-free grammars there are
well-known algorithms to generate efficient LL parsers and LR parsers to recognize
the corresponding languages those grammars generate.

****** Context-free grammars[edit]

A context-free grammar is a grammar in which the left-hand side of each production
rule consists of only a single nonterminal symbol. This restriction is
non-trivial; not all languages can be generated by context-free grammars. Those
that can are called context-free languages.

The language L(G) = \ defined above is not a context-free language, and this can
be strictly proven using the pumping lemma for context-free languages, but for
example the language \left \{ (at least 1 a        followed by the same number of
b       's) is context-free, as it can be defined by the grammar G_2      with
N=\left , \Sigma=\, S        the start symbol, and the following production rules:

    1. S \right
    2. S \right

A context-free language can be recognized in O(n^3)   time (see Big O notation) by
an algorithm such as Earley's algorithm. That is, for every context-free language,
a machine can be built that takes a string as input and determines in O(n^3)  
time whether the string is a member of the language, where n        is the length
of the string.^[7] Deterministic context-free languages is a subset of
context-free languages that can be recognized in linear time.^[8] There exist
various algorithms that target either this set of languages or some subset of it.

****** Regular grammars[edit]

In regular grammars, the left hand side is again only a single nonterminal symbol,
but now the right-hand side is also restricted. The right side may be the empty
string, or a single terminal symbol, or a single terminal symbol followed by a
nonterminal symbol, but nothing else. (Sometimes a broader definition is used: one
can allow longer strings of terminals or single nonterminals without anything
else, making languages easier to denote while still defining the same class of
languages.)

The language \left \{ defined above is not regular, but the language \left \{ (at
least 1 a        followed by at least 1 b       , where the numbers may be
different) is, as it can be defined by the grammar G_3      with N=\left ,
\Sigma=\, S        the start symbol, and the following production rules:

     1. S \right
     2. A \right
     3. A \right
     4. B \right
     5. B \right

All languages generated by a regular grammar can be recognized in linear time by a
finite state machine. Although, in practice, regular grammars are commonly
expressed using regular expressions, some forms of regular expression used in
practice do not strictly generate the regular languages and do not show linear
recognitional performance due to those deviations.

****** Other forms of generative grammars[edit]

Many extensions and variations on Chomsky's original hierarchy of formal grammars
have been developed, both by linguists and by computer scientists, usually either
in order to increase their expressive power or in order to make them easier to
analyze or parse. Some forms of grammars developed include:
  
****** Tree-adjoining grammars 
      increase the expressiveness of conventional generative grammars by
      allowing rewrite rules to operate on parse trees instead of just
      strings.^[9]
****** Affix grammars^[10] and attribute grammars^[11]^[12] 
      allow rewrite rules to be augmented with semantic attributes and
      operations, useful both for increasing grammar expressiveness and
      for constructing practical language translation tools.

***** Recursive grammars[edit]

Not to be confused with Recursive language.

#+begin_src n3
:recursive-grammar :disjointWith :recursive-language .
#+end_src

A recursive grammar is a grammar which contains production rules that are 
recursive. For example, a grammar for a context-free language is left-recursive if
there exists a non-terminal symbol A that can be put through the production rules
to produce a string with A as the leftmost symbol.^[13] All types of grammars in
the Chomsky hierarchy can be recursive.

***** Analytic grammars[edit]

Though there is a tremendous body of literature on parsing algorithms, most of
these algorithms assume that the language to be parsed is initially described by
means of a generative formal grammar, and that the goal is to transform this
generative grammar into a working parser. Strictly speaking, a generative grammar
does not in any way correspond to the algorithm used to parse a language, and
various algorithms have different restrictions on the form of production rules
that are considered well-formed.

An alternative approach is to formalize the language in terms of an analytic
grammar in the first place, which more directly corresponds to the structure and
semantics of a parser for the language. Examples of analytic grammar formalisms
include the following:

  * The Language Machine directly implements unrestricted analytic grammars.
    Substitution rules are used to transform an input to produce outputs and
    behaviour. The system can also produce the lm-diagram which shows what happens
    when the rules of an unrestricted analytic grammar are being applied.
  * Top-down parsing language (TDPL): a highly minimalist analytic grammar
    formalism developed in the early 1970s to study the behavior of top-down
    parsers.^[14]
  * Link grammars: a form of analytic grammar designed for linguistics, which
    derives syntactic structure by examining the positional relationships between
    pairs of words.^[15]^[16]
  * Parsing expression grammars (PEGs): a more recent generalization of TDPL
    designed around the practical expressiveness needs of programming language and
    compiler writers.^[17]

#+begin_src n3
:formal-grammar :seeAlso :Abstract-syntax-tree ,
  :Adaptive-grammar ,
  :Ambiguous-grammar ,
  :Backus–Naur-form ,
  :Categorial-grammar ,
  :Concrete-syntax-tree ,
  :Extended-Backus–Naur-form ,
  :Augmented-Backus-Naur-form ,
  :Grammar-framework ,
  :L-system ,
  :Lojban ,
  :Post-canonical-system ,
  :Shape-grammar ,
  :Well-formed-formula .
#+end_src

***** References[edit]

 1. ^ Jump up to: ^a ^b Chomsky, Noam (1956). "Three Models for the Description of
    Language". IRE Transactions on Information Theory 2 (2): 113–123. doi:10.1109/
    TIT.1956.1056813. 
 2. Jump up ^ Chomsky, Noam (1957). Syntactic Structures. The Hague: Mouton. 
 3. Jump up ^ Ginsburg, Seymour (1975). Algebraic and automata theoretic
    properties of formal languages. North-Holland. pp. 8–9. ISBN 0-7204-2506-9. 
 4. Jump up ^ Harrison, Michael A. (1978). Introduction to Formal Language Theory.
    Reading, Mass.: Addison-Wesley Publishing Company. p. 13. ISBN 0-201-02955-3. 
 5. Jump up ^ Sentential Forms, Context-Free Grammars, David Matuszek
 6. Jump up ^ Grune, Dick & Jacobs, Ceriel H., Parsing Techniques – A Practical
    Guide, Ellis Horwood, England, 1990.
 7. Jump up ^ Earley, Jay, "An Efficient Context-Free Parsing Algorithm," 
    Communications of the ACM, Vol. 13 No. 2, pp. 94-102, February 1970.
 8. Jump up ^ Knuth, D. E. (July 1965). "On the translation of languages from left
    to right". Information and Control 8 (6): 607–639. doi:10.1016/S0019-9958(65)
    90426-2. Retrieved 29 May 2011.  edit
 9. Jump up ^ Joshi, Aravind K., et al., "Tree Adjunct Grammars," Journal of
    Computer Systems Science, Vol. 10 No. 1, pp. 136-163, 1975.
10. Jump up ^ Koster , Cornelis H. A., "Affix Grammars," in ALGOL 68
    Implementation, North Holland Publishing Company, Amsterdam, p. 95-109, 1971.
11. Jump up ^ Knuth, Donald E., "Semantics of Context-Free Languages," 
    Mathematical Systems Theory, Vol. 2 No. 2, pp. 127-145, 1968.
12. Jump up ^ Knuth, Donald E., "Semantics of Context-Free Languages
    (correction)," Mathematical Systems Theory, Vol. 5 No. 1, pp 95-96, 1971.
13. Jump up ^ Notes on Formal Language Theory and Parsing, James Power, Department
    of Computer Science National University of Ireland, Maynooth Maynooth, Co.
    Kildare, Ireland.JPR02
14. Jump up ^ Birman, Alexander, The TMG Recognition Schema, Doctoral thesis,
    Princeton University, Dept. of Electrical Engineering, February 1970.
15. Jump up ^ Sleator, Daniel D. & Temperly, Davy, "Parsing English with a Link
    Grammar," Technical Report CMU-CS-91-196, Carnegie Mellon University Computer
    Science, 1991.
16. Jump up ^ Sleator, Daniel D. & Temperly, Davy, "Parsing English with a Link
    Grammar," Third International Workshop on Parsing Technologies, 1993. (Revised
    version of above report.)
17. Jump up ^ Ford, Bryan, Packrat Parsing: a Practical Linear-Time Algorithm with
    Backtracking, Master’s thesis, Massachusetts Institute of Technology, Sept.
    2002.

**** Automata theory: formal languages and formal grammars
***** Chomsky hierarchy table               
| Chomsky  | Grammars              | Languages           | Minimal automaton        |
|          | * Unrestricted        | * Recursively       | * Turing machine         |
|          | * (no common name)    | enumerable          | * Decider                |
| * Type-0 | * Context-sensitive   | * Decidable         | * Linear-bounded         |
| * —      | * Indexed             | * Context-sensitive | * Nested stack           |
| * Type-1 | * Linear context-free | * Indexed           | * Thread automaton       |
| * —      | rewriting systems     | * Mildly            | * Embedded pushdown      |
| * —      | etc.                  | context-sensitive   | * Nondeterministic       |
| * —      | * Tree-adjoining etc. | * Tree-adjoining    | pushdown                 |
| * Type-2 | * Context-free        | * Context-free      | * Deterministic          |
| * —      | * Deterministic       | * Deterministic     | pushdown                 |
| * —      | context-free          | context-free        | * Visibly pushdown       |
| * Type-3 | * Visibly pushdown    | * Visibly pushdown  | * Finite                 |
| * —      | * Regular             | * Regular           | * Counter-free (with     |
|          | * —                   | * Star-free         | aperiodic finite monoid) |
                                                                                   
Each category of languages is a proper subset of the category directly above it.   
Any automaton and any grammar in each category has an equivalent automaton or      
grammar in the category directly above it.                                         

Retrieved from "
http://en.wikipedia.org/w/index.php?title=Formal_grammar&oldid=581347229"

**** Wikipedia Stuff
***** Categories:
     * Formal languages
     * Grammar
     * Linguistics
     * Mathematical logic
     * Syntax
     * Automata theory
***** Navigation menu
***** Personal tools

     * Create account
     * Log in

***** Namespaces
     * Article
     * Talk
***** Variants
***** Views

     * Read
     * Edit
     * View history

***** Actions
***** Search

[                    ] S 

***** Navigation

     * Main page
     * Contents
     * Featured content
     * Current events
     * Random article
     * Donate to Wikipedia
     * Wikimedia Shop

***** Interaction

     * Help
     * About Wikipedia
     * Community portal
     * Recent changes
     * Contact page

***** Tools

     * What links here
     * Related changes
     * Upload file
     * Special pages
     * Permanent link
     * Page information
     * Data item
     * Cite this page

***** Print/export

     * Create a book
     * Download as PDF
     * Printable version

***** Languages

      * Bosanski
      * Català
      * Čeština
      * Deutsch
      * Eesti
      * Ελληνικά
      * Español
      * Esperanto
      * فارسی
      * Français
      * Galego
      * 한국어
      * Hrvatski
      * Italiano
      * Magyar
      * Nederlands
      * 日本語
      * Norsk bokmål
      * Polski
      * Português
      * Русский
      * Slovenčina
      * Српски / srpski
      * Srpskohrvatski / српскохрватски
      * Suomi
      * Svenska
      * Українська
      * 中文
      * Edit links

      * This page was last modified on 12 November 2013 at 16:05.
      * Text is available under the Creative Commons Attribution-ShareAlike License;
       	additional terms may apply. By using this site, you agree to the Terms of Use
       	and Privacy Policy.
       	Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a
       	non-profit organization.

      * Privacy policy
      * About Wikipedia
      * Disclaimers
      * Contact Wikipedia
      * Developers
      * Mobile view

      * Wikimed
      * Powered
**** TODO selectOneOf				     :quicksort:prolog:debug:
     ::= (elisp|xslt|xpath|xquery|sparql|spin)
     sort into standards, specifications and implementations perhaps
     quicksort might be useful here, but will it have to be in elisp?
**** quicksort
partition([], _, [], []).
partition([X|Xs], Pivot, Smalls, Bigs) :-
    (   X @< Pivot ->
        Smalls = [X|Rest],
        partition(Xs, Pivot, Rest, Bigs)
    ;   Bigs = [X|Rest],
        partition(Xs, Pivot, Smalls, Rest)
    ).
 
quicksort([])     --> [].
quicksort([X|Xs]) -->
    { partition(Xs, X, Smaller, Bigger) },
    quicksort(Smaller), [X], quicksort(Bigger).
*** xml								    :rdf:xml:
**** spec 1.0							    :rdf:xml:
   W3C
   Extensible Markup Language (XML) 1.0 (Fifth Edition)
   W3C Recommendation 26 November 2008

   This version:
   http://www.w3.org/TR/2008/REC-xml-20081126/ 
   Latest version:
   http://www.w3.org/TR/xml/ 
   Previous versions:
   http://www.w3.org/TR/2008/PER-xml-20080205/
   http://www.w3.org/TR/2006/REC-xml-20060816/ 
   Editors:
   Tim Bray, Textuality and Netscape <tbray@textuality.com>
   Jean Paoli, Microsoft <jeanpa@microsoft.com>
   C. M. Sperberg-McQueen, W3C <cmsmcq@w3.org>
   Eve Maler, Sun Microsystems, Inc. <eve.maler@east.sun.com>
   François Yergeau

   Please refer to the errata for this document, which may include
   some normative corrections.

   The previous errata for this document, are also available.

   See also translations.

   This document is also available in these non-normative formats: XML
   and XHTML with color-coded revision indicators.

   Copyright © 2008 W3C® (MIT, ERCIM, Keio), All Rights Reserved. W3C liability, trademark and document use rules apply.
   Abstract

   The Extensible Markup Language (XML) is a subset of SGML that is
   completely described in this document. Its goal is to enable generic
   SGML to be served, received, and processed on the Web in the way that
   is now possible with HTML. XML has been designed for ease of
   implementation and for interoperability with both SGML and HTML.

   Status of this Document

   This section describes the status of this document at the time of
   its publication. Other documents may supersede this document. A
   list of current W3C publications and the latest revision of this
   technical report can be found in the W3C technical reports index at
   http://www.w3.org/TR/.

   This document specifies a syntax created by subsetting an existing,
   widely used international text processing standard (Standard
   Generalized Markup Language, ISO 8879:1986(E) as amended and
   corrected) for use on the World Wide Web. It is a product of the
   XML Core Working Group as part of the XML Activity. The English
   version of this specification is the only normative
   version. However, for translations of this document, see
   http://www.w3.org/2003/03/Translations/byTechnology?technology=xml.

   This document is a W3C Recommendation. This fifth edition is not a
   new version of XML. As a convenience to readers, it incorporates
   the changes dictated by the accumulated errata (available at
   http://www.w3.org/XML/xml-V10-4e-errata) to the Fourth Edition of
   XML 1.0, dated 16 August 2006. In particular, erratum [E09] relaxes
   the restrictions on element and attribute names, thereby providing
   in XML 1.0 the major end user benefit currently achievable only by
   using XML 1.1. As a consequence, many possible documents which were
   not well-formed according to previous editions of this
   specification are now well-formed, and previously invalid documents
   using the newly-allowed name characters in, for example, ID
   attributes, are now valid.

   This edition supersedes the previous W3C Recommendation of 16
   August 2006.

   Please report errors in this document to the public
   xml-editor@w3.org mail list; public archives are available. For the
   convenience of readers, an XHTML version with color-coded revision
   indicators is also provided; this version highlights each change
   due to an erratum published in the errata list for the previous
   edition, together with a link to the particular erratum in that
   list. Most of the errata in the list provide a rationale for the
   change. The errata list for this fifth edition is available at
   http://www.w3.org/XML/xml-V10-5e-errata.

   An implementation report is available at
   http://www.w3.org/XML/2008/01/xml10-5e-implementation.html. A Test
   Suite is maintained to help assessing conformance to this
   specification.

   This document has been reviewed by W3C Members, by software
   developers, and by other W3C groups and interested parties, and is
   endorsed by the Director as a W3C Recommendation. It is a stable
   document and may be used as reference material or cited from
   another document. W3C's role in making the Recommendation is to
   draw attention to the specification and to promote its widespread
   deployment. This enhances the functionality and interoperability of
   the Web.

   W3C maintains a public list of any patent disclosures made in
   connection with the deliverables of the group; that page also
   includes instructions for disclosing a patent. An individual who
   has actual knowledge of a patent which the individual believes
   contains Essential Claim(s) must disclose the information in
   accordance with section 6 of the W3C Patent Policy.  Table of
   Contents

   1 Introduction
   1.1 Origin and Goals
   1.2 Terminology
   2 Documents
   2.1 Well-Formed XML Documents
   2.2 Characters
   2.3 Common Syntactic Constructs
   2.4 Character Data and Markup
   2.5 Comments
   2.6 Processing Instructions
   2.7 CDATA Sections
   2.8 Prolog and Document Type Declaration
   2.9 Standalone Document Declaration
   2.10 White Space Handling
   2.11 End-of-Line Handling
   2.12 Language Identification
   3 Logical Structures
   3.1 Start-Tags, End-Tags, and Empty-Element Tags
   3.2 Element Type Declarations
   3.2.1 Element Content
   3.2.2 Mixed Content
   3.3 Attribute-List Declarations
   3.3.1 Attribute Types
   3.3.2 Attribute Defaults
   3.3.3 Attribute-Value Normalization
   3.4 Conditional Sections
   4 Physical Structures
   4.1 Character and Entity References
   4.2 Entity Declarations
   4.2.1 Internal Entities
   4.2.2 External Entities
   4.3 Parsed Entities
   4.3.1 The Text Declaration
   4.3.2 Well-Formed Parsed Entities
   4.3.3 Character Encoding in Entities
   4.4 XML Processor Treatment of Entities and References
   4.4.1 Not Recognized
   4.4.2 Included
   4.4.3 Included If Validating
   4.4.4 Forbidden
   4.4.5 Included in Literal
   4.4.6 Notify
   4.4.7 Bypassed
   4.4.8 Included as PE
   4.4.9 Error
   4.5 Construction of Entity Replacement Text
   4.6 Predefined Entities
   4.7 Notation Declarations
   4.8 Document Entity
   5 Conformance
   5.1 Validating and Non-Validating Processors
   5.2 Using XML Processors
   6 Notation
   Appendices

   A References
   A.1 Normative References
   A.2 Other References
   B Character Classes
   C XML and SGML (Non-Normative)
   D Expansion of Entity and Character References (Non-Normative)
   E Deterministic Content Models (Non-Normative)
   F Autodetection of Character Encodings (Non-Normative)
   F.1 Detection Without External Encoding Information
   F.2 Priorities in the Presence of External Encoding Information
   G W3C XML Working Group (Non-Normative)
   H W3C XML Core Working Group (Non-Normative)
   I Production Notes (Non-Normative)
   J Suggestions for XML Names (Non-Normative)
   1 Introduction

   Extensible Markup Language, abbreviated XML, describes a class of
   data objects called XML documents and partially describes the
   behavior of computer programs which process them. XML is an
   application profile or restricted form of SGML, the Standard
   Generalized Markup Language [ISO 8879]. By construction, XML
   documents are conforming SGML documents.

   XML documents are made up of storage units called entities, which
   contain either parsed or unparsed data. Parsed data is made up of
   characters, some of which form character data, and some of which
   form markup. Markup encodes a description of the document's storage
   layout and logical structure. XML provides a mechanism to impose
   constraints on the storage layout and logical structure.

   [Definition: A software module called an XML processor is used to
   read XML documents and provide access to their content and
   structure.] [Definition: It is assumed that an XML processor is
   doing its work on behalf of another module, called the
   application.] This specification describes the required behavior of
   an XML processor in terms of how it must read XML data and the
   information it must provide to the application.

   1.1 Origin and Goals

   XML was developed by an XML Working Group (originally known as the
   SGML Editorial Review Board) formed under the auspices of the World
   Wide Web Consortium (W3C) in 1996. It was chaired by Jon Bosak of
   Sun Microsystems with the active participation of an XML Special
   Interest Group (previously known as the SGML Working Group) also
   organized by the W3C. The membership of the XML Working Group is
   given in an appendix. Dan Connolly served as the Working Group's
   contact with the W3C.

   The design goals for XML are:

   XML shall be straightforwardly usable over the Internet.

   XML shall support a wide variety of applications.

   XML shall be compatible with SGML.

   It shall be easy to write programs which process XML documents.

   The number of optional features in XML is to be kept to the absolute minimum, ideally zero.

   XML documents should be human-legible and reasonably clear.

   The XML design should be prepared quickly.

   The design of XML shall be formal and concise.

   XML documents shall be easy to create.

   Terseness in XML markup is of minimal importance.

   This specification, together with associated standards (Unicode
   [Unicode] and ISO/IEC 10646 [ISO/IEC 10646] for characters,
   Internet BCP 47 [IETF BCP 47] and the Language Subtag Registry
   [IANA-LANGCODES] for language identification tags), provides all
   the information necessary to understand XML Version 1.0 and
   construct computer programs to process it.

   This version of the XML specification may be distributed freely, as
   long as all text and legal notices remain intact.

   1.2 Terminology

   The terminology used to describe XML documents is defined in the
   body of this specification. The key words MUST, MUST NOT, REQUIRED,
   SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and
   OPTIONAL, when EMPHASIZED, are to be interpreted as described in
   [IETF RFC 2119]. In addition, the terms defined in the following
   list are used in building those definitions and in describing the
   actions of an XML processor:

   error

   [Definition: A violation of the rules of this specification;
   results are undefined. Unless otherwise specified, failure to observe
   a prescription of this specification indicated by one of the keywords
   MUST, REQUIRED, MUST NOT, SHALL and SHALL NOT is an error. Conforming
   software MAY detect and report an error and MAY recover from it.]

   fatal error

   [Definition: An error which a conforming XML processor MUST detect and report to the application. After encountering a fatal error, the processor MAY continue processing the data to search for further errors and MAY report such errors to the application. In order to support correction of errors, the processor MAY make unprocessed data from the document (with intermingled character data and markup) available to the application. Once a fatal error is detected, however, the processor MUST NOT continue normal processing (i.e., it MUST NOT continue to pass character data and information about the document's logical structure to the application in the normal way).] 
   
   at user option

    [Definition: Conforming software MAY or MUST (depending on the modal verb in the sentence) behave as described; if it does, it MUST provide users a means to enable or disable the behavior described.] 

    validity constraint

    [Definition: A rule which applies to all valid XML documents. Violations of validity constraints are errors; they MUST, at user option, be reported by validating XML processors.] 

    well-formedness constraint

    [Definition: A rule which applies to all well-formed XML documents. Violations of well-formedness constraints are fatal errors.] 
match

    [Definition: (Of strings or names:) Two strings or names being compared are identical. Characters with multiple possible representations in ISO/IEC 10646 (e.g. characters with both precomposed and base+diacritic forms) match only if they have the same representation in both strings. No case folding is performed. (Of strings and rules in the grammar:) A string matches a grammatical production if it belongs to the language generated by that production. (Of content and content models:) An element matches its declaration when it conforms in the fashion described in the constraint [VC: Element Valid].] 

    for compatibility

    [Definition: Marks a sentence describing a feature of XML included solely to ensure that XML remains compatible with SGML.] 

    for interoperability

    [Definition: Marks a sentence describing a non-binding recommendation included to increase the chances that XML documents can be processed by the existing installed base of SGML processors which predate the WebSGML Adaptations Annex to ISO 8879.] 

    2 Documents

    [Definition: A data object is an XML document if it is well-formed, as defined in this specification. In addition, the XML document is valid if it meets certain further constraints.]

    Each XML document has both a logical and a physical structure. Physically, the document is composed of units called entities. An entity may refer to other entities to cause their inclusion in the document. A document begins in a "root" or document entity. Logically, the document is composed of declarations, elements, comments, character references, and processing instructions, all of which are indicated in the document by explicit markup. The logical and physical structures MUST nest properly, as described in 4.3.2 Well-Formed Parsed Entities.

    2.1 Well-Formed XML Documents

    [Definition: A textual object is a well-formed XML document if:]

    Taken as a whole, it matches the production labeled document.

    It meets all the well-formedness constraints given in this specification.

    Each of the parsed entities which is referenced directly or
    indirectly within the document is well-formed.

    Document
    [1]   	document	   ::=   	prolog element Misc*

    Matching the document production implies that:

    It contains one or more elements.

    [Definition: There is exactly one element, called the root, or document element, no part of which appears in the content of any other element.] For all other elements, if the start-tag is in the content of another element, the end-tag is in the content of the same element. More simply stated, the elements, delimited by start- and end-tags, nest properly within each other.

    [Definition: As a consequence of this, for each non-root element C in the document, there is one other element P in the document such that C is in the content of P, but is not in the content of any other element that is in the content of P. P is referred to as the parent of C, and C as a child of P.]

    2.2 Characters

    [Definition: A parsed entity contains text, a sequence of
    characters, which may represent markup or character data.]
    [Definition: A character is an atomic unit of text as specified by
    ISO/IEC 10646:2000 [ISO/IEC 10646]. Legal characters are tab,
    carriage return, line feed, and the legal characters of Unicode
    and ISO/IEC 10646. The versions of these standards cited in A.1
    Normative References were current at the time this document was
    prepared. New characters may be added to these standards by
    amendments or new editions. Consequently, XML processors MUST
    accept any character in the range specified for Char. ]

    Character Range
    [2]   	Char	   ::=   	#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]	/* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */

    The mechanism for encoding character code points into bit patterns
    may vary from entity to entity. All XML processors MUST accept the
    UTF-8 and UTF-16 encodings of Unicode [Unicode]; the mechanisms
    for signaling which of the two is in use, or for bringing other
    encodings into play, are discussed later, in 4.3.3 Character
    Encoding in Entities.

    Note:

    Document authors are encouraged to avoid "compatibility
    characters", as defined in section 2.3 of [Unicode]. The
    characters defined in the following ranges are also
    discouraged. They are either control characters or permanently
    undefined Unicode characters:

    [#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDEF],
    [#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
    [#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
    [#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
    [#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
    [#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF],
    [#x10FFFE-#x10FFFF].

    2.3 Common Syntactic Constructs

    This section defines some symbols used widely in the grammar.

    S (white space) consists of one or more space (#x20) characters, carriage returns, line feeds, or tabs.
    White Space
    [3]   	S	   ::=   	(#x20 | #x9 | #xD | #xA)+

    Note:

    The presence of #xD in the above production is maintained purely
    for backward compatibility with the First Edition. As explained in
    2.11 End-of-Line Handling, all #xD characters literally present in
    an XML document are either removed or replaced by #xA characters
    before any other processing is done. The only way to get a #xD
    character to match this production is to use a character reference
    in an entity value literal.

    An Nmtoken (name token) is any mixture of name characters.

    [Definition: A Name is an Nmtoken with a restricted set of initial
    characters.] Disallowed initial characters for Names include
    digits, diacritics, the full stop and the hyphen.

    Names beginning with the string "xml", or with any string which
    would match (('X'|'x') ('M'|'m') ('L'|'l')), are reserved for
    standardization in this or future versions of this specification.

    Note:

    The Namespaces in XML Recommendation [XML Names] assigns a meaning
    to names containing colon characters. Therefore, authors should
    not use the colon in XML names except for namespace purposes, but
    XML processors must accept the colon as a name character.

    The first character of a Name MUST be a NameStartChar, and any
    other characters MUST be NameChars; this mechanism is used to
    prevent names from beginning with European (ASCII) digits or with
    basic combining characters. Almost all characters are permitted in
    names, except those which either are or reasonably could be used
    as delimiters. The intention is to be inclusive rather than
    exclusive, so that writing systems not yet encoded in Unicode can
    be used in XML names. See J Suggestions for XML Names for
    suggestions on the creation of names.

    Document authors are encouraged to use names which are meaningful words or combinations of words in natural languages, and to avoid symbolic or white space characters in names. Note that COLON, HYPHEN-MINUS, FULL STOP (period), LOW LINE (underscore), and MIDDLE DOT are explicitly permitted.

    The ASCII symbols and punctuation marks, along with a fairly large
    group of Unicode symbol characters, are excluded from names
    because they are more useful as delimiters in contexts where XML
    names are used outside XML documents; providing this group gives
    those contexts hard guarantees about what cannot be part of an XML
    name. The character #x037E, GREEK QUESTION MARK, is excluded
    because when normalized it becomes a semicolon, which could change
    the meaning of entity references.

    Names and Tokens
    [4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
    [4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
    [5]   	Name	   ::=   	NameStartChar (NameChar)*
    [6]   	Names	   ::=   	Name (#x20 Name)*
    [7]   	Nmtoken	   ::=   	(NameChar)+
    [8]   	Nmtokens	   ::=   	Nmtoken (#x20 Nmtoken)*

    Note:

    The Names and Nmtokens productions are used to define the validity
    of tokenized attribute values after normalization (see 3.3.1
    Attribute Types).

    Literal data is any quoted string not containing the quotation
    mark used as a delimiter for that string. Literals are used for
    specifying the content of internal entities (EntityValue), the
    values of attributes (AttValue), and external identifiers
    (SystemLiteral). Note that a SystemLiteral can be parsed without
    scanning for markup.

    Literals
    [9]   	EntityValue	   ::=   	'"' ([^%&"] | PEReference | Reference)* '"'
			|  "'" ([^%&'] | PEReference | Reference)* "'"
    [10]   	AttValue	   ::=   	'"' ([^<&"] | Reference)* '"'
			|  "'" ([^<&'] | Reference)* "'"
    [11]   	SystemLiteral	   ::=   	('"' [^"]* '"') | ("'" [^']* "'")
    [12]   	PubidLiteral	   ::=   	'"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
    [13]   	PubidChar	   ::=   	#x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]

    Note:

    Although the EntityValue production allows the definition of a
    general entity consisting of a single explicit < in the literal
    (e.g., <!ENTITY mylt "<">), it is strongly advised to avoid this
    practice since any reference to that entity will cause a
    well-formedness error.

    2.4 Character Data and Markup

    Text consists of intermingled character data and
    markup. [Definition: Markup takes the form of start-tags,
    end-tags, empty-element tags, entity references, character
    references, comments, CDATA section delimiters, document type
    declarations, processing instructions, XML declarations, text
    declarations, and any white space that is at the top level of the
    document entity (that is, outside the document element and not
    inside any other markup).]

    [Definition: All text that is not markup constitutes the character
    data of the document.]

    The ampersand character (&) and the left angle bracket (<) MUST
    NOT appear in their literal form, except when used as markup
    delimiters, or within a comment, a processing instruction, or a
    CDATA section. If they are needed elsewhere, they MUST be escaped
    using either numeric character references or the strings " &amp; "
    and " &lt; " respectively. The right angle bracket (>) may be
    represented using the string " &gt; ", and MUST, for
    compatibility, be escaped using either " &gt; " or a character
    reference when it appears in the string " ]]> " in content, when
    that string is not marking the end of a CDATA section.

    In the content of elements, character data is any string of
    characters which does not contain the start-delimiter of any
    markup and does not include the CDATA-section-close delimiter, "
    ]]> ". In a CDATA section, character data is any string of
    characters not including the CDATA-section-close delimiter, " ]]>
    ".

    To allow attribute values to contain both single and double
    quotes, the apostrophe or single-quote character (') may be
    represented as " &apos; ", and the double-quote character (") as "
    &quot; ".

    Character Data
    [14]   	CharData	   ::=   	[^<&]* - ([^<&]* ']]>' [^<&]*)

    2.5 Comments

    [Definition: Comments may appear anywhere in a document outside
    other markup; in addition, they may appear within the document
    type declaration at places allowed by the grammar. They are not
    part of the document's character data; an XML processor MAY, but
    need not, make it possible for an application to retrieve the text
    of comments. For compatibility, the string " -- " (double-hyphen)
    MUST NOT occur within comments.] Parameter entity references MUST
    NOT be recognized within comments.

    Comments
    [15]   	Comment	   ::=   	'<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'

    An example of a comment:

    <!-- declarations for <head> & <body> -->

    Note that the grammar does not allow a comment ending in --->. The
    following example is not well-formed.

    <!-- B+, B, or B--->

    2.6 Processing Instructions

    [Definition: Processing instructions (PIs) allow documents to
    contain instructions for applications.]

    Processing Instructions
    [16]   	PI	   ::=   	'<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
    [17]   	PITarget	   ::=   	Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))

    PIs are not part of the document's character data, but MUST be
    passed through to the application. The PI begins with a target
    (PITarget) used to identify the application to which the
    instruction is directed. The target names " XML ", " xml ", and so
    on are reserved for standardization in this or future versions of
    this specification. The XML Notation mechanism may be used for
    formal declaration of PI targets. Parameter entity references MUST
    NOT be recognized within processing instructions.

    2.7 CDATA Sections

    [Definition: CDATA sections may occur anywhere character data may
    occur; they are used to escape blocks of text containing
    characters which would otherwise be recognized as markup. CDATA
    sections begin with the string " <![CDATA[ " and end with the
    string " ]]> ":]

    CDATA Sections
    [18]   	CDSect	   ::=   	CDStart CData CDEnd
    [19]   	CDStart	   ::=   	'<![CDATA['
    [20]   	CData	   ::=   	(Char* - (Char* ']]>' Char*))
    [21]   	CDEnd	   ::=   	']]>'

    Within a CDATA section, only the CDEnd string is recognized as
    markup, so that left angle brackets and ampersands may occur in
    their literal form; they need not (and cannot) be escaped using "
    &lt; " and " &amp; ". CDATA sections cannot nest.

    An example of a CDATA section, in which " <greeting> " and "
    </greeting> " are recognized as character data, not markup:

    <![CDATA[<greeting>Hello, world!</greeting>]]> 

    2.8 Prolog and Document Type Declaration

    [Definition: XML documents SHOULD begin with an XML declaration
    which specifies the version of XML being used.] For example, the
    following is a complete XML document, well-formed but not valid:

    <?xml version="1.0"?>
    <greeting>Hello, world!</greeting> 

    and so is this:

    <greeting>Hello, world!</greeting>

    The function of the markup in an XML document is to describe its
    storage and logical structure and to associate attribute
    name-value pairs with its logical structures. XML provides a
    mechanism, the document type declaration, to define constraints on
    the logical structure and to support the use of predefined storage
    units. [Definition: An XML document is valid if it has an
    associated document type declaration and if the document complies
    with the constraints expressed in it.]

    The document type declaration MUST appear before the first element
    in the document.  

    Prolog
    [22]   	prolog	   ::=   	XMLDecl? Misc* (doctypedecl Misc*)?
    [23]   	XMLDecl	   ::=   	'<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
    [24]   	VersionInfo	   ::=   	S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')
    [25]   	Eq	   ::=   	S? '=' S?
    [26]   	VersionNum	   ::=   	'1.' [0-9]+
    [27]   	Misc	   ::=   	Comment | PI | S

    Even though the VersionNum production matches any version number
    of the form '1.x', XML 1.0 documents SHOULD NOT specify a version
    number other than '1.0'.

    Note:

    When an XML 1.0 processor encounters a document that specifies a
    1.x version number other than '1.0', it will process it as a 1.0
    document. This means that an XML 1.0 processor will accept 1.x
    documents provided they do not use any non-1.0 features.

    [Definition: The XML document type declaration contains or points
    to markup declarations that provide a grammar for a class of
    documents. This grammar is known as a document type definition, or
    DTD. The document type declaration can point to an external subset
    (a special kind of external entity) containing markup
    declarations, or can contain the markup declarations directly in
    an internal subset, or can do both. The DTD for a document
    consists of both subsets taken together.]

    [Definition: A markup declaration is an element type declaration,
    an attribute-list declaration, an entity declaration, or a
    notation declaration.] These declarations may be contained in
    whole or in part within parameter entities, as described in the
    well-formedness and validity constraints below. For further
    information, see 4 Physical Structures.

    Document Type Definition
    [28]   	doctypedecl	   ::=   	'<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'	[VC: Root Element Type]
				[WFC: External Subset]
    [28a]   	DeclSep	   ::=   	PEReference | S 	[WFC: PE Between Declarations]
    [28b]   	intSubset	   ::=   	(markupdecl | DeclSep)*
    [29]   	markupdecl	   ::=   	elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment 	[VC: Proper Declaration/PE Nesting]
				[WFC: PEs in Internal Subset]

    Note that it is possible to construct a well-formed document
    containing a doctypedecl that neither points to an external subset
    nor contains an internal subset.

    The markup declarations may be made up in whole or in part of the
    replacement text of parameter entities. The productions later in
    this specification for individual nonterminals (elementdecl,
    AttlistDecl, and so on) describe the declarations after all the
    parameter entities have been included.

    Parameter entity references are recognized anywhere in the DTD
    (internal and external subsets and external parameter entities),
    except in literals, processing instructions, comments, and the
    contents of ignored conditional sections (see 3.4 Conditional
    Sections). They are also recognized in entity value literals. The
    use of parameter entities in the internal subset is restricted as
    described below.

    Validity constraint: Root Element Type

    The Name in the document type declaration MUST match the element
    type of the root element.

    Validity constraint: Proper Declaration/PE Nesting

    Parameter-entity replacement text MUST be properly nested with
    markup declarations. That is to say, if either the first character
    or the last character of a markup declaration (markupdecl above)
    is contained in the replacement text for a parameter-entity
    reference, both MUST be contained in the same replacement text.

    Well-formedness constraint: PEs in Internal Subset

    In the internal DTD subset, parameter-entity references MUST NOT
    occur within markup declarations; they may occur where markup
    declarations can occur. (This does not apply to references that
    occur in external parameter entities or to the external subset.)

    Well-formedness constraint: External Subset

    The external subset, if any, MUST match the production for extSubset.

    Well-formedness constraint: PE Between Declarations

    The replacement text of a parameter entity reference in a DeclSep
    MUST match the production extSubsetDecl.

    Like the internal subset, the external subset and any external
    parameter entities referenced in a DeclSep MUST consist of a
    series of complete markup declarations of the types allowed by the
    non-terminal symbol markupdecl, interspersed with white space or
    parameter-entity references. However, portions of the contents of
    the external subset or of these external parameter entities may
    conditionally be ignored by using the conditional section
    construct; this is not allowed in the internal subset but is
    allowed in external parameter entities referenced in the internal
    subset.

    External Subset
    [30]   	extSubset	   ::=   	TextDecl? extSubsetDecl
    [31]   	extSubsetDecl	   ::=   	( markupdecl | conditionalSect | DeclSep)*

    The external subset and external parameter entities also differ
    from the internal subset in that in them, parameter-entity
    references are permitted within markup declarations, not only
    between markup declarations.

    An example of an XML document with a document type declaration:

    <?xml version="1.0"?>
    <!DOCTYPE greeting SYSTEM "hello.dtd">
    <greeting>Hello, world!</greeting> 

    The system identifier " hello.dtd " gives the address (a URI
    reference) of a DTD for the document.

    The declarations can also be given locally, as in this example:

    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE greeting [
    <!ELEMENT greeting (#PCDATA)>
    ]>
    <greeting>Hello, world!</greeting>

    If both the external and internal subsets are used, the internal
    subset MUST be considered to occur before the external
    subset. This has the effect that entity and attribute-list
    declarations in the internal subset take precedence over those in
    the external subset.

    2.9 Standalone Document Declaration

    Markup declarations can affect the content of the document, as
    passed from an XML processor to an application; examples are
    attribute defaults and entity declarations. The standalone
    document declaration, which may appear as a component of the XML
    declaration, signals whether or not there are such declarations
    which appear external to the document entity or in parameter
    entities. [Definition: An external markup declaration is defined
    as a markup declaration occurring in the external subset or in a
    parameter entity (external or internal, the latter being included
    because non-validating processors are not required to read them).]

    Standalone Document Declaration
    [32]   	SDDecl	   ::=   	S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"')) 	[VC: Standalone Document Declaration]

    In a standalone document declaration, the value "yes" indicates
    that there are no external markup declarations which affect the
    information passed from the XML processor to the application. The
    value "no" indicates that there are or may be such external markup
    declarations. Note that the standalone document declaration only
    denotes the presence of external declarations; the presence, in a
    document, of references to external entities, when those entities
    are internally declared, does not change its standalone status.

    If there are no external markup declarations, the standalone
    document declaration has no meaning. If there are external markup
    declarations but there is no standalone document declaration, the
    value "no" is assumed.

    Any XML document for which standalone="no" holds can be converted
    algorithmically to a standalone document, which may be desirable
    for some network delivery applications.

    Validity constraint: Standalone Document Declaration

    The standalone document declaration MUST have the value "no" if
    any external markup declarations contain declarations of:

    attributes with default values, if elements to which these
    attributes apply appear in the document without specifications of
    values for these attributes, or

    entities (other than amp, lt, gt, apos, quot), if references to
    those entities appear in the document, or

    attributes with tokenized types, where the attribute appears in
    the document with a value such that normalization will produce a
    different value from that which would be produced in the absence
    of the declaration, or

    element types with element content, if white space occurs directly
    within any instance of those types.

    An example XML declaration with a standalone document declaration:

    <?xml version="1.0" standalone='yes'?>

    2.10 White Space Handling

    In editing XML documents, it is often convenient to use "white
    space" (spaces, tabs, and blank lines) to set apart the markup for
    greater readability. Such white space is typically not intended
    for inclusion in the delivered version of the document. On the
    other hand, "significant" white space that should be preserved in
    the delivered version is common, for example in poetry and source
    code.

    An XML processor MUST always pass all characters in a document
    that are not markup through to the application. A validating XML
    processor MUST also inform the application which of these
    characters constitute white space appearing in element content.

    A special attribute named xml:space may be attached to an element
    to signal an intention that in that element, white space should be
    preserved by applications. In valid documents, this attribute,
    like any other, MUST be declared if it is used. When declared, it
    MUST be given as an enumerated type whose values are one or both
    of "default" and "preserve". For example:

    <!ATTLIST poem  xml:space (default|preserve) 'preserve'>

    <!ATTLIST pre xml:space (preserve) #FIXED 'preserve'>

    The value "default" signals that applications' default white-space
    processing modes are acceptable for this element; the value
    "preserve" indicates the intent that applications preserve all the
    white space. This declared intent is considered to apply to all
    elements within the content of the element where it is specified,
    unless overridden with another instance of the xml:space
    attribute. This specification does not give meaning to any value
    of xml:space other than "default" and "preserve". It is an error
    for other values to be specified; the XML processor MAY report the
    error or MAY recover by ignoring the attribute specification or by
    reporting the (erroneous) value to the application. Applications
    may ignore or reject erroneous values.

    The root element of any document is considered to have signaled no
    intentions as regards application space handling, unless it
    provides a value for this attribute or the attribute is declared
    with a default value.

    2.11 End-of-Line Handling

    XML parsed entities are often stored in computer files which, for
    editing convenience, are organized into lines. These lines are
    typically separated by some combination of the characters CARRIAGE
    RETURN (#xD) and LINE FEED (#xA).

    To simplify the tasks of applications, the XML processor MUST
    behave as if it normalized all line breaks in external parsed
    entities (including the document entity) on input, before parsing,
    by translating both the two-character sequence #xD #xA and any #xD
    that is not followed by #xA to a single #xA character.

    2.12 Language Identification

    In document processing, it is often useful to identify the natural
    or formal language in which the content is written. A special
    attribute named xml:lang may be inserted in documents to specify
    the language used in the contents and attribute values of any
    element in an XML document. In valid documents, this attribute,
    like any other, MUST be declared if it is used. The values of the
    attribute are language identifiers as defined by [IETF BCP 47],
    Tags for the Identification of Languages; in addition, the empty
    string may be specified.

    (Productions 33 through 38 have been removed.)

    For example:

    <p xml:lang="en">The quick brown fox jumps over the lazy dog.</p>
    <p xml:lang="en-GB">What colour is it?</p>
    <p xml:lang="en-US">What color is it?</p>
    <sp who="Faust" desc='leise' xml:lang="de">
    <l>Habe nun, ach! Philosophie,</l>
    <l>Juristerei, und Medizin</l>
    <l>und leider auch Theologie</l>
    <l>durchaus studiert mit heißem Bemüh'n.</l>
    </sp>

    The language specified by xml:lang applies to the element where it
    is specified (including the values of its attributes), and to all
    elements in its content unless overridden with another instance of
    xml:lang. In particular, the empty value of xml:lang is used on an
    element B to override a specification of xml:lang on an enclosing
    element A, without specifying another language. Within B, it is
    considered that there is no language information available, just
    as if xml:lang had not been specified on B or any of its
    ancestors. Applications determine which of an element's attribute
    values and which parts of its character content, if any, are
    treated as language-dependent values described by xml:lang.

    Note:

    Language information may also be provided by external transport
    protocols (e.g. HTTP or MIME). When available, this information
    may be used by XML applications, but the more local information
    provided by xml:lang should be considered to override it.

    A simple declaration for xml:lang might take the form

    xml:lang CDATA #IMPLIED

    but specific default values may also be given, if appropriate. In
    a collection of French poems for English students, with glosses
    and notes in English, the xml:lang attribute might be declared
    this way:

    <!ATTLIST poem   xml:lang CDATA 'fr'>
    <!ATTLIST gloss  xml:lang CDATA 'en'>
    <!ATTLIST note   xml:lang CDATA 'en'>

    3 Logical Structures

    [Definition: Each XML document contains one or more elements, the
    boundaries of which are either delimited by start-tags and
    end-tags, or, for empty elements, by an empty-element tag. Each
    element has a type, identified by name, sometimes called its
    "generic identifier" (GI), and may have a set of attribute
    specifications.] Each attribute specification has a name and a
    value.

    Element
    [39]   	element	   ::=   	EmptyElemTag
			| STag content ETag 	[WFC: Element Type Match]
				[VC: Element Valid]

     This specification does not constrain the application semantics,
     use, or (beyond syntax) names of the element types and
     attributes, except that names beginning with a match to
     (('X'|'x')('M'|'m')('L'|'l')) are reserved for standardization in
     this or future versions of this specification.

     Well-formedness constraint: Element Type Match

     The Name in an element's end-tag MUST match the element type in
     the start-tag.

     Validity constraint: Element Valid

     An element is valid if there is a declaration matching
     elementdecl where the Name matches the element type, and one of
     the following holds:

     The declaration matches EMPTY and the element has no content (not
     even entity references, comments, PIs or white space).

     The declaration matches children and the sequence of child
     elements belongs to the language generated by the regular
     expression in the content model, with optional white space,
     comments and PIs (i.e. markup matching production [27] Misc)
     between the start-tag and the first child element, between child
     elements, or between the last child element and the end-tag. Note
     that a CDATA section containing only white space or a reference
     to an entity whose replacement text is character references
     expanding to white space do not match the nonterminal S, and
     hence cannot appear in these positions; however, a reference to
     an internal entity with a literal value consisting of character
     references expanding to white space does match S, since its
     replacement text is the white space resulting from expansion of
     the character references.

     The declaration matches Mixed, and the content (after replacing
     any entity references with their replacement text) consists of
     character data (including CDATA sections), comments, PIs and child
     elements whose types match names in the content model.

     The declaration matches ANY, and the content (after replacing any
     entity references with their replacement text) consists of
     character data, CDATA sections, comments, PIs and child elements
     whose types have been declared.

     3.1 Start-Tags, End-Tags, and Empty-Element Tags

     [Definition: The beginning of every non-empty XML element is
     marked by a start-tag.]

     Start-tag
     [40]   	STag	   ::=   	'<' Name (S Attribute)* S? '>'	[WFC: Unique Att Spec]
     [41]   	Attribute	   ::=   	Name Eq AttValue 	[VC: Attribute Value Type]
				[WFC: No External Entity References]
				[WFC: No < in Attribute Values]

     The Name in the start- and end-tags gives the element's
     type. 

     [Definition: The Name-AttValue pairs are referred to as the
     attribute specifications of the element], 

     [Definition: with the Name in each pair referred to as the
     attribute name ] and

     [Definition: the content of the AttValue (the text between the '
     or " delimiters) as the attribute value.]

     Note that the order of attribute specifications in a start-tag or
     empty-element tag is not significant.

     Well-formedness constraint: Unique Att Spec

     An attribute name MUST NOT appear more than once in the same
     start-tag or empty-element tag.

     Validity constraint: Attribute Value Type

     The attribute MUST have been declared; the value MUST be of the
     type declared for it. (For attribute types, see 3.3
     Attribute-List Declarations.)

     Well-formedness constraint: No External Entity References

     Attribute values MUST NOT contain direct or indirect entity
     references to external entities.

     Well-formedness constraint: No < in Attribute Values

     The replacement text of any entity referred to directly or
     indirectly in an attribute value MUST NOT contain a <.

     An example of a start-tag:

     <termdef id="dt-dog" term="dog">

     [Definition: The end of every element that begins with a
     start-tag MUST be marked by an end-tag containing a name that
     echoes the element's type as given in the start-tag:]

     End-tag
     [42]   	ETag	   ::=   	'</' Name S? '>'

     An example of an end-tag:

     </termdef>

     [Definition: The text between the start-tag and end-tag is called
     the element's content:]

     Content of Elements
     [43]   	content	   ::=   CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*

     [Definition: An element with no content is said to be empty.] The
     representation of an empty element is either a start-tag
     immediately followed by an end-tag, or an empty-element
     tag. [Definition: An empty-element tag takes a special form:]

     Tags for Empty Elements
     [44]   	EmptyElemTag ::=   '<' Name (S Attribute)* S? '/>'	[WFC: Unique Att Spec]

     Empty-element tags may be used for any element which has no
     content, whether or not it is declared using the keyword
     EMPTY. For interoperability, the empty-element tag SHOULD be
     used, and SHOULD only be used, for elements which are declared
     EMPTY.

     Examples of empty elements:

     <IMG align="left"
     src="http://www.w3.org/Icons/WWW/w3c_home" />
     <br></br>
     <br/>

     3.2 Element Type Declarations

     The element structure of an XML document may, for validation
     purposes, be constrained using element type and attribute-list
     declarations. An element type declaration constrains the
     element's content.

     Element type declarations often constrain which element types can
     appear as children of the element. At user option, an XML
     processor MAY issue a warning when a declaration mentions an
     element type for which no declaration is provided, but this is
     not an error.

     [Definition: An element type declaration takes the form:]

     Element Type Declaration
     [45]   	elementdecl	   ::=   	'<!ELEMENT' S Name S contentspec S? '>'	[VC: Unique Element Type Declaration]
     [46]   	contentspec	   ::=   	'EMPTY' | 'ANY' | Mixed | children

     where the Name gives the element type being declared.

     Validity constraint: Unique Element Type Declaration

     An element type MUST NOT be declared more than once.

     Examples of element type declarations:

     <!ELEMENT br EMPTY>
     <!ELEMENT p (#PCDATA|emph)* >
     <!ELEMENT %name.para; %content.para; >
     <!ELEMENT container ANY>

     3.2.1 Element Content

     [Definition: An element type has element content when elements of
     that type MUST contain only child elements (no character data),
     optionally separated by white space (characters matching the
     nonterminal S).] [Definition: In this case, the constraint
     includes a content model, a simple grammar governing the allowed
     types of the child elements and the order in which they are
     allowed to appear.] The grammar is built on content particles
     (cps), which consist of names, choice lists of content particles,
     or sequence lists of content particles:

     Element-content Models
     [47]   	children   ::=   	(choice | seq) ('?' | '*' | '+')?
     [48]   	cp	   ::=   	(Name | choice | seq) ('?' | '*' | '+')?
     [49]   	choice	   ::=   	'(' S? cp ( S? '|' S? cp )+ S? ')'	[VC: Proper Group/PE Nesting]
     [50]   	seq	   ::=   	'(' S? cp ( S? ',' S? cp )* S? ')'	[VC: Proper Group/PE Nesting]

     where each Name is the type of an element which may appear as a
     child. Any content particle in a choice list may appear in the
     element content at the location where the choice list appears in
     the grammar; content particles occurring in a sequence list MUST
     each appear in the element content in the order given in the
     list. The optional character following a name or list governs
     whether the element or the content particles in the list may
     occur one or more (+), zero or more (*), or zero or one times
     (?). The absence of such an operator means that the element or
     content particle MUST appear exactly once. This syntax and
     meaning are identical to those used in the productions in this
     specification.

     The content of an element matches a content model if and only if
     it is possible to trace out a path through the content model,
     obeying the sequence, choice, and repetition operators and
     matching each element in the content against an element type in
     the content model. For compatibility, it is an error if the
     content model allows an element to match more than one occurrence
     of an element type in the content model. For more information,
     see E Deterministic Content Models.

     Validity constraint: Proper Group/PE Nesting

     Parameter-entity replacement text MUST be properly nested with
     parenthesized groups. That is to say, if either of the opening or
     closing parentheses in a choice, seq, or Mixed construct is
     contained in the replacement text for a parameter entity, both
     MUST be contained in the same replacement text.

     For interoperability, if a parameter-entity reference appears in
     a choice, seq, or Mixed construct, its replacement text SHOULD
     contain at least one non-blank character, and neither the first
     nor last non-blank character of the replacement text SHOULD be a
     connector (| or ,).

     Examples of element-content models:

     <!ELEMENT spec (front, body, back?)>
     <!ELEMENT div1 (head, (p | list | note)*, div2*)>
     <!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*>

     3.2.2 Mixed Content

     [Definition: An element type has mixed content when elements of
     that type may contain character data, optionally interspersed
     with child elements.] In this case, the types of the child
     elements may be constrained, but not their order or their number
     of occurrences:

     Mixed-content Declaration
     [51]   	Mixed	   ::=   	'(' S? '#PCDATA' (S? '|' S? Name)* S? ')*'
			| '(' S? '#PCDATA' S? ')' 	[VC: Proper Group/PE Nesting]
				[VC: No Duplicate Types]

     where the Names give the types of elements that may appear as
     children. The keyword #PCDATA derives historically from the term
     "parsed character data."

     Validity constraint: No Duplicate Types

     The same name MUST NOT appear more than once in a single
     mixed-content declaration.

     Examples of mixed content declarations:

     <!ELEMENT p (#PCDATA|a|ul|b|i|em)*>
     <!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* >
     <!ELEMENT b (#PCDATA)>

     3.3 Attribute-List Declarations

     Attributes are used to associate name-value pairs with
     elements. Attribute specifications MUST NOT appear outside of
     start-tags and empty-element tags; thus, the productions used to
     recognize them appear in 3.1 Start-Tags, End-Tags, and
     Empty-Element Tags. Attribute-list declarations may be used:

     To define the set of attributes pertaining to a given element
     type.

     To establish type constraints for these attributes.

     To provide default values for attributes.

     [Definition: Attribute-list declarations specify the name, data
     type, and default value (if any) of each attribute associated
     with a given element type:]

     Attribute-list Declaration
     [52]   	AttlistDecl	   ::=   	'<!ATTLIST' S Name AttDef* S? '>'
     [53]   	AttDef	   ::=   	S Name S AttType S DefaultDecl

     The Name in the AttlistDecl rule is the type of an element. At
     user option, an XML processor MAY issue a warning if attributes
     are declared for an element type not itself declared, but this is
     not an error. The Name in the AttDef rule is the name of the
     attribute.

     When more than one AttlistDecl is provided for a given element
     type, the contents of all those provided are merged. When more
     than one definition is provided for the same attribute of a given
     element type, the first declaration is binding and later
     declarations are ignored. For interoperability, writers of DTDs
     may choose to provide at most one attribute-list declaration for
     a given element type, at most one attribute definition for a
     given attribute name in an attribute-list declaration, and at
     least one attribute definition in each attribute-list
     declaration. For interoperability, an XML processor MAY at user
     option issue a warning when more than one attribute-list
     declaration is provided for a given element type, or more than
     one attribute definition is provided for a given attribute, but
     this is not an error.

     3.3.1 Attribute Types

     XML attribute types are of three kinds: a string type, a set of
     tokenized types, and enumerated types. The string type may take
     any literal string as a value; the tokenized types are more
     constrained. The validity constraints noted in the grammar are
     applied after the attribute value has been normalized as
     described in 3.3.3 Attribute-Value Normalization.

      Attribute Types
      [54]   	AttType	   ::=   	StringType | TokenizedType | EnumeratedType
      [55]   	StringType	   ::=   	'CDATA'
      [56]   	TokenizedType	   ::=   	'ID'	[VC: ID]
				[VC: One ID per Element Type]
				[VC: ID Attribute Default]
			| 'IDREF'	[VC: IDREF]
			| 'IDREFS'	[VC: IDREF]
			| 'ENTITY'	[VC: Entity Name]
			| 'ENTITIES'	[VC: Entity Name]
			| 'NMTOKEN'	[VC: Name Token]
			| 'NMTOKENS'	[VC: Name Token]

     Validity constraint: ID

     Values of type ID MUST match the Name production. A name MUST NOT
     appear more than once in an XML document as a value of this type;
     i.e., ID values MUST uniquely identify the elements which bear
     them.

     Validity constraint: One ID per Element Type

     An element type MUST NOT have more than one ID attribute specified.

     Validity constraint: ID Attribute Default

     An ID attribute MUST have a declared default of #IMPLIED or
     #REQUIRED.

     Validity constraint: IDREF

     Values of type IDREF MUST match the Name production, and values
     of type IDREFS MUST match Names; each Name MUST match the value
     of an ID attribute on some element in the XML document;
     i.e. IDREF values MUST match the value of some ID attribute.

     Validity constraint: Entity Name

     Values of type ENTITY MUST match the Name production, values of
     type ENTITIES MUST match Names; each Name MUST match the name of
     an unparsed entity declared in the DTD.

     Validity constraint: Name Token

     Values of type NMTOKEN MUST match the Nmtoken production; values of type NMTOKENS MUST match Nmtokens.

     [Definition: Enumerated attributes have a list of allowed values
     in their declaration ]. They MUST take one of those values. There
     are two kinds of enumerated attribute types:

     Enumerated Attribute Types
     [57]   	EnumeratedType	   ::=   	NotationType | Enumeration
     [58]   	NotationType	   ::=   	'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')' 	[VC: Notation Attributes]
				[VC: One Notation Per Element Type]
				[VC: No Notation on Empty Element]
				[VC: No Duplicate Tokens]
     [59]   	Enumeration	   ::=   	'(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'	[VC: Enumeration]
				[VC: No Duplicate Tokens]

     A NOTATION attribute identifies a notation, declared in the DTD
     with associated system and/or public identifiers, to be used in
     interpreting the element to which the attribute is attached.

     Validity constraint: Notation Attributes

     Values of this type MUST match one of the notation names included
     in the declaration; all notation names in the declaration MUST be
     declared.

     Validity constraint: One Notation Per Element Type

     An element type MUST NOT have more than one NOTATION attribute
     specified.

     Validity constraint: No Notation on Empty Element

     For compatibility, an attribute of type NOTATION MUST NOT be
     declared on an element declared EMPTY.

     Validity constraint: No Duplicate Tokens

     The notation names in a single NotationType attribute
     declaration, as well as the NmTokens in a single Enumeration
     attribute declaration, MUST all be distinct.

     Validity constraint: Enumeration

     Values of this type MUST match one of the Nmtoken tokens in the
     declaration.

     For interoperability, the same Nmtoken SHOULD NOT occur more than
     once in the enumerated attribute types of a single element type.

     3.3.2 Attribute Defaults

     An attribute declaration provides information on whether the
     attribute's presence is REQUIRED, and if not, how an XML
     processor is to react if a declared attribute is absent in a
     document.

     Attribute Defaults
     [60]   	DefaultDecl	   ::=   	'#REQUIRED' | '#IMPLIED'
			| (('#FIXED' S)? AttValue)	[VC: Required Attribute]
				[VC: Attribute Default Value Syntactically Correct]
				[WFC: No < in Attribute Values]
				[VC: Fixed Attribute Default]
				[WFC: No External Entity References]

     In an attribute declaration, #REQUIRED means that the attribute
     MUST always be provided, #IMPLIED that no default value is
     provided. [Definition: If the declaration is neither #REQUIRED
     nor #IMPLIED, then the AttValue value contains the declared
     default value; the #FIXED keyword states that the attribute MUST
     always have the default value. When an XML processor encounters
     an element without a specification for an attribute for which it
     has read a default value declaration, it MUST report the
     attribute with the declared default value to the application.]

     Validity constraint: Required Attribute

     If the default declaration is the keyword #REQUIRED, then the
     attribute MUST be specified for all elements of the type in the
     attribute-list declaration.

     Validity constraint: Attribute Default Value Syntactically Correct

     The declared default value MUST meet the syntactic constraints of
     the declared attribute type. That is, the default value of an
     attribute:

    of type IDREF or ENTITY must match the Name production;

    of type IDREFS or ENTITIES must match the Names production;

    of type NMTOKEN must match the Nmtoken production;

    of type NMTOKENS must match the Nmtokens production;

    of an enumerated type (either a NOTATION type or an enumeration) must match one of the enumerated values.

    Note that only the syntactic constraints of the type are required
    here; other constraints (e.g. that the value be the name of a
    declared unparsed entity, for an attribute of type ENTITY) will be
    reported by a validating parser only if an element without a
    specification for this attribute actually occurs.

    Validity constraint: Fixed Attribute Default

    If an attribute has a default value declared with the #FIXED
    keyword, instances of that attribute MUST match the default value.

    Examples of attribute-list declarations:

    <!ATTLIST termdef
    id      ID      #REQUIRED
    name    CDATA   #IMPLIED>
    <!ATTLIST list
    type    (bullets|ordered|glossary)  "ordered">
    <!ATTLIST form
    method  CDATA   #FIXED "POST">

    3.3.3 Attribute-Value Normalization

    Before the value of an attribute is passed to the application or
    checked for validity, the XML processor MUST normalize the
    attribute value by applying the algorithm below, or by using some
    other method such that the value passed to the application is the
    same as that produced by the algorithm.

    All line breaks MUST have been normalized on input to #xA as
    described in 2.11 End-of-Line Handling, so the rest of this
    algorithm operates on text normalized in this way.

    Begin with a normalized value consisting of the empty string.

    For each character, entity reference, or character reference in
    the unnormalized attribute value, beginning with the first and
    continuing to the last, do the following:

    For a character reference, append the referenced character to the
    normalized value.

    For an entity reference, recursively apply step 3 of this
    algorithm to the replacement text of the entity.

    For a white space character (#x20, #xD, #xA, #x9), append a space
    character (#x20) to the normalized value.

    For another character, append the character to the normalized
    value.

    If the attribute type is not CDATA, then the XML processor MUST
    further process the normalized attribute value by discarding any
    leading and trailing space (#x20) characters, and by replacing
    sequences of space (#x20) characters by a single space (#x20)
    character.

    Note that if the unnormalized attribute value contains a character
    reference to a white space character other than space (#x20), the
    normalized value contains the referenced character itself (#xD,
    #xA or #x9). This contrasts with the case where the unnormalized
    value contains a white space character (not a reference), which is
    replaced with a space character (#x20) in the normalized value and
    also contrasts with the case where the unnormalized value contains
    an entity reference whose replacement text contains a white space
    character; being recursively processed, the white space character
    is replaced with a space character (#x20) in the normalized value.

    All attributes for which no declaration has been read SHOULD be
    treated by a non-validating processor as if declared CDATA.

    It is an error if an attribute value contains a reference to an
    entity for which no declaration has been read.

    Following are examples of attribute normalization. Given the
    following declarations:

    <!ENTITY d "&#xD;">
    <!ENTITY a "&#xA;">
    <!ENTITY da "&#xD;&#xA;">

    the attribute specifications in the left column below would be
    normalized to the character sequences of the middle column if the
    attribute a is declared NMTOKENS and to those of the right columns
    if a is declared CDATA.

    Attribute specification	a is NMTOKENS	a is CDATA

    a="

    xyz"

	

    x y z

	

    #x20 #x20 x y z

    a="&d;&d;A&a;&#x20;&a;B&da;"

	

    A #x20 B

	

    #x20 #x20 A #x20 #x20 #x20 B #x20 #x20

    a=
    "&#xd;&#xd;A&#xa;&#xa;B&#xd;&#xa;"

	

    #xD #xD A #xA #xA B #xD #xA

	

    #xD #xD A #xA #xA B #xD #xA

    Note that the last example is invalid (but well-formed) if a is
    declared to be of type NMTOKENS.

    3.4 Conditional Sections

    [Definition: Conditional sections are portions of the document
    type declaration external subset or of external parameter entities
    which are included in, or excluded from, the logical structure of
    the DTD based on the keyword which governs them.]

    Conditional Section
    [61]   	conditionalSect	   ::=   	includeSect | ignoreSect
    [62]   	includeSect	   ::=   	'<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>' 	[VC: Proper Conditional Section/PE Nesting]
    [63]   	ignoreSect	   ::=   	'<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'	[VC: Proper Conditional Section/PE Nesting]
    [64]   	ignoreSectContents	   ::=   	Ignore ('<![' ignoreSectContents ']]>' Ignore)*
    [65]   	Ignore	   ::=   	Char* - (Char* ('<![' | ']]>') Char*)

    Validity constraint: Proper Conditional Section/PE Nesting

    If any of the "<![", "[", or "]]>" of a conditional section is
    contained in the replacement text for a parameter-entity
    reference, all of them MUST be contained in the same replacement
    text.

    Like the internal and external DTD subsets, a conditional section
    may contain one or more complete declarations, comments,
    processing instructions, or nested conditional sections,
    intermingled with white space.

    If the keyword of the conditional section is INCLUDE, then the
    contents of the conditional section MUST be processed as part of
    the DTD. If the keyword of the conditional section is IGNORE, then
    the contents of the conditional section MUST NOT be processed as
    part of the DTD. If a conditional section with a keyword of
    INCLUDE occurs within a larger conditional section with a keyword
    of IGNORE, both the outer and the inner conditional sections MUST
    be ignored. The contents of an ignored conditional section MUST be
    parsed by ignoring all characters after the "[" following the
    keyword, except conditional section starts "<![" and ends "]]>",
    until the matching conditional section end is found. Parameter
    entity references MUST NOT be recognized in this process.

    If the keyword of the conditional section is a parameter-entity
    reference, the parameter entity MUST be replaced by its content
    before the processor decides whether to include or ignore the
    conditional section.

    An example:

    <!ENTITY % draft 'INCLUDE' >
    <!ENTITY % final 'IGNORE' >

    <![%draft;[
    <!ELEMENT book (comments*, title, body, supplements?)>
    ]]>
    <![%final;[
    <!ELEMENT book (title, body, supplements?)>
    ]]>

    4 Physical Structures

    [Definition: An XML document may consist of one or many storage
    units. These are called entities; they all have content and are
    all (except for the document entity and the external DTD subset)
    identified by entity name.] Each XML document has one entity
    called the document entity, which serves as the starting point for
    the XML processor and may contain the whole document.

    Entities may be either parsed or unparsed. [Definition: The
    contents of a parsed entity are referred to as its replacement
    text; this text is considered an integral part of the document.]

    [Definition: An unparsed entity is a resource whose contents may
    or may not be text, and if text, may be other than XML. Each
    unparsed entity has an associated notation, identified by
    name. Beyond a requirement that an XML processor make the
    identifiers for the entity and notation available to the
    application, XML places no constraints on the contents of unparsed
    entities.]

    Parsed entities are invoked by name using entity references;
    unparsed entities by name, given in the value of ENTITY or
    ENTITIES attributes.

    [Definition: General entities are entities for use within the
    document content. In this specification, general entities are
    sometimes referred to with the unqualified term entity when this
    leads to no ambiguity.] [Definition: Parameter entities are parsed
    entities for use within the DTD.] These two types of entities use
    different forms of reference and are recognized in different
    contexts. Furthermore, they occupy different namespaces; a
    parameter entity and a general entity with the same name are two
    distinct entities.

    4.1 Character and Entity References

    [Definition: A character reference refers to a specific character
    in the ISO/IEC 10646 character set, for example one not directly
    accessible from available input devices.]

    Character Reference
    [66]   	CharRef	   ::=   	'&#' [0-9]+ ';'
			| '&#x' [0-9a-fA-F]+ ';'	[WFC: Legal Character]

    Well-formedness constraint: Legal Character

    Characters referred to using character references MUST match the
    production for Char.

    If the character reference begins with " &#x ", the digits and
    letters up to the terminating ; provide a hexadecimal
    representation of the character's code point in ISO/IEC 10646. If
    it begins just with " &# ", the digits up to the terminating ;
    provide a decimal representation of the character's code point.

    [Definition: An entity reference refers to the content of a named
    entity.] 

    [Definition: References to parsed general entities use
    ampersand (&) and semicolon (;) as delimiters.] 

    [Definition: Parameter-entity references use percent-sign (%) and
    semicolon (;) as delimiters.]
    
    Entity Reference
    [67]   	Reference	::=   	EntityRef | CharRef
    [68]   	EntityRef	::=   	'&' Name ';'	[WFC: Entity Declared]
				[VC: Entity Declared]
				[WFC: Parsed Entity]
				[WFC: No Recursion]
    [69]   	PEReference	::=   	'%' Name ';'	[VC: Entity Declared]
				[WFC: No Recursion]
				[WFC: In DTD]

     Well-formedness constraint: Entity Declared

     In a document without any DTD, a document with only an internal
     DTD subset which contains no parameter entity references, or a
     document with " standalone='yes' ", for an entity reference that
     does not occur within the external subset or a parameter entity,
     the Name given in the entity reference MUST match that in an
     entity declaration that does not occur within the external subset
     or a parameter entity, except that well-formed documents need not
     declare any of the following entities: amp, lt, gt, apos,
     quot. The declaration of a general entity MUST precede any
     reference to it which appears in a default value in an
     attribute-list declaration.

     Note that non-validating processors are not obligated to read and
     process entity declarations occurring in parameter entities or in
     the external subset; for such documents, the rule that an entity
     must be declared is a well-formedness constraint only if
     standalone='yes'.

     Validity constraint: Entity Declared

     In a document with an external subset or parameter entity
     references, if the document is not standalone (either
     "standalone='no'" is specified or there is no standalone
     declaration), then the Name given in the entity reference MUST
     match that in an entity declaration. For interoperability, valid
     documents SHOULD declare the entities amp, lt, gt, apos, quot, in
     the form specified in 4.6 Predefined Entities. The declaration of
     a parameter entity MUST precede any reference to it. Similarly,
     the declaration of a general entity MUST precede any
     attribute-list declaration containing a default value with a
     direct or indirect reference to that general entity.

     Well-formedness constraint: Parsed Entity

     An entity reference MUST NOT contain the name of an unparsed
     entity. Unparsed entities may be referred to only in attribute
     values declared to be of type ENTITY or ENTITIES.

     Well-formedness constraint: No Recursion

     A parsed entity MUST NOT contain a recursive reference to itself,
     either directly or indirectly.

     Well-formedness constraint: In DTD

     Parameter-entity references MUST NOT appear outside the DTD.

     Examples of character and entity references:

     Type <key>less-than</key> (&#x3C;) to save options.
     This document was prepared on &docdate; and
     is classified &security-level;.

     Example of a parameter-entity reference:

     <!-- declare the parameter entity "ISOLat2"... -->
     <!ENTITY % ISOLat2
     SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" >
     <!-- ... now reference it. -->
     %ISOLat2;

     4.2 Entity Declarations

     [Definition: Entities are declared thus:]

     Entity Declaration
     [70]   	EntityDecl	   ::=   	GEDecl | PEDecl
     [71]   	GEDecl	   ::=   	'<!ENTITY' S Name S EntityDef S? '>'
     [72]   	PEDecl	   ::=   	'<!ENTITY' S '%' S Name S PEDef S? '>'
     [73]   	EntityDef	   ::=   	EntityValue | (ExternalID NDataDecl?)
     [74]   	PEDef	   ::=   	EntityValue | ExternalID

     The Name identifies the entity in an entity reference or, in the
     case of an unparsed entity, in the value of an ENTITY or ENTITIES
     attribute. If the same entity is declared more than once, the
     first declaration encountered is binding; at user option, an XML
     processor MAY issue a warning if entities are declared multiple
     times.

     4.2.1 Internal Entities

     [Definition: If the entity definition is an EntityValue, the
     defined entity is called an internal entity. There is no separate
     physical storage object, and the content of the entity is given
     in the declaration.] Note that some processing of entity and
     character references in the literal entity value may be required
     to produce the correct replacement text: see 4.5 Construction of
     Entity Replacement Text.

     An internal entity is a parsed entity.

     Example of an internal entity declaration:

     <!ENTITY Pub-Status "This is a pre-release of the
     specification.">

     4.2.2 External Entities

     [Definition: If the entity is not internal, it is an external
     entity, declared as follows:]

     External Entity Declaration
     [75]   	ExternalID	   ::=   	'SYSTEM' S SystemLiteral
			| 'PUBLIC' S PubidLiteral S SystemLiteral
     [76]   	NDataDecl	   ::=   	S 'NDATA' S Name 	[VC: Notation Declared]

     If the NDataDecl is present, this is a general unparsed entity;
     otherwise it is a parsed entity.

     Validity constraint: Notation Declared

     The Name MUST match the declared name of a notation.

     [Definition: The SystemLiteral is called the entity's system
     identifier. It is meant to be converted to a URI reference (as
     defined in [IETF RFC 3986]), as part of the process of
     dereferencing it to obtain input for the XML processor to
     construct the entity's replacement text.] It is an error for a
     fragment identifier (beginning with a # character) to be part of
     a system identifier. Unless otherwise provided by information
     outside the scope of this specification (e.g. a special XML
     element type defined by a particular DTD, or a processing
     instruction defined by a particular application specification),
     relative URIs are relative to the location of the resource within
     which the entity declaration occurs. This is defined to be the
     external entity containing the '<' which starts the declaration,
     at the point when it is parsed as a declaration. A URI might thus
     be relative to the document entity, to the entity containing the
     external DTD subset, or to some other external parameter
     entity. Attempts to retrieve the resource identified by a URI may
     be redirected at the parser level (for example, in an entity
     resolver) or below (at the protocol level, for example, via an
     HTTP Location: header). In the absence of additional information
     outside the scope of this specification within the resource, the
     base URI of a resource is always the URI of the actual resource
     returned. In other words, it is the URI of the resource retrieved
     after all redirection has occurred.

     System identifiers (and other XML strings meant to be used as URI
     references) may contain characters that, according to [IETF RFC
     3986], must be escaped before a URI can be used to retrieve the
     referenced resource. The characters to be escaped are the control
     characters #x0 to #x1F and #x7F (most of which cannot appear in
     XML), space #x20, the delimiters '<' #x3C, '>' #x3E and '"' #x22,
     the unwise characters '{' #x7B, '}' #x7D, '|' #x7C, '\' #x5C, '^'
     #x5E and '`' #x60, as well as all characters above #x7F. Since
     escaping is not always a fully reversible process, it MUST be
     performed only when absolutely necessary and as late as possible
     in a processing chain. In particular, neither the process of
     converting a relative URI to an absolute one nor the process of
     passing a URI reference to a process or software component
     responsible for dereferencing it SHOULD trigger escaping. When
     escaping does occur, it MUST be performed as follows:

     Each character to be escaped is represented in UTF-8 [Unicode] as
     one or more bytes.

     The resulting bytes are escaped with the URI escaping mechanism
     (that is, converted to % HH, where HH is the hexadecimal notation
     of the byte value).

     The original character is replaced by the resulting character sequence.

     Note:

     In a future edition of this specification, the XML Core Working
     Group intends to replace the preceding paragraph and list of
     steps with a normative reference to an upcoming revision of IETF
     RFC 3987, which will define "Legacy Extended IRIs (LEIRIs)". When
     this revision is available, it is the intent of the XML Core WG
     to use it to replace language similar to the above in any future
     revisions of XML-related specifications under its purview.

     [Definition: In addition to a system identifier, an external
     identifier may include a public identifier.] An XML processor
     attempting to retrieve the entity's content may use any
     combination of the public and system identifiers as well as
     additional information outside the scope of this specification to
     try to generate an alternative URI reference. If the processor is
     unable to do so, it MUST use the URI reference specified in the
     system literal. Before a match is attempted, all strings of white
     space in the public identifier MUST be normalized to single space
     characters (#x20), and leading and trailing white space MUST be
     removed.

     Examples of external entity declarations:

     <!ENTITY open-hatch
     SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">
     <!ENTITY open-hatch
     PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
     "http://www.textuality.com/boilerplate/OpenHatch.xml">
     <!ENTITY hatch-pic
     SYSTEM "../grafix/OpenHatch.gif"
     NDATA gif >

     4.3 Parsed Entities
     4.3.1 The Text Declaration

     External parsed entities SHOULD each begin with a text declaration.

     Text Declaration
     [77]   	TextDecl	   ::=   	'<?xml' VersionInfo? EncodingDecl S? '?>'

     The text declaration MUST be provided literally, not by reference
     to a parsed entity. The text declaration MUST NOT appear at any
     position other than the beginning of an external parsed
     entity. The text declaration in an external parsed entity is not
     considered part of its replacement text.

     4.3.2 Well-Formed Parsed Entities

     The document entity is well-formed if it matches the production
     labeled document. An external general parsed entity is
     well-formed if it matches the production labeled
     extParsedEnt. All external parameter entities are well-formed by
     definition.

     Note:

     Only parsed entities that are referenced directly or indirectly
     within the document are required to be well-formed.

     Well-Formed External Parsed Entity
     [78]   	extParsedEnt	   ::=   	TextDecl? content

     An internal general parsed entity is well-formed if its
     replacement text matches the production labeled content. All
     internal parameter entities are well-formed by definition.

     A consequence of well-formedness in general entities is that the
     logical and physical structures in an XML document are properly
     nested; no start-tag, end-tag, empty-element tag, element,
     comment, processing instruction, character reference, or entity
     reference can begin in one entity and end in another.

     4.3.3 Character Encoding in Entities

     Each external parsed entity in an XML document may use a
     different encoding for its characters. All XML processors MUST be
     able to read entities in both the UTF-8 and UTF-16 encodings. The
     terms "UTF-8" and "UTF-16" in this specification do not apply to
     related character encodings, including but not limited to
     UTF-16BE, UTF-16LE, or CESU-8.

     Entities encoded in UTF-16 MUST and entities encoded in UTF-8 MAY
     begin with the Byte Order Mark described by Annex H of [ISO/IEC
     10646:2000], section 16.8 of [Unicode] (the ZERO WIDTH NO-BREAK
     SPACE character, #xFEFF). This is an encoding signature, not part
     of either the markup or the character data of the XML
     document. XML processors MUST be able to use this character to
     differentiate between UTF-8 and UTF-16 encoded documents.

     If the replacement text of an external entity is to begin with
     the character U+FEFF, and no text declaration is present, then a
     Byte Order Mark MUST be present, whether the entity is encoded in
     UTF-8 or UTF-16.

     Although an XML processor is required to read only entities in
     the UTF-8 and UTF-16 encodings, it is recognized that other
     encodings are used around the world, and it may be desired for
     XML processors to read entities that use them. In the absence of
     external character encoding information (such as MIME headers),
     parsed entities which are stored in an encoding other than UTF-8
     or UTF-16 MUST begin with a text declaration (see 4.3.1 The Text
     Declaration) containing an encoding declaration:

     Encoding Declaration
     [80]   	EncodingDecl	   ::=   	S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )
     [81]   	EncName	   ::=   	[A-Za-z] ([A-Za-z0-9._] | '-')*	/* Encoding name contains only Latin characters */

     In the document entity, the encoding declaration is part of the
     XML declaration. The EncName is the name of the encoding used.

     In an encoding declaration, the values " UTF-8 ", " UTF-16 ", "
     ISO-10646-UCS-2 ", and " ISO-10646-UCS-4 " SHOULD be used for the
     various encodings and transformations of Unicode / ISO/IEC 10646,
     the values " ISO-8859-1 ", " ISO-8859-2 ", ... " ISO-8859- n "
     (where n is the part number) SHOULD be used for the parts of ISO
     8859, and the values " ISO-2022-JP ", " Shift_JIS ", and " EUC-JP
     " SHOULD be used for the various encoded forms of JIS
     X-0208-1997. It is RECOMMENDED that character encodings
     registered (as charsets) with the Internet Assigned Numbers
     Authority [IANA-CHARSETS], other than those just listed, be
     referred to using their registered names; other encodings SHOULD
     use names starting with an "x-" prefix. XML processors SHOULD
     match character encoding names in a case-insensitive way and
     SHOULD either interpret an IANA-registered name as the encoding
     registered at IANA for that name or treat it as unknown
     (processors are, of course, not required to support all
     IANA-registered encodings).

     In the absence of information provided by an external transport
     protocol (e.g. HTTP or MIME), it is a fatal error for an entity
     including an encoding declaration to be presented to the XML
     processor in an encoding other than that named in the
     declaration, or for an entity which begins with neither a Byte
     Order Mark nor an encoding declaration to use an encoding other
     than UTF-8. Note that since ASCII is a subset of UTF-8, ordinary
     ASCII entities do not strictly need an encoding declaration.

     It is a fatal error for a TextDecl to occur other than at the
     beginning of an external entity.

     It is a fatal error when an XML processor encounters an entity
     with an encoding that it is unable to process. It is a fatal
     error if an XML entity is determined (via default, encoding
     declaration, or higher-level protocol) to be in a certain
     encoding but contains byte sequences that are not legal in that
     encoding. Specifically, it is a fatal error if an entity encoded
     in UTF-8 contains any ill-formed code unit sequences, as defined
     in section 3.9 of Unicode [Unicode]. Unless an encoding is
     determined by a higher-level protocol, it is also a fatal error
     if an XML entity contains no encoding declaration and its content
     is not legal UTF-8 or UTF-16.

     Examples of text declarations containing encoding declarations:

     <?xml encoding='UTF-8'?>
     <?xml encoding='EUC-JP'?>

     4.4 XML Processor Treatment of Entities and References

     The table below summarizes the contexts in which character
     references, entity references, and invocations of unparsed
     entities might appear and the REQUIRED behavior of an XML
     processor in each case. The labels in the leftmost column
     describe the recognition context:

     Reference in Content

     as a reference anywhere after the start-tag and before the
     end-tag of an element; corresponds to the nonterminal content.

     Reference in Attribute Value

     as a reference within either the value of an attribute in a
     start-tag, or a default value in an attribute declaration; corresponds
     to the nonterminal AttValue.  Occurs as Attribute Value

     as a Name, not a reference, appearing either as the value of an
     attribute which has been declared as type ENTITY, or as one of
     the space-separated tokens in the value of an attribute which has
     been declared as type ENTITIES.

     Reference in Entity Value

     as a reference within a parameter or internal entity's literal
     entity value in the entity's declaration; corresponds to the
     nonterminal EntityValue.  

     Reference in DTD

     as a reference within either the internal or external subsets of
     the DTD, but outside of an EntityValue, AttValue, PI, Comment,
     SystemLiteral, PubidLiteral, or the contents of an ignored
     conditional section (see 3.4 Conditional Sections).

    .

    Entity Type	Character
    Parameter	Internal General	External Parsed General	Unparsed
    Reference in Content	Not recognized 	Included 	Included if validating 	Forbidden 	Included
    Reference in Attribute Value	Not recognized 	Included in literal 	Forbidden 	Forbidden 	Included
    Occurs as Attribute Value	Not recognized 	Forbidden 	Forbidden 	Notify 	Not recognized
    Reference in EntityValue	Included in literal 	Bypassed 	Bypassed 	Error 	Included
    Reference in DTD	Included as PE 	Forbidden 	Forbidden 	Forbidden 	Forbidden

    4.4.1 Not Recognized

    Outside the DTD, the % character has no special significance;
    thus, what would be parameter entity references in the DTD are not
    recognized as markup in content. Similarly, the names of unparsed
    entities are not recognized except when they appear in the value
    of an appropriately declared attribute.

    4.4.2 Included

    [Definition: An entity is included when its replacement text is
    retrieved and processed, in place of the reference itself, as
    though it were part of the document at the location the reference
    was recognized.] The replacement text may contain both character
    data and (except for parameter entities) markup, which MUST be
    recognized in the usual way. (The string " AT&amp;T; " expands to
    " AT&T; " and the remaining ampersand is not recognized as an
    entity-reference delimiter.) A character reference is included
    when the indicated character is processed in place of the
    reference itself.

    4.4.3 Included If Validating

    When an XML processor recognizes a reference to a parsed entity,
    in order to validate the document, the processor MUST include its
    replacement text. If the entity is external, and the processor is
    not attempting to validate the XML document, the processor MAY,
    but need not, include the entity's replacement text. If a
    non-validating processor does not include the replacement text, it
    MUST inform the application that it recognized, but did not read,
    the entity.

    This rule is based on the recognition that the automatic inclusion
    provided by the SGML and XML entity mechanism, primarily designed
    to support modularity in authoring, is not necessarily appropriate
    for other applications, in particular document browsing. Browsers,
    for example, when encountering an external parsed entity
    reference, might choose to provide a visual indication of the
    entity's presence and retrieve it for display only on demand.

    4.4.4 Forbidden

    The following are forbidden, and constitute fatal errors:

    the appearance of a reference to an unparsed entity, except in the
    EntityValue in an entity declaration.

    the appearance of any character or general-entity reference in the
    DTD except within an EntityValue or AttValue.

    a reference to an external entity in an attribute value.

    4.4.5 Included in Literal

    When an entity reference appears in an attribute value, or a
    parameter entity reference appears in a literal entity value, its
    replacement text MUST be processed in place of the reference
    itself as though it were part of the document at the location the
    reference was recognized, except that a single or double quote
    character in the replacement text MUST always be treated as a
    normal data character and MUST NOT terminate the literal. For
    example, this is well-formed:

    <!ENTITY % YN '"Yes"' >
    <!ENTITY WhatHeSaid "He said %YN;" >

    while this is not:

    <!ENTITY EndAttr "27'" >
    <element attribute='a-&EndAttr;>

    4.4.6 Notify

    When the name of an unparsed entity appears as a token in the
    value of an attribute of declared type ENTITY or ENTITIES, a
    validating processor MUST inform the application of the system and
    public (if any) identifiers for both the entity and its associated
    notation.

    4.4.7 Bypassed

    When a general entity reference appears in the EntityValue in an
    entity declaration, it MUST be bypassed and left as is.

    4.4.8 Included as PE

    Just as with external parsed entities, parameter entities need
    only be included if validating. When a parameter-entity reference
    is recognized in the DTD and included, its replacement text MUST
    be enlarged by the attachment of one leading and one following
    space (#x20) character; the intent is to constrain the replacement
    text of parameter entities to contain an integral number of
    grammatical tokens in the DTD. This behavior MUST NOT apply to
    parameter entity references within entity values; these are
    described in 4.4.5 Included in Literal.

    4.4.9 Error

    It is an error for a reference to an unparsed entity to appear in
    the EntityValue in an entity declaration.

    4.5 Construction of Entity Replacement Text

    In discussing the treatment of entities, it is useful to
    distinguish two forms of the entity's value. [Definition: For an
    internal entity, the literal entity value is the quoted string
    actually present in the entity declaration, corresponding to the
    non-terminal EntityValue.] [Definition: For an external entity,
    the literal entity value is the exact text contained in the
    entity.] [Definition: For an internal entity, the replacement text
    is the content of the entity, after replacement of character
    references and parameter-entity references.] [Definition: For an
    external entity, the replacement text is the content of the
    entity, after stripping the text declaration (leaving any
    surrounding whitespace) if there is one but without any
    replacement of character references or parameter-entity
    references.]

    The literal entity value as given in an internal entity
    declaration (EntityValue) may contain character, parameter-entity,
    and general-entity references. Such references MUST be contained
    entirely within the literal entity value. The actual replacement
    text that is included (or included in literal) as described above
    MUST contain the replacement text of any parameter entities
    referred to, and MUST contain the character referred to, in place
    of any character references in the literal entity value; however,
    general-entity references MUST be left as-is, unexpanded. For
    example, given the following declarations:

    <!ENTITY % pub    "&#xc9;ditions Gallimard" >
    <!ENTITY   rights "All rights reserved" >
    <!ENTITY   book   "La Peste: Albert Camus,
    &#xA9; 1947 %pub;. &rights;" >

    then the replacement text for the entity " book " is:

    La Peste: Albert Camus,
    © 1947 Éditions Gallimard. &rights;

    The general-entity reference " &rights; " would be expanded should
    the reference " &book; " appear in the document's content or an
    attribute value.

    These simple rules may have complex interactions; for a detailed
    discussion of a difficult example, see D Expansion of Entity and
    Character References.

    4.6 Predefined Entities

    [Definition: Entity and character references may both be used to
    escape the left angle bracket, ampersand, and other delimiters. A
    set of general entities (amp, lt, gt, apos, quot) is specified for
    this purpose. Numeric character references may also be used; they
    are expanded immediately when recognized and MUST be treated as
    character data, so the numeric character references " &#60; " and
    " &#38; " may be used to escape < and & when they occur in
    character data.]

    All XML processors MUST recognize these entities whether they are
    declared or not. For interoperability, valid XML documents SHOULD
    declare these entities, like any others, before using them. If the
    entities lt or amp are declared, they MUST be declared as internal
    entities whose replacement text is a character reference to the
    respective character (less-than sign or ampersand) being escaped;
    the double escaping is REQUIRED for these entities so that
    references to them produce a well-formed result. If the entities
    gt, apos, or quot are declared, they MUST be declared as internal
    entities whose replacement text is the single character being
    escaped (or a character reference to that character; the double
    escaping here is OPTIONAL but harmless). For example:

    <!ENTITY lt     "&#38;#60;">
    <!ENTITY gt     "&#62;">
    <!ENTITY amp    "&#38;#38;">
    <!ENTITY apos   "&#39;">
    <!ENTITY quot   "&#34;">

    4.7 Notation Declarations

    [Definition: Notations identify by name the format of unparsed
    entities, the format of elements which bear a notation attribute,
    or the application to which a processing instruction is
    addressed.]

    [Definition: Notation declarations provide a name for the
    notation, for use in entity and attribute-list declarations and in
    attribute specifications, and an external identifier for the
    notation which may allow an XML processor or its client
    application to locate a helper application capable of processing
    data in the given notation.]

    Notation Declarations
    [82]   	NotationDecl	   ::=   	'<!NOTATION' S Name S (ExternalID | PublicID) S? '>'	[VC: Unique Notation Name]
    [83]   	PublicID	   ::=   	'PUBLIC' S PubidLiteral

    Validity constraint: Unique Notation Name

    A given Name MUST NOT be declared in more than one notation
    declaration.

    XML processors MUST provide applications with the name and
    external identifier(s) of any notation declared and referred to in
    an attribute value, attribute definition, or entity
    declaration. They MAY additionally resolve the external identifier
    into the system identifier, file name, or other information needed
    to allow the application to call a processor for data in the
    notation described. (It is not an error, however, for XML
    documents to declare and refer to notations for which
    notation-specific applications are not available on the system
    where the XML processor or application is running.)

    4.8 Document Entity

    [Definition: The document entity serves as the root of the entity
    tree and a starting-point for an XML processor.] This
    specification does not specify how the document entity is to be
    located by an XML processor; unlike other entities, the document
    entity has no name and might well appear on a processor input
    stream without any identification at all.

    5 Conformance
    5.1 Validating and Non-Validating Processors

    Conforming XML processors fall into two classes: validating and
    non-validating.

    Validating and non-validating processors alike MUST report
    violations of this specification's well-formedness constraints in
    the content of the document entity and any other parsed entities
    that they read.

    [Definition: Validating processors MUST, at user option, report
    violations of the constraints expressed by the declarations in the
    DTD, and failures to fulfill the validity constraints given in
    this specification.] To accomplish this, validating XML processors
    MUST read and process the entire DTD and all external parsed
    entities referenced in the document.

    Non-validating processors are REQUIRED to check only the document
    entity, including the entire internal DTD subset, for
    well-formedness. [Definition: While they are not required to check
    the document for validity, they are REQUIRED to process all the
    declarations they read in the internal DTD subset and in any
    parameter entity that they read, up to the first reference to a
    parameter entity that they do not read; that is to say, they MUST
    use the information in those declarations to normalize attribute
    values, include the replacement text of internal entities, and
    supply default attribute values.] Except when standalone="yes",
    they MUST NOT process entity declarations or attribute-list
    declarations encountered after a reference to a parameter entity
    that is not read, since the entity may have contained overriding
    declarations; when standalone="yes", processors MUST process these
    declarations.

    Note that when processing invalid documents with a non-validating processor the application may not be presented with consistent information. For example, several requirements for uniqueness within the document may not be met, including more than one element with the same id, duplicate declarations of elements or notations with the same name, etc. In these cases the behavior of the parser with respect to reporting such information to the application is undefined.

    5.2 Using XML Processors

    The behavior of a validating XML processor is highly predictable;
    it must read every piece of a document and report all
    well-formedness and validity violations. Less is required of a
    non-validating processor; it need not read any part of the
    document other than the document entity. This has two effects that
    may be important to users of XML processors:

    Certain well-formedness errors, specifically those that require
    reading external entities, may fail to be detected by a
    non-validating processor. Examples include the constraints
    entitled Entity Declared, Parsed Entity, and No Recursion, as well
    as some of the cases described as forbidden in 4.4 XML Processor
    Treatment of Entities and References.

    The information passed from the processor to the application may
    vary, depending on whether the processor reads parameter and
    external entities. For example, a non-validating processor may
    fail to normalize attribute values, include the replacement text
    of internal entities, or supply default attribute values, where
    doing so depends on having read declarations in external or
    parameter entities, or in the internal subset after an unread
    parameter entity reference.

    For maximum reliability in interoperating between different XML
    processors, applications which use non-validating processors
    SHOULD NOT rely on any behaviors not required of such
    processors. Applications which require DTD facilities not related
    to validation (such as the declaration of default attributes and
    internal entities that are or may be specified in external
    entities) SHOULD use validating XML processors.

    6 Notation

    The formal grammar of XML is given in this specification using a
    simple Extended Backus-Naur Form (EBNF) notation. Each rule in the
    grammar defines one symbol, in the form

    symbol ::= expression

    Symbols are written with an initial capital letter if they are the
    start symbol of a regular language, otherwise with an initial
    lowercase letter. Literal strings are quoted.

    Within the expression on the right-hand side of a rule, the following
    expressions are used to match strings of one or more characters:

    #xN

    where N is a hexadecimal integer, the expression matches the
    character whose number (code point) in ISO/IEC 10646 is N. The number
    of leading zeros in the #xN form is insignificant.  [a-zA-Z],
    [#xN-#xN]

    matches any Char with a value in the range(s) indicated
    (inclusive).  [abc], [#xN#xN#xN]

    matches any Char with a value among the characters
    enumerated. Enumerations and ranges can be mixed in one set of
    brackets.  [^a-z], [^#xN-#xN]

    matches any Char with a value outside the range indicated.
    [^abc], [^#xN#xN#xN]

    matches any Char with a value not among the characters
    given. Enumerations and ranges of forbidden values can be mixed in one
    set of brackets.  "string"

    matches a literal string matching that given inside the double
    quotes.  'string'

    matches a literal string matching that given inside the single
    quotes.

    These symbols may be combined to match more complex patterns as
    follows, where A and B represent simple expressions:

    (expression)

    expression is treated as a unit and may be combined as described
    in this list.  A?

    matches A or nothing; optional A.
    A B

    matches A followed by B. This operator has higher precedence than
    alternation; thus A B | C D is identical to (A B) | (C D).  A | B

    matches A or B.
    A - B

    matches any string that matches A but does not match B.
    A+

    matches one or more occurrences of A. Concatenation has higher
    precedence than alternation; thus A+ | B+ is identical to (A+) |
    (B+).  A*

    matches zero or more occurrences of A. Concatenation has higher
    precedence than alternation; thus A* | B* is identical to (A*) |
    (B*).

    Other notations used in the productions are:

    /* ... */

    comment.
    [ wfc: ... ]

    well-formedness constraint; this identifies by name a constraint
    on well-formed documents associated with a production.  [ vc: ... ]

    validity constraint; this identifies by name a constraint on valid
    documents associated with a production.

    A References

    A.1 Normative References

    IANA-CHARSETS
    (Internet Assigned Numbers Authority) Official Names for Character Sets, ed. Keld Simonsen et al. (See http://www.iana.org/assignments/character-sets.)
    IETF RFC 2119
    IETF (Internet Engineering Task Force). RFC 2119: Key words for use in RFCs to Indicate Requirement Levels. Scott Bradner, 1997. (See http://www.ietf.org/rfc/rfc2119.txt.)
    IETF BCP 47
    IETF (Internet Engineering Task Force). BCP 47, consisting of RFC 4646: Tags for Identifying Languages, and RFC 4647: Matching of Language Tags, A. Phillips, M. Davis. 2006. (See ftp://ftp.isi.edu/in-notes/bcp/bcp47.txt.)
    IETF RFC 3986
    IETF (Internet Engineering Task Force). RFC 3986: Uniform Resource Identifier (URI): Generic Syntax. T. Berners-Lee, R. Fielding, L. Masinter. 2005. (See http://www.ietf.org/rfc/rfc3986.txt.)
    ISO/IEC 10646
    ISO (International Organization for Standardization). ISO/IEC 10646-1:2000. Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 1: Architecture and Basic Multilingual Plane and ISO/IEC 10646-2:2001. Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 2: Supplementary Planes, as, from time to time, amended, replaced by a new edition or expanded by the addition of new parts. [Geneva]: International Organization for Standardization. (See http://www.iso.org/iso/home.htm for the latest version.)
    ISO/IEC 10646:2000
    ISO (International Organization for Standardization). ISO/IEC 10646-1:2000. Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 1: Architecture and Basic Multilingual Plane. [Geneva]: International Organization for Standardization, 2000.
    Unicode
    The Unicode Consortium. The Unicode Standard, Version 5.0.0, defined by: The Unicode Standard, Version 5.0 (Boston, MA, Addison-Wesley, 2007. ISBN 0-321-48091-0).
    UnicodeNormal
    The Unicode Consortium. Unicode normalization forms. Mark Davis and Martin Durst. 2008. (See http://unicode.org/reports/tr15/.)

    A.2 Other References

    Aho/Ullman
    Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. Compilers: Principles, Techniques, and Tools. Reading: Addison-Wesley, 1986, rpt. corr. 1988.
    Brüggemann-Klein
    Brüggemann-Klein, Anne. Formal Models in Document Processing. Habilitationsschrift. Faculty of Mathematics at the University of Freiburg, 1993. (See ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps.)
    Brüggemann-Klein and Wood
    Brüggemann-Klein, Anne, and Derick Wood. Deterministic Regular Languages. Universität Freiburg, Institut für Informatik, Bericht 38, Oktober 1991. Extended abstract in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184. Springer-Verlag, Berlin 1992. Lecture Notes in Computer Science 577. Full version titled One-Unambiguous Regular Languages in Information and Computation 140 (2): 229-253, February 1998.
    Clark
    James Clark. Comparison of SGML and XML. (See http://www.w3.org/TR/NOTE-sgml-xml-971215.)
    IANA-LANGCODES
    (Internet Assigned Numbers Authority) Registry of Language Tags (See http://www.iana.org/assignments/language-subtag-registry.)
    IETF RFC 2141
    IETF (Internet Engineering Task Force). RFC 2141: URN Syntax, ed. R. Moats. 1997. (See http://www.ietf.org/rfc/rfc2141.txt.)
    IETF RFC 3023
    IETF (Internet Engineering Task Force). RFC 3023: XML Media Types. eds. M. Murata, S. St.Laurent, D. Kohn. 2001. (See http://www.ietf.org/rfc/rfc3023.txt.)
    IETF RFC 2781
    IETF (Internet Engineering Task Force). RFC 2781: UTF-16, an encoding of ISO 10646, ed. P. Hoffman, F. Yergeau. 2000. (See http://www.ietf.org/rfc/rfc2781.txt.)
    ISO 639
    (International Organization for Standardization). ISO 639:1988 (E). Code for the representation of names of languages. [Geneva]: International Organization for Standardization, 1988.
    ISO 3166
    (International Organization for Standardization). ISO 3166-1:1997 (E). Codes for the representation of names of countries and their subdivisions — Part 1: Country codes [Geneva]: International Organization for Standardization, 1997.
    ISO 8879
    ISO (International Organization for Standardization). ISO 8879:1986(E). Information processing — Text and Office Systems — Standard Generalized Markup Language (SGML). First edition — 1986-10-15. [Geneva]: International Organization for Standardization, 1986. 
    ISO/IEC 10744
    ISO (International Organization for Standardization). ISO/IEC 10744-1992 (E). Information technology — Hypermedia/Time-based Structuring Language (HyTime). [Geneva]: International Organization for Standardization, 1992. Extended Facilities Annexe. [Geneva]: International Organization for Standardization, 1996. 
    WEBSGML
    ISO (International Organization for Standardization). ISO 8879:1986 TC2. Information technology — Document Description and Processing Languages. [Geneva]: International Organization for Standardization, 1998. (See http://www.sgmlsource.com/8879/n0029.htm.)
    XML Names
    Tim Bray, Dave Hollander, and Andrew Layman, editors. Namespaces in XML. Textuality, Hewlett-Packard, and Microsoft. World Wide Web Consortium, 1999. (See http://www.w3.org/TR/xml-names/.)

    B Character Classes

    Because of changes to productions [4] and [5], the productions in
    this Appendix are now orphaned and not used anymore in determining
    name characters. This Appendix may be removed in a future edition
    of this specification; other specifications that wish to refer to
    the productions herein should do so by means of a reference to the
    relevant production(s) in the Fourth Edition of this
    specification.

    Following the characteristics defined in the Unicode standard,
    characters are classed as base characters (among others, these
    contain the alphabetic characters of the Latin alphabet),
    ideographic characters, and combining characters (among others,
    this class contains most diacritics). Digits and extenders are
    also distinguished.

    Characters
    [84]   	Letter	   ::=   	BaseChar | Ideographic
    [85]   	BaseChar	   ::=   	[#x0041-#x005A] | [#x0061-#x007A] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x00FF] | [#x0100-#x0131] | [#x0134-#x013E] | [#x0141-#x0148] | [#x014A-#x017E] | [#x0180-#x01C3] | [#x01CD-#x01F0] | [#x01F4-#x01F5] | [#x01FA-#x0217] | [#x0250-#x02A8] | [#x02BB-#x02C1] | #x0386 | [#x0388-#x038A] | #x038C | [#x038E-#x03A1] | [#x03A3-#x03CE] | [#x03D0-#x03D6] | #x03DA | #x03DC | #x03DE | #x03E0 | [#x03E2-#x03F3] | [#x0401-#x040C] | [#x040E-#x044F] | [#x0451-#x045C] | [#x045E-#x0481] | [#x0490-#x04C4] | [#x04C7-#x04C8] | [#x04CB-#x04CC] | [#x04D0-#x04EB] | [#x04EE-#x04F5] | [#x04F8-#x04F9] | [#x0531-#x0556] | #x0559 | [#x0561-#x0586] | [#x05D0-#x05EA] | [#x05F0-#x05F2] | [#x0621-#x063A] | [#x0641-#x064A] | [#x0671-#x06B7] | [#x06BA-#x06BE] | [#x06C0-#x06CE] | [#x06D0-#x06D3] | #x06D5 | [#x06E5-#x06E6] | [#x0905-#x0939] | #x093D | [#x0958-#x0961] | [#x0985-#x098C] | [#x098F-#x0990] | [#x0993-#x09A8] | [#x09AA-#x09B0] | #x09B2 | [#x09B6-#x09B9] | [#x09DC-#x09DD] | [#x09DF-#x09E1] | [#x09F0-#x09F1] | [#x0A05-#x0A0A] | [#x0A0F-#x0A10] | [#x0A13-#x0A28] | [#x0A2A-#x0A30] | [#x0A32-#x0A33] | [#x0A35-#x0A36] | [#x0A38-#x0A39] | [#x0A59-#x0A5C] | #x0A5E | [#x0A72-#x0A74] | [#x0A85-#x0A8B] | #x0A8D | [#x0A8F-#x0A91] | [#x0A93-#x0AA8] | [#x0AAA-#x0AB0] | [#x0AB2-#x0AB3] | [#x0AB5-#x0AB9] | #x0ABD | #x0AE0 | [#x0B05-#x0B0C] | [#x0B0F-#x0B10] | [#x0B13-#x0B28] | [#x0B2A-#x0B30] | [#x0B32-#x0B33] | [#x0B36-#x0B39] | #x0B3D | [#x0B5C-#x0B5D] | [#x0B5F-#x0B61] | [#x0B85-#x0B8A] | [#x0B8E-#x0B90] | [#x0B92-#x0B95] | [#x0B99-#x0B9A] | #x0B9C | [#x0B9E-#x0B9F] | [#x0BA3-#x0BA4] | [#x0BA8-#x0BAA] | [#x0BAE-#x0BB5] | [#x0BB7-#x0BB9] | [#x0C05-#x0C0C] | [#x0C0E-#x0C10] | [#x0C12-#x0C28] | [#x0C2A-#x0C33] | [#x0C35-#x0C39] | [#x0C60-#x0C61] | [#x0C85-#x0C8C] | [#x0C8E-#x0C90] | [#x0C92-#x0CA8] | [#x0CAA-#x0CB3] | [#x0CB5-#x0CB9] | #x0CDE | [#x0CE0-#x0CE1] | [#x0D05-#x0D0C] | [#x0D0E-#x0D10] | [#x0D12-#x0D28] | [#x0D2A-#x0D39] | [#x0D60-#x0D61] | [#x0E01-#x0E2E] | #x0E30 | [#x0E32-#x0E33] | [#x0E40-#x0E45] | [#x0E81-#x0E82] | #x0E84 | [#x0E87-#x0E88] | #x0E8A | #x0E8D | [#x0E94-#x0E97] | [#x0E99-#x0E9F] | [#x0EA1-#x0EA3] | #x0EA5 | #x0EA7 | [#x0EAA-#x0EAB] | [#x0EAD-#x0EAE] | #x0EB0 | [#x0EB2-#x0EB3] | #x0EBD | [#x0EC0-#x0EC4] | [#x0F40-#x0F47] | [#x0F49-#x0F69] | [#x10A0-#x10C5] | [#x10D0-#x10F6] | #x1100 | [#x1102-#x1103] | [#x1105-#x1107] | #x1109 | [#x110B-#x110C] | [#x110E-#x1112] | #x113C | #x113E | #x1140 | #x114C | #x114E | #x1150 | [#x1154-#x1155] | #x1159 | [#x115F-#x1161] | #x1163 | #x1165 | #x1167 | #x1169 | [#x116D-#x116E] | [#x1172-#x1173] | #x1175 | #x119E | #x11A8 | #x11AB | [#x11AE-#x11AF] | [#x11B7-#x11B8] | #x11BA | [#x11BC-#x11C2] | #x11EB | #x11F0 | #x11F9 | [#x1E00-#x1E9B] | [#x1EA0-#x1EF9] | [#x1F00-#x1F15] | [#x1F18-#x1F1D] | [#x1F20-#x1F45] | [#x1F48-#x1F4D] | [#x1F50-#x1F57] | #x1F59 | #x1F5B | #x1F5D | [#x1F5F-#x1F7D] | [#x1F80-#x1FB4] | [#x1FB6-#x1FBC] | #x1FBE | [#x1FC2-#x1FC4] | [#x1FC6-#x1FCC] | [#x1FD0-#x1FD3] | [#x1FD6-#x1FDB] | [#x1FE0-#x1FEC] | [#x1FF2-#x1FF4] | [#x1FF6-#x1FFC] | #x2126 | [#x212A-#x212B] | #x212E | [#x2180-#x2182] | [#x3041-#x3094] | [#x30A1-#x30FA] | [#x3105-#x312C] | [#xAC00-#xD7A3]
    [86]   	Ideographic	   ::=   	[#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]
    [87]   	CombiningChar	   ::=   	[#x0300-#x0345] | [#x0360-#x0361] | [#x0483-#x0486] | [#x0591-#x05A1] | [#x05A3-#x05B9] | [#x05BB-#x05BD] | #x05BF | [#x05C1-#x05C2] | #x05C4 | [#x064B-#x0652] | #x0670 | [#x06D6-#x06DC] | [#x06DD-#x06DF] | [#x06E0-#x06E4] | [#x06E7-#x06E8] | [#x06EA-#x06ED] | [#x0901-#x0903] | #x093C | [#x093E-#x094C] | #x094D | [#x0951-#x0954] | [#x0962-#x0963] | [#x0981-#x0983] | #x09BC | #x09BE | #x09BF | [#x09C0-#x09C4] | [#x09C7-#x09C8] | [#x09CB-#x09CD] | #x09D7 | [#x09E2-#x09E3] | #x0A02 | #x0A3C | #x0A3E | #x0A3F | [#x0A40-#x0A42] | [#x0A47-#x0A48] | [#x0A4B-#x0A4D] | [#x0A70-#x0A71] | [#x0A81-#x0A83] | #x0ABC | [#x0ABE-#x0AC5] | [#x0AC7-#x0AC9] | [#x0ACB-#x0ACD] | [#x0B01-#x0B03] | #x0B3C | [#x0B3E-#x0B43] | [#x0B47-#x0B48] | [#x0B4B-#x0B4D] | [#x0B56-#x0B57] | [#x0B82-#x0B83] | [#x0BBE-#x0BC2] | [#x0BC6-#x0BC8] | [#x0BCA-#x0BCD] | #x0BD7 | [#x0C01-#x0C03] | [#x0C3E-#x0C44] | [#x0C46-#x0C48] | [#x0C4A-#x0C4D] | [#x0C55-#x0C56] | [#x0C82-#x0C83] | [#x0CBE-#x0CC4] | [#x0CC6-#x0CC8] | [#x0CCA-#x0CCD] | [#x0CD5-#x0CD6] | [#x0D02-#x0D03] | [#x0D3E-#x0D43] | [#x0D46-#x0D48] | [#x0D4A-#x0D4D] | #x0D57 | #x0E31 | [#x0E34-#x0E3A] | [#x0E47-#x0E4E] | #x0EB1 | [#x0EB4-#x0EB9] | [#x0EBB-#x0EBC] | [#x0EC8-#x0ECD] | [#x0F18-#x0F19] | #x0F35 | #x0F37 | #x0F39 | #x0F3E | #x0F3F | [#x0F71-#x0F84] | [#x0F86-#x0F8B] | [#x0F90-#x0F95] | #x0F97 | [#x0F99-#x0FAD] | [#x0FB1-#x0FB7] | #x0FB9 | [#x20D0-#x20DC] | #x20E1 | [#x302A-#x302F] | #x3099 | #x309A
    [88]   	Digit	   ::=   	[#x0030-#x0039] | [#x0660-#x0669] | [#x06F0-#x06F9] | [#x0966-#x096F] | [#x09E6-#x09EF] | [#x0A66-#x0A6F] | [#x0AE6-#x0AEF] | [#x0B66-#x0B6F] | [#x0BE7-#x0BEF] | [#x0C66-#x0C6F] | [#x0CE6-#x0CEF] | [#x0D66-#x0D6F] | [#x0E50-#x0E59] | [#x0ED0-#x0ED9] | [#x0F20-#x0F29]
    [89]   	Extender	   ::=   	#x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E] | [#x30FC-#x30FE]

    The character classes defined here can be derived from the Unicode
    2.0 character database as follows:

    Name start characters must have one of the categories Ll, Lu, Lo,
    Lt, Nl.

    Name characters other than Name-start characters must have one of
    the categories Mc, Me, Mn, Lm, or Nd.

    Characters in the compatibility area (i.e. with character code
    greater than #xF900 and less than #xFFFE) are not allowed in XML
    names.

    Characters which have a font or compatibility decomposition
    (i.e. those with a "compatibility formatting tag" in field 5 of
    the database -- marked by field 5 beginning with a "<") are not
    allowed.

    The following characters are treated as name-start characters
    rather than name characters, because the property file classifies
    them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.

    Characters #x20DD-#x20E0 are excluded (in accordance with Unicode
    2.0, section 5.14).

    Character #x00B7 is classified as an extender, because the
    property list so identifies it.

    Character #x0387 is added as a name character, because #x00B7 is
    its canonical equivalent.

    Characters ':' and '_' are allowed as name-start characters.

    Characters '-' and '.' are allowed as name characters.

    C XML and SGML (Non-Normative)

    XML is designed to be a subset of SGML, in that every XML document
    should also be a conforming SGML document. For a detailed
    comparison of the additional restrictions that XML places on
    documents beyond those of SGML, see [Clark].

    D Expansion of Entity and Character References (Non-Normative)

    This appendix contains some examples illustrating the sequence of
    entity- and character-reference recognition and expansion, as
    specified in 4.4 XML Processor Treatment of Entities and
    References.

    If the DTD contains the declaration

    <!ENTITY example "<p>An ampersand (&#38;#38;) may be escaped
    numerically (&#38;#38;#38;) or with a general entity
    (&amp;amp;).</p>" >

    then the XML processor will recognize the character references
    when it parses the entity declaration, and resolve them before
    storing the following string as the value of the entity " example
    ":

    <p>An ampersand (&#38;) may be escaped
    numerically (&#38;#38;) or with a general entity
    (&amp;amp;).</p>

    A reference in the document to " &example; " will cause the text
    to be reparsed, at which time the start- and end-tags of the p
    element will be recognized and the three references will be
    recognized and expanded, resulting in a p element with the
    following content (all data, no delimiters or markup):

    An ampersand (&) may be escaped
    numerically (&#38;) or with a general entity
    (&amp;).

    A more complex example will illustrate the rules and their effects
    fully. In the following example, the line numbers are solely for
    reference.

    1 <?xml version='1.0'?>
    2 <!DOCTYPE test [
    3 <!ELEMENT test (#PCDATA) >
    4 <!ENTITY % xx '&#37;zz;'>
    5 <!ENTITY % zz '&#60;!ENTITY tricky "error-prone" >' >
    6 %xx;
    7 ]>
    8 <test>This sample shows a &tricky; method.</test>

    This produces the following:

    in line 4, the reference to character 37 is expanded immediately,
    and the parameter entity " xx " is stored in the symbol table with
    the value " %zz; ". Since the replacement text is not rescanned,
    the reference to parameter entity " zz " is not recognized. (And
    it would be an error if it were, since " zz " is not yet
    declared.)

    in line 5, the character reference " &#60; " is expanded
    immediately and the parameter entity " zz " is stored with the
    replacement text " <!ENTITY tricky "error-prone" > ", which is a
    well-formed entity declaration.

    in line 6, the reference to " xx " is recognized, and the
    replacement text of " xx " (namely " %zz; ") is parsed. The
    reference to " zz " is recognized in its turn, and its replacement
    text (" <!ENTITY tricky "error-prone" > ") is parsed. The general
    entity " tricky " has now been declared, with the replacement text
    " error-prone ".

    in line 8, the reference to the general entity " tricky " is
    recognized, and it is expanded, so the full content of the test
    element is the self-describing (and ungrammatical) string This
    sample shows a error-prone method.

    In the following example

    <!DOCTYPE foo [ 
    <!ENTITY x "&lt;"> 
    ]> 
    <foo attr="&x;"/>

    the replacement text of x is the four characters "&lt;" because
    references to general entities in entity values are bypassed. The
    replacement text of lt is a character reference to the less-than
    character, for example the five characters "&#60;" (see 4.6
    Predefined Entities). Since neither of these contains a less-than
    character the result is well-formed.

    If the definition of x had been

    <!ENTITY x "&#60;">

    then the document would not have been well-formed, because the
    replacement text of x would be the single character "<" which is
    not permitted in attribute values (see WFC: No < in Attribute
    Values).
    
    E Deterministic Content Models (Non-Normative)

    As noted in 3.2.1 Element Content, it is required that content
    models in element type declarations be deterministic. This
    requirement is for compatibility with SGML (which calls
    deterministic content models "unambiguous"); XML processors built
    using SGML systems may flag non-deterministic content models as
    errors.

    For example, the content model ((b, c) | (b, d)) is
    non-deterministic, because given an initial b the XML processor
    cannot know which b in the model is being matched without looking
    ahead to see which element follows the b. In this case, the two
    references to b can be collapsed into a single reference, making
    the model read (b, (c | d)). An initial b now clearly matches only
    a single name in the content model. The processor doesn't need to
    look ahead to see what follows; either c or d would be accepted.

    More formally: a finite state automaton may be constructed from
    the content model using the standard algorithms, e.g. algorithm
    3.5 in section 3.9 of Aho, Sethi, and Ullman [Aho/Ullman]. In many
    such algorithms, a follow set is constructed for each position in
    the regular expression (i.e., each leaf node in the syntax tree
    for the regular expression); if any position has a follow set in
    which more than one following position is labeled with the same
    element type name, then the content model is in error and may be
    reported as an error.

    Algorithms exist which allow many but not all non-deterministic
    content models to be reduced automatically to equivalent
    deterministic models; see Brüggemann-Klein 1991
    [Brüggemann-Klein].

    F Autodetection of Character Encodings (Non-Normative)

    The XML encoding declaration functions as an internal label on
    each entity, indicating which character encoding is in use. Before
    an XML processor can read the internal label, however, it
    apparently has to know what character encoding is in use—which is
    what the internal label is trying to indicate. In the general
    case, this is a hopeless situation. It is not entirely hopeless in
    XML, however, because XML limits the general case in two ways:
    each implementation is assumed to support only a finite set of
    character encodings, and the XML encoding declaration is
    restricted in position and content in order to make it feasible to
    autodetect the character encoding in use in each entity in normal
    cases. Also, in many cases other sources of information are
    available in addition to the XML data stream itself. Two cases may
    be distinguished, depending on whether the XML entity is presented
    to the processor without, or with, any accompanying (external)
    information. We will consider these cases in turn.

    F.1 Detection Without External Encoding Information

    Because each XML entity not accompanied by external encoding
    information and not in UTF-8 or UTF-16 encoding must begin with an
    XML encoding declaration, in which the first characters must be
    '<?xml', any conforming processor can detect, after two to four
    octets of input, which of the following cases apply. In reading
    this list, it may help to know that in UCS-4, '<' is " #x0000003C
    " and '?' is " #x0000003F ", and the Byte Order Mark required of
    UTF-16 data streams is " #xFEFF ". The notation ## is used to
    denote any byte value except that two consecutive ##s cannot be
    both 00.

    With a Byte Order Mark:
    00 00 FE FF 	UCS-4, big-endian machine (1234 order)
    FF FE 00 00 	UCS-4, little-endian machine (4321 order)
    00 00 FF FE 	UCS-4, unusual octet order (2143)
    FE FF 00 00 	UCS-4, unusual octet order (3412)
    FE FF ## ## 	UTF-16, big-endian
    FF FE ## ## 	UTF-16, little-endian
    EF BB BF 	UTF-8

    Without a Byte Order Mark:
    00 00 00 3C 	UCS-4 or other encoding with a 32-bit code unit and ASCII characters encoded as ASCII values, in respectively big-endian (1234), little-endian (4321) and two unusual byte orders (2143 and 3412). The encoding declaration must be read to determine which of UCS-4 or other supported 32-bit encodings applies.
    3C 00 00 00
    00 00 3C 00
    00 3C 00 00
    00 3C 00 3F 	UTF-16BE or big-endian ISO-10646-UCS-2 or other encoding with a 16-bit code unit in big-endian order and ASCII characters encoded as ASCII values (the encoding declaration must be read to determine which)
    3C 00 3F 00 	UTF-16LE or little-endian ISO-10646-UCS-2 or other encoding with a 16-bit code unit in little-endian order and ASCII characters encoded as ASCII values (the encoding declaration must be read to determine which)
    3C 3F 78 6D 	UTF-8, ISO 646, ASCII, some part of ISO 8859, Shift-JIS, EUC, or any other 7-bit, 8-bit, or mixed-width encoding which ensures that the characters of ASCII have their normal positions, width, and values; the actual encoding declaration must be read to detect which of these applies, but since all of these encodings use the same bit patterns for the relevant ASCII characters, the encoding declaration itself may be read reliably
    4C 6F A7 94 	EBCDIC (in some flavor; the full encoding declaration must be read to tell which code page is in use)
    Other	UTF-8 without an encoding declaration, or else the data stream is mislabeled (lacking a required encoding declaration), corrupt, fragmentary, or enclosed in a wrapper of some kind

    Note:

    In cases above which do not require reading the encoding
    declaration to determine the encoding, section 4.3.3 still
    requires that the encoding declaration, if present, be read and
    that the encoding name be checked to match the actual encoding of
    the entity. Also, it is possible that new character encodings will
    be invented that will make it necessary to use the encoding
    declaration to determine the encoding, in cases where this is not
    required at present.

    This level of autodetection is enough to read the XML encoding
    declaration and parse the character-encoding identifier, which is
    still necessary to distinguish the individual members of each
    family of encodings (e.g. to tell UTF-8 from 8859, and the parts
    of 8859 from each other, or to distinguish the specific EBCDIC
    code page in use, and so on).

    Because the contents of the encoding declaration are restricted to
    characters from the ASCII repertoire (however encoded), a
    processor can reliably read the entire encoding declaration as
    soon as it has detected which family of encodings is in use. Since
    in practice, all widely used character encodings fall into one of
    the categories above, the XML encoding declaration allows
    reasonably reliable in-band labeling of character encodings, even
    when external sources of information at the operating-system or
    transport-protocol level are unreliable. Character encodings such
    as UTF-7 that make overloaded usage of ASCII-valued bytes may fail
    to be reliably detected.

    Once the processor has detected the character encoding in use, it
    can act appropriately, whether by invoking a separate input
    routine for each case, or by calling the proper conversion
    function on each character of input.

    Like any self-labeling system, the XML encoding declaration will
    not work if any software changes the entity's character set or
    encoding without updating the encoding declaration. Implementors
    of character-encoding routines should be careful to ensure the
    accuracy of the internal and external information used to label
    the entity.

    F.2 Priorities in the Presence of External Encoding Information

    The second possible case occurs when the XML entity is accompanied
    by encoding information, as in some file systems and some network
    protocols. When multiple sources of information are available,
    their relative priority and the preferred method of handling
    conflict should be specified as part of the higher-level protocol
    used to deliver XML. In particular, please refer to [IETF RFC
    3023] or its successor, which defines the text/xml and
    application/xml MIME types and provides some useful guidance. In
    the interests of interoperability, however, the following rule is
    recommended.

    If an XML entity is in a file, the Byte-Order Mark and encoding
    declaration are used (if present) to determine the character
    encoding.

    G W3C XML Working Group (Non-Normative)

    This specification was prepared and approved for publication by
    the W3C XML Working Group (WG). WG approval of this specification
    does not necessarily imply that all WG members voted for its
    approval. The current and former participants of the XML WG are:

    Jon Bosak, Sun (Chair)
    James Clark (Technical Lead)
    Tim Bray, Textuality and Netscape (XML Co-editor)
    Jean Paoli, Microsoft (XML Co-editor)
    C. M. Sperberg-McQueen, U. of Ill. (XML Co-editor)
    Dan Connolly, W3C (W3C Liaison)
    Paula Angerstein, Texcel
    Steve DeRose, INSO
    Dave Hollander, HP
    Eliot Kimber, ISOGEN
    Eve Maler, ArborText
    Tom Magliery, NCSA
    Murray Maloney, SoftQuad, Grif SA, Muzmo and Veo Systems
    MURATA Makoto (FAMILY Given), Fuji Xerox Information Systems
    Joel Nava, Adobe
    Conleth O'Connell, Vignette
    Peter Sharpe, SoftQuad
    John Tigue, DataChannel

    H W3C XML Core Working Group (Non-Normative)

    The fifth edition of this specification was prepared by the W3C
    XML Core Working Group (WG). The participants in the WG at the
    time of publication of this edition were:

    John Cowan, Google
    Andrew Fang, PTC-Arbortext
    Paul Grosso, PTC-Arbortext (Co-Chair)
    Konrad Lanz, A-SIT
    Glenn Marcy, IBM
    Henry Thompson, W3C (Staff Contact)
    Richard Tobin, University of Edinburgh
    Daniel Veillard
    Norman Walsh, Mark Logic (Co-Chair)
    François Yergeau

    I Production Notes (Non-Normative)

    This edition was encoded in a slightly modified version of the
    XMLspec DTD, v2.10. The XHTML versions were produced with a
    combination of the xmlspec.xsl, diffspec.xsl, and REC-xml.xsl XSLT
    stylesheets.

    J Suggestions for XML Names (Non-Normative)

    The following suggestions define what is believed to be best
    practice in the construction of XML names used as element names,
    attribute names, processing instruction targets, entity names,
    notation names, and the values of attributes of type ID, and are
    intended as guidance for document authors and schema
    designers. All references to Unicode are understood with respect
    to a particular version of the Unicode Standard greater than or
    equal to 5.0; which version should be used is left to the
    discretion of the document author or schema designer.

    The first two suggestions are directly derived from the rules
    given for identifiers in Standard Annex #31 (UAX #31) of the
    Unicode Standard, version 5.0 [Unicode], and exclude all control
    characters, enclosing nonspacing marks, non-decimal numbers,
    private-use characters, punctuation characters (with the noted
    exceptions), symbol characters, unassigned codepoints, and white
    space characters. The other suggestions are mostly derived from
    Appendix B in previous editions of this specification.

    The first character of any name should have a Unicode property of
    ID_Start, or else be '_' #x5F.

    Characters other than the first should have a Unicode property of
    ID_Continue, or be one of the characters listed in the table
    entitled "Characters for Natural Language Identifiers" in UAX #31,
    with the exception of "'" #x27 and "’" #x2019.

    Characters in names should be expressed using Normalization Form C
    as defined in [UnicodeNormal].

    Ideographic characters which have a canonical decomposition
    (including those in the ranges [#xF900-#xFAFF] and
    [#x2F800-#x2FFFD], with 12 exceptions) should not be used in
    names.

    Characters which have a compatibility decomposition (those with a
    "compatibility formatting tag" in field 5 of the Unicode Character
    Database -- marked by field 5 beginning with a "<") should not be
    used in names. This suggestion does not apply to characters which
    despite their compatibility decompositions are in regular use in
    their scripts, for example #x0E33 THAI CHARACTER SARA AM or #x0EB3
    LAO CHARACTER AM.

    Combining characters meant for use with symbols only (including
    those in the ranges [#x20D0-#x20EF] and [#x1D165-#x1D1AD]) should
    not be used in names.

    The interlinear annotation characters ([#xFFF9-#xFFFB]) should not
    be used in names.

    Variation selector characters should not be used in names.

    Names which are nonsensical, unpronounceable, hard to read, or
    easily confusable with other names should not be employed.
*** gruff							      :gruff:
**** The Programmatic Lisp API to Gruff

The symbols documented here are exported from the gruff package, which has the nickname "uf".
display-triples

Displays node pictures and link lines in a graph-node-pane for a set of triples, and then does a layout to arrange the nodes for readability.

(defun display-triples
  (triples &key
           uncache-for-new-triple-store
           keep-old-nodes
           (layout-from-scratch (or uncache-for-new-triple-store
                                    (not keep-old-nodes)))
           node-upi-for-initial-position
           max-iterations
           select-window
           no-push-go-back-state
           no-regroup
           (node-pane (graph-node-pane (gruff-browser))))

triples should be a list of triples that exist in the currently open store. You can use whatever means you like to derive the list of triples to be displayed, such as one or more calls to get-triples-list.

uncache-for-new-triple-store should be true if you have just programmatically created or opened a store after displaying nodes and links from a previous store. If the store was created or opened using the standard browser's File menu, then this was done automatically.

If keep-old-nodes is true, then any nodes and links that are already on the node pane will be retained, with the specified triples being added to them. If nil, then all nodes and links are first removed from the node pane.

If layout-from-scratch is true, then a "full layout" will be done with all nodes initially at the center of the node pane, to remove any bias from the current node positions that may have resulted from multiple "incremental" layouts. If nil, then an incremental layout is done with any old nodes starting out at their current positions.

If node-upi-for-initial-position is true, then it normally should be a part ID (a UPI, future-part, or string in ntriples format) of one of the nodes that are already displayed on the node pane, and keep-old-nodes should be true. Then any nodes that are added to the display will initially be positioned where the node for that UPI is currently positioned, and then moved from there as the layout is done. This is useful when adding a set of nodes that are linked in the store with the specified node, to make the incremental layout that follows disrupt the existing layout less than it would otherwise.

max-iterations is the number of iterations at which the automatic incremental layout will stop if it has not reached a stable state by that time. To suppress the layout altogether, specify 0 (because nil will default to some positive number). Suppressing the layout may be useful if you are going to modify the set of nodes and links that are added before you care to nicely arrange them, such as if you plan to remove all leaf nodes after adding the triples by calling remove-orphans.

If select-window is true, then the top-level window of the node pane will be brought to the front and given the keyboard focus.

If no-push-go-back-state is true, then the current state will not be added to the node pane's undo stack before doing the new operation. Otherwise an undo state will be added, allowing the user to return to the current state from the new state that results from this operation. A state consists of a particular set of nodes and links and the positions of all of the nodes.

If no-regroup is true, then objects that have many links will not be divided into multiple nodes according to Visual Graph Options | Node and Link Spacing | Maximum Links Per Node Copy.

node-pane is the window onto which to add node pictures and link lines. It should be an instance of the graph-node-pane class. When unspecified, it will default to the node pane of the standard full Gruff browser window, which will be created automatically if it doesn't exist already. Otherwise it should a graph-node-pane instance that was created by calling the Common Graphics function make-window; see "Using the standard full browser or a plain graph layout pane".

Here's an example, which expects *my-node-pane* to exist from the example under "Using the standard full browser or a plain graph layout pane", and for a new store to have been created.

First let's create some resources and add some triples for them to the store. The triples here will form a logical "wheel" with one node that's connected to the other nodes that are themselves connected in a loop.

(defparameter *middle-thing* (triple-store:resource "MiddleThing")) 

(defparameter *things* (let* ((things nil))
                         (dotimes (j 9)
                           (push (triple-store:resource
                                  (format nil "Thing ~a" j))
                             things))
                         (nreverse things)))

(defparameter *points-to* (triple-store:resource "PointsTo")) 

(let* ((count 9)
       (triples nil))
  (dotimes (j count)
    (triple-store:add-triple *middle-thing* *points-to* (nth j *things*))
    (triple-store:add-triple (nth j *things*) *points-to*
                             (nth (mod (1+ j) count) *things*))))

And now (this could be any time later), let's display the triples as a visual graph. This displays all triples whose predicate is PointsTo, which happens to include all of the triples we just created.

(display-triples (triple-store:get-triples-list :p *points-to*)
                 :keep-old-nodes nil
                 :layout-from-scratch t
                 :node-pane *my-node-pane*
                 :select-window t)

display-upis

Displays node pictures on a node pane for a set of subject and object UPIs, and adds link lines between them for a given set of predicate UPIs.

(defun display-upis
  (upi-list &key predicate-upis
                 uncache-for-new-triple-store
                 keep-old-nodes
                 (layout-from-scratch (or uncache-for-new-triple-store
                                          (not keep-old-nodes)))
                 node-upi-for-initial-position
                 max-iterations
                 select-window
                 no-push-go-back-state
                 no-regroup
                 (node-pane (graph-node-pane (gruff-browser))))

upi-list should be a list of subject and object part IDs of triples that exist in the currently open store. A node picture will be added to the node pane for each one. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

predicate-upis should be a list of predicate part IDs of triples that exist in the open store, or else t or nil. t means all predicates for which there are triples in the store, while nil means all "current predicates", as set by calling set-current-predicates or using the "Global Options | Select Current Predicates" menu command in the standard browser.

Link lines will be added to the display to connect any of the new nodes with any new or already-displayed nodes that are linked by the specified predicates in the store. More specifically, a link line will be added to the node pane between two nodes whenever there are one or more triples in the currently open store where the subject or object of the triple is in the specified upi-list, the predicate of the triple is in the specified predicate-upis, and the other subject or object of the triple is either also in the upi-list or was already displayed on the node pane.

See display-triples for descriptions of the other arguments.

Here's an example that would display the wheel from the example for display-triples, except excluding the middle node.

(display-upis *things*
              :predicate-upis (list *points-to*)
              :keep-old-nodes nil
              :layout-from-scratch t
              :node-pane *my-node-pane*
              :select-window t)

This would add the middle node to the existing nodes. The layout would probably be closer to a nice wheel-like shape if you change the :layout-from-scratch argument here to t.

(display-upis (list *middle-thing*)
              :predicate-upis (list *points-to*)
              :keep-old-nodes t
              :layout-from-scratch nil
              :node-pane *my-node-pane*
              :select-window t)

display-upis-from-file

Displays node pictures on a node pane for a set of subject and object UPIs that are listed in a file, and adds link lines between them for a set of predicate UPIs that are listed in the same file. This is like display-upis except that it reads the UPIs from a file instead of accepting them as arguments.

(defun display-upis-from-file
  (path &key keep-old-nodes
             select-window
             (layout-from-scratch (not keep-old-nodes))
             (node-pane (graph-node-pane (gruff-browser))))

path is the pathname or path namestring of a file that contains the URIs of the nodes and links to display. The file should contain a list of URIs for nodes (subjects and objects), with one URI per text line, followed by a blank line, followed by a list of predicate URIs. All of the URIs should name objects that are in the currently open store.

See display-triples for descriptions of the other arguments.

Here is a small example of the contents of a file that could be passed to this function, after opening the dbpedia store.

http://dbpedia.org/resource/Joanne_Woodward 
http://dbpedia.org/resource/Paul_Newman 
http://dbpedia.org/resource/The_Long%2C_Hot_Summer 

http://dbpedia.org/property/starring 
http://dbpedia.org/property/director 

To display a set of triples from a file (rather than individual resources and predicates as with this function), you could use the usual AllegroGraph functions to create a new store and load triples into it, and then call the Gruff function display-store to display it.
find-and-display-paths

Displays nodes and links for all paths between two nodes that use certain predicates, up to a certain maximum path length. Returns the list of paths that were found.

(defun find-and-display-paths
    (node-upi1 node-upi2 predicate-upis
               &key (finder-function 'triple-store:all-bidirectional-search-paths)
               (maximum-depth 4) warn-on-many-triples
               uncache-for-new-triple-store keep-old-nodes
               (layout-from-scratch (or uncache-for-new-triple-store
                                        (not keep-old-nodes)))
               (end-node-placement (and layout-from-scratch
                                        :left-and-right))
               node-upi-for-initial-position
               max-iterations select-window no-push-go-back-state
               (timeout 30)
               (node-pane (graph-node-pane (gruff-browser))))

node-upi1 and node-upi2 are the part IDs of the two resources and/or literals between which paths should be found. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

predicate-upis should be a list of predicate part IDs. Only paths that use only predicates from this list will be found. If this argument is nil, it will default to the current predicates (see current-predicates). If it is t, then all predicates will be used.

finder-function is the particular AllegroGraph Social Network Analysis (SNA) function to call to find the paths. The default value is triple-store:all-bidirectional-search-paths, which will find only the shortest paths even when maximum-depth is large. This argument could be any path-finding function that takes the same arguments, such as triple-store:all-depth-first-search-paths or triple-store:all-breadth-first-search-paths.

maximum-depth is the length of the longest paths that are to be found.

end-node-placement works as with display-paths.

If warn-on-many-triples is true and the number of found paths is greater than the number-of-found-paths-for-warning option of the node pane, then a confirmation dialog is shown, and the nodes and links are added to the display only if the user confirms.

If the call to a path-finding function does not return in timeout seconds, then this function gives up and returns the symbol :timeout.

The other arguments are passed straight through to display-triples.

This function corresponds to the menu command Link | Display Paths Between Two Nodes (when keep-old-nodes is true) and to Link | Display Only Paths Between Two Nodes (when keep-old-nodes is nil).

This function calls display-paths to display the paths that were found. If you are calling AllegroGraph's path-finding functions such as all-bidirectional-search-paths yourself, then you could pass the result to display-paths instead of calling this function.
display-paths

Displays nodes and links for a set of paths that are specified as lists of nodes, for a particular set of predicates that link them.

(defun display-paths (paths predicate-upis
                            &key warn-on-many-triples
                            uncache-for-new-triple-store keep-old-nodes
                            (layout-from-scratch (or uncache-for-new-triple-store
                                                     (not keep-old-nodes)))
                            (end-node-placement (and layout-from-scratch
                                                     :left-and-right))
                            node-upi-for-initial-position
                            max-iterations select-window no-push-go-back-state
                            (node-pane (graph-node-pane (gruff-browser))))

paths is a list of lists of the part IDs of resources and/or literals, where each sublist should specify a sequence of nodes that are linked by the specified predicates. Typically this value would have been returned by one of AllegroGraph's social network path-finding functions such as all-depth-first-search-paths or all-bidirectional-search-paths. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

predicate-upis should be a list of predicate part IDs. Links will be shown between the displayed nodes only for the predicates in this list. If this argument is nil, it will default to the current predicates (see current-predicates). If it is t, then all predicates will be used.

If warn-on-many-triples is true and the number of triples in all of the paths is greater than the number-of-found-path-links-for-warning option of the node pane, then a confirmation dialog is shown, and the nodes and links are added to the display only if the user confirms.

end-node-placement determines whether the two end nodes are pinned near the edges of the window during the automatic incremental layout that occurs. Pinning the end nodes near the window edges typically makes the paths between them clearer by stretching them out. :left-and-right will place the node-upi1 node near the left edge of the window and the node-upi2 node near the right edge. :top-and-bottom would place them near the top and bottom edges, while nil will let the two end nodes float freely as usual during the layout. The default is :left-and-right when layout-from-scratch is true, but nil when layout-from-scratch is false (to avoid disrupting the current layout).

The other arguments are passed straight through to display-triples.

This function is called by find-and-display-paths, which first finds the paths to display from nodes that lie at the ends of the paths.
display-linked-nodes

Adds nodes to the display that are linked in the store to a particular specified node by any of the current predicates, and adds these links to the display. A link is also added to the display between any newly-displayed node and any newly-displayed or already-displayed node to which it is linked by any current predicate.

(defun display-linked-nodes
  (from-node-upi &key (keep-old-nodes t)
                      (levels-to-add 1)
                      (deselect-selected-node t)
                      (exclude-explicitly-excluded-nodes t)
                      (node-pane (graph-node-pane (gruff-browser))))

from-node-upi should be a part ID of a node that is already displayed on the node pane. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".) Node pictures will be added to the node pane, and link-lines will connect them to this node, for any nodes in the store that are linked with this node by any of the current predicates. Call set-current-predicates beforehand to establish the current predicates.

If keep-old-nodes is true, then nodes and links that were already on the node-pane will not be removed. If nil, all nodes and links will be removed except for the node of the specified from-node-upi.

levels-to-add should be a positive integer indicating how many links from the specified from-node-upi should be traversed to find additional nodes to add. The default is 1 to add only nodes that are directly linked to the from-node-upi by the current predicates. A value of 2 would also add any nodes that are linked to those nodes by the current predicates. Note that a higher value is likely to add more nodes than can reasonably be layed out or viewed at one time.

If deselect-selected-node is true, then the currently selected node (which in this case will be the from-node-upi node) is deselected before the layout is done. Otherwise the from-node-upi node will be fixed in place during the layout.

If exclude-explicitly-excluded-nodes is true, then no nodes that have been explicitly excluded by the user will be added to the node pane. Otherwise they will be added if they meet the other requirements. A node is excluded by calling remove-node-of-upi with the exclude argument as true.

See display-triples for a description of the node-pane argument.

This function corresponds to the menu command Link | Display Linked Nodes for the Current Predicates, except that that command always acts on the node picture that has been selected by the user.

Here's an example that uses the test objects from the preceding examples. It first displays the middle node by itself and waits a couple of seconds. Then it makes our *points-to* predicate be a current predicate and adds any nodes that are linked with the middle node by any current predicates.

(progn 

  ;; Display the middle thing by itself.
  (display-upis (list *middle-thing*)
                :keep-old-nodes nil
                :layout-from-scratch t
                :node-pane *my-node-pane*
                :select-window t)

  ;; Add nodes to the middle node that are linked to it by
  ;; any current predicates.
  (sleep 2)
  (set-current-predicates (list *points-to*) :node-pane *my-node-pane*)
  (display-linked-nodes *middle-thing*
                        :node-pane *my-node-pane*)

  ;; For three of the nodes, add triples to connect them to
  ;; new resources, and then display any nodes that are linked
  ;; to the new ones by the current predicates.
  (dotimes (node-num 3)
    (sleep 2)
    (dotimes (count 4)
      (triple-store:add-triple
       (nth node-num *things*) *points-to*
       (triple-store:resource (format nil "Thing ~a"
                                (+ 100 (* node-num 10) count)))))
    (uncache-for-modified-triple-store)
    (set-current-predicates (list *points-to*) :node-pane *my-node-pane*)
    (display-linked-nodes (nth node-num *things*)
                          :node-pane *my-node-pane*))

  ;; The layout is probably not as nice as it could be due to
  ;; doing multiple incremental layouts, so redo it from scratch.
  (sleep 2)
  (update-the-layout :layout-from-scratch t
                     :node-pane *my-node-pane*))

display-store

Displays node pictures and link lines in a graph-node-pane for some or all of the triples in the currently open store, and then does a layout to arrange the nodes for readability.

(defun display-store
  (&key (limit 100)
        graph
        uncache-for-new-triple-store
        keep-old-nodes
        include-nodes-for-label-properties
        include-nodes-for-comment-properties
        (layout-from-scratch (or uncache-for-new-triple-store
                                 (not keep-old-nodes)))
        max-iterations
        select-window
        no-push-go-back-state
        no-regroup
        (node-pane (graph-node-pane (gruff-browser))))

limit is the maximum number of nodes to add to the display. When limit is less than the number of triples in the store, then the first arbitrary set of triples that are found will be used, even if they are already displayed on the node pane.

graph may be the UPI of one of the graphs of the store, to display only nodes that are in that particular graph.

Attempting to display all triples in a large store can easily overwhelm the ability of the software to do a layout in a reasonable amount of time. You can make the scrolling canvas larger to accomodate more nodes, though; see "Adjusting the size of the canvas for the layout".

If include-nodes-for-label-properties is nil, then nodes that are the object of triples whose predicates are rdfs:label will be excluded from the display. If true, they will be included like any other node. Typically it is not useful to include nodes for label properties because their values are printed on the nodes for which they are the labels.

If include-nodes-for-comment-properties is nil, then nodes that are the object triples whose predicates are rdfs:comment will be excluded from the display. If true, they will be included like any other node. Typically it is not necessary to include nodes for comment properties because the comment strings are displayed in tooltips when holding the mouse over nodes for which they are the comments.

See display-triples for descriptions of the other arguments.

This function corresponds to the menu command Display | Display Some Sample Triples.
remove-node-of-upi

Removes the node picture for a UPI from the display, along with any link lines that are connected to it.

(defun remove-node-of-upi
  (node-upi &key exclude
                 (node-pane (graph-node-pane (gruff-browser))))

Removes a node picture that has been added to the display at some earlier time. Any link lines that are connected directly to the node picture are also removed (because otherwise they would be left pointing to nothing).

node-upi should be a part ID of a node that is currently displayed (though if it is not found a status-bar message will simply indicate that). (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

If exclude is true, then the node will be marked as an indefinitely excluded node, and it will not be added back by functions or commands that add any nodes that are linked by the current predicates, or by display-store.

See display-triples for a description of the node-pane argument.

This function corresponds to the menu commands Remove | Remove Selected Node and Remove | Exclude Selected Node, except that those commands always act on the node that has been selected by the user.

Here's an example using the graph that was built in earlier examples.

(remove-node-of-upi *middle-thing*
                    :node-pane *my-node-pane*)

remove-orphans

Removes any orpan and/or leaf nodes from the display.

(defun remove-orphans
  (&key leaves-too unhighlighted
        no-update no-warning
        (node-pane (graph-node-pane (gruff-browser))))

This function removes from the display any nodes that are not connected to other displayed nodes by link lines, and optionally also any nodes that are connected to only a single other displayed node.

If leaves-too is true, then leaf nodes (ones that are linked to exactly one other displayed node) are removed in addition to orphan nodes. If nil, then only orphan nodes (ones that are not linked to any other displayed nodes) are removed. Note that removing leaves may turn some remaining nodes into leaves, and so calling this function again may remove additional nodes.

If unhighlighted is true, then a completely different thing is done, to remove all nodes except for ones that are highligted.

If no-update is true, then no layout is done after removing the nodes. If nil, then an incremental layout is done.

If no-warning is true, then no warning is shown in the status bar if there were no nodes to remove, and otherwise a warning will be shown. It may be useful to suppress the warning to avoid covering an earlier more important status bar message.

See display-triples for a description of the node-pane argument.

This function corresponds to the menu commands Remove | Remove All Orphan Nodes, Remove | Remove All Leaf Nodes, and Remove | Remove All Unhighlighted Nodes.
remove-all-nodes

Removes all nodes and links from the display. This is useful for clearing the display to begin building a new one.

This function corresponds to the menu command Remove | Remove All Nodes.
current-predicates

Returns the current predicates as UPIs.

(defun current-predicates () 

Two values are returned, where the first is a list of UPIs of the predicates that will be used when a specified node is the subject of any triples that use those predicates, and the second being a list of UPIs of the predicates that are used when a specified node is the object of a triple.
set-current-predicates

Defines the set of predicates that are used by functions that use the current predicates.

(defun set-current-predicates
  (predicate-upis &key (node-pane (graph-node-pane (gruff-browser))))

Some functions and menu commands act on a set of current predicates. This is a convenience feature that allows specifying a set of predicates that are of interest a single time, and then making multiple calls to add nodes that are linked by those predicates.

For example, if you call display-upis with the predicate-upis argument as nil, then it will add link lines to the display for any triples that link displayed nodes by these current predicates. And the function display-linked-nodes always uses the current predicates.

predicate-upis should be a list of predicate part IDs. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

See the example for display-linked-nodes.

This function corresponds to the menu command Global Options | Select Current Predicates.
highlight-node-by-upi

Highlights or unhighlights a node that is on a node pane, by changing its background color.

(defun highlight-node-by-upi
  (node-upi &key off (node-pane (graph-node-pane (gruff-browser))))

Highlighted nodes are drawn with a light red background to make it easier to spot particular nodes. This function is like the menu command Select | Toggle Highlighting of the Selected Node or Link, except that you can specify an arbitrary node.

node-upi should be a part ID of a node picture that is currently displayed on the node pane. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

off should be nil to turn highlighting on for the node picture, or true to turn it off.

See display-triples for a description of the node-pane argument.

Alternately call remove-all-highlighting.

This function corresponds to the menu command Select | Toggle Highlighting of the Selected Node or Link.
remove-all-highlighting

Turns highlighting off for all node pictures that are currently displayed.

(defun remove-all-highlighting
  (&key (node-pane (graph-node-pane (gruff-browser))))

See display-triples for a description of the node-pane argument.

This function corresponds to the menu command Select | Remove All Node and Link Highlighting.
update-the-layout

Arranges the nodes that are currently displayed to make the overall layout of nodes and links relatively readable.

(defun update-the-layout
    (&key layout-from-scratch
          max-iterations
          fixed-node-upis
          deselect-selected-node
          compress-layout
          center-the-graph
          (node-pane (graph-node-pane (gruff-browser))))

fixed-node-upis may be a list of part IDs whose node pictures should remain at their current locations during the layout, forcing other nodes to arrange themselves around those fixed nodes. If nil, then no node pictures will be fixed in place. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "<foo>".)

If deselect-selected-node is true, then the currently selected node (if any) is deselected before the layout is done. Otherwise the currently selected node will be fixed in place during the layout.

If compress-layout is true, then an additional step is done after the main layout that tends to bring the nodes closer together so that the entire graph takes up less space. If nil, this is not done. See the menu command Visual Graph Options | Layout Options | Compress After Full Layout.

If center-the-graph is true, then after the layout is done, the entire set of nodes is moved to the middle of the scrollable canvas, and the window is scrolled to the middle of the canvas. If nil, this is not done. See the menu command Visual Graph Options | Layout Options | Center After Full Layout.

See display-triples for descriptions of the other arguments.

This function corresponds to the menu commands Layout | Update Layout Incrementally and Layout | Redo Layout from Scratch.
center-the-graph

Centers the graph as a whole in the window.

(defun center-the-graph
  (&key (node-pane (graph-node-pane (gruff-browser))))

This function first moves the whole set of displayed nodes and links as a group to the middle of the scrollable canvas of the node pane, and then scrolls the node pane to the middle of the canvas.

The two options Visual Graph Options | Layout Options | Center After Full Layout and Visual Graph Options | Layout Options | Center After Incremental Layout cause this to be done automatically at certain times, but note that the option for centering after an incremental layout will scroll the window to the middle only if it was nearly scrolled to the middle before the layout. This function will always do it.

See display-triples for a description of the node-pane argument.

This function corresponds to the menu command Layout | Center the Graph.
gruff-browser

Returns the standard full Gruff browser, complete with its menu bar of interactive commands and its alternate views. If the browser does not exist currently, it is created automatically.

(defun gruff-browser (&key expose exterior http-server-port disable-menus) 

If expose is true, then the browser will be brought to the front and given the keyboard focus, whether or not the browser already exists. If nil, then it will come to the front only if it did not exist yet.

The exterior argument can be passed to specify the screen coordinates of the Gruff window, if it is being created. The value should be a Common Graphics "box" object that specifies the left, top, right, and bottom edges, as created by a call like (make-box 100 100 800 600).

The http-server-port argument may be an integer to tell Gruff to start up an HTTP server at that port, to allow controlling Gruff remotely with HTTP commands. See The HTTP Interface to Gruff.

If disable-menus is true, then no menu bar or pop-up menus will appear, and their keyboard shortcuts will be disabled as well. This may be useful for preventing the end user from controlling Gruff interactively if you want to exclusively control Gruff with HTTP commands.

The programmatic interface for graph layout can be used on the "graph view" node pane of the full browser, which is returned by this expression:

(graph-node-pane (gruff-browser)) 

Alternately you can make and use a raw instance of the graph-node-pane class. See "Using the standard full browser or a plain graph layout pane".
graph-node-pane

This symbol names both a class and a function.

An instance of the class is a Common Graphics window on which node pictures and link lines are placed. Various Gruff functions take a graph-node-pane as an argument. You can use either the one in the standard full browser, which is returned by (graph-node-pane (gruff-browser)), or use a custom graph-node-pane instance that you create by calling the Common Graphics function make-window.

See "Using the standard full browser or a plain graph layout pane".

This symbol also names a function, which returns the "graph view" node pane of the standard full Gruff browser.

(defmethod graph-node-pane ((window gruff-frame)) 

This simply returns the descendent window of the standard full Gruff browser that is used for drawing visual graphs of nodes and links in the graph view.

This child window is the default value for functions where a node-pane argument is needed, so you likely will not need to call this function yourself. Either you will be using the full Gruff browser and letting the node-pane arguments default, or you will be using your own instance of graph-node-pane and passing that node pane instead.

The argument to this function should be the Gruff browser window that's returned by gruff-browser.
save-layout

Saves the current state of a visual graph, which can be loaded any time later with load-layout.

(defmethod save-layout ((pane graph-node-pane) file) 

pane is the graph-node-pane that is displaying a visual graph.

file is the pathname or path namestring of the file into which to save the data.

This function corresponds to the menu command File | Save Layout State.
load-layout

(defmethod load-layout ((pane graph-node-pane) file) 

Loads a visual graph that was saved some time earlier with save-layout. The same store that was open when the save was done should be open when calling this function (or possibly another store that contains the same triples). Any triples in the saved state that are not found in the currently-open store will simply not be displayed.

True is returned if the load was successful, and otherwise nil is returned. A return value of nil may indicate that the file does not exist or that it is not really a gruff layout file.

pane is the graph-node-pane onto which to display the loaded visual graph.

file is the pathname or path namestring of the file from which to load the data.

This function corresponds to the menu command File | Load Layout State.
save-layout-as-pixmap

Creates a pixmap file containing an image of the currently-displayed visual graph. The pixmap will encompass all of the displayed nodes in the visual graph, even if they are scrolled out of view, adding a bit of margin around them all. On Windows a BMP file will be saved, while on Linux a PNG file will be saved.

(defun save-layout-as-pixmap (pane &key path show-saved-pixmap) 

pane is the graph-node-pane that is displaying a visual graph.

path is the pathname or path namestring of the file into which to save the image. If nil or unsupplied, a dialog will ask for the path to which to save the image.

If show-saved-pixmap is true, then the saved pixmap will be displayed by another program. The other program will be either your default pixmap-viewing program or your preferred web browser, depending on the value of Global Options | Miscellaneous | Use Web Browser for All Documents.

This function corresponds to the menu command File | Save Layout As Pixmap.
uncache-for-modified-triple-store

Uncaches information as needed if the open store has been modified after displaying information from it in Gruff.

(defun uncache-for-modified-triple-store () 

If you have opened a triple-store and displayed some of its nodes and links in a visual graph, and then you have modified the store (such as by adding additional triples), then you should call this function before calling any further Gruff functions. Otherwise Gruff may use out-of-date information about the nodes and links that are in the store.

This function does not remove any of the displayed information in the Gruff interface, and so you do not need to start over building a visual graph, for example. But if any currently-displayed triples have been removed from the store, then this function will not be sufficient, and uncache-for-new-triple-store should be called instead.
uncache-for-new-triple-store

Clears everything as needed to begin displaying a different triple-store in Gruff.

(defun uncache-for-new-triple-store
  (&key (node-pane (graph-node-pane (gruff-browser))))

Removes all nodes and links from the specified node pane, and clears information that has been cached about nodes and links in the current store. This is needed when creating or opening a different triple-store programmatically when the node pane is displaying objects from a previous store. This function is called automatically by the functions on the File menu of the standard browser, but otherwise needs to be called by an application that has created or opened a store in some other way after displaying information from another store.

If you have simply modified the store that's being browsed, without removing any of the currently-displayed triples, then you could instead call uncache-for-modified-triple-store to avoid clearing the currently-displayed information.

This function corresponds to the menu command File | Clear and Uncache Everything.
gruff-options-path

Returns the path of the file where your personal Gruff options are saved.

(defun gruff-options-path () 

If the standard Gruff browser window is used by calling gruff-browser rather than by creating a custom instance of the graph-node-pane class, then Gruff will save personal preferences from the various options menus of the standard browser. The options will be saved whenever the Global Options | Save All Options command is used, and also when the browser is exited. The saved options will be loaded when the standard browser is restarted.

The expression (gruff-options-path) returns the path of the file where the option values are saved. This file could be deleted to revert all default options, including ones that are not reverted by Global Options | Revert to Default Options.
*selected-node*

A global variable whose value is the UPI of the most recently selected node in the graph view, or else nil if no node has been selected yet.

This is intended as a handy way to get a programmatic handle on a resource or literal that appears in the interface. A debugging expression using this variable could be evaluated in a lisp listener of a development lisp, for example, after selecting the desired node in the graph view.
*selected-link*

A global variable whose value is the UPI of the most recently selected link in the graph view, or else nil if no node has been selected yet.

If the selected link represents multiple predicates, then one of those predicates is chosen arbitrarily and its UPI is used.
*suppressing-gruff-messages*

A global variable that determines whether messages will appear in any ancestor window of a graph-node-pane that has a status bar at the bottom of the window. The value is nil by default, and Gruff binds it to t now and then.

An application could bind this variable to a non-nil value while executing certain code where the status bar messages would be cumbersome. Or it could set the value permanently to a non-nil value to totally suppress status bar messages.
*gruff-version*

A global variable whose value is a string indicating the current version of Gruff. This value is shown in the Help | About dialog.

**** Lisp Functions for Modifying User Options Programmatically

The standard interactive Gruff browser has several menus for modifying a variety of user options interactively. There are also functions for reading and writing the option values programmatically. Each option is an accessor function of the graph-node-pane class.

For example, the menu option Visual Graph Options | Node and Link Spacing | Minimum Node-to-Node Spacing uses the accessor function min-node-to-node-spacing. Evaluating the form (min-node-to-node-spacing my-node-pane) will return the current value, while (setf (min-node-to-node-spacing my-node-pane) 10) would set the value to 10.

Here is a table of the various option menu commands and the accessor function that corresponds to each one. Refer to the documentation for each menu command for the meaning of the option.

  View | Graph View Panes | Show Legend - show-legend (boolean)
  View | Graph View Panes | Show Overview - show-overview (boolean)
  Edit | Confirm Triple Deletion - confirm-triple-deletion (boolean)
  Edit | Show Menus of Recent Namespaces - show-menus-of-recent-namespaces (boolean)
  Edit | Percent-Decode Characters for Editing - percent-decode-characters-for-editing (boolean)
  Edit | Percent-Encode Non-ASCII After Editing - percent-encode-non-ascii-after-editing (boolean)
  Global Options | Status Bar Font - gruff-status-bar-font (font)
  Global Options | Widget Font - gruff-widget-font (font)
  Global Options | Node Label Predicates | Use Label Predicates for Node Labels - use-label-properties (boolean)
  Global Options | Node Label Predicates | Label Predicate Language - label-property-language (string)
  Global Options | Node Label Predicates | Custom Predicates for Node Labels - custom-predicates-for-labels-help (string)
  Global Options | Node Label Predicates | Custom Predicates for Node Comments - custom-predicates-for-comments (string)
  Global Options | Node Label Predicates | Custom Predicates for Node Pixmaps - custom-predicates-for-pixmaps (string)
  Global Options | Derived Node and Link Labels | Exclude Namespaces from Labels - exclude-namespaces-from-labels (boolean)
  Global Options | Derived Node and Link Labels | Add Spaces to Labels - add-spaces-to-labels (boolean)
  Global Options | Derived Node and Link Labels | Collapse Contiguous Spaces in Labels - collapse-contiguous-spaces-in-labels (boolean)
  Global Options | Derived Node and Link Labels | Capitalize First Word - capitalize-first-word (boolean)
  Global Options | Derived Node and Link Labels | Convert Percent Encoding in Labels - convert-percent-hex-in-labels (boolean)
  Global Options | Derived Node and Link Labels | Display subClassOf as "Superclass" | display-subclassof-as-superclass (boolean)
  Global Options | Maximum Menu String Length | max-menu-item-string-length (integer)
  Global Options | Show Full URIs in Pop-Up Menus | show-full-uris-in-pop-up-menus (boolean)
  Global Options | Case-Sensitive Sorting for Menus | case-sensitive-sorting (boolean)
  Global Options | Maximum Choices When Selecting a Subset | max-choices-when-selecting-a-subset (integer)
  Global Options | General Triple-Fetching Limit - get-triples-list-limit (integer)
  Global Options | Finding All Types Timeout - finding-all-types-timeout (integer)
  Global Options | Finding All Predicates Timeout - finding-all-predicates-timeout (integer)
  Global Options | SPARQL Endpoints | Query Results Limit - get-triples-list-limit-with-endpoints (integer)
  Global Options | SPARQL Endpoints | Use Label Predicates for Node Labels - use-label-properties-with-endpoints (boolean)
  Global Options | SPARQL Endpoints | Use Most Specific Type for Node Color - use-most-specific-type-for-node-color-with-endpoints (boolean)
  Global Options | Communications | Use Session Ports - use-session-ports (boolean)
  Global Options | Communications | HTTP Proxy for Microformat Extraction - gruff-http-proxy (list)
  Global Options | Communications | Use any23.org for RDFa - use-any23-for-rdfa (boolean)
  Global Options | Communications | Ignored RDFa Relationships - ignored-rdfa-relationships (list)
  Global Options | Miscellaneous | Confirm Exit - confirm-exit (boolean)
  Global Options | Miscellaneous | Reasoner Enables Restriction Reasoning - reasoner-enables-restriction-reasoning (boolean)
  Global Options | Miscellaneous | External Format for Loading Triples - external-format-for-load-ntriples (symbol)
  Global Options | Miscellaneous | Auto Font Switching on Text Entry - auto-font-switching-on-text-entry (boolean)
  Global Options | Miscellaneous | Use Web Browser for All Documents - use-web-browser-for-all-documents (boolean)
  Global Options | Miscellaneous | Document Base Folder - document-base-folder (string)
  Query Options | Query String Font - query-string-font (font)
  Query Options | Query Timeout - query-timeout (integer)
  Query Options | Query Results Limit - query-results-limit (integer)
  Query Options | Percent-Encode Non-ASCII in Queries - percent-encode-non-ascii-in-queries (boolean)
  Query Options | Query Logging Enabled - query-logging-enabled (boolean)
  Query Options | Query Logging File - query-logging-file (file)
  Query Options | New Log File for Each Session - new-log-file-for-each-session (boolean)
  Query Options | Query Text Report Show Full URIs - query-text-report-show-full-uris (boolean)
  Query Options | Query Text Report One Line per Value - query-text-report-one-line-per-value (boolean)
  Table Options | Table Property Name Font - table-property-name-font (font)
  Table Options | Table Property Value Font - table-property-value-font (font)
  Table Options | Show Full URIs in Tables - show-full-uris-in-tables (boolean)
  Table Options | Show Multiple Property Values - show-multiple-property-values
  Table Options | Show Multiple Text Lines - fit-row-height-to-text (boolean)
  Table Options | Display Literals of All Languages - display-literals-of-all-languages-in-tables (boolean)
  Table Options | Maximum Triples Per Predicate in Table - max-triples-per-predicate (integer)
  Table Options | Maximum String Length in Table - max-string-length-in-table (integer)
  Table Options | Table Color One - table-color-one (color)
  Table Options | Table Color Two - table-color-two (color)
  Table Options | Table Cell Vertical Padding - table-cell-vertical-padding (integer)
  Outline Options | Outline Font - outline-node-font (font)
  Outline Options | Show Full URIs in Outline - show-full-uris-in-outlines (boolean)
  Outline Options | Create All Nodes as Blank Nodes | create-all-outline-nodes-as-blank-nodes (boolean)
  Visual Graph Options | Node Labels | Node Label Font - node-font (font)
  Visual Graph Options | Node Labels | Show Full URIs on Nodes - show-full-uris-on-nodes (boolean)
  Visual Graph Options | Node Labels | Maximum Node Label Length - max-node-label-length (integer)
  Visual Graph Options | Node Labels | Enforce Maximum Node Label Length - enforce-max-node-label-length (boolean)
  Visual Graph Options | Node Labels | Absolute Maximum Node Label Length - absolute-max-node-label-length (integer)
  Visual Graph Options | Link Labels | Draw Link Labels - draw-link-labels (boolean)
  Visual Graph Options | Link Labels | Draw Graph Link Labels Horizontally - draw-link-labels-horizontally (boolean)
  Visual Graph Options | Link Labels | Draw Query Link Labels Horizontally - draw-query-link-labels-horizontally (boolean)
  Visual Graph Options | Link Labels | Use Line Color for Link Labels - use-line-color-for-link-labels (boolen)
  Visual Graph Options | Link Labels | Link Label Color - link-label-color (color)
  Visual Graph Options | Link Labels | Link Label Font - link-label-font (font)
  Visual Graph Options | Link Labels | Draw Link Labels for Node Under Mouse (boolean)
  Visual Graph Options | Link Labels | Link Label Box Color - link-label-box-color (color)
  Visual Graph Options | Layout Options | Do Automatic Incremental Layouts - do-automatic-incremental-layouts (boolean)
  Visual Graph Options | Layout Options | Animate Layouts - animate-layouts (boolean)
  Visual Graph Options | Layout Options | Maximum Nodes for Animation - max-nodes-for-animated-layout (integer)
  Visual Graph Options | Layout Options | Maximum Iterations for Full Layout - max-iterations-for-full-layout (integer)
  Visual Graph Options | Layout Options | Maximum Iterations for Incremental Layout - max-iterations-for-incremental-layout (integer)
  Visual Graph Options | Layout Options | Center After Full Layout - center-after-full-layout (boolean)
  Visual Graph Options | Layout Options | Center After Incremental Layout - center-after-incremental-layout (boolean)
  Visual Graph Options | Layout Options | Compress After Full Layout - compress-after-full-layout (boolean)
  Visual Graph Options | Layout Options | Compress After Incremental Layout - compress-after-incremental-layout (boolean)
  Visual Graph Options | Layout Options | Honor Layout Direction Constraints - honor-layout-direction-constraints (boolean)
  Visual Graph Options | Layout Options | Specify Layout Direction for a Predicate - directional-predicates (alist)
  Visual Graph Options | Layout Options | Clear Layout Direction for a Predicate - directional-predicates (alist)
  Visual Graph Options | Layout Options | Canvas Resize Factor - canvas-resize-factor (real)
  Visual Graph Options | Layout Options | Drag Scroll Zoom Factor - drag-scroll-zoom-factor (real)
  Visual Graph Options | Spring Layout Options | Minimum Nodes for Spring Layout - min-nodes-for-spring-layout (integer)
  Visual Graph Options | Spring Layout Options | Spacing Factor - spring-layout-spacing-factor (integer)
  Visual Graph Options | Spring Layout Options | Velocity Divisor - spring-layout-velocity-divisor (integer)
  Visual Graph Options | Spring Layout Options | Slowdown Exponent - spring-layout-slowdown-exponent (integer)
  Visual Graph Options | Spring Layout Options | Keep Nodes on Canvas - spring-layout-keep-nodes-on-canvas (boolean)
  Visual Graph Options | Constraint-Based Layout Options | Begin Full Layout at Random Positions | begin-with-nodes-at-random-positions (boolean)
  Visual Graph Options | Inclusion Options | Remove Orphans on Node Removal - remove-orphans-on-node-removal (boolean)
  Visual Graph Options | Inclusion Options | Number of Total Links for Warning - number-of-links-for-warning-2 (integer)
  Visual Graph Options | Inclusion Options | Number of Total Links for Abort - number-of-links-for-abort-2 (integer)
  Visual Graph Options | Inclusion Options | Number of Links from One Node for Warning - number-of-radial-links-for-warning-2 (integer)
  Visual Graph Options | Inclusion Options | Show 1 Level of Nodes on Display Only Linked Nodes - levels-to-add-on-display-linked-nodes (integer)
  Visual Graph Options | Inclusion Options | Show 2 Levels of Nodes on Display Only Linked Nodes - levels-to-add-on-display-linked-nodes (integer)
  Visual Graph Options | Inclusion Options | Maximum Sample Triples to Display - max-triples-for-display-all-triples-2 (integer)
  Visual Graph Options | Finding Paths Between Nodes | Maximum Path Length - max-path-length-for-add-paths (integer)
  Visual Graph Options | Finding Paths Between Nodes | Find Only Shortest Paths - find-only-shortest-paths (boolean)
  Visual Graph Options | Finding Paths Between Nodes | Path-Finding Timeout - path-finding-timeout (integer)
  Visual Graph Options | Finding Paths Between Nodes | Number of Found Paths for Warning - number-of-found-paths-for-warning (integer)
  Visual Graph Options | Finding Paths Between Nodes | Maximum Paths to Display - max-paths-to-display (integer)
  Visual Graph Options | Finding Paths Between Nodes | Find Paths on Server - find-remote-paths-on-server (boolean)
  Visual Graph Options | Finding Paths Between Nodes | Place Path End Nodes at Left and Right - path-end-node-placement (symbol)
  Visual Graph Options | Finding Paths Between Nodes | Place Path End Nodes at Top and Bottom - path-end-node-placement (symbol)
  Visual Graph Options | Finding Paths Between Nodes | Place Path End Nodes Anywhere - path-end-node-placement (symbol)
  Visual Graph Options | Finding Paths Between Nodes | Path End Node Margin - path-end-node-margin (integer)
  Visual Graph Options | Node and Link Spacing | Minimum Node-to-Node Spacing - min-node-to-node-spacing (integer)
  Visual Graph Options | Node and Link Spacing | Minimum Link-to-Node Spacing - min-link-to-node-spacing (integer)
  Visual Graph Options | Node and Link Spacing | Node Label Margin - label-margin (integer)
  Visual Graph Options | Node and Link Spacing | Maximum Links Per Node Copy - max-links-per-node-copy (integer)
  Visual Graph Options | Node and Link Spacing | Spacing Increment for Many Links - spacing-increment-for-many-links (integer)
  Visual Graph Options | Node and Link Spacing | Add Spacing for Long Paths - add-spacing-for-long-paths (boolean)
  Visual Graph Options | Node and Link Spacing | Long Path Spacing Increment - long-path-spacing-increment (integer)
  Visual Graph Options | Node and Link Spacing | Long Path Maximum Spacing - long-path-max-spacing (integer)
  Visual Graph Options | Node and Link Spacing | Limit Outward Stretching - limit-outward-stretching (boolean)
  Visual Graph Options | Node and Link Spacing | Link Line Mousing Margin - link-line-mousing-margin (integer)
  Visual Graph Options | Node and Link Flashing | Flash Legend Matches - flash-legend-matches (boolean)
  Visual Graph Options | Node and Link Flashing | Flash End Nodes of Found Paths - flash-end-nodes-of-found-paths (boolean)
  Visual Graph Options | Node and Link Flashing | Flash Newly Added Nodes - flash-newly-added-nodes (boolean)
  Visual Graph Options | Node and Link Flashing | Flash Selected Search Matches - flash-selected-search-matches (booelan)
  Visual Graph Options | Node and Link Flashing | Times to Flash - times-to-flash (integer or nil)
  Visual Graph Options | Node and Link Flashing | Flashing Time Interval - flashing-interval (integer)
  Visual Graph Options | Node and Link Flashing | Flashing Node Color Delta - flashing-node-color-difference (integer)
  Visual Graph Options | Tooltips | Show Node Tooltips - show-node-tooltips (boolean)
  Visual Graph Options | Tooltips | Show Link Tooltips - show-link-tooltips (boolean)
  Visual Graph Options | Tooltips | Tooltip Font - node-and-link-tooltip-font (font)
  Visual Graph Options | Tooltips | Tooltip Background Color - node-and-link-tooltip-background-color (color)
  Visual Graph Options | Tooltips | Node Tooltips Delay - node-tooltip-delay (integer)
  Visual Graph Options | Tooltips | Link Tooltips Delay - link-tooltip-delay (integer)
  Visual Graph Options | Antialiasing | Antialias Lines - antialias-lines (boolen)
  Visual Graph Options | Antialiasing | Antialias Text - antialias-text (boolen)
  Visual Graph Options | Antialiasing | Suppress Antialiasing During Animation - suppress-antialiasing-during-animation (boolen)
  Visual Graph Options | Arrowheads | Arrowhead Length - default-arrowhead-length (integer)
  Visual Graph Options | Arrowheads | Arrowhead Width - default-arrowhead-width (integer)
  Visual Graph Options | Color Gradients | Show Node Color Gradients - show-node-color-gradients (boolean)
  Visual Graph Options | Color Gradients | Color Gradient Intensity - color-gradient-intensity (integer)
  Visual Graph Options | Color Gradients | Suppress Color Gradients During Animation - suppress-color-gradients-during-animation (boolean)
  Visual Graph Options | Color Nodes for Node Type - node-color-scheme (symbol)
  Visual Graph Options | Color Nodes for Unseen Links - node-color-scheme (symbol)
  Visual Graph Options | Node and Link Color for Types | Use Most Specific Type for Node Color - use-most-specific-type-for-node-color (boolean)
  Visual Graph Options | Node and Link Color for Types | Specify Color for Selected Node's Type - node-colors-for-types (alist)
  Visual Graph Options | Node and Link Color for Types | Remove Color Mapping for Selected Node's Type - node-colors-for-types (alist)
  Visual Graph Options | Node and Link Color for Types | Specify Color for Selected Link's Predicate - line-styles-for-predicates (alist)
  Visual Graph Options | Node and Link Color for Types | Specify Line Width for Selected Link's Predicate - line-styles-for-predicates (alist)
  Visual Graph Options | Node and Link Color for Types | Specify Dashing for Selected Link's Predicate - line-styles-for-predicates (alist)
  Visual Graph Options | Node and Link Color for Types | Suppress Link Link Styles - suppress-link-line-styles (boolean)
  Visual Graph Options | Node Color for Unseen Links | Node Color for Unseen Current Links - node-color-for-unseen-current-links (color)
  Visual Graph Options | Node Color for Unseen Links | Node Color for Unseen Non-Current Links - node-color-for-unseen-noncurrent-links (color)
  Visual Graph Options | Node Color for Unseen Links | Node Color for No Unseen Links - node-color-for-no-unseen-links (color)
  Visual Graph Options | Window Background | Graph View Background Color - color-for-window-background (color)
  Visual Graph Options | Window Background | Legend Background Color - color-for-legend-background (color)
  Visual Graph Options | Window Background | Background Pixmap - background-pixmap-source (file)
  Visual Graph Options | Window Background | Show Background Pixmap (if any) - show-background-pixmap (boolean)
  Visual Graph Options | Window Background | Stretch Background Pixmap - stretch-background-pixmap (boolean)
  Visual Graph Options | Window Background | Graphical Query View Background Color - color-for-graphical-query-background (color)
  Visual Graph Options | Node Border Color - node-border-color (color)
  Help | Use Web Browser for Menu Help - use-web-browser-for-menu-help (boolean)
  Help | Show Warnings in Dialogs - show-warnings-in-dialog (boolean)
  Help | Show Quick Start on Startup - show-quick-start-on-startup (boolean)
*** acl90						    :lisp:prolog:rdf:
/archive/xk05/acl90/doc/
Location: file:///archive/xk05/acl90/doc/prolog.html                          
ToC DocOverview CGDoc RelNotes Index PermutedIndex     Allegro CL version 8.0
                                                                   New in 7.0
*** xslt						   :parser:rdf:debug:
**** XSLT w3-rec
#+begin_src xslt
<!-- Category: instruction -->
<xsl:copy
  copy-namespaces? = "yes" | "no"
  inherit-namespaces? = "yes" | "no"
  use-attribute-sets? = qnames
  type? = qname
  validation? = "strict" | "lax" | "preserve" | "strip">
  <!-- Content: sequence-constructor -->
</xsl:copy>
#+end_src
Abstract

This specification defines the syntax and semantics of XSLT 2.0, a language
for transforming XML documents into other XML documents.

XSLT 2.0 is a revised version of the XSLT 1.0 Recommendation [XSLT 1.0]
published on 16 November 1999.

XSLT 2.0 is designed to be used in conjunction with XPath 2.0, which is
defined in [XPath 2.0]. XSLT shares the same data model as XPath 2.0, which is
defined in [Data Model], and it uses the library of functions and operators
defined in [Functions and Operators].

XSLT 2.0 also includes optional facilities to serialize the results of a
transformation, by means of an interface to the serialization component
described in [XSLT and XQuery Serialization].

This document contains hyperlinks to specific sections or definitions within
other documents in this family of specifications. These links are indicated
visually by a superscript identifying the target specification: for example XP
for XPath, DM for the XDM data model, FO for Functions and Operators.

Status of this Document

This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current
W3C publications and the latest revision of this technical report can be found
in the W3C technical reports index at http://www.w3.org/TR/.

This Recommendation builds on the success of [XSLT 1.0], which was published
on 16 November 1999. Many new features have been added to the language (see 
J.2 New Functionality) while retaining a high level of backwards compatibility
(see J.1 Incompatible Changes). The changes have been designed to meet the
requirements for XSLT 2.0 described in [XSLT 2.0 Requirements]. The way in
which each requirement has been addressed is outlined in I Checklist of
Requirements.

XSLT 2.0 depends on a number of other specifications that have progressed to
Recommendation status at the same time: see [XPath 2.0], [Data Model], 
[Functions and Operators], and [XSLT and XQuery Serialization]. These
subsidiary documents are also referenced in the specification of XQuery 1.0.

This document has been produced by the XSL Working Group, which is part of the
XML Activity. The document has been reviewed by W3C Members and other
interested parties, and is endorsed by the Director. It is a stable document
and may be used as reference material or cited as a normative reference from
another document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This enhances
the functionality and interoperability of the Web.

A small number of editorial corrections and clarifications have been made to
the document since it was published as a Proposed Recommendation on 21
November 2006. These changes are listed at J.2.4 Changes since Proposed
Recommendation.

Please record any comments about this document in W3C's public Bugzilla system
(instructions can be found at http://www.w3.org/XML/2005/04/qt-bugzilla). If
access to that system is not feasible, you may send your comments to the W3C
XSLT/XPath/XQuery public comments mailing list, public-qt-comments@w3.org. It
is helpful to include the string [XSLT] in the subject line of your comment,
whether made in Bugzilla or in email. Each Bugzilla entry and email message
should contain only one comment. Archives of the comments and responses are
available at http://lists.w3.org/Archives/Public/public-qt-comments/.

General public discussion of XSLT takes place on the XSL-List forum.

This document was produced by a group operating under the 5 February 2004 W3C
Patent Policy. W3C maintains a public list of any patent disclosures made in
connection with the deliverables of the group; that page also includes
instructions for disclosing a patent. An individual who has actual knowledge
of a patent which the individual believes contains Essential Claim(s) must
disclose the information in accordance with section 6 of the W3C Patent Policy
.

Table of Contents

1 Introduction
    1.1 What is XSLT?
    1.2 What's New in XSLT 2.0?
2 Concepts
    2.1 Terminology
    2.2 Notation
    2.3 Initiating a Transformation
    2.4 Executing a Transformation
    2.5 The Evaluation Context
    2.6 Parsing and Serialization
    2.7 Extensibility
    2.8 Stylesheets and XML Schemas
    2.9 Error Handling
3 Stylesheet Structure
    3.1 XSLT Namespace
    3.2 Reserved Namespaces
    3.3 Extension Attributes
    3.4 XSLT Media Type
    3.5 Standard Attributes
    3.6 Stylesheet Element
        3.6.1 The default-collation attribute
        3.6.2 User-defined Data Elements
    3.7 Simplified Stylesheet Modules
    3.8 Backwards-Compatible Processing
    3.9 Forwards-Compatible Processing
    3.10 Combining Stylesheet Modules
        3.10.1 Locating Stylesheet Modules
        3.10.2 Stylesheet Inclusion
        3.10.3 Stylesheet Import
    3.11 Embedded Stylesheet Modules
    3.12 Conditional Element Inclusion
    3.13 Built-in Types
    3.14 Importing Schema Components
4 Data Model
    4.1 XML Versions
    4.2 Stripping Whitespace from the Stylesheet
    4.3 Stripping Type Annotations from a Source Tree
    4.4 Stripping Whitespace from a Source Tree
    4.5 Attribute Types and DTD Validation
    4.6 Limits
    4.7 Disable Output Escaping
5 Features of the XSLT Language
    5.1 Qualified Names
    5.2 Unprefixed QNames in Expressions and Patterns
    5.3 Expressions
    5.4 The Static and Dynamic Context
        5.4.1 Initializing the Static Context
        5.4.2 Additional Static Context Components used by XSLT
        5.4.3 Initializing the Dynamic Context
            5.4.3.1 Maintaining Position: the Focus
            5.4.3.2 Other components of the XPath Dynamic Context
        5.4.4 Additional Dynamic Context Components used by XSLT
    5.5 Patterns
        5.5.1 Examples of Patterns
        5.5.2 Syntax of Patterns
        5.5.3 The Meaning of a Pattern
        5.5.4 Errors in Patterns
    5.6 Attribute Value Templates
    5.7 Sequence Constructors
        5.7.1 Constructing Complex Content
        5.7.2 Constructing Simple Content
        5.7.3 Namespace Fixup
    5.8 URI References
6 Template Rules
    6.1 Defining Templates
    6.2 Defining Template Rules
    6.3 Applying Template Rules
    6.4 Conflict Resolution for Template Rules
    6.5 Modes
    6.6 Built-in Template Rules
    6.7 Overriding Template Rules
7 Repetition
8 Conditional Processing
    8.1 Conditional Processing with xsl:if
    8.2 Conditional Processing with xsl:choose
9 Variables and Parameters
    9.1 Variables
    9.2 Parameters
    9.3 Values of Variables and Parameters
    9.4 Creating implicit document nodes
    9.5 Global Variables and Parameters
    9.6 Local Variables and Parameters
    9.7 Scope of Variables
    9.8 Circular Definitions
10 Callable Components
    10.1 Named Templates
        10.1.1 Passing Parameters to Templates
        10.1.2 Tunnel Parameters
    10.2 Named Attribute Sets
    10.3 Stylesheet Functions
11 Creating Nodes and Sequences
    11.1 Literal Result Elements
        11.1.1 Setting the Type Annotation for Literal Result Elements
        11.1.2 Attribute Nodes for Literal Result Elements
        11.1.3 Namespace Nodes for Literal Result Elements
        11.1.4 Namespace Aliasing
    11.2 Creating Element Nodes Using xsl:element
        11.2.1 Setting the Type Annotation for a Constructed Element Node
    11.3 Creating Attribute Nodes Using xsl:attribute
        11.3.1 Setting the Type Annotation for a Constructed Attribute Node
    11.4 Creating Text Nodes
        11.4.1 Literal Text Nodes
        11.4.2 Creating Text Nodes Using xsl:text
        11.4.3 Generating Text with xsl:value-of
    11.5 Creating Document Nodes
    11.6 Creating Processing Instructions
    11.7 Creating Namespace Nodes
    11.8 Creating Comments
    11.9 Copying Nodes
        11.9.1 Shallow Copy
        11.9.2 Deep Copy
    11.10 Constructing Sequences
12 Numbering
    12.1 Formatting a Supplied Number
    12.2 Numbering based on Position in a Document
    12.3 Number to String Conversion Attributes
13 Sorting
    13.1 The xsl:sort Element
        13.1.1 The Sorting Process
        13.1.2 Comparing Sort Key Values
        13.1.3 Sorting Using Collations
    13.2 Creating a Sorted Sequence
    13.3 Processing a Sequence in Sorted Order
14 Grouping
    14.1 The Current Group
    14.2 The Current Grouping Key
    14.3 The xsl:for-each-group Element
    14.4 Examples of Grouping
15 Regular Expressions
    15.1 The xsl:analyze-string instruction
    15.2 Captured Substrings
    15.3 Examples of Regular Expression Matching
16 Additional Functions
    16.1 Multiple Source Documents
    16.2 Reading Text Files
    16.3 Keys
        16.3.1 The xsl:key Declaration
        16.3.2 The key Function
    16.4 Number Formatting
        16.4.1 Defining a Decimal Format
        16.4.2 Processing the Picture String
        16.4.3 Analysing the Picture String
        16.4.4 Formatting the Number
    16.5 Formatting Dates and Times
        16.5.1 The Picture String
        16.5.2 The Language, Calendar, and Country Arguments
        16.5.3 Examples of Date and Time Formatting
    16.6 Miscellaneous Additional Functions
        16.6.1 current
        16.6.2 unparsed-entity-uri
        16.6.3 unparsed-entity-public-id
        16.6.4 generate-id
        16.6.5 system-property
17 Messages
18 Extensibility and Fallback
    18.1 Extension Functions
        18.1.1 Testing Availability of Functions
        18.1.2 Calling Extension Functions
        18.1.3 External Objects
        18.1.4 Testing Availability of Types
    18.2 Extension Instructions
        18.2.1 Designating an Extension Namespace
        18.2.2 Testing Availability of Instructions
        18.2.3 Fallback
19 Final Result Trees
    19.1 Creating Final Result Trees
    19.2 Validation
        19.2.1 Validating Constructed Elements and Attributes
            19.2.1.1 Validation using the [xsl:]validation Attribute
            19.2.1.2 Validation using the [xsl:]type Attribute
            19.2.1.3 The Validation Process
        19.2.2 Validating Document Nodes
20 Serialization
    20.1 Character Maps
    20.2 Disabling Output Escaping
21 Conformance
    21.1 Basic XSLT Processor
    21.2 Schema-Aware XSLT Processor
    21.3 Serialization Feature
    21.4 Backwards Compatibility Feature

Appendices

A References
    A.1 Normative References
    A.2 Other References
B The XSLT Media Type
    B.1 Registration of MIME Media Type application/xslt+xml
    B.2 Fragment Identifiers
C Glossary (Non-Normative)
D Element Syntax Summary (Non-Normative)
E Summary of Error Conditions (Non-Normative)
F Checklist of Implementation-Defined Features (Non-Normative)
G Schema for XSLT Stylesheets (Non-Normative)
H Acknowledgements (Non-Normative)
I Checklist of Requirements (Non-Normative)
J Changes from XSLT 1.0 (Non-Normative)
    J.1 Incompatible Changes
        J.1.1 Tree construction: whitespace stripping
        J.1.2 Changes in Serialization Behavior
        J.1.3 Backwards Compatibility Behavior
        J.1.4 Incompatibility in the Absence of a Schema
        J.1.5 Compatibility in the Presence of a Schema
        J.1.6 XPath 2.0 Backwards Compatibility
    J.2 New Functionality
        J.2.1 Pervasive changes
        J.2.2 Major Features
        J.2.3 Minor Changes
        J.2.4 Changes since Proposed Recommendation

------------------------------------------------------------------------------

1 Introduction

1.1 What is XSLT?

This specification defines the syntax and semantics of the XSLT 2.0 language.

[Definition: A transformation in the XSLT language is expressed in the form of
a stylesheet, whose syntax is well-formed XML [XML 1.0] conforming to the
Namespaces in XML Recommendation [Namespaces in XML 1.0].]

A stylesheet generally includes elements that are defined by XSLT as well as
elements that are not defined by XSLT. XSLT-defined elements are distinguished
by use of the namespace http://www.w3.org/1999/XSL/Transform (see 3.1 XSLT
Namespace), which is referred to in this specification as the XSLT namespace.
Thus this specification is a definition of the syntax and semantics of the
XSLT namespace.

The term stylesheet reflects the fact that one of the important roles of XSLT
is to add styling information to an XML source document, by transforming it
into a document consisting of XSL formatting objects (see [Extensible
Stylesheet Language (XSL)]), or into another presentation-oriented format such
as HTML, XHTML, or SVG. However, XSLT is used for a wide range of
transformation tasks, not exclusively for formatting and presentation
applications.

A transformation expressed in XSLT describes rules for transforming zero or
more source trees into one or more result trees. The structure of these trees
is described in [Data Model]. The transformation is achieved by a set of 
template rules. A template rule associates a pattern, which matches nodes in
the source document, with a sequence constructor. In many cases, evaluating
the sequence constructor will cause new nodes to be constructed, which can be
used to produce part of a result tree. The structure of the result trees can
be completely different from the structure of the source trees. In
constructing a result tree, nodes from the source trees can be filtered and
reordered, and arbitrary structure can be added. This mechanism allows a 
stylesheet to be applicable to a wide class of documents that have similar
source tree structures.

[Definition: A stylesheet may consist of several stylesheet modules, contained
in different XML documents. For a given transformation, one of these functions
as the principal stylesheet module. The complete stylesheet is assembled by
finding the stylesheet modules referenced directly or indirectly from the
principal stylesheet module using xsl:include and xsl:import elements: see 
3.10.2 Stylesheet Inclusion and 3.10.3 Stylesheet Import.]

1.2 What's New in XSLT 2.0?

XSLT 1.0 was published in November 1999, and version 2.0 represents a
significant increase in the capability of the language. A detailed list of
changes is included in J Changes from XSLT 1.0. XSLT 2.0 has been developed in
parallel with XPath 2.0 (see [XPath 2.0]), so the changes to XPath must be
considered alongside the changes to XSLT.

2 Concepts

2.1 Terminology

For a full glossary of terms, see C Glossary.

[Definition: The software responsible for transforming source trees into
result trees using an XSLT stylesheet is referred to as the processor. This is
sometimes expanded to XSLT processor to avoid any confusion with other
processors, for example an XML processor.]

[Definition: A specific product that performs the functions of an XSLT
processor is referred to as an implementation ].

[Definition: The term result tree is used to refer to any tree constructed by 
instructions in the stylesheet. A result tree is either a final result tree or
a temporary tree.]

[Definition: A final result tree is a result tree that forms part of the final
output of a transformation. Once created, the contents of a final result tree
are not accessible within the stylesheet itself.] The xsl:result-document
instruction always creates a final result tree, and a final result tree may
also be created implicitly by the initial template. The conditions under which
this happens are described in 2.4 Executing a Transformation. A final result
tree may be serialized as described in 20 Serialization.

[Definition: The term source tree means any tree provided as input to the
transformation. This includes the document containing the initial context node
if any, documents containing nodes supplied as the values of stylesheet
parameters, documents obtained from the results of functions such as document,
doc^ FO, and collection^FO, and documents returned by extension functions or
extension instructions. In the context of a particular XSLT instruction, the
term source tree means any tree provided as input to that instruction; this
may be a source tree of the transformation as a whole, or it may be a 
temporary tree produced during the course of the transformation.]

[Definition: The term temporary tree means any tree that is neither a source
tree nor a final result tree.] Temporary trees are used to hold intermediate
results during the execution of the transformation.

In this specification the phrases must, must not, should, should not, may, 
required, and recommended are to be interpreted as described in [RFC2119].

Where the phrase must, must not, or required relates to the behavior of the
XSLT processor, then an implementation is not conformant unless it behaves as
specified, subject to the more detailed rules in 21 Conformance.

Where the phrase must, must not, or required relates to a stylesheet, then the
processor must enforce this constraint on stylesheets by reporting an error if
the constraint is not satisfied.

Where the phrase should, should not, or recommended relates to a stylesheet,
then a processor may produce warning messages if the constraint is not
satisfied, but must not treat this as an error.

[Definition: In this specification, the term implementation-defined refers to
a feature where the implementation is allowed some flexibility, and where the
choices made by the implementation must be described in documentation that
accompanies any conformance claim.]

[Definition: The term implementation-dependent refers to a feature where the
behavior may vary from one implementation to another, and where the vendor is
not expected to provide a full specification of the behavior.] (This might
apply, for example, to limits on the size of source documents that can be
transformed.)

In all cases where this specification leaves the behavior
implementation-defined or implementation-dependent, the implementation has the
option of providing mechanisms that allow the user to influence the behavior.

A paragraph labeled as a Note or described as an example is non-normative.

Many terms used in this document are defined in the XPath specification [XPath
2.0] or the XDM specification [Data Model]. Particular attention is drawn to
the following:

  * [Definition: The term atomization is defined in Section 2.4.2 Atomization^
    XP. It is a process that takes as input a sequence of nodes and atomic
    values, and returns a sequence of atomic values, in which the nodes are
    replaced by their typed values as defined in [Data Model].] For some nodes
    (for example, elements with element-only content), atomization generates a
    dynamic error.
   
  * [Definition: The term typed value is defined in Section 5.15 typed-value
    Accessor^DM. Every node except an element defined in the schema with
    element-only content has a typed value. For example, the typed value of an
    attribute of type xs:IDREFS is a sequence of zero or more xs:IDREF values.
    ]
   
  * [Definition: The term string value is defined in Section 5.13 string-value
    Accessor^DM. Every node has a string value. For example, the string value
    of an element is the concatenation of the string values of all its
    descendant text nodes.]
   
  * [Definition: The term XPath 1.0 compatibility mode is defined in Section
    2.1.1 Static Context^XP. This is a setting in the static context of an
    XPath expression; it has two values, true and false. When the value is set
    to true, the semantics of function calls and certain other operations are
    adjusted to give a greater degree of backwards compatibility between XPath
    2.0 and XPath 1.0.]
   
[Definition: The term core function means a function that is specified in 
[Functions and Operators] and that is in the standard function namespace.]

2.2 Notation

[Definition: An XSLT element is an element in the XSLT namespace whose syntax
and semantics are defined in this specification.] For a non-normative list of
XSLT elements, see D Element Syntax Summary.

In this document the specification of each XSLT element is preceded by a
summary of its syntax in the form of a model for elements of that element
type. A full list of all these specifications can be found in D Element Syntax
Summary. The meaning of syntax summary notation is as follows:

  * An attribute that is required is shown with its name in bold. An attribute
    that may be omitted is shown with a question mark following its name.
   
  * An attribute that is deprecated is shown in a grayed font within square
    brackets.
   
  * The string that occurs in the place of an attribute value specifies the
    allowed values of the attribute. If this is surrounded by curly brackets
    ({...}), then the attribute value is treated as an attribute value
    template, and the string occurring within curly brackets specifies the
    allowed values of the result of evaluating the attribute value template.
    Alternative allowed values are separated by |. A quoted string indicates a
    value equal to that specific string. An unquoted, italicized name
    specifies a particular type of value.
   
    In all cases where this specification states that the value of an
    attribute must be one of a limited set of values, leading and trailing
    whitespace in the attribute value is ignored. In the case of an attribute
    value template, this applies to the effective value obtained when the
    attribute value template is expanded.
   
  * Unless the element is required to be empty, the model element contains a
    comment specifying the allowed content. The allowed content is specified
    in a similar way to an element type declaration in XML; sequence
    constructor means that any mixture of text nodes, literal result elements,
    extension instructions, and XSLT elements from the instruction category is
    allowed; other-declarations means that any mixture of XSLT elements from
    the declaration category, other than xsl:import, is allowed, together with
    user-defined data elements.
   
  * The element is prefaced by comments indicating if it belongs to the
    instruction category or declaration category or both. The category of an
    element only affects whether it is allowed in the content of elements that
    allow a sequence constructor or other-declarations.
   
Example: Syntax Notation

This example illustrates the notation used to describe XSLT elements.

<!-- Category: instruction -->
<xsl:example-element
  select = expression
  debug? = { "yes" | "no" }>
  <!-- Content: ((xsl:variable | xsl:param)*, xsl:sequence) -->
</xsl:example-element>

This example defines a (non-existent) element xsl:example-element. The element
is classified as an instruction. It takes a mandatory select attribute, whose
value is an XPath expression, and an optional debug attribute, whose value 
must be either yes or no; the curly brackets indicate that the value can be
defined as an attribute value template, allowing a value such as debug="
{$debug}", where the variable debug is evaluated to yield "yes" or "no" at
run-time.

The content of an xsl:example-element instruction is defined to be a sequence
of zero or more xsl:variable and xsl:param elements, followed by an 
xsl:sequence element.

[ERR XTSE0010] A static error is signaled if an XSLT-defined element is used
in a context where it is not permitted, if a required attribute is omitted, or
if the content of the element does not correspond to the content that is
allowed for the element.

Attributes are validated as follows. These rules apply to the value of the
attribute after removing leading and trailing whitespace.

  * [ERR XTSE0020] It is a static error if an attribute (other than an
    attribute written using curly brackets in a position where an attribute
    value template is permitted) contains a value that is not one of the
    permitted values for that attribute.
   
  * [ERR XTDE0030] It is a non-recoverable dynamic error if the effective
    value of an attribute written using curly brackets, in a position where an
    attribute value template is permitted, is a value that is not one of the
    permitted values for that attribute. If the processor is able to detect
    the error statically (for example, when any XPath expressions within the
    curly brackets can be evaluated statically), then the processor may
    optionally signal this as a static error.
   
Special rules apply if the construct appears in part of the stylesheet that is
processed with forwards-compatible behavior: see 3.9 Forwards-Compatible
Processing.

[Definition: Some constructs defined in this specification are described as
being deprecated. The use of this term implies that stylesheet authors should
not use the construct, and that the construct may be removed in a later
version of this specification.] All constructs that are deprecated in this
specification are also (as it happens) optional features that implementations
are not required to provide.

Note:

This working draft includes a non-normative XML Schema for XSLT stylesheet
modules (see G Schema for XSLT Stylesheets). The syntax summaries described in
this section are normative.

XSLT defines a set of standard functions which are additional to those defined
in [Functions and Operators]. The signatures of these functions are described
using the same notation as used in [Functions and Operators]. The names of
these functions are all in the standard function namespace.

2.3 Initiating a Transformation

This document does not specify any application programming interfaces or other
interfaces for initiating a transformation. This section, however, describes
the information that is supplied when a transformation is initiated. Except
where otherwise indicated, the information is required.

Implementations may allow a transformation to run as two or more phases, for
example parsing, compilation and execution. Such a distinction is outside the
scope of this specification, which treats transformation as a single process
controlled using a set of stylesheet modules, supplied in the form of XML
documents.

The following information is supplied to execute a transformation:

  * The stylesheet module that is to act as the principal stylesheet module
    for the transformation. The complete stylesheet is assembled by
    recursively expanding the xsl:import and xsl:include declarations in the
    principal stylesheet module, as described in 3.10.2 Stylesheet Inclusion
    and 3.10.3 Stylesheet Import.
   
  * A set (possibly empty) of values for stylesheet parameters (see 9.5 Global
    Variables and Parameters). These values are available for use within 
    expressions in the stylesheet.
   
  * [Definition: A node that acts as the initial context node for the
    transformation. This node is accessible within the stylesheet as the
    initial value of the XPath expressions . (dot) and self::node(), as
    described in 5.4.3.1 Maintaining Position: the Focus].
   
    If no initial context node is supplied, then the context item, context
    position, and context size will initially be undefined, and the evaluation
    of any expression that references these values will result in a dynamic
    error. (Note that the initial context size and context position will
    always be 1 (one) when an initial context node is supplied, and will be
    undefined if no initial context node is supplied).
   
  * Optionally, the name of a named template which is to be executed as the
    entry point to the transformation. This template must exist within the 
    stylesheet. If no named template is supplied, then the transformation
    starts with the template rule that best matches the initial context node,
    according to the rules defined in 6.4 Conflict Resolution for Template
    Rules. Either a named template, or an initial context node, or both, must
    be supplied.
   
  * Optionally, an initial mode. This must either be the default mode, or a
    mode that is explicitly named in the mode attribute of an xsl:template
    declaration within the stylesheet. If an initial mode is supplied, then in
    searching for the template rule that best matches the initial context node
    , the processor considers only those rules that apply to the initial mode.
    If no initial mode is supplied, the default mode is used.
   
  * A base output URI. [Definition:  The base output URI is a URI to be used
    as the base URI when resolving a relative URI allocated to a final result
    tree. If the transformation generates more than one final result tree,
    then typically each one will be allocated a URI relative to this base URI.
    ] The way in which a base output URI is established is 
    implementation-defined.
   
  * A mechanism for obtaining a document node and a media type, given an
    absolute URI. The total set of available documents (modeled as a mapping
    from URIs to document nodes) forms part of the context for evaluating
    XPath expressions, specifically the doc^ FO function. The XSLT document
    function additionally requires the media type of the resource
    representation, for use in interpreting any fragment identifier present
    within a URI Reference.
   
    Note:
   
    The set of documents that are available to the stylesheet is 
    implementation-dependent, as is the processing that is carried out to
    construct a tree representing the resource retrieved using a given URI.
    Some possible ways of constructing a document (specifically, rules for
    constructing a document from an Infoset or from a PSVI) are described in 
    [Data Model].
   
[ERR XTDE0040] It is a non-recoverable dynamic error if the invocation of the 
stylesheet specifies a template name that does not match the expanded-QName of
a named template defined in the stylesheet.

[ERR XTDE0045] It is a non-recoverable dynamic error if the invocation of the 
stylesheet specifies an initial mode (other than the default mode) that does
not match the expanded-QName in the mode attribute of any template defined in
the stylesheet.

[ERR XTDE0047] It is a non-recoverable dynamic error if the invocation of the 
stylesheet specifies both an initial mode and an initial template.

[ERR XTDE0050] It is a non-recoverable dynamic error if the stylesheet that is
invoked declares a visible stylesheet parameter with required="yes" and no
value for this parameter is supplied during the invocation of the stylesheet.
A stylesheet parameter is visible if it is not masked by another global
variable or parameter with the same name and higher import precedence.

[Definition: The transformation is performed by evaluating an initial template
. If a named template is supplied when the transformation is initiated, then
this is the initial template; otherwise, the initial template is the template
rule selected according to the rules of the xsl:apply-templates instruction
for processing the initial context node in the initial mode.]

Parameters passed to the transformation by the client application are matched
against stylesheet parameters (see 9.5 Global Variables and Parameters), not
against the template parameters declared within the initial template. All 
template parameters within the initial template to be executed will take their
default values.

[ERR XTDE0060] It is a non-recoverable dynamic error if the initial template
defines a template parameter that specifies required="yes".

A stylesheet can process further source documents in addition to those
supplied when the transformation is invoked. These additional documents can be
loaded using the functions document (see 16.1 Multiple Source Documents) or 
doc^ FO or collection^FO (see [Functions and Operators]), or they can be
supplied as stylesheet parameters (see 9.5 Global Variables and Parameters),
or as the result of an extension function (see 18.1 Extension Functions).

2.4 Executing a Transformation

[Definition: A stylesheet contains a set of template rules (see 6 Template
Rules). A template rule has three parts: a pattern that is matched against
nodes, a (possibly empty) set of template parameters, and a sequence
constructor that is evaluated to produce a sequence of items.] In many cases
these items are newly constructed nodes, which are then written to a result
tree.

A transformation as a whole is executed by evaluating the sequence constructor
of the initial template as described in 5.7 Sequence Constructors.

If the initial template has an as attribute, then the result sequence of the
initial template is checked against the required type in the same way as for
any other template. If this result sequence is non-empty, then it is used to
construct an implicit final result tree, following the rules described in 
5.7.1 Constructing Complex Content: the effect is as if the initial template T
were called by an implicit template of the form:

<xsl:template name="IMPLICIT">
  <xsl:result-document href="">
    <xsl:call-template name="T"/>
  </xsl:result-document>
</xsl:template>

An implicit result tree is also created when the result sequence is empty,
provided that no xsl:result-document instruction has been evaluated during the
course of the transformation. In this situation the implicit result tree will
consist of a document node with no children.

Note:

This means that there is always at least one result tree. It also means that
if the content of the initial template is a single xsl:result-document
instruction, as in the example above, then only one result tree is produced,
not two. It is useful to make the result document explicit as this is the only
way of invoking document-level validation.

If the result of the initial template is non-empty, and an explicit 
xsl:result-document instruction has been evaluated with the empty attribute
href="", then an error will occur [see ERR XTDE1490], since it is not possible
to create two final result trees with the same URI.

A sequence constructor is a sequence of sibling nodes in the stylesheet, each
of which is either an XSLT instruction, a literal result element, a text node,
or an extension instruction.

[Definition: An instruction is either an XSLT instruction or an extension
instruction.]

[Definition: An XSLT instruction is an XSLT element whose syntax summary in
this specification contains the annotation <!-- category: instruction -->.]

Extension instructions are described in 18.2 Extension Instructions.

The main categories of XSLT instruction are as follows:

  * instructions that create new nodes: xsl:document, xsl:element, 
    xsl:attribute, xsl:processing-instruction, xsl:comment, xsl:value-of, 
    xsl:text, xsl:namespace;
   
  * an instruction that returns an arbitrary sequence by evaluating an XPath
    expression: xsl:sequence;
   
  * instructions that cause conditional or repeated evaluation of nested
    instructions: xsl:if, xsl:choose, xsl:for-each, xsl:for-each-group;
   
  * instructions that invoke templates: xsl:apply-templates, xsl:apply-imports
    , xsl:call-template, xsl:next-match;
   
  * Instructions that declare variables: xsl:variable, xsl:param;
   
  * other specialized instructions: xsl:number, xsl:analyze-string, 
    xsl:message, xsl:result-document.
   
Often, a sequence constructor will include an xsl:apply-templates instruction,
which selects a sequence of nodes to be processed. Each of the selected nodes
is processed by searching the stylesheet for a matching template rule and
evaluating the sequence constructor of that template rule. The resulting
sequences of items are concatenated, in order, to give the result of the 
xsl:apply-templates instruction, as described in 6.3 Applying Template Rules;
this sequence is often added to a result tree. Since the sequence constructors
of the selected template rules may themselves contain xsl:apply-templates
instructions, this results in a cycle of selecting nodes, identifying template
rules, constructing sequences, and constructing result trees, that recurses
through a source tree.

2.5 The Evaluation Context

The results of some expressions and instructions in a stylesheet may depend on
information provided contextually. This context information is divided into
two categories: the static context, which is known during static analysis of
the stylesheet, and the dynamic context, which is not known until the
stylesheet is evaluated. Although information in the static context is known
at analysis time, it is sometimes used during stylesheet evaluation.

Some context information can be set by means of declarations within the
stylesheet itself. For example, the namespace bindings used for any XPath
expression are determined by the namespace declarations present in containing
elements in the stylesheet. Other information may be supplied externally or
implicitly: an example is the current date and time.

The context information used in processing an XSLT stylesheet includes as a
subset all the context information required when evaluating XPath expressions.
The XPath 2.0 specification defines a static and dynamic context that the host
language (in this case, XSLT) may initialize, which affects the results of
XPath expressions used in that context. XSLT augments the context with
additional information: this additional information is used firstly by XSLT
constructs outside the scope of XPath (for example, the xsl:sort element), and
secondly, by functions that are defined in the XSLT specification (such as key
and format-number) that are available for use in XPath expressions appearing
within a stylesheet.

The static context for an expression or other construct in a stylesheet is
determined by the place in which it appears lexically. The details vary for
different components of the static context, but in general, elements within a
stylesheet module affect the static context for their descendant elements
within the same stylesheet module.

The dynamic context is maintained as a stack. When an instruction or
expression is evaluated, it may add dynamic context information to the stack;
when evaluation is complete, the dynamic context reverts to its previous
state. An expression that accesses information from the dynamic context always
uses the value at the top of the stack.

The most commonly used component of the dynamic context is the context item.
This is an implicit variable whose value is the item (it may be a node or an
atomic value) currently being processed. The value of the context item can be
referenced within an XPath expression using the expression . (dot).

Full details of the static and dynamic context are provided in 5.4 The Static
and Dynamic Context.

2.6 Parsing and Serialization

An XSLT stylesheet describes a process that constructs a set of final result
trees from a set of source trees.

The stylesheet does not describe how a source tree is constructed. Some
possible ways of constructing source trees are described in [Data Model].
Frequently an implementation will operate in conjunction with an XML parser
(or more strictly, in the terminology of [XML 1.0], an XML processor), to
build a source tree from an input XML document. An implementation may also
provide an application programming interface allowing the tree to be
constructed directly, or allowing it to be supplied in the form of a DOM
Document object (see [DOM Level 2]). This is outside the scope of this
specification. Users should be aware, however, that since the input to the
transformation is a tree conforming to the XDM data model as described in 
[Data Model], constructs that might exist in the original XML document, or in
the DOM, but which are not within the scope of the data model, cannot be
processed by the stylesheet and cannot be guaranteed to remain unchanged in
the transformation output. Such constructs include CDATA section boundaries,
the use of entity references, and the DOCTYPE declaration and internal DTD
subset.

[Definition: A frequent requirement is to output a final result tree as an XML
document (or in other formats such as HTML). This process is referred to as 
serialization.]

Like parsing, serialization is not part of the transformation process, and it
is not required that an XSLT processor must be able to perform serialization.
However, for pragmatic reasons, this specification describes declarations (the
xsl:output element and the xsl:character-map declarations, see 20
Serialization), and attributes on the xsl:result-document instruction, that
allow a stylesheet to specify the desired properties of a serialized output
file. When serialization is not being performed, either because the
implementation does not support the serialization option, or because the user
is executing the transformation in a way that does not invoke serialization,
then the content of the xsl:output and xsl:character-map declarations has no
effect. Under these circumstances the processor may report any errors in an 
xsl:output or xsl:character-map declaration, or in the serialization
attributes of xsl:result-document, but is not required to do so.

2.7 Extensibility

XSLT defines a number of features that allow the language to be extended by
implementers, or, if implementers choose to provide the capability, by users.
These features have been designed, so far as possible, so that they can be
used without sacrificing interoperability. Extensions other than those
explicitly defined in this specification are not permitted.

These features are all based on XML namespaces; namespaces are used to ensure
that the extensions provided by one implementer do not clash with those of a
different implementer.

The most common way of extending the language is by providing additional
functions, which can be invoked from XPath expressions. These are known as 
extension functions, and are described in 18.1 Extension Functions.

It is also permissible to extend the language by providing new instructions.
These are referred to as extension instructions, and are described in 18.2
Extension Instructions. A stylesheet that uses extension instructions must
declare that it is doing so by using the [xsl:]extension-element-prefixes
attribute.

Extension instructions and extension functions defined according to these
rules may be provided by the implementer of the XSLT processor, and the
implementer may also provide facilities to allow users to create further
extension instructions and extension functions.

This specification defines how extension instructions and extension functions
are invoked, but the facilities for creating new extension instructions and
extension functions are implementation-defined. For further details, see 18
Extensibility and Fallback.

The XSLT language can also be extended by the use of extension attributes (see
3.3 Extension Attributes), and by means of user-defined data elements (see 
3.6.2 User-defined Data Elements).

2.8 Stylesheets and XML Schemas

An XSLT stylesheet can make use of information from a schema. An XSLT
transformation can take place in the absence of a schema (and, indeed, in the
absence of a DTD), but where the source document has undergone schema validity
assessment, the XSLT processor has access to the type information associated
with individual nodes, not merely to the untyped text.

Information from a schema can be used both statically (when the stylesheet is
compiled), and dynamically (during evaluation of the stylesheet to transform a
source document).

There are places within a stylesheet, and within XPath expressions and 
patterns in a stylesheet, where it is possible to refer to named type
definitions in a schema, or to element and attribute declarations. For
example, it is possible to declare the types expected for the parameters of a
function. This is done using the SequenceType^ XP syntax defined in [XPath
2.0].

[Definition: Type definitions and element and attribute declarations are
referred to collectively as schema components.]

[Definition: The schema components that may be referenced by name in a 
stylesheet are referred to as the in-scope schema components. This set is the
same throughout all the modules of a stylesheet.]

The conformance rules for XSLT 2.0, defined in 21 Conformance, distinguish
between a basic XSLT processor and a schema-aware XSLT processor. As the names
suggest, a basic XSLT processor does not support the features of XSLT that
require access to schema information, either statically or dynamically. A 
stylesheet that works with a basic XSLT processor will produce the same
results with a schema-aware XSLT processor provided that the source documents
are untyped (that is, they are not validated against a schema). However, if
source documents are validated against a schema then the results may be
different from the case where they are not validated. Some constructs that
work on untyped data may fail with typed data (for example, an attribute of
type xs:date cannot be used as an argument of the substring^FO function) and
other constructs may produce different results depending on the data type (for
example, given the element <product price="10.00" discount="2.00"/>, the
expression @price gt @discount will return true if the attributes have type
xs:decimal, but will return false if they are untyped).

There is a standard set of type definitions that are always available as 
in-scope schema components in every stylesheet. These are defined in 3.13
Built-in Types. The set of built-in types varies between a basic XSLT
processor and a schema-aware XSLT processor.

The remainder of this section describes facilities that are available only
with a schema-aware XSLT processor.

Additional schema components (type definitions, element declarations, and
attribute declarations) may be added to the in-scope schema components by
means of the xsl:import-schema declaration in a stylesheet.

The xsl:import-schema declaration may reference an external schema document by
means of a URI, or it may contain an inline xs:schema element.

It is only necessary to import a schema explicitly if one or more of its 
schema components are referenced explicitly by name in the stylesheet; it is
not necessary to import a schema merely because the stylesheet is used to
process a source document that has been assessed against that schema. It is
possible to make use of the information resulting from schema assessment (for
example, the fact that a particular attribute holds a date) even if no schema
has been imported by the stylesheet.

Further, importing a schema does not of itself say anything about the type of
the source document that the stylesheet is expected to process. The imported
type definitions can be used for temporary nodes or for nodes on a result tree
just as much as for nodes in source documents. It is possible to make
assertions about the type of an input document by means of tests within the 
stylesheet. For example:

Example: Asserting the Required Type of the Source Document

<xsl:template match="document-node(schema-element(my:invoice))" priority="2">
. . .
</xsl:template>

<xsl:template match="document-node()" priority="1">
  <xsl:message terminate="yes">Source document is not an invoice</xsl:message>
</xsl:template>

This example will cause the transformation to fail with an error message
unless the document element of the source document is valid against the
top-level element declaration my:invoice, and has been annotated as such.

It is possible that a source document may contain nodes whose type annotation
is not one of the types imported by the stylesheet. This creates a potential
problem because in the case of an expression such as data(.) instance of
xs:integer the system needs to know whether the type named in the type
annotation of the context node is derived by restriction from the type
xs:integer. This information is not explicitly available in an XDM tree, as
defined in [Data Model]. The implementation may choose one of several
strategies for dealing with this situation:

 1. The processor may signal a non-recoverable dynamic error if a source
    document is found to contain a type annotation that is not known to the
    processor.
   
 2. The processor may maintain additional metadata, beyond that described in 
    [Data Model], that allows the source document to be processed as if all
    the necessary schema information had been imported using xsl:import-schema
    . Such metadata might be held in the data structure representing the
    source document itself, or it might be held in a system catalog or
    repository.
   
 3. The processor may be configured to use a fixed set of schemas, which are
    automatically used to validate all source documents before they can be
    supplied as input to a transformation. In this case it is impossible for a
    source document to have a type annotation that the processor is not aware
    of.
   
 4. The processor may be configured to treat the source document as if no
    schema processing had been performed, that is, effectively to strip all
    type annotations from elements and attributes on input, marking them
    instead as having type xs:untyped and xs:untypedAtomic respectively.
   
Where a stylesheet author chooses to make assertions about the types of nodes
or of variables and parameters, it is possible for an XSLT processor to
perform static analysis of the stylesheet (that is, analysis in the absence of
any source document). Such analysis may reveal errors that would otherwise not
be discovered until the transformation is actually executed. An XSLT processor
is not required to perform such static type-checking. Under some circumstances
(see 2.9 Error Handling) type errors that are detected early may be reported
as static errors. In addition an implementation may report any condition found
during static analysis as a warning, provided that this does not prevent the
stylesheet being evaluated as described by this specification.

A stylesheet can also control the type annotations of nodes that it constructs
in a final result tree, or in temporary trees. This can be done in a number of
ways.

  * It is possible to request explicit validation of a complete document, that
    is, a tree rooted at a document node. This applies both to temporary trees
    constructed using the xsl:document (or xsl:copy) instruction and also to 
    final result trees constructed using xsl:result-document. Validation is
    either strict or lax, as described in [XML Schema Part 1]. If validation
    of a result tree fails (strictly speaking, if the outcome of the validity
    assessment is invalid), then the transformation fails, but in all other
    cases, the element and attribute nodes of the tree will be annotated with
    the names of the types to which these nodes conform. These type
    annotations will be discarded if the result tree is serialized as an XML
    document, but they remain available when the result tree is passed to an
    application (perhaps another stylesheet) for further processing.
   
  * It is also possible to validate individual element and attribute nodes as
    they are constructed. This is done using the type and validation
    attributes of the xsl:element, xsl:attribute, xsl:copy, and xsl:copy-of
    instructions, or the xsl:type and xsl:validation attributes of a literal
    result element.
   
  * When elements, attributes, or document nodes are copied, either explicitly
    using the xsl:copy or xsl:copy-of instructions, or implicitly when nodes
    in a sequence are attached to a new parent node, the options validation=
    "strip" and validation="preserve" are available, to control whether
    existing type annotations are to be retained or not.
   
When nodes in a temporary tree are validated, type information is available
for use by operations carried out on the temporary tree, in the same way as
for a source document that has undergone schema assessment.

For details of how validation of element and attribute nodes works, see 19.2
Validation.

2.9 Error Handling

[Definition: An error that is detected by examining a stylesheet before
execution starts (that is, before the source document and values of stylesheet
parameters are available) is referred to as a static error.]

Errors classified in this specification as static errors must be signaled by
all implementations: that is, the processor must indicate that the error is
present. A static error must be signaled even if it occurs in a part of the 
stylesheet that is never evaluated. Static errors are never recoverable. After
signaling a static error, a processor may continue for the purpose of
signaling additional errors, but it must eventually terminate abnormally
without producing any final result tree.

There is an exception to this rule when the stylesheet specifies 
forwards-compatible behavior (see 3.9 Forwards-Compatible Processing).

Generally, errors in the structure of the stylesheet, or in the syntax of
XPath expressions contained in the stylesheet, are classified as static errors
. Where this specification states that an element in the stylesheet must or 
must not appear in a certain position, or that it must or must not have a
particular attribute, or that an attribute must or must not have a value
satisfying specified conditions, then any contravention of this rule is a
static error unless otherwise specified.

[Definition: An error that is not detected until a source document is being
transformed is referred to as a dynamic error.]

[Definition: Some dynamic errors are classed as recoverable errors. When a
recoverable error occurs, this specification allows the processor either to
signal the error (by reporting the error condition and terminating execution)
or to take a defined recovery action and continue processing.] It is 
implementation-defined whether the error is signaled or the recovery action is
taken.

[Definition: If an implementation chooses to recover from a recoverable
dynamic error, it must take the optional recovery action defined for that
error condition in this specification.]

When the implementation makes the choice between signaling a dynamic error or
recovering, it is not restricted in how it makes the choice; for example, it 
may provide options that can be set by the user. When an implementation
chooses to recover from a dynamic error, it may also take other action, such
as logging a warning message.

[Definition: A dynamic error that is not recoverable is referred to as a 
non-recoverable dynamic error. When a non-recoverable dynamic error occurs,
the processor must signal the error, and the transformation fails.]

Because different implementations may optimize execution of the stylesheet in
different ways, the detection of dynamic errors is to some degree 
implementation-dependent. In cases where an implementation is able to produce
the final result trees without evaluating a particular construct, the
implementation is never required to evaluate that construct solely in order to
determine whether doing so causes a dynamic error. For example, if a variable
is declared but never referenced, an implementation may choose whether or not
to evaluate the variable declaration, which means that if evaluating the
variable declaration causes a dynamic error, some implementations will signal
this error and others will not.

There are some cases where this specification requires that a construct must
not be evaluated: for example, the content of an xsl:if instruction must not
be evaluated if the test condition is false. This means that an implementation
must not signal any dynamic errors that would arise if the construct were
evaluated.

An implementation may signal a dynamic error before any source document is
available, but only if it can determine that the error would be signaled for
every possible source document and every possible set of parameter values. For
example, some circularity errors fall into this category: see 9.8 Circular
Definitions.

The XPath specification states (see Section 2.3.1 Kinds of Errors^XP) that if
any expression (at any level) can be evaluated during the analysis phase
(because all its explicit operands are known and it has no dependencies on the
dynamic context), then any error in performing this evaluation may be reported
as a static error. For XPath expressions used in an XSLT stylesheet, however,
any such errors must not be reported as static errors in the stylesheet unless
they would occur in every possible evaluation of that stylesheet; instead,
they must be signaled as dynamic errors, and signaled only if the XPath
expression is actually evaluated.

Example: Errors in Constant Subexpressions

An XPath processor may report statically that the expression 1 div 0 fails
with a "divide by zero" error. But suppose this XPath expression occurs in an
XSLT construct such as:

<xsl:choose>
  <xsl:when test="system-property('xsl:version') = '1.0'">
    <xsl:value-of select="1 div 0"/>
  </xsl:when>
  <xsl:otherwise>
    <xsl:value-of select="xs:double('INF')"/>
  </xsl:otherwise>
</xsl:choose>

Then the XSLT processor must not report an error, because the relevant XPath
construct appears in a context where it will never be executed by an XSLT 2.0
processor. (An XSLT 1.0 processor will execute this code successfully,
returning positive infinity, because it uses double arithmetic rather than
decimal arithmetic.)

[Definition: Certain errors are classified as type errors. A type error occurs
when the value supplied as input to an operation is of the wrong type for that
operation, for example when an integer is supplied to an operation that
expects a node.] If a type error occurs in an instruction that is actually
evaluated, then it must be signaled in the same way as a non-recoverable
dynamic error. Alternatively, an implementation may signal a type error during
the analysis phase in the same way as a static error, even if it occurs in
part of the stylesheet that is never evaluated, provided it can establish that
execution of a particular construct would never succeed.

It is implementation-defined whether type errors are signaled statically.

Example: A Type Error

The following construct contains a type error, because 42 is not allowed as an
operand of the xsl:apply-templates instruction. An implementation may
optionally signal this as a static error, even though the offending
instruction will never be evaluated, and the type error would therefore never
be signaled as a dynamic error.

<xsl:if test="false()">
  <xsl:apply-templates select="42"/>
</xsl:if>

On the other hand, in the following example it is not possible to determine
statically whether the operand of xsl:apply-templates will have a suitable
dynamic type. An implementation may produce a warning in such cases, but it 
must not treat it as an error.

<xsl:template match="para">
  <xsl:param name="p" as="item()"/>
  <xsl:apply-templates select="$p"/>
</xsl:template>

If more than one error arises, an implementation is not required to signal any
errors other than the first one that it detects. It is 
implementation-dependent which of the several errors is signaled. This applies
both to static errors and to dynamic errors. An implementation is allowed to
signal more than one error, but if any errors have been signaled, it must not
finish as if the transformation were successful.

When a transformation signals one or more dynamic errors, the final state of
any persistent resources updated by the transformation is 
implementation-dependent. Implementations are not required to restore such
resources to their initial state. In particular, where a transformation
produces multiple result documents, it is possible that one or more serialized
result documents may be written successfully before the transformation
terminates, but the application cannot rely on this behavior.

Everything said above about error handling applies equally to errors in
evaluating XSLT instructions, and errors in evaluating XPath expressions.
Static errors and dynamic errors may occur in both cases.

[Definition: If a transformation has successfully produced a final result tree
, it is still possible that errors may occur in serializing the result tree.
For example, it may be impossible to serialize the result tree using the
encoding selected by the user. Such an error is referred to as a serialization
error.] If the processor performs serialization, then it must do so as
specified in 20 Serialization, and in particular it must signal any
serialization errors that occur.

Errors are identified by a QName. For errors defined in this specification,
the namespace of the QName is always http://www.w3.org/2005/xqt-errors (and is
therefore not given explicitly), while the local part is an 8-character code
in the form PPSSNNNN. Here PP is always XT (meaning XSLT), and SS is one of SE
(static error), DE (dynamic error), RE (recoverable dynamic error), or TE
(type error). Note that the allocation of an error to one of these categories
is purely for convenience and carries no normative implications about the way
the error is handled. Many errors, for example, can be reported either
dynamically or statically.

These error codes are used to label error conditions in this specification,
and are summarized in E Summary of Error Conditions). They are provided
primarily for ease of reference. Implementations may use these codes when
signaling errors, but they are not required to do so. An API specification,
however, may require the use of error codes based on these QNames. Additional
errors defined by an implementation (or by an application) may use QNames in
an implementation-defined (or user-defined) namespace without risk of
collision.

Errors defined in the [XPath 2.0] and [Functions and Operators] specifications
use QNames with a similar structure, in the same namespace. When errors occur
in processing XPath expressions, an XSLT processor should use the original
error code reported by the XPath processor, unless a more specific XSLT error
code is available.

3 Stylesheet Structure

[Definition: A stylesheet consists of one or more stylesheet modules, each one
forming all or part of an XML document.]

Note:

A stylesheet module is represented by an XDM element node (see [Data Model]). 
In the case of a standard stylesheet module, this will be an xsl:stylesheet or
xsl:transform element. In the case of a simplified stylesheet module, it can
be any element (not in the XSLT namespace) that has an xsl:version attribute.

Although stylesheet modules will commonly be maintained in the form of
documents conforming to XML 1.0 or XML 1.1, this specification does not
mandate such a representation. As with source trees, the way in which
stylesheet modules are constructed, from textual XML or otherwise, is outside
the scope of this specification.

A stylesheet module is either a standard stylesheet module or a simplified
stylesheet module:

  * [Definition: A standard stylesheet module is a tree, or part of a tree,
    consisting of an xsl:stylesheet or xsl:transform element (see 3.6
    Stylesheet Element) together with its descendant nodes and associated
    attributes and namespaces.]
   
  * [Definition: A simplified stylesheet module is a tree, or part of a tree,
    consisting of a literal result element together with its descendant nodes
    and associated attributes and namespaces. This element is not itself in
    the XSLT namespace, but it must have an xsl:version attribute, which
    implies that it must have a namespace node that declares a binding for the
    XSLT namespace. For further details see 3.7 Simplified Stylesheet Modules.
    ]
   
Both forms of stylesheet module (standard and simplified) can exist either as
an entire XML document, or embedded as part of another XML document, typically
but not necessarily a source document that is to be processed using the
stylesheet.

[Definition: A standalone stylesheet module is a stylesheet module that
comprises the whole of an XML document.]

[Definition: An embedded stylesheet module is a stylesheet module that is
embedded within another XML document, typically the source document that is
being transformed.] (see 3.11 Embedded Stylesheet Modules).

There are thus four kinds of stylesheet module:

    standalone standard stylesheet modules
    standalone simplified stylesheet modules
    embedded standard stylesheet modules
    embedded simplified stylesheet modules
   
3.1 XSLT Namespace

[Definition: The XSLT namespace has the URI 
http://www.w3.org/1999/XSL/Transform. It is used to identify elements,
attributes, and other names that have a special meaning defined in this
specification.]

Note:

The 1999 in the URI indicates the year in which the URI was allocated by the
W3C. It does not indicate the version of XSLT being used, which is specified
by attributes (see 3.6 Stylesheet Element and 3.7 Simplified Stylesheet
Modules).

XSLT processors must use the XML namespaces mechanism [Namespaces in XML 1.0]
to recognize elements and attributes from this namespace. Elements from the
XSLT namespace are recognized only in the stylesheet and not in the source
document. The complete list of XSLT-defined elements is specified in D Element
Syntax Summary. Implementations must not extend the XSLT namespace with
additional elements or attributes. Instead, any extension must be in a
separate namespace. Any namespace that is used for additional instruction
elements must be identified by means of the extension instruction mechanism
specified in 18.2 Extension Instructions.

This specification uses a prefix of xsl: for referring to elements in the XSLT
namespace. However, XSLT stylesheets are free to use any prefix, provided that
there is a namespace declaration that binds the prefix to the URI of the XSLT
namespace.

Note:

Throughout this specification, an element or attribute that is in no
namespace, or an expanded-QName whose namespace part is an empty sequence, is
referred to as having a null namespace URI.

Note:

The conventions used for the names of XSLT elements, attributes and functions
are that names are all lower-case, use hyphens to separate words, and use
abbreviations only if they already appear in the syntax of a related language
such as XML or HTML. Names of types defined in XML Schema however, are
regarded as single words and are capitalized exactly as in XML Schema. This
sometimes leads to composite function names such as current-dateTime^FO.

3.2 Reserved Namespaces

[Definition: The XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as reserved namespaces and 
must be used only as specified in this and related specifications.] The
reserved namespaces are those listed below.

  * The XSLT namespace, described in 3.1 XSLT Namespace, is reserved.
   
  * [Definition: The standard function namespace 
    http://www.w3.org/2005/xpath-functions is used for functions in the
    function library defined in [Functions and Operators] and standard
    functions defined in this specification.]
   
  * [Definition: The XML namespace, defined in [Namespaces in XML 1.0] as 
    http://www.w3.org/XML/1998/namespace, is used for attributes such as
    xml:lang, xml:space, and xml:id.]
   
  * [Definition: The schema namespace http://www.w3.org/2001/XMLSchema is used
    as defined in [XML Schema Part 1] ]. In a stylesheet this namespace may be
    used to refer to built-in schema datatypes and to the constructor
    functions associated with those datatypes.
   
  * [Definition: The schema instance namespace 
    http://www.w3.org/2001/XMLSchema-instance is used as defined in [XML
    Schema Part 1] ]. Attributes in this namespace, if they appear in a 
    stylesheet, are treated by the XSLT processor in the same way as any other
    attributes.
   
Reserved namespaces may be used without restriction to refer to the names of
elements and attributes in source documents and result documents. As far as
the XSLT processor is concerned, reserved namespaces other than the XSLT
namespace may be used without restriction in the names of literal result
elements and user-defined data elements, and in the names of attributes of
literal result elements or of XSLT elements: but other processors may impose
restrictions or attach special meaning to them. Reserved namespaces must not
be used, however, in the names of stylesheet-defined objects such as variables
and stylesheet functions.

Note:

With the exception of the XML namespace, any of the above namespaces that are
used in a stylesheet must be explicitly declared with a namespace declaration.
Although conventional prefixes are used for these namespaces in this
specification, any prefix may be used in a user stylesheet.

[ERR XTSE0080] It is a static error to use a reserved namespace in the name of
a named template, a mode, an attribute set, a key, a decimal-format, a 
variable or parameter, a stylesheet function, a named output definition, or a 
character map.

3.3 Extension Attributes

[Definition: An element from the XSLT namespace may have any attribute not
from the XSLT namespace, provided that the expanded-QName (see [XPath 2.0]) of
the attribute has a non-null namespace URI. These attributes are referred to
as extension attributes.] The presence of an extension attribute must not
cause the final result trees produced by the transformation to be different
from the result trees that a conformant XSLT 2.0 processor might produce. They
must not cause the processor to fail to signal an error that a conformant
processor is required to signal. This means that an extension attribute must
not change the effect of any instruction except to the extent that the effect
is implementation-defined or implementation-dependent.

Furthermore, if serialization is performed using one of the serialization
methods xml, xhtml, html, or text described in 20 Serialization, the presence
of an extension attribute must not cause the serializer to behave in a way
that is inconsistent with the mandatory provisions of that specification.

Note:

Extension attributes may be used to modify the behavior of extension functions
and extension instructions. They may be used to select processing options in
cases where the specification leaves the behavior implementation-defined or 
implementation-dependent. They may also be used for optimization hints, for
diagnostics, or for documentation.

Extension attributes may also be used to influence the behavior of the
serialization methods xml, xhtml, html, or text, to the extent that the
behavior of the serialization method is implementation-defined or 
implementation-dependent. For example, an extension attribute might be used to
define the amount of indentation to be used when indent="yes" is specified. If
a serialization method other than one of these four is requested (using a
prefixed QName in the method parameter) then extension attributes may
influence its behavior in arbitrary ways. Extension attributes must not be
used to cause the four standard serialization methods to behave in a
non-conformant way, for example by failing to report serialization errors that
a serializer is required to report. An implementation that wishes to provide
such options must create a new serialization method for the purpose.

An implementation that does not recognize the name of an extension attribute,
or that does not recognize its value, must perform the transformation as if
the extension attribute were not present. As always, it is permissible to
produce warning messages.

The namespace used for an extension attribute will be copied to the result
tree in the normal way if it is in scope for a literal result element. This
can be prevented using the [xsl:]exclude-result-prefixes attribute.

Example: An Extension Attribute for xsl:message

The following code might be used to indicate to a particular implementation
that the xsl:message instruction is to ask the user for confirmation before
continuing with the transformation:

<xsl:message
    abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions">Phase 1 complete</xsl:message>

Implementations that do not recognize the namespace 
http://vendor.example.com/xslt/extensions will simply ignore the extra
attribute, and evaluate the xsl:message instruction in the normal way.

[ERR XTSE0090] It is a static error for an element from the XSLT namespace to
have an attribute whose namespace is either null (that is, an attribute with
an unprefixed name) or the XSLT namespace, other than attributes defined for
the element in this document.

3.4 XSLT Media Type

The media type application/xslt+xml will be registered for XSLT stylesheet
modules.

The proposed definition of the media type is at B The XSLT Media Type

This media type should be used for an XML document containing a standard
stylesheet module at its top level, and it may also be used for a simplified
stylesheet module. It should not be used for an XML document containing an 
embedded stylesheet module.

3.5 Standard Attributes

[Definition: There are a number of standard attributes that may appear on any 
XSLT element: specifically version, exclude-result-prefixes,
extension-element-prefixes, xpath-default-namespace, default-collation, and
use-when.]

These attributes may also appear on a literal result element, but in this
case, to distinguish them from user-defined attributes, the names of the
attributes are in the XSLT namespace. They are thus typically written as
xsl:version, xsl:exclude-result-prefixes, xsl:extension-element-prefixes,
xsl:xpath-default-namespace, xsl:default-collation, or xsl:use-when.

It is recommended that all these attributes should also be permitted on 
extension instructions, but this is at the discretion of the implementer of
each extension instruction. They may also be permitted on user-defined data
elements, though they will only have any useful effect in the case of data
elements that are designed to behave like XSLT declarations or instructions.

In the following descriptions, these attributes are referred to generically as
[xsl:]version, and so on.

These attributes all affect the element they appear on, together with any
elements and attributes that have that element as an ancestor. The two forms
with and without the XSLT namespace have the same effect; the XSLT namespace
is used for the attribute if and only if its parent element is not in the XSLT
namespace.

In the case of [xsl:]version, [xsl:]xpath-default-namespace, and [xsl:]
default-collation, the value can be overridden by a different value for the
same attribute appearing on a descendant element. The effective value of the
attribute for a particular stylesheet element is determined by the innermost 
ancestor-or-self element on which the attribute appears.

In an embedded stylesheet module, standard attributes appearing on ancestors
of the outermost element of the stylesheet module have no effect.

In the case of [xsl:]exclude-result-prefixes and [xsl:]
extension-element-prefixes the values are cumulative. For these attributes,
the value is given as a whitespace-separated list of namespace prefixes, and
the effective value for an element is the combined set of namespace URIs
designated by the prefixes that appear in this attribute for that element and
any of its ancestor elements. Again, the two forms with and without the XSLT
namespace are equivalent.

The effect of the [xsl:]use-when attribute is described in 3.12 Conditional
Element Inclusion.

Because these attributes may appear on any XSLT element, they are not listed
in the syntax summary of each individual element. Instead they are listed and
described in the entry for the xsl:stylesheet and xsl:transform elements only.
This reflects the fact that these attributes are often used on the 
xsl:stylesheet element only, in which case they apply to the entire stylesheet
module.

Note that the effect of these attributes does not extend to stylesheet modules
referenced by xsl:include or xsl:import declarations.

For the detailed effect of each attribute, see the following sections:

[xsl:]version
   
    see 3.8 Backwards-Compatible Processing and 3.9 Forwards-Compatible
    Processing
   
[xsl:]xpath-default-namespace
   
    see 5.2 Unprefixed QNames in Expressions and Patterns
   
[xsl:]exclude-result-prefixes
   
    see 11.1.3 Namespace Nodes for Literal Result Elements
   
[xsl:]extension-element-prefixes
   
    see 18.2 Extension Instructions
   
[xsl:]use-when
   
    see 3.12 Conditional Element Inclusion
   
[xsl:]default-collation
   
    see 3.6.1 The default-collation attribute
   
3.6 Stylesheet Element

<xsl:stylesheet
  id? = id
  extension-element-prefixes? = tokens
  exclude-result-prefixes? = tokens
  version = number
  xpath-default-namespace? = uri
  default-validation? = "preserve" | "strip"
  default-collation? = uri-list
  input-type-annotations? = "preserve" | "strip" | "unspecified">
  <!-- Content: (xsl:import*, other-declarations) -->
</xsl:stylesheet>

<xsl:transform
  id? = id
  extension-element-prefixes? = tokens
  exclude-result-prefixes? = tokens
  version = number
  xpath-default-namespace? = uri
  default-validation? = "preserve" | "strip"
  default-collation? = uri-list
  input-type-annotations? = "preserve" | "strip" | "unspecified">
  <!-- Content: (xsl:import*, other-declarations) -->
</xsl:transform>

A stylesheet module is represented by an xsl:stylesheet element in an XML
document. xsl:transform is allowed as a synonym for xsl:stylesheet; everything
this specification says about the xsl:stylesheet element applies equally to 
xsl:transform.

An xsl:stylesheet element must have a version attribute, indicating the
version of XSLT that the stylesheet module requires.

[ERR XTSE0110] The value of the version attribute must be a number:
specifically, it must be a a valid instance of the type xs:decimal as defined
in [XML Schema Part 2]. For this version of XSLT, the value should normally be
2.0. A value of 1.0 indicates that the stylesheet module was written with the
intention that it should be processed using an XSLT 1.0 processor.

If a stylesheet that specifies [xsl:]version="1.0" in the outermost element of
the principal stylesheet module (that is, version="1.0" in the case of a 
standard stylesheet module, or xsl:version="1.0" in the case of a simplified
stylesheet module) is submitted to an XSLT 2.0 processor, the processor should
output a warning advising the user of possible incompatibilities, unless the
user has requested otherwise. The processor must then process the stylesheet
using the rules for backwards-compatible behavior. These rules require that if
the processor does not support backwards-compatible behavior, it must signal
an error and must not execute the transformation.

When the value of the version attribute is greater than 2.0, 
forwards-compatible behavior is enabled (see 3.9 Forwards-Compatible
Processing).

Note:

XSLT 1.0 allowed the [xsl:]version attribute to take any numeric value, and
specified that if the value was not equal to 1.0, the stylesheet would be
executed in forwards compatible mode. XSLT 2.0 continues to allow the
attribute to take any unsigned decimal value. A software product that includes
both an XSLT 1.0 processor and an XSLT 2.0 processor (or that can execute as
either) may use the [xsl:]version attribute to decide which processor to
invoke; such behavior is outside the scope of this specification. When the
stylesheet is executed with an XSLT 2.0 processor, the value 1.0 is taken to
indicate that the stylesheet module was written with XSLT 1.0 in mind: if this
value appears on the outermost element of the principal stylesheet module then
an XSLT 2.0 processor will either reject the stylesheet or execute it in
backwards compatible mode, as described above. Setting version="2.0" indicates
that the stylesheet is to be executed with neither backwards nor forwards
compatible behavior enabled. Any other value less than 2.0 enables backwards
compatible behavior, while any value greater than 2.0 enables forwards
compatible behavior.

When developing a stylesheet that is designed to execute under either XSLT 1.0
or XSLT 2.0, the recommended practice is to create two alternative stylesheet
modules, one specifying version="1.0", and the other specifying version="2.0";
these modules can use xsl:include or xsl:import to incorporate the common
code. When running under an XSLT 1.0 processor, the version="1.0" module can
be selected as the principal stylesheet module; when running under an XSLT 2.0
processor, the version="2.0" module can be selected as the principal
stylesheet module. Stylesheet modules that are included or imported should
specify version="2.0" if they make use of XSLT 2.0 facilities, and version=
"1.0" otherwise.

The effect of the input-type-annotations attribute is described in 4.3
Stripping Type Annotations from a Source Tree.

The default-validation attribute defines the default value of the validation
attribute of all xsl:document, xsl:element, xsl:attribute, xsl:copy, 
xsl:copy-of, and xsl:result-document instructions, and of the xsl:validation
attribute of all literal result elements. It also determines the validation
applied to the implicit final result tree created in the absence of an 
xsl:result-document instruction. This default applies within the stylesheet
module: it does not extend to included or imported stylesheet modules. If the
attribute is omitted, the default is strip. The permitted values are preserve
and strip. For details of the effect of this attribute, see 19.2 Validation.

[ERR XTSE0120] An xsl:stylesheet element must not have any text node children.
(This rule applies after stripping of whitespace text nodes as described in 
4.2 Stripping Whitespace from the Stylesheet.)

[Definition: An element occurring as a child of an xsl:stylesheet element is
called a top-level element.]

[Definition: Top-level elements fall into two categories: declarations, and
user-defined data elements. Top-level elements whose names are in the XSLT
namespace are declarations. Top-level elements in any other namespace are 
user-defined data elements (see 3.6.2 User-defined Data Elements)].

The declaration elements permitted in the xsl:stylesheet element are:

    xsl:import
    xsl:include
    xsl:attribute-set
    xsl:character-map
    xsl:decimal-format
    xsl:function
    xsl:import-schema
    xsl:key
    xsl:namespace-alias
    xsl:output
    xsl:param
    xsl:preserve-space
    xsl:strip-space
    xsl:template
    xsl:variable
   
Note that the xsl:variable and xsl:param elements can act either as 
declarations or as instructions. A global variable or parameter is defined
using a declaration; a local variable or parameter using an instruction.

If there are xsl:import elements, these must come before any other elements.
Apart from this, the child elements of the xsl:stylesheet element may appear
in any order. The ordering of these elements does not affect the results of
the transformation unless there are conflicting declarations (for example, two
template rules with the same priority that match the same node). In general,
it is an error for a stylesheet to contain such conflicting declarations, but
in some cases the processor is allowed to recover from the error by choosing
the declaration that appears last in the stylesheet.

3.6.1 The default-collation attribute

The default-collation attribute is a standard attribute that may appear on any
element in the XSLT namespace, or (as xsl:default-collation) on a literal
result element.

The attribute is used to specify the default collation used by all XPath
expressions appearing in the attributes of this element, or attributes of
descendant elements, unless overridden by another default-collation attribute
on an inner element. It also determines the collation used by certain XSLT
constructs (such as xsl:key and xsl:for-each-group) within its scope.

The value of the attribute is a whitespace-separated list of collation URIs. 
If any of these URIs is a relative URI, then it is resolved relative to the
base URI of the attribute's parent element. If the implementation recognizes
one or more of the resulting absolute collation URIs, then it uses the first
one that it recognizes as the default collation.

[ERR XTSE0125] It is a static error if the value of an [xsl:]default-collation
attribute, after resolving against the base URI, contains no URI that the
implementation recognizes as a collation URI.

Note:

The reason the attribute allows a list of collation URIs is that collation
URIs will often be meaningful only to one particular XSLT implementation.
Stylesheets designed to run with several different implementations can
therefore specify several different collation URIs, one for use with each. To
avoid the above error condition, it is possible to specify the Unicode
Codepoint Collation as the last collation URI in the list.

The [xsl:]default-collation attribute does not affect the collation used by
xsl:sort.

3.6.2 User-defined Data Elements

[Definition: In addition to declarations, the xsl:stylesheet element may
contain any element not from the XSLT namespace, provided that the 
expanded-QName of the element has a non-null namespace URI. Such elements are
referred to as user-defined data elements.]

[ERR XTSE0130] It is a static error if the xsl:stylesheet element has a child
element whose name has a null namespace URI.

An implementation may attach an implementation-defined meaning to user-defined
data elements that appear in particular namespaces. The set of namespaces that
are recognized for such data elements is implementation-defined. The presence
of a user-defined data element must not change the behavior of XSLT elements
and functions defined in this document; for example, it is not permitted for a
user-defined data element to specify that xsl:apply-templates should use
different rules to resolve conflicts. The constraints on what user-defined
data elements can and cannot do are exactly the same as the constraints on 
extension attributes, described in 3.3 Extension Attributes. Thus, an
implementation is always free to ignore user-defined data elements, and must
ignore such data elements without giving an error if it does not recognize the
namespace URI.

User-defined data elements can provide, for example,

  * information used by extension instructions or extension functions (see 18
    Extensibility and Fallback),
   
  * information about what to do with any final result tree,
   
  * information about how to construct source trees,
   
  * optimization hints for the processor,
   
  * metadata about the stylesheet,
   
  * structured documentation for the stylesheet.
   
A user-defined data element must not precede an xsl:import element within a 
stylesheet module [see ERR XTSE0200]

3.7 Simplified Stylesheet Modules

A simplified syntax is allowed for a stylesheet module that defines only a
single template rule for the document node. The stylesheet module may consist
of just a literal result element (see 11.1 Literal Result Elements) together
with its contents. The literal result element must have an xsl:version
attribute (and it must therefore also declare the XSLT namespace). Such a
stylesheet module is equivalent to a standard stylesheet module whose 
xsl:stylesheet element contains a template rule containing the literal result
element, minus its xsl:version attribute; the template rule has a match 
pattern of /.

Example: A Simplified Stylesheet

For example:

<html xsl:version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Expense Report Summary</title>
  </head>
  <body>
    <p>Total Amount: <xsl:value-of select="expense-report/total"/></p>
  </body>
</html>

has the same meaning as

<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml">
<xsl:template match="/">
<html>
  <head>
    <title>Expense Report Summary</title>
  </head>
  <body>
    <p>Total Amount: <xsl:value-of select="expense-report/total"/></p>
  </body>
</html>
</xsl:template>
</xsl:stylesheet>

Note that it is not possible, using a simplified stylesheet, to request that
the serialized output contains a DOCTYPE declaration. This can only be done by
using a standard stylesheet module, and using the xsl:output element.

More formally, a simplified stylesheet module is equivalent to the standard
stylesheet module that would be generated by applying the following
transformation to the simplified stylesheet module, invoking the
transformation by calling the named template expand, with the containing
literal result element as the context node:

<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:template name="expand">
  <xsl:element name="xsl:stylesheet">
    <xsl:attribute name="version" select="@xsl:version"/>
    <xsl:element name="xsl:template">
      <xsl:attribute name="match">/</xsl:attribute>
      <xsl:copy-of select="."/>
    </xsl:element>
  </xsl:element>
</xsl:template>  

</xsl:stylesheet>

[ERR XTSE0150] A literal result element that is used as the outermost element
of a simplified stylesheet module must have an xsl:version attribute. This
indicates the version of XSLT that the stylesheet requires. For this version
of XSLT, the value will normally be 2.0; the value must be a valid instance of
the type xs:decimal as defined in [XML Schema Part 2].

Other literal result elements may also have an xsl:version attribute. When the
xsl:version attribute is numerically less than 2.0, backwards-compatible
processing behavior is enabled (see 3.8 Backwards-Compatible Processing). When
the xsl:version attribute is numerically greater than 2.0, forwards-compatible
behavior is enabled (see 3.9 Forwards-Compatible Processing).

The allowed content of a literal result element when used as a simplified
stylesheet is the same as when it occurs within a sequence constructor. Thus,
a literal result element used as the document element of a simplified
stylesheet cannot contain declarations. Simplified stylesheets therefore
cannot use global variables, stylesheet parameters, stylesheet functions, keys
, attribute-sets, or output definitions. In turn this means that the only
useful way to initiate the transformation is to supply a document node as the 
initial context node, to be matched by the implicit match="/" template rule
using the default mode.

3.8 Backwards-Compatible Processing

[Definition: An element enables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an [xsl:]version
attribute (see 3.5 Standard Attributes) whose value is less than 2.0.]

An element that has an [xsl:]version attribute whose value is greater than or
equal to 2.0 disables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes. The compatibility behavior
established by an element overrides any compatibility behavior established by
an ancestor element.

If an attribute containing an XPath expression is processed with
backwards-compatible behavior, then the expression is evaluated with XPath 1.0
compatibility mode set to true. For details of this mode, see Section 2.1.1
Static Context^XP. Furthermore, in such an expression any function call for
which no implementation is available (unless it uses the standard function
namespace) is bound to a fallback error function whose effect when evaluated
is to raise a dynamic error [see ERR XTDE1425] . The effect is that with
backwards-compatible behavior enabled, calls on extension functions that are
not available in a particular implementation do not cause an error unless the
function call is actually evaluated. For further details, see 18.1 Extension
Functions.

Note:

This might appear to contradict the specification of XPath 2.0, which states
that a static error [XPST0017] is raised when an expression contains a call to
a function that is not present (with matching name and arity) in the static
context. This apparent contradiction is resolved by specifying that the XSLT
processor constructs a static context for the expression in which every
possible function name and arity (other than names in the standard function
namespace) is present; when no other implementation of the function is
available, the function call is bound to a fallback error function whose
run-time effect is to raise a dynamic error.

Certain XSLT constructs also produce different results when
backwards-compatible behavior is enabled. This is described separately for
each such construct.

These rules do not apply to the xsl:output element, whose version attribute
has an entirely different purpose: it is used to define the version of the
output method to be used for serialization.

Note:

By making use of backwards-compatible behavior, it is possible to write the
stylesheet in a way that ensures that its results when processed with an XSLT
2.0 processor are identical to the effects of processing the same stylesheet
using an XSLT 1.0 processor. The differences are described (non-normatively)
in J.1 Incompatible Changes. To assist with transition, some parts of a
stylesheet may be processed with backwards compatible behavior enabled, and
other parts with this behavior disabled. All data values manipulated by an
XSLT 2.0 processor are defined by the XDM data model, whether or not the
relevant expressions use backwards compatible behavior. Because the same data
model is used in both cases, expressions are fully composable. The result of
evaluating instructions or expressions with backwards compatible behavior is
fully defined in the XSLT 2.0 and XPath 2.0 specifications, it is not defined
by reference to the XSLT 1.0 and XPath 1.0 specifications.

It is implementation-defined whether a particular XSLT 2.0 implementation
supports backwards-compatible behavior.

[ERR XTDE0160] If an implementation does not support backwards-compatible
behavior, then it is a non-recoverable dynamic error if any element is
evaluated that enables backwards-compatible behavior.

Note:

To write a stylesheet that works with both XSLT 1.0 and 2.0 processors, while
making selective use of XSLT 2.0 facilities, it is necessary to understand
both the rules for backwards-compatible behavior in XSLT 2.0, and the rules
for forwards-compatible behavior in XSLT 1.0. If the xsl:stylesheet element
specifies version="2.0", then an XSLT 1.0 processor will ignore XSLT 2.0 
declarations that were not defined in XSLT 1.0, for example xsl:function and 
xsl:import-schema. If any new XSLT 2.0 instructions are used (for example 
xsl:analyze-string or xsl:namespace), or if new XPath 2.0 features are used
(for example, new functions, or syntax such as conditional expressions, or
calls to a function defined using xsl:function), then the stylesheet must
provide fallback behavior that relies on XSLT 1.0 and XPath 1.0 facilities
only. The fallback behavior can be invoked by using the xsl:fallback
instruction, or by testing the results of the function-available or 
element-available functions, or by testing the value of the xsl:version
property returned by the system-property function.

3.9 Forwards-Compatible Processing

The intent of forwards-compatible behavior is to make it possible to write a
stylesheet that takes advantage of features introduced in some version of XSLT
subsequent to XSLT 2.0, while retaining the ability to execute the stylesheet
with an XSLT 2.0 processor using appropriate fallback behavior.

It is always possible to write conditional code to run under different XSLT
versions by using the use-when feature described in 3.12 Conditional Element
Inclusion. The rules for forwards-compatible behavior supplement this
mechanism in two ways:

  * certain constructs in the stylesheet that mean nothing to an XSLT 2.0
    processor are ignored, rather than being treated as errors.
   
  * explicit fallback behavior can be defined for instructions defined in a
    future XSLT release, using the xsl:fallback instruction.
   
The detailed rules follow.

[Definition: An element enables forwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an [xsl:]version
attribute (see 3.5 Standard Attributes) whose value is greater than 2.0.]

An element that has an [xsl:]version attribute whose value is less than or
equal to 2.0 disables forwards-compatible behavior for itself, its attributes,
its descendants and their attributes. The compatibility behavior established
by an element overrides any compatibility behavior established by an ancestor
element.

These rules do not apply to the version attribute of the xsl:output element,
which has an entirely different purpose: it is used to define the version of
the output method to be used for serialization.

Within a section of a stylesheet where forwards-compatible behavior is
enabled:

  * if an element in the XSLT namespace appears as a child of the 
    xsl:stylesheet element, and XSLT 2.0 does not allow such elements to occur
    as children of the xsl:stylesheet element, then the element and its
    content must be ignored.
   
  * if an element has an attribute that XSLT 2.0 does not allow the element to
    have, then the attribute must be ignored.
   
  * if an element in the XSLT namespace appears as part of a sequence
    constructor, and XSLT 2.0 does not allow such elements to appear as part
    of a sequence constructor, then:
   
     1. If the element has one or more xsl:fallback children, then no error is
        reported either statically or dynamically, and the result of
        evaluating the instruction is the concatenation of the sequences
        formed by evaluating the sequence constructors within its xsl:fallback
        children, in document order. Siblings of the xsl:fallback elements are
        ignored, even if they are valid XSLT 2.0 instructions.
       
     2. If the element has no xsl:fallback children, then a static error is
        reported in the same way as if forwards-compatible behavior were not
        enabled.
       
Example: Forwards Compatible Behavior

For example, an XSLT 2.0 processor will process the following stylesheet
without error, although the stylesheet includes elements from the XSLT
namespace that are not defined in this specification:

<xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:exciting-new-17.0-feature>
      <xsl:fly-to-the-moon/>
      <xsl:fallback>
        <html>
          <head>
            <title>XSLT 17.0 required</title>
          </head>
          <body>
            <p>Sorry, this stylesheet requires XSLT 17.0.</p>
          </body>
        </html>
      </xsl:fallback>
    </xsl:exciting-new-17.0-feature>
  </xsl:template>
</xsl:stylesheet>

Note:

If a stylesheet depends crucially on a declaration introduced by a version of
XSLT after 2.0, then the stylesheet can use an xsl:message element with
terminate="yes" (see 17 Messages) to ensure that implementations that conform
to an earlier version of XSLT will not silently ignore the declaration.

Example: Testing the XSLT Version

For example,

<xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:important-new-17.0-declaration/>

  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="number(system-property('xsl:version')) lt 17.0">
        <xsl:message terminate="yes">
          <xsl:text>Sorry, this stylesheet requires XSLT 17.0.</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:otherwise>
        ...
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  ...
</xsl:stylesheet>

3.10 Combining Stylesheet Modules

XSLT provides two mechanisms to construct a stylesheet from multiple 
stylesheet modules:

  * an inclusion mechanism that allows stylesheet modules to be combined
    without changing the semantics of the modules being combined, and
   
  * an import mechanism that allows stylesheet modules to override each other.
   
3.10.1 Locating Stylesheet Modules

The include and import mechanisms use two declarations, xsl:include and 
xsl:import, which are defined in the sections that follow.

These declarations use an href attribute, whose value is a URI reference, to
identify the stylesheet module to be included or imported. If the value of
this attribute is a relative URI, it is resolved as described in 5.8 URI
References.

After resolving against the base URI, the way in which the URI reference is
used to locate a representation of a stylesheet module, and the way in which
the stylesheet module is constructed from that representation, are 
implementation-defined. In particular, it is implementation-defined which URI
schemes are supported, whether fragment identifiers are supported, and what
media types are supported. Conventionally, the URI is a reference to a
resource containing the stylesheet module as a source XML document, or it may
include a fragment identifier that selects an embedded stylesheet module
within a source XML document; but the implementation is free to use other
mechanisms to locate the stylesheet module identified by the URI reference.

The referenced stylesheet module may be any of the four kinds of stylesheet
module: that is, it may be standalone or embedded, and it may be standard or 
simplified. If it is a simplified stylesheet module then it is transformed
into the equivalent standard stylesheet module by applying the transformation
described in 3.7 Simplified Stylesheet Modules.

Implementations may choose to accept URI references containing a fragment
identifier defined by reference to the XPointer specification (see [XPointer
Framework]). Note that if the implementation does not support the use of
fragment identifiers in the URI reference, then it will not be possible to
include an embedded stylesheet module.

[ERR XTSE0165] It is a static error if the processor is not able to retrieve
the resource identified by the URI reference, or if the resource that is
retrieved does not contain a stylesheet module conforming to this
specification.

3.10.2 Stylesheet Inclusion

<!-- Category: declaration -->
<xsl:include
  href = uri-reference />

A stylesheet module may include another stylesheet module using an xsl:include
declaration.

The xsl:include declaration has a required href attribute whose value is a URI
reference identifying the stylesheet module to be included. This attribute is
used as described in 3.10.1 Locating Stylesheet Modules.

[ERR XTSE0170] An xsl:include element must be a top-level element.

[Definition: A stylesheet level is a collection of stylesheet modules
connected using xsl:include declarations: specifically, two stylesheet modules
A and B are part of the same stylesheet level if one of them includes the
other by means of an xsl:include declaration, or if there is a third
stylesheet module C that is in the same stylesheet level as both A and B.]

[Definition: The declarations within a stylesheet level have a total ordering
known as declaration order. The order of declarations within a stylesheet
level is the same as the document order that would result if each stylesheet
module were inserted textually in place of the xsl:include element that
references it.] In other respects, however, the effect of xsl:include is not
equivalent to the effect that would be obtained by textual inclusion.

[ERR XTSE0180] It is a static error if a stylesheet module directly or
indirectly includes itself.

Note:

It is not intrinsically an error for a stylesheet to include the same module
more than once. However, doing so can cause errors because of duplicate
definitions. Such multiple inclusions are less obvious when they are indirect.
For example, if stylesheet B includes stylesheet A, stylesheet C includes
stylesheet A, and stylesheet D includes both stylesheet B and stylesheet C,
then A will be included indirectly by D twice. If all of B, C and D are used
as independent stylesheets, then the error can be avoided by separating
everything in B other than the inclusion of A into a separate stylesheet B'
and changing B to contain just inclusions of B' and A, similarly for C, and
then changing D to include A, B', C'.

3.10.3 Stylesheet Import

<!-- Category: declaration -->
<xsl:import
  href = uri-reference />

A stylesheet module may import another stylesheet module using an xsl:import 
declaration. Importing a stylesheet module is the same as including it (see 
3.10.2 Stylesheet Inclusion) except that template rules and other declarations
in the importing module take precedence over template rules and declarations
in the imported module; this is described in more detail below.

The xsl:import declaration has a required href attribute whose value is a URI
reference identifying the stylesheet module to be included. This attribute is
used as described in 3.10.1 Locating Stylesheet Modules.

[ERR XTSE0190] An xsl:import element must be a top-level element.

[ERR XTSE0200] The xsl:import element children must precede all other element
children of an xsl:stylesheet element, including any xsl:include element
children and any user-defined data elements.

Example: Using xsl:import

For example,

<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:import href="article.xsl"/>
  <xsl:import href="bigfont.xsl"/>
  <xsl:attribute-set name="note-style">
    <xsl:attribute name="font-style">italic</xsl:attribute>
  </xsl:attribute-set>
</xsl:stylesheet>

[Definition: The stylesheet levels making up a stylesheet are treated as
forming an import tree. In the import tree, each stylesheet level has one
child for each xsl:import declaration that it contains.] The ordering of the
children is the declaration order of the xsl:import declarations within their
stylesheet level.

[Definition: A declaration D in the stylesheet is defined to have lower import
precedence than another declaration E if the stylesheet level containing D
would be visited before the stylesheet level containing E in a post-order
traversal of the import tree (that is, a traversal of the import tree in which
a stylesheet level is visited after its children). Two declarations within the
same stylesheet level have the same import precedence.]

For example, suppose

  * stylesheet module A imports stylesheet modules B and C in that order;
   
  * stylesheet module B imports stylesheet module D;
   
  * stylesheet module C imports stylesheet module E.
   
Then the import tree has the following structure:

         A
         |
     +---+---+
     |       |
     B       C
     |       |
     D       E

The order of import precedence (lowest first) is D, B, E, C, A.

In general, a declaration with higher import precedence takes precedence over
a declaration with lower import precedence. This is defined in detail for each
kind of declaration.

[ERR XTSE0210] It is a static error if a stylesheet module directly or
indirectly imports itself.

Note:

The case where a stylesheet module with a particular URI is imported several
times is not treated specially. The effect is exactly the same as if several
stylesheet modules with different URIs but identical content were imported.
This might or might not cause an error, depending on the content of the
stylesheet module.

3.11 Embedded Stylesheet Modules

An embedded stylesheet module is a stylesheet module whose containing element
is not the outermost element of the containing XML document. Both standard
stylesheet modules and simplified stylesheet modules may be embedded in this
way.

Two situations where embedded stylesheets may be useful are:

  * The stylesheet may be embedded in the source document to be transformed.
   
  * The stylesheet may be embedded in an XML document that describes a
    sequence of processing of which the XSLT transformation forms just one
    part.
   
The xsl:stylesheet element may have an id attribute to facilitate reference to
the stylesheet module within the containing document.

Note:

In order for such an attribute value to be used as a fragment identifier in a
URI, the XDM attribute node must generally have the is-id property: see 
Section 5.5 is-id Accessor^DM. This property will typically be set if the
attribute is defined in a DTD as being of type ID, or if is defined in a
schema as being of type xs:ID. It is also necessary that the media type of the
containing document should support the use of ID values as fragment
identifiers. Such support is widespread in existing products, and is expected
to be endorsed in respect of the media type application/xml by a future
revision of [RFC3023].

An alternative, if the implementation supports it, is to use an xml:id
attribute. XSLT allows this attribute (like other namespaced attributes) to
appear on any XSLT element.

Example: The xml-stylesheet Processing Instruction

The following example shows how the xml-stylesheet processing instruction (see
[XML Stylesheet]) can be used to allow a source document to contain its own
stylesheet. The URI reference uses a relative URI with a fragment identifier
to locate the xsl:stylesheet element:

<?xml-stylesheet type="application/xslt+xml" href="#style1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<head>
<xsl:stylesheet id="style1"
                version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format">
<xsl:import href="doc.xsl"/>
<xsl:template match="id('foo')">
  <fo:block font-weight="bold"><xsl:apply-templates/></fo:block>
</xsl:template>
<xsl:template match="xsl:stylesheet">
  <!-- ignore -->
</xsl:template>
</xsl:stylesheet>
</head>
<body>
<para id="foo">
...
</para>
</body>
</doc>

Note:

A stylesheet module that is embedded in the document to which it is to be
applied typically needs to contain a template rule that specifies that 
xsl:stylesheet elements are to be ignored.

Note:

The above example uses the pseudo-attribute type="application/xslt+xml" in the
xml-stylesheet processing instruction to denote an XSLT stylesheet. This usage
is subject to confirmation: see 3.4 XSLT Media Type. In the absence of a
registered media type for XSLT stylesheets, some vendors' products have
adopted different conventions, notably type="text/xsl".

Note:

Support for the xml-stylesheet processing instruction is not required for
conformance with this Recommendation. Implementations are not constrained in
the mechanisms they use to identify a stylesheet when a transformation is
initiated: see 2.3 Initiating a Transformation.

3.12 Conditional Element Inclusion

Any element in the XSLT namespace may have a use-when attribute whose value is
an XPath expression that can be evaluated statically. If the attribute is
present and the effective boolean value^XP of the expression is false, then
the element, together with all the nodes having that element as an ancestor,
is effectively excluded from the stylesheet module. When a node is effectively
excluded from a stylesheet module the stylesheet module has the same effect as
if the node were not there. Among other things this means that no static or
dynamic errors will be reported in respect of the element and its contents,
other than errors in the use-when attribute itself.

Note:

This does not apply to XML parsing or validation errors, which will be
reported in the usual way. It also does not apply to attributes that are
necessarily processed before [xsl:]use-when, examples being xml:space and
[xsl:]xpath-default-namespace.

A literal result element, or any other element within a stylesheet module that
is not in the XSLT namespace, may similarly carry an xsl:use-when attribute.

If the xsl:stylesheet or xsl:transform element itself is effectively excluded,
the effect is to exclude all the children of the xsl:stylesheet or 
xsl:transform element, but not the xsl:stylesheet or xsl:transform element or
its attributes.

Note:

This allows all the declarations that depend on the same condition to be
included in one stylesheet module, and for their inclusion or exclusion to be
controlled by a single use-when attribute at the level of the module.

Conditional element exclusion happens after stripping of whitespace text nodes
from the stylesheet, as described in 4.2 Stripping Whitespace from the
Stylesheet.

There are no syntactic constraints on the XPath expression that can be used as
the value of the use-when attribute. However, there are severe constraints on
the information provided in its evaluation context. These constraints are
designed to ensure that the expression can be evaluated at the earliest
possible stage of stylesheet processing, without any dependency on information
contained in the stylesheet itself or in any source document.

Specifically, the components of the static and dynamic context are defined by
the following two tables:

              Static Context Components for use-when Expressions              
+----------------------------------------------------------------------------+
|   Component   |                           Value                            |
|---------------+------------------------------------------------------------|
| XPath 1.0     |                                                            |
| compatibility | false                                                      |
| mode          |                                                            |
|---------------+------------------------------------------------------------|
| In scope      | determined by the in-scope namespaces for the containing   |
| namespaces    | element in the stylesheet                                  |
|---------------+------------------------------------------------------------|
| Default       | determined by the xpath-default-namespace attribute if     |
| element/type  | present (see 5.2 Unprefixed QNames in Expressions and      |
| namespace     | Patterns); otherwise the null namespace                    |
|---------------+------------------------------------------------------------|
| Default       |                                                            |
| function      | The standard function namespace                            |
| namespace     |                                                            |
|---------------+------------------------------------------------------------|
| In scope type | The type definitions that would be available in the        |
| definitions   | absence of any xsl:import-schema declaration               |
|---------------+------------------------------------------------------------|
| In scope      |                                                            |
| element       | None                                                       |
| declarations  |                                                            |
|---------------+------------------------------------------------------------|
| In scope      |                                                            |
| attribute     | None                                                       |
| declarations  |                                                            |
|---------------+------------------------------------------------------------|
| In scope      | None                                                       |
| variables     |                                                            |
|---------------+------------------------------------------------------------|
| In scope      | The core functions defined in [Functions and Operators],   |
| functions     | together with the functions element-available,             |
|               | function-available, type-available, and system-property    |
|               | defined in this specification, plus the set of extension   |
|               | functions that are present in the static context of every  |
|               | XPath expression (other than a use-when expression) within |
|               | the content of the element that is the parent of the       |
|               | use-when attribute. Note that stylesheet functions are not |
|               | included in the context, which means that the function     |
|               | function-available will return false in respect of such    |
|               | functions. The effect of this rule is to ensure that       |
|               | function-available returns true in respect of functions    |
|               | that can be called within the scope of the use-when        |
|               | attribute. It also has the effect that these extensions    |
|               | functions will be recognized within the use-when attribute |
|               | itself; however, the fact that a function is available in  |
|               | this sense gives no guarantee that a call on the function  |
|               | will succeed.                                              |
|---------------+------------------------------------------------------------|
| In scope      | Implementation-defined                                     |
| collations    |                                                            |
|---------------+------------------------------------------------------------|
| Default       | The Unicode Codepoint Collation                            |
| collation     |                                                            |
|---------------+------------------------------------------------------------|
| Base URI      | The base URI of the containing element in the stylesheet   |
|---------------+------------------------------------------------------------|
| Statically    |                                                            |
| known         | None                                                       |
| documents     |                                                            |
|---------------+------------------------------------------------------------|
| Statically    |                                                            |
| known         | None                                                       |
| collections   |                                                            |
+----------------------------------------------------------------------------+

             Dynamic Context Components for use-when Expressions              
+----------------------------------------------------------------------------+
|                 Component                  |             Value             |
|--------------------------------------------+-------------------------------|
| Context item, position, and size           | Undefined                     |
|--------------------------------------------+-------------------------------|
| Dynamic variables                          | None                          |
|--------------------------------------------+-------------------------------|
| Current date and time                      | Implementation-defined        |
|--------------------------------------------+-------------------------------|
| Implicit timezone                          | Implementation-defined        |
|--------------------------------------------+-------------------------------|
| Available documents                        | None                          |
|--------------------------------------------+-------------------------------|
| Available collections                      | None                          |
+----------------------------------------------------------------------------+

Within a stylesheet module, all expressions contained in [xsl:]use-when
attributes are evaluated in a single execution scope^FO. This need not be the
same execution scope as that used for [xsl]:use-when expressions in other
stylesheet modules, or as that used when evaluating XPath expressions
appearing elsewhere in the stylesheet module. This means that a function such
as current-date^FO will return the same result when called in different [xsl:]
use-when expressions within the same stylesheet module, but will not
necessarily return the same result as the same call in an [xsl:]use-when
expression within a different stylesheet module, or as a call on the same
function executed during the transformation proper.

The use of [xsl:]use-when is illustrated in the following examples.

Example: Using Conditional Exclusion to Achieve Portability

This example demonstrates the use of the use-when attribute to achieve
portability of a stylesheet across schema-aware and non-schema-aware
processors.

<xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/>

<xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2">
  <xsl:result-document validation="strict">
    <xsl:apply-templates/>
  </xsl:result-document>
</xsl:template>

<xsl:template match="/">
  <xsl:apply-templates/>
</xsl:template>

The effect of these declarations is that a non-schema-aware processor ignores
the xsl:import-schema declaration and the first template rule, and therefore
generates no errors in respect of the schema-related constructs in these
declarations.

Example: Including Variant Stylesheet Modules

This example includes different stylesheet modules depending on which XSLT
processor is in use.

<xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/>
<xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/>

3.13 Built-in Types

Every XSLT 2.0 processor includes the following named type definitions in the 
in-scope schema components:

  * All the primitive atomic types defined in [XML Schema Part 2], with the
    exception of xs:NOTATION. That is: xs:string, xs:boolean, xs:decimal,
    xs:double, xs:float, xs:date, xs:time, xs:dateTime, xs:duration, xs:QName,
    xs:anyURI, xs:gDay, xs:gMonthDay, xs:gMonth, xs:gYearMonth, xs:gYear,
    xs:base64Binary, and xs:hexBinary.
   
  * The derived atomic type xs:integer defined in [XML Schema Part 2].
   
  * The types xs:anyType and xs:anySimpleType.
   
  * The following types defined in [XPath 2.0]: xs:yearMonthDuration, 
    xs:dayTimeDuration, xs:anyAtomicType, xs:untyped, and xs:untypedAtomic.
   
A schema-aware XSLT processor additionally supports:

  * All other built-in types defined in [XML Schema Part 2]
   
  * User-defined types, and element and attribute declarations, that are
    imported using an xsl:import-schema declaration as described in 3.14
    Importing Schema Components. These may include both simple and complex
    types.
   
Note:

The names that are imported from the XML Schema namespace do not include all
the names of top-level types defined in either the Schema for Schemas or the
Schema for Datatypes. The Schema for Datatypes, as well as defining built-in
types such as xs:integer and xs:double, also defines types that are intended
for use only within the Schema for DataTypes, such as xs:derivationControl. A 
stylesheet that is designed to process XML Schema documents as its input or
output may import the Schema for Schemas.

An implementation may define mechanisms that allow additional schema
components to be added to the in-scope schema components for the stylesheet.
For example, the mechanisms used to define extension functions (see 18.1
Extension Functions) may also be used to import the types used in the
interface to such functions.

These schema components are the only ones that may be referenced in XPath
expressions within the stylesheet, or in the [xsl:]type and as attributes of
those elements that permit these attributes.

For a Basic XSLT Processor, schema built-in types that are not included in the
static context (for example, xs:NCName) are "unknown types" in the sense of 
Section 2.5.4 SequenceType Matching^XP. In the language of that section, a
Basic XSLT Processor must be able to determine whether these unknown types are
derived from known schema types such as xs:string. The purpose of this rule is
to ensure that system functions such as local-name-from-QName^FO, which is
defined to return an xs:NCName, behave correctly. A stylesheet that uses a
Basic XSLT Processor will not be able to test whether the returned value is an
xs:NCName, but it will be able to use it as if it were an xs:string.

3.14 Importing Schema Components

Note:

The facilities described in this section are not available with a basic XSLT
processor. They require a schema-aware XSLT processor, as described in 21
Conformance.

<!-- Category: declaration -->
<xsl:import-schema
  namespace? = uri-reference
  schema-location? = uri-reference>
  <!-- Content: xs:schema? -->
</xsl:import-schema>

The xsl:import-schema declaration is used to identify schema components (that
is, top-level type definitions and top-level element and attribute
declarations) that need to be available statically, that is, before any source
document is available. Names of such components used statically within the 
stylesheet must refer to an in-scope schema component, which means they must
either be built-in types as defined in 3.13 Built-in Types, or they must be
imported using an xsl:import-schema declaration.

The xsl:import-schema declaration identifies a namespace containing the names
of the components to be imported (or indicates that components whose names are
in no namespace are to be imported). The effect is that the names of top-level
element and attribute declarations and type definitions from this namespace
(or non-namespace) become available for use within XPath expressions in the 
stylesheet, and within other stylesheet constructs such as the type and as
attributes of various XSLT elements.

The same schema components are available in all stylesheet modules; importing
components in one stylesheet module makes them available throughout the 
stylesheet.

The namespace and schema-location attributes are both optional.

If the xsl:import-schema element contains an xs:schema element, then the
schema-location attribute must be absent, and the namespace attribute must
either have the same value as the targetNamespace attribute of the xs:schema
element (if present), or must be absent, in which case its effective value is
that of the targetNamespace attribute of the xs:schema element if present or
the zero-length string otherwise.

[ERR XTSE0215] It is a static error if an xsl:import-schema element that
contains an xs:schema element has a schema-location attribute, or if it has a
namespace attribute that conflicts with the target namespace of the contained
schema.

If two xsl:import-schema declarations specify the same namespace, or if both
specify no namespace, then only the one with highest import precedence is
used. If this leaves more than one, then all the declarations at the highest
import precedence are used (which may cause conflicts, as described below).

After discarding any xsl:import-schema declarations under the above rule, the
effect of the remaining xsl:import-schema declarations is defined in terms of
a hypothetical document called the synthetic schema document, which is
constructed as follows. The synthetic schema document defines an arbitrary
target namespace that is different from any namespace actually used by the
application, and it contains xs:import elements corresponding one-for-one with
the xsl:import-schema declarations in the stylesheet, with the following
correspondence:

  * The namespace attribute of the xs:import element is copied from the
    namespace attribute of the xsl:import-schema declaration if it is 
    explicitly present, or is implied by the targetNamespace attribute of a
    contained xs:schema element, and is absent if it is absent.
   
  * The schemaLocation attribute of the xs:import element is copied from the
    schema-location attribute of the xsl:import-schema declaration if present,
    and is absent if it is absent. If there is a contained xs:schema element,
    the effective value of the schemaLocation attribute is a URI referencing a
    document containing a copy of the xs:schema element.
   
  * The base URI of the xs:import element is the same as the base URI of the 
    xsl:import-schema declaration.
   
The schema components included in the in-scope schema components (that is, the
components whose names are available for use within the stylesheet) are the
top-level element and attribute declarations and type definitions that are
available for reference within the synthetic schema document. See [XML Schema
Part 1] (section 4.2.3, References to schema components across namespaces).

[ERR XTSE0220] It is a static error if the synthetic schema document does not
satisfy the constraints described in [XML Schema Part 1] (section 5.1, Errors
in Schema Construction and Structure). This includes, without loss of
generality, conflicts such as multiple definitions of the same name.

Note:

The synthetic schema document does not need to be constructed by a real
implementation. It is purely a mechanism for defining the semantics of 
xsl:import-schema in terms of rules that already exist within the XML Schema
specification. In particular, it implicitly defines the rules that determine
whether the set of xsl:import-schema declarations are mutually consistent.

These rules do not cause names to be imported transitively. The fact that a
name is available for reference within a schema document A does not of itself
make the name available for reference in a stylesheet that imports the target
namespace of schema document A. (See [XML Schema Part 1] section 3.15.3,
Constraints on XML Representations of Schemas.) The stylesheet must import all
the namespaces containing names that it actually references.

The namespace attribute indicates that a schema for the given namespace is
required by the stylesheet. This information may be enough on its own to
enable an implementation to locate the required schema components. The
namespace attribute may be omitted to indicate that a schema for names in no
namespace is being imported. The zero-length string is not a valid namespace
URI, and is therefore not a valid value for the namespace attribute.

The schema-location attribute is a URI Reference that gives a hint indicating
where a schema document or other resource containing the required definitions
may be found. It is likely that a schema-aware XSLT processor will be able to
process a schema document found at this location.

The XML Schema specification gives implementations flexibility in how to
handle multiple imports for the same namespace. Multiple imports do not cause
errors if the definitions do not conflict.

A consequence of these rules is that it is not intrinsically an error if no
schema document can be located for a namespace identified in an 
xsl:import-schema declaration. This will cause an error only if it results in
the stylesheet containing references to names that have not been imported.

An inline schema document (using an xs:schema element as a child of the
xsl:import-schema element) has the same status as an external schema document,
in the sense that it acts as a hint for a source of schema components in the
relevant namespace. To ensure that the inline schema document is always used,
it is advisable to use a target namespace that is unique to this schema
document.

The use of a namespace in an xsl:import-schema declaration does not by itself
associate any namespace prefix with the namespace. If names from the namespace
are used within the stylesheet module then a namespace declaration must be
included in the stylesheet module, in the usual way.

Example: An Inline Schema Document

The following example shows an inline schema document. This declares a simple
type local:yes-no, which the stylesheet then uses in the declaration of a
variable.

The example assumes the namespace declaration xmlns:local="
http://localhost/ns/yes-no"

<xsl:import-schema>
  <xs:schema targetNamespace="http://localhost/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:simpleType name="local:yes-no">
      <xs:restriction base="xs:string">
        <xs:enumeration value="yes"/>
        <xs:enumeration value="no"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:schema>
</xsl:import-schema>

<xs:variable name="condition" select="'yes'" as="local:yes-no"/>

4 Data Model

The data model used by XSLT is the XPath 2.0 and XQuery 1.0 data model (XDM),
as defined in [Data Model]. XSLT operates on source, result and stylesheet
documents using the same data model.

This section elaborates on some particular features of XDM as it is used by
XSLT:

The rules in 4.2 Stripping Whitespace from the Stylesheet and 4.4 Stripping
Whitespace from a Source Tree make use of the concept of a whitespace text
node.

[Definition: A whitespace text node is a text node whose content consists
entirely of whitespace characters (that is, #x09, #x0A, #x0D, or #x20).]

Note:

Features of a source XML document that are not represented in the XDM tree
will have no effect on the operation of an XSLT stylesheet. Examples of such
features are entity references, CDATA sections, character references,
whitespace within element tags, and the choice of single or double quotes
around attribute values.

4.1 XML Versions

The XDM data model defined in [Data Model] is capable of representing either
an XML 1.0 document (conforming to [XML 1.0] and [Namespaces in XML 1.0]) or
an XML 1.1 document (conforming to [XML 1.1] and [Namespaces in XML 1.1]), and
it makes no distinction between the two. In principle, therefore, XSLT 2.0 can
be used with either of these XML versions.

Construction of the XDM tree is outside the scope of this specification, so
XSLT 2.0 places no formal requirements on an XSLT processor to accept input
from either XML 1.0 documents or XML 1.1 documents or both. This specification
does define a serialization capability (see 20 Serialization), though from a
conformance point of view it is an optional feature. Although facilities are
described for serializing the XDM tree as either XML 1.0 or XML 1.1 (and
controlling the choice), there is again no formal requirement on an XSLT
processor to support either or both of these XML versions as serialization
targets.

Because the XDM tree is the same whether the original document was XML 1.0 or
XML 1.1, the semantics of XSLT processing do not depend on the version of XML
used by the original document. There is no reason in principle why all the
input and output documents used in a single transformation must conform to the
same version of XML.

Some of the syntactic constructs in XSLT 2.0 and XPath 2.0, for example the
productions Char^ XML and NCName^ Names, are defined by reference to the XML
and XML Namespaces specifications. There are slight variations between the XML
1.0 and XML 1.1 versions of these productions. Implementations may support
either version; it is recommended that an XSLT 2.0 processor that implements
the 1.1 versions should also provide a mode that supports the 1.0 versions. It
is thus implementation-defined whether the XSLT processor supports XML 1.0
with XML Namespaces 1.0, or XML 1.1 with XML Namespaces 1.1, or supports both
versions at user option.

Note:

The specification referenced as [Namespaces in XML 1.0] was actually published
without a version number.

At the time of writing there is no published version of [XML Schema Part 2]
that references the XML 1.1 specifications. This means that data types such as
xs:NCName and xs:ID are constrained by the XML 1.0 rules, and do not allow the
full range of values permitted by XML 1.1. This situation will not be resolved
until a new version of [XML Schema Part 2] becomes available; in the meantime,
it is recommended that implementers wishing to support XML 1.1 should consult 
[XML Schema 1.0 and XML 1.1] for guidance. An XSLT 2.0 processor that supports
XML 1.1 should implement the rules in later versions of [XML Schema Part 2] as
they become available.

4.2 Stripping Whitespace from the Stylesheet

The tree representing the stylesheet is preprocessed as follows:

 1. All comments and processing instructions are removed.
   
 2. Any text nodes that are now adjacent to each other are merged.
   
 3. Any whitespace text node that satisfies both the following conditions is
    removed from the tree:
   
      + The parent of the text node is not an xsl:text element
       
      + The text node does not have an ancestor element that has an xml:space
        attribute with a value of preserve, unless there is a closer ancestor
        element having an xml:space attribute with a value of default.
       
 4. Any whitespace text node whose parent is one of the following elements is
    removed from the tree, regardless of any xml:space attributes:
   
        xsl:analyze-string
        xsl:apply-imports
        xsl:apply-templates
        xsl:attribute-set
        xsl:call-template
        xsl:character-map
        xsl:choose
        xsl:next-match
        xsl:stylesheet
        xsl:transform
       
 5. Any whitespace text node whose following-sibling node is an xsl:param or 
    xsl:sort element is removed from the tree, regardless of any xml:space
    attributes.
   
[ERR XTSE0260] Within an XSLT element that is required to be empty, any
content other than comments or processing instructions, including any 
whitespace text node preserved using the xml:space="preserve" attribute, is a 
static error.

Note:

Using xml:space="preserve" in parts of the stylesheet that contain sequence
constructors will cause all text nodes in that part of the stylesheet,
including those that contain whitespace only, to be copied to the result of
the sequence constructor. When the result of the sequence constructor is used
to form the content of an element, this can cause errors if such text nodes
are followed by attribute nodes generated using xsl:attribute.

Note:

If an xml:space attribute is specified on a literal result element, it will be
copied to the result tree in the same way as any other attribute.

4.3 Stripping Type Annotations from a Source Tree

[Definition: The term type annotation is used in this specification to refer
to the value returned by the dm:type-name accessor of a node: see Section 5.14
type-name Accessor^DM.]

There is sometimes a requirement to write stylesheets that produce the same
results whether or not the source documents have been validated against a
schema. To achieve this, an option is provided to remove any type annotations
on element and attribute nodes in a source tree, replacing them with an
annotation of xs:untyped in the case of element nodes, and xs:untypedAtomic in
the case of attribute nodes.

Such stripping of type annotations can be requested by specifying
input-type-annotations="strip" on the xsl:stylesheet element. This attribute
has three permitted values: strip, preserve, and unspecified. The default
value is unspecified. Stripping of type annotations takes place if at least
one stylesheet module in the stylesheet specifies input-type-annotations=
"strip".

[ERR XTSE0265] It is a static error if there is a stylesheet module in the 
stylesheet that specifies input-type-annotations="strip" and another 
stylesheet module that specifies input-type-annotations="preserve".

The source trees to which this applies are the same as those affected by 
xsl:strip-space and xsl:preserve-space: see 4.4 Stripping Whitespace from a
Source Tree.

When type annotations are stripped, the following changes are made to the
source tree:

  * The type annotation of every element node is changed to xs:untyped
   
  * The type annotation of every attribute node is changed to xs:untypedAtomic
   
  * The typed value of every element and attribute node is set to be the same
    as its string value, as an instance of xs:untypedAtomic.
   
  * The is-nilled property of every element node is set to false.
   
The values of the is-id and is-idrefs properties are not changed.

Note:

Stripping type annotations does not necessarily return the document to the
state it would be in had validation not taken place. In particular, any
defaulted elements and attributes that were added to the tree by the
validation process will still be present , and elements and attributes
validated as IDs will still be accessible using the id^ FO function.

4.4 Stripping Whitespace from a Source Tree

A source tree supplied as input to the transformation process may contain 
whitespace text nodes that are of no interest, and that do not need to be
retained by the transformation. Conceptually, an XSLT processor makes a copy
of the source tree from which unwanted whitespace text nodes have been
removed. This process is referred to as whitespace stripping.

For the purposes of this section, the term source tree means the document
containing the initial context node, and any document returned by the
functions document, doc^ FO, or collection^FO. It does not include documents
passed as the values of stylesheet parameters or returned from extension
functions.

The stripping process takes as input a set of element names whose child 
whitespace text nodes are to be preserved. The way in which this set of
element names is established using the xsl:strip-space and xsl:preserve-space
declarations is described later in this section.

A whitespace text node is preserved if either of the following apply:

  * The element name of the parent of the text node is in the set of
    whitespace-preserving element names.
   
  * An ancestor element of the text node has an xml:space attribute with a
    value of preserve, and no closer ancestor element has xml:space with a
    value of default.
   
Otherwise, the whitespace text node is stripped.

The xml:space attributes are not removed from the tree.

<!-- Category: declaration -->
<xsl:strip-space
  elements = tokens />

<!-- Category: declaration -->
<xsl:preserve-space
  elements = tokens />

The set of whitespace-preserving element names is specified by xsl:strip-space
and xsl:preserve-space declarations. Whether an element name is included in
the set of whitespace-preserving names is determined by the best match among
all the xsl:strip-space or xsl:preserve-space declarations: it is included if
and only if there is no match or the best match is an xsl:preserve-space
element. The xsl:strip-space and xsl:preserve-space elements each have an
elements attribute whose value is a whitespace-separated list of NameTests^ XP
; an element name matches an xsl:strip-space or xsl:preserve-space element if
it matches one of the NameTests^ XP. An element matches a NameTest^ XP if and
only if the NameTest^ XP would be true for the element as an XPath node test.
When more than one xsl:strip-space and xsl:preserve-space element matches, the
best matching element is determined by the best matching NameTest^ XP. This is
determined in the same way as with template rules:

  * First, any match with lower import precedence than another match is
    ignored.
   
  * Next, any match that has a lower default priority than the default
    priority of another match is ignored.
   
[ERR XTRE0270] It is a recoverable dynamic error if this leaves more than one
match, unless all the matched declarations are equivalent (that is, they are
all xsl:strip-space or they are all xsl:preserve-space). The optional recovery
action is to select, from the matches that are left, the one that occurs last
in declaration order.

If an element in a source document has a type annotation that is a simple type
or a complex type with simple content, then any whitespace text nodes among
its children are preserved, regardless of any xsl:strip-space declarations.
The reason for this is that stripping a whitespace text node from an element
with simple content could make the element invalid: for example, it could
cause the minLength facet to be violated.

Stripping of type annotations happens before stripping of whitespace text
nodes, so this situation will not occur if input-type-annotations="strip" is
specified.

Note:

In [Data Model], processes are described for constructing an XDM tree from an
Infoset or from a PSVI. Those processes deal with whitespace according to
their own rules, and the provisions in this section apply to the resulting
tree. In practice this means that elements that are defined in a DTD or a
Schema to contain element-only content will have whitespace text nodes
stripped, regardless of the xsl:strip-space and xsl:preserve-space
declarations in the stylesheet.

However, source trees are not necessarily constructed using those processes;
indeed, they are not necessarily constructed by parsing XML documents. Nothing
in the XSLT specification constrains how the source tree is constructed, or
what happens to whitespace text nodes during its construction. The provisions
in this section relate only to whitespace text nodes that are present in the
tree supplied as input to the XSLT processor. The XSLT processor cannot
preserve whitespace text nodes unless they were actually present in the
supplied tree.

4.5 Attribute Types and DTD Validation

The mapping from the Infoset to the XDM data model, described in [Data Model],
does not retain attribute types. This means, for example, that an attribute
described in the DTD as having attribute type NMTOKENS will be annotated in 
the XDM tree as xs:untypedAtomic rather than xs:NMTOKENS, and its typed value
will consist of a single xs:untypedAtomic value rather than a sequence of
xs:NMTOKEN values.

Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in
the XDM tree as having the is-id or is-idrefs properties. It is these
properties, rather than any type annotation, that are examined by the
functions id^ FO and idref^ FO described in [Functions and Operators].

4.6 Limits

The XDM data model (see [Data Model]) leaves it to the host language to define
limits. This section describes the limits that apply to XSLT.

Limits on some primitive data types are defined in [XML Schema Part 2]. Other
limits, listed below, are implementation-defined. Note that this does not
necessarily mean that each limit must be a simple constant: it may vary
depending on environmental factors such as available resources.

The following limits are implementation-defined:

 1. For the xs:decimal type, the maximum number of decimal digits (the
    totalDigits facet). This must be at least 18 digits. (Note, however, that
    support for the full value range of xs:unsignedLong requires 20 digits.)
   
 2. For the types xs:date, xs:time, xs:dateTime, xs:gYear, and xs:gYearMonth:
    the range of values of the year component, which must be at least +0001 to
    +9999; and the maximum number of fractional second digits, which must be
    at least 3.
   
 3. For the xs:duration type: the maximum absolute values of the years,
    months, days, hours, minutes, and seconds components.
   
 4. For the xs:yearMonthDuration type: the maximum absolute value, expressed
    as an integer number of months.
   
 5. For the xs:dayTimeDuration type: the maximum absolute value, expressed as
    a decimal number of seconds.
   
 6. For the types xs:string, xs:hexBinary, xs:base64Binary, xs:QName,
    xs:anyURI, xs:NOTATION, and types derived from them: the maximum length of
    the value.
   
 7. For sequences, the maximum number of items in a sequence.
   
4.7 Disable Output Escaping

For backwards compatibility reasons, XSLT 2.0 continues to support the
disable-output-escaping feature introduced in XSLT 1.0. This is an optional
feature and implementations are not required to support it. A new facility,
that of named character maps (see 20.1 Character Maps) is introduced in XSLT
2.0. It provides similar capabilities to disable-output-escaping, but without
distorting the data model.

If an implementation supports the disable-output-escaping attribute of 
xsl:text and xsl:value-of, (see 20.2 Disabling Output Escaping), then the data
model for trees constructed by the processor is augmented with a boolean value
representing the value of this property. This boolean value, however, can be
set only within a final result tree that is being passed to the serializer.

Conceptually, each character in a text node on such a result tree has a
boolean property indicating whether the serializer is to disable the normal
rules for escaping of special characters (for example, outputting of & as &
amp;) in respect of this character or attribute node.

Note:

In practice, the nodes in a final result tree will often be streamed directly
from the XSLT processor to the serializer. In such an implementation,
disable-output-escaping can be viewed not so much a property stored with nodes
in the tree, but rather as additional information passed across the interface
between the XSLT processor and the serializer.

5 Features of the XSLT Language

5.1 Qualified Names

The name of a stylesheet-defined object, specifically a named template, a mode
, an attribute set, a key, a decimal-format, a variable or parameter, a 
stylesheet function, a named output definition, or a character map is
specified as a QName using the syntax for QName^ Names as defined in 
[Namespaces in XML 1.0].

[Definition: A QName is always written in the form (NCName ":")? NCName, that
is, a local name optionally preceded by a namespace prefix. When two QNames
are compared, however, they are considered equal if the corresponding 
expanded-QNames are the same, as described below.]

Because an atomic value of type xs:QName is sometimes referred to loosely as a
QName, this specification also uses the term lexical QName to emphasize that
it is referring to a QName^ Names in its lexical form rather than its expanded
form. This term is used especially when strings containing lexical QNames are
manipulated as run-time values.

[Definition: A lexical QName is a string representing a QName in the form
(NCName ":")? NCName, that is, a local name optionally preceded by a namespace
prefix.]

[Definition: A string in the form of a lexical QName may occur as the value of
an attribute node in a stylesheet module, or within an XPath expression
contained in such an attribute node, or as the result of evaluating an XPath
expression contained in such an attribute node. The element containing this
attribute node is referred to as the defining element of the QName.]

[Definition: An expanded-QName contains a pair of values, namely a local name
and an optional namespace URI. It may also contain a namespace prefix. Two
expanded-QNames are equal if the namespace URIs are the same (or both absent)
and the local names are the same. The prefix plays no part in the comparison,
but is used only if the expanded-QName needs to be converted back to a string.
]

If the QName has a prefix, then the prefix is expanded into a URI reference
using the namespace declarations in effect on its defining element. The 
expanded-QName consisting of the local part of the name and the possibly null
URI reference is used as the name of the object. The default namespace of the
defining element (see Section 6.2 Element Nodes^DM) is not used for unprefixed
names.

There are three cases where the default namespace of the defining element is
used when expanding an unprefixed QName:

 1. Where a QName is used to define the name of an element being constructed.
    This applies both to cases where the name is known statically (that is,
    the name of a literal result element) and to cases where it is computed
    dynamically (the value of the name attribute of the xsl:element
    instruction).
   
 2. The default namespace is used when expanding the first argument of the
    function element-available.
   
 3. The default namespace applies to any unqualified element names appearing
    in the cdata-section-elements attribute of xsl:output or 
    xsl:result-document
   
In the case of an unprefixed QName used as a NameTest within an XPath 
expression (see 5.3 Expressions) , and in certain other contexts, the
namespace to be used in expanding the QName may be specified by means of the
[xsl:]xpath-default-namespace attribute, as specified in 5.2 Unprefixed QNames
in Expressions and Patterns.

[ERR XTSE0280] In the case of a prefixed QName used as the value of an
attribute in the stylesheet, or appearing within an XPath expression in the
stylesheet, it is a static error if the defining element has no namespace node
whose name matches the prefix of the QName.

[ERR XTDE0290] Where the result of evaluating an XPath expression (or an
attribute value template) is required to be a lexical QName, then unless
otherwise specified it is a non-recoverable dynamic error if the defining
element has no namespace node whose name matches the prefix of the lexical
QName. This error may be signaled as a static error if the value of the
expression can be determined statically.

5.2 Unprefixed QNames in Expressions and Patterns

The attribute [xsl:]xpath-default-namespace (see 3.5 Standard Attributes) may
be used on an element in the stylesheet to define the namespace that will be
used for an unprefixed element name or type name within an XPath expression,
and in certain other contexts listed below.

The value of the attribute is the namespace URI to be used.

For any element in the stylesheet, this attribute has an effective value,
which is the value of the [xsl:]xpath-default-namespace on that element or on
the innermost containing element that specifies such an attribute, or the
zero-length string if no containing element specifies such an attribute.

For any element in the stylesheet, the effective value of this attribute
determines the value of the default namespace for element and type names in
the static context of any XPath expression contained in an attribute of that
element (including XPath expressions in attribute value templates). The effect
of this is specified in [XPath 2.0]; in summary, it determines the namespace
used for any unprefixed type name in the SequenceType production, and for any
element name appearing in a path expression or in the SequenceType production.

The effective value of this attribute similarly applies to any of the
following constructs appearing within its scope:

  * any unprefixed element name or type name used in a pattern
   
  * any unprefixed element name used in the elements attribute of the 
    xsl:strip-space or xsl:preserve-space instructions
   
  * any unprefixed element name or type name used in the as attribute of an 
    XSLT element
   
  * any unprefixed type name used in the type attribute of an XSLT element
   
  * any unprefixed type name used in the xsl:type attribute of a literal
    result element.
   
The [xsl:]xpath-default-namespace attribute must be in the XSLT namespace if
and only if its parent element is not in the XSLT namespace.

If the effective value of the attribute is a zero-length string, which will be
the case if it is explicitly set to a zero-length string or if it is not
specified at all, then an unprefixed element name or type name refers to a
name that is in no namespace. The default namespace of the parent element (see
Section 6.2 Element Nodes^DM) is not used.

The attribute does not affect other names, for example function names,
variable names, or template names, or strings that are interpreted as lexical
QNames during stylesheet evaluation, such as the effective value of the name
attribute of xsl:element or the string supplied as the first argument to the 
key function.

5.3 Expressions

XSLT uses the expression language defined by XPath 2.0 [XPath 2.0].
Expressions are used in XSLT for a variety of purposes including:

  * selecting nodes for processing;
   
  * specifying conditions for different ways of processing a node;
   
  * generating text to be inserted in a result tree.
   
[Definition: Within this specification, the term XPath expression, or simply 
expression, means a string that matches the production Expr^ XP defined in 
[XPath 2.0].]

An XPath expression may occur as the value of certain attributes on
XSLT-defined elements, and also within curly brackets in attribute value
templates.

Except where forwards-compatible behavior is enabled (see 3.9
Forwards-Compatible Processing), it is a static error if the value of such an
attribute, or the text between curly brackets in an attribute value template,
does not match the XPath production Expr^ XP, or if it fails to satisfy other
static constraints defined in the XPath specification, for example that all
variable references must refer to variables that are in scope. Error codes are
defined in [XPath 2.0].

The transformation fails with a non-recoverable dynamic error if any XPath 
expression is evaluated and raises a dynamic error. Error codes are defined in
[XPath 2.0].

The transformation fails with a type error if an XPath expression raises a
type error, or if the result of evaluating the XPath expression is evaluated
and raises a type error, or if the XPath processor signals a type error during
static analysis of an expression. Error codes are defined in [XPath 2.0].

[Definition: The context within a stylesheet where an XPath expression appears
may specify the required type of the expression. The required type indicates
the type of the value that the expression is expected to return.] If no
required type is specified, the expression may return any value: in effect,
the required type is then item()*.

[Definition: Except where otherwise indicated, the actual value of an 
expression is converted to the required type using the function conversion
rules. These are the rules defined in [XPath 2.0] for converting the supplied
argument of a function call to the required type of that argument, as defined
in the function signature. The relevant rules are those that apply when XPath
1.0 compatibility mode is set to false.]

This specification also invokes the XPath 2.0 function conversion rules to
convert the result of evaluating an XSLT sequence constructor to a required
type (for example, the sequence constructor enclosed in an xsl:variable, 
xsl:template, or xsl:function element).

Any dynamic error or type error that occurs when applying the function
conversion rules to convert a value to a required type results in the
transformation failing, in the same way as if the error had occurred while
evaluating an expression.

Note:

Note the distinction between the two kinds of error that may occur. Attempting
to convert an integer to a date is a type error, because such a conversion is
never possible. Type errors can be reported statically if they can be detected
statically, whether or not the construct in question is ever evaluated.
Attempting to convert the string 2003-02-29 to a date is a dynamic error
rather than a type error, because the problem is with this particular value,
not with its type. Dynamic errors are reported only if the instructions or
expressions that cause them are actually evaluated.

5.4 The Static and Dynamic Context

XPath defines the concept of an expression context^XP which contains all the
information that can affect the result of evaluating an expression. The
expression context has two parts, the static context^XP, and the dynamic
context^XP. The components that make up the expression context are defined in
the XPath specification (see Section 2.1 Expression Context^XP). This section
describes the way in which these components are initialized when an XPath
expression is contained within an XSLT stylesheet.

As well as providing values for the static and dynamic context components
defined in the XPath specification, XSLT defines additional context components
of its own. These context components are used by XSLT instructions (for
example, xsl:next-match and xsl:apply-imports), and also by the functions in
the extended function library described in this specification.

The following four sections describe:

    5.4.1 Initializing the Static Context
    5.4.2 Additional Static Context Components used by XSLT
    5.4.3 Initializing the Dynamic Context
    5.4.4 Additional Dynamic Context Components used by XSLT
   
5.4.1 Initializing the Static Context

The static context^XP of an XPath expression appearing in an XSLT stylesheet
is initialized as follows. In these rules, the term containing element means
the element within the stylesheet that is the parent of the attribute whose
value contains the XPath expression in question, and the term enclosing
element means the containing element or any of its ancestors.

  * XPath 1.0 compatibility mode is set to true if and only if the containing
    element occurs in part of the stylesheet where backwards compatible
    behavior is enabled (see 3.8 Backwards-Compatible Processing).
   
  * The statically known namespaces^XP are the namespace declarations that are
    in scope for the containing element.
   
  * The default element/type namespace^XP is the namespace defined by the
    [xsl:]xpath-default-namespace attribute on the innermost enclosing element
    that has such an attribute, as described in 5.2 Unprefixed QNames in
    Expressions and Patterns. The value of this attribute is a namespace URI. 
    If there is no [xsl:]xpath-default-namespace attribute on an enclosing
    element, the default namespace for element names and type names is the
    null namespace.
   
  * The default function namespace^XP is the standard function namespace,
    defined in [Functions and Operators]. This means that it is not necessary
    to declare this namespace in the stylesheet, nor is it necessary to use
    the prefix fn (or any other prefix) in calls to the core functions.
   
  * The in-scope schema definitions^XP for the XPath expression are the same
    as the in-scope schema components for the stylesheet, and are as specified
    in 3.13 Built-in Types.
   
  * The in-scope variables^XP are defined by the variable binding elements
    that are in scope for the containing element (see 9 Variables and
    Parameters).
   
  * The function signatures^XP are the core functions defined in [Functions
    and Operators], the constructor functions for all the atomic types in the 
    in-scope schema definitions^XP, the additional functions defined in this
    specification, the stylesheet functions defined in the stylesheet, plus
    any extension functions bound using implementation-defined mechanisms (see
    18 Extensibility and Fallback).
   
    Note:
   
    It follows from the above that a conformant XSLT processor must implement
    the entire library of core functions defined in [Functions and Operators].
   
  * The statically known collations^XP are implementation-defined. However,
    the set of in-scope collations must always include the Unicode codepoint
    collation, defined in Section 7.3 Equality and Comparison of Strings^FO.
   
  * The default collation^XP is defined by the value of the [xsl:]
    default-collation attribute on the innermost enclosing element that has
    such an attribute. For details, see 3.6.1 The default-collation attribute.
   
    [Definition: In this specification the term default collation means the
    collation that is used by XPath operators such as eq and lt appearing in
    XPath expressions within the stylesheet.]
   
    This collation is also used by default when comparing strings in the
    evaluation of the xsl:key and xsl:for-each-group elements. This may also
    (but need not necessarily) be the same as the default collation used for 
    xsl:sort elements within the stylesheet. Collations used by xsl:sort are
    described in 13.1.3 Sorting Using Collations.
   
  * The base URI^XP is the base URI of the containing element. The concept of
    the base URI of a node is defined in Section 5.2 base-uri Accessor^DM
   
5.4.2 Additional Static Context Components used by XSLT

Some of the components of the XPath static context are used also by XSLT
elements. For example, the xsl:sort element makes use of the collations
defined in the static context, and attributes such as type and as may
reference types defined in the in-scope schema components.

Many top-level declarations in a stylesheet, and attributes on the 
xsl:stylesheet element, affect the behavior of instructions within the
stylesheet. Each of these constructs is described in its appropriate place in
this specification.

A number of these constructs are of particular significance because they are
used by functions defined in XSLT, which are added to the library of functions
available for use in XPath expressions within the stylesheet. These are:

  * The set of named keys, used by the key function
   
  * The set of named decimal formats, used by the format-number function
   
  * The values of system properties, used by the system-property function
   
  * The set of available instructions, used by the element-available function
   
5.4.3 Initializing the Dynamic Context

For convenience, the dynamic context is described in two parts: the focus,
which represents the place in the source document that is currently being
processed, and a collection of additional context variables.

A number of functions specified in [Functions and Operators] are defined to be
stable^ FO, meaning that if they are called twice during the same execution
scope^FO, with the same arguments, then they return the same results (see 
Section 1.7 Terminology^FO). In XSLT, the execution of a stylesheet defines
the execution scope. This means, for example, that if the function 
current-dateTime^FO is called repeatedly during a transformation, it produces
the same result each time. By implication, the components of the dynamic
context on which these functions depend are also stable for the duration of
the transformation. Specifically, the following components defined in Section
2.1.2 Dynamic Context^XP must be stable: function implementations, current
dateTime, implicit timezone, available documents, available collections, and 
default collection. The values of global variables and stylesheet parameters
are also stable for the duration of a transformation. The focus is not stable;
the additional dynamic context components defined in 5.4.4 Additional Dynamic
Context Components used by XSLT are also not stable.

As specified in [Functions and Operators], implementations may provide user
options that relax the requirement for the doc^ FO and collection^FO functions
(and therefore, by implication, the document function) to return stable
results. By default, however, the functions must be stable. The manner in
which such user options are provided, if at all, is implementation-defined.

XPath expressions contained in [xsl:]use-when attributes are not considered to
be evaluated "during the transformation" as defined above. For details see 
3.12 Conditional Element Inclusion.

5.4.3.1 Maintaining Position: the Focus

[Definition: When a sequence constructor is evaluated, the processor keeps
track of which items are being processed by means of a set of implicit
variables referred to collectively as the focus.] More specifically, the focus
consists of the following three values:

  * [Definition: The context item is the item currently being processed. An
    item (see [Data Model]) is either an atomic value (such as an integer,
    date, or string), or a node. The context item is initially set to the 
    initial context node supplied when the transformation is invoked (see 2.3
    Initiating a Transformation). It changes whenever instructions such as 
    xsl:apply-templates and xsl:for-each are used to process a sequence of
    items; each item in such a sequence becomes the context item while that
    item is being processed.] The context item is returned by the XPath 
    expression . (dot).
   
  * [Definition: The context position is the position of the context item
    within the sequence of items currently being processed. It changes
    whenever the context item changes. When an instruction such as 
    xsl:apply-templates or xsl:for-each is used to process a sequence of
    items, the first item in the sequence is processed with a context position
    of 1, the second item with a context position of 2, and so on.] The
    context position is returned by the XPath expression position().
   
  * [Definition: The context size is the number of items in the sequence of
    items currently being processed. It changes whenever instructions such as 
    xsl:apply-templates and xsl:for-each are used to process a sequence of
    items; during the processing of each one of those items, the context size
    is set to the count of the number of items in the sequence (or
    equivalently, the position of the last item in the sequence).] The context
    size is returned by the XPath expression last().
   
[Definition: If the context item is a node (as distinct from an atomic value
such as an integer), then it is also referred to as the context node. The
context node is not an independent variable, it changes whenever the context
item changes. When the context item is an atomic value, there is no context
node.] The context node is returned by the XPath expression self::node(), and
it is used as the starting node for all relative path expressions.

Where the containing element of an XPath expression is an instruction or a 
literal result element, the initial context item, context position, and
context size for the XPath expression are the same as the context item, 
context position, and context size for the evaluation of the containing
instruction or literal result element.

In other cases (for example, where the containing element is xsl:sort, 
xsl:with-param, or xsl:key), the rules are given in the specification of the
containing element.

The current function can be used within any XPath expression to select the
item that was supplied as the context item to the XPath expression by the XSLT
processor. Unlike . (dot) this is unaffected by changes to the context item
that occur within the XPath expression. The current function is described in 
16.6.1 current.

On completion of an instruction that changes the focus (such as 
xsl:apply-templates or xsl:for-each), the focus reverts to its previous value.

When a stylesheet function is called, the focus within the body of the
function is initially undefined. The focus is also undefined on initial entry
to the stylesheet if no initial context node is supplied.

When the focus is undefined, evaluation of any expression that references the
context item, context position, or context size results in a non-recoverable
dynamic error [XPDY0002]

The description above gives an outline of the way the focus works. Detailed
rules for the effect of each instruction are given separately with the
description of that instruction. In the absence of specific rules, an
instruction uses the same focus as its parent instruction.

[Definition: A singleton focus based on a node N has the context item (and
therefore the context node) set to N, and the context position and context
size both set to 1 (one).]

5.4.3.2 Other components of the XPath Dynamic Context

The previous section explained how the focus for an XPath expression appearing
in an XSLT stylesheet is initialized. This section explains how the other
components of the dynamic context^XP of an XPath expression are initialized.

  * The dynamic variables^XP are the current values of the in-scope variable
    binding elements.
   
  * The current date and time represents an implementation-dependent point in
    time during processing of the transformation; it does not change during
    the course of the transformation.
   
  * The implicit timezone^XP is implementation-defined.
   
  * The available documents^XP, and the available collections^XP are
    determined as part of the process for initiating a transformation (see 2.3
    Initiating a Transformation).
   
    The available documents^XP are defined as part of the XPath 2.0 dynamic
    context to support the doc^FO function, but this component is also
    referenced by the similar XSLT document function: see 16.1 Multiple Source
    Documents. This variable defines a mapping between URIs passed to the doc^
    FO or document function and the document nodes that are returned.
   
    Note:
   
    Defining this as part of the evaluation context is a formal way of
    specifying that the way in which URIs get turned into document nodes is
    outside the control of the language specification, and depends entirely on
    the run-time environment in which the transformation takes place.
   
    The XSLT-defined document function allows the use of URI references
    containing fragment identifiers. The interpretation of a fragment
    identifier depends on the media type of the resource representation.
    Therefore, the information supplied in available documents^XP for XSLT
    processing must provide not only a mapping from URIs to document nodes as
    required by XPath, but also a mapping from URIs to media types.
   
  * The default collection^XP is implementation-defined. This allows options
    such as setting the default collection to be an empty sequence, or to be
    undefined.
   
5.4.4 Additional Dynamic Context Components used by XSLT

In addition to the values that make up the focus, an XSLT processor maintains
a number of other dynamic context components that reflect aspects of the
evaluation context. These components are fully described in the sections of
the specification that maintain and use them. They are:

  * The current template rule, which is the template rule most recently
    invoked by an xsl:apply-templates, xsl:apply-imports, or xsl:next-match
    instruction: see 6.7 Overriding Template Rules;
   
  * The current mode, which is the mode set by the most recent call of 
    xsl:apply-templates (for a full definition see 6.5 Modes);
   
  * The current group and current grouping key, which provide information
    about the collection of items currently being processed by an 
    xsl:for-each-group instruction: see 14.1 The Current Group and 14.2 The
    Current Grouping Key;
   
  * The current captured substrings: this is a sequence of strings, which is
    maintained when a string is matched against a regular expression using the
    xsl:analyze-string instruction, and which is accessible using the 
    regex-group function: see 15.2 Captured Substrings.
   
  * The output state: this is a flag whose two possible values are final
    output state and temporary output state. This flag indicates whether
    instructions are currently writing to a final result tree or to an
    internal data structure. The initial setting is final output state, and it
    is switched to temporary output state by instructions such as xsl:variable
    . For more details, see 19.1 Creating Final Result Trees.
   
The following non-normative table summarizes the initial state of each of the
components in the evaluation context, and the instructions which cause the
state of the component to change.

+-------------------------------------------------------------------------------------+
| Component  | Initial Setting | Set by                 | Cleared by                  |
|------------+-----------------+------------------------+-----------------------------|
| focus      | singleton focus | xsl:apply-templates,   | calls on stylesheet         |
|            | based on the    | xsl:for-each,          | functions                   |
|            | initial context | xsl:for-each-group,    |                             |
|            | node if         | xsl:analyze-string     |                             |
|            | supplied        |                        |                             |
|------------+-----------------+------------------------+-----------------------------|
| current    | If a named      | xsl:apply-templates,   | xsl:for-each,               |
| template   | template is     | xsl:apply-imports,     | xsl:for-each-group, and     |
| rule       | supplied as the | xsl:next-match         | xsl:analyze-string, and     |
|            | entry point to  |                        | calls on stylesheet         |
|            | the             |                        | functions. Also cleared     |
|            | transformation, |                        | while evaluating global     |
|            | then null;      |                        | variables or default values |
|            | otherwise the   |                        | of stylesheet parameters,   |
|            | initial         |                        | and the sequence            |
|            | template        |                        | constructors contained in   |
|            |                 |                        | xsl:key and xsl:sort.       |
|------------+-----------------+------------------------+-----------------------------|
| current    | the initial     | xsl:apply-templates    | calls on stylesheet         |
| mode       | mode            |                        | functions                   |
|------------+-----------------+------------------------+-----------------------------|
| current    | empty sequence  | xsl:for-each-group     | calls on stylesheet         |
| group      |                 |                        | functions                   |
|------------+-----------------+------------------------+-----------------------------|
| current    | empty sequence  | xsl:for-each-group     | calls on stylesheet         |
| grouping   |                 |                        | functions                   |
| key        |                 |                        |                             |
|------------+-----------------+------------------------+-----------------------------|
| current    | empty sequence  | xsl:matching-substring | xsl:non-matching-substring; |
| captured   |                 |                        | calls on stylesheet         |
| substrings |                 |                        | functions                   |
|------------+-----------------+------------------------+-----------------------------|
| output     | final output    | Set to temporary       | None                        |
| state      | state           | output state by        |                             |
|            |                 | instructions such as   |                             |
|            |                 | xsl:variable,          |                             |
|            |                 | xsl:attribute, etc.,   |                             |
|            |                 | and by calls on        |                             |
|            |                 | stylesheet functions   |                             |
+-------------------------------------------------------------------------------------+

5.5 Patterns

A template rule identifies the nodes to which it applies by means of a
pattern. As well as being used in template rules, patterns are used for
numbering (see 12 Numbering), for grouping (see 14 Grouping), and for
declaring keys (see 16.3 Keys).

[Definition: A pattern specifies a set of conditions on a node. A node that
satisfies the conditions matches the pattern; a node that does not satisfy the
conditions does not match the pattern. The syntax for patterns is a subset of
the syntax for expressions.] As explained in detail below, a node matches a
pattern if the node can be selected by deriving an equivalent expression, and
evaluating this expression with respect to some possible context.

5.5.1 Examples of Patterns

Example: Patterns

Here are some examples of patterns:

  * para matches any para element.
   
  * * matches any element.
   
  * chapter|appendix matches any chapter element and any appendix element.
   
  * olist/entry matches any entry element with an olist parent.
   
  * appendix//para matches any para element with an appendix ancestor element.
   
  * schema-element(us:address) matches any element that is annotated as an
    instance of the type defined by the schema element declaration us:address,
    and whose name is either us:address or the name of another element in its
    substitution group.
   
  * attribute(*, xs:date) matches any attribute annotated as being of type
    xs:date.
   
  * / matches a document node.
   
  * document-node() matches a document node.
   
  * document-node(schema-element(my:invoice)) matches the document node of a
    document whose document element is named my:invoice and matches the type
    defined by the global element declaration my:invoice.
   
  * text() matches any text node.
   
  * node() matches any node other than an attribute node, namespace node, or
    document node.
   
  * id("W33") matches the element with unique ID W33.
   
  * para[1] matches any para element that is the first para child element of
    its parent. It also matches a parentless para element.
   
  * //para matches any para element that has a parent node.
   
  * bullet[position() mod 2 = 0] matches any bullet element that is an
    even-numbered bullet child of its parent.
   
  * div[@class="appendix"]//p matches any p element with a div ancestor
    element that has a class attribute with value appendix.
   
  * @class matches any class attribute (not any element that has a class
    attribute).
   
  * @* matches any attribute node.
   
5.5.2 Syntax of Patterns

[ERR XTSE0340] Where an attribute is defined to contain a pattern, it is a 
static error if the pattern does not match the production Pattern. Every
pattern is a legal XPath expression, but the converse is not true: 2+2 is an
example of a legal XPath expression that is not a pattern. The XPath
expressions that can be used as patterns are those that match the grammar for 
Pattern, given below.

Informally, a Pattern is a set of path expressions separated by |, where each
step in the path expression is constrained to be an AxisStep^ XP that uses
only the child or attribute axes. Patterns may also use the // operator. A 
Predicate^ XP within the PredicateList^ XP in a pattern can contain arbitrary
XPath expressions (enclosed between square brackets) in the same way as a 
predicate^ XP in a path expression.

Patterns may start with an id^ FO or key function call, provided that the
value to be matched is supplied as either a literal or a reference to a 
variable or parameter, and the key name (in the case of the key function) is
supplied as a string literal. These patterns will never match a node in a tree
whose root is not a document node.

If a pattern occurs in part of the stylesheet where backwards compatible
behavior is enabled (see 3.8 Backwards-Compatible Processing), then the
semantics of the pattern are defined on the basis that the equivalent XPath
expression is evaluated with XPath 1.0 compatibility mode set to true.

Patterns

[1]   Pattern                ::=   PathPattern                                
                                                                              
                                   | Pattern '|' PathPattern                  
[2]   PathPattern            ::=   RelativePathPattern                        
                                                                              
                                   | '/' RelativePathPattern?                 
                                   | '//' RelativePathPattern                 
                                   | IdKeyPattern (('/' | '//')               
                                   RelativePathPattern)?                      
[3]   RelativePathPattern    ::=   PatternStep (('/' | '//')                  
                                   RelativePathPattern)?                      
[4]   PatternStep            ::=   PatternAxis? NodeTest^ XP PredicateList^XP 
                                                                              
[5]   PatternAxis            ::=   ('child' '::' | 'attribute' '::' | '@')    
                                                                              
[6]   IdKeyPattern           ::=   'id' '(' IdValue ')'                       
                                                                              
                                   | 'key' '(' StringLiteral^XP ',' KeyValue  
                                   ')'                                        
[7]   IdValue                ::=   StringLiteral^XP | VarRef^ XP              
                                                                              
[8]   KeyValue               ::=   Literal^ XP | VarRef^ XP                   

The constructs NodeTest^ XP, PredicateList^ XP, VarRef^ XP, Literal^ XP, and 
StringLiteral^ XP are part of the XPath expression language, and are defined
in [XPath 2.0].

5.5.3 The Meaning of a Pattern

The meaning of a pattern is defined formally as follows.

First we define the concept of an equivalent expression. In general, the
equivalent expression is the XPath expression that takes the same lexical form
as the pattern as written. However, if the pattern contains a PathPattern that
is a RelativePathPattern, then the first PatternStep PS of this
RelativePathPattern is adjusted to allow it to match a parentless element or
attribute node, as follows:

  * If the NodeTest in PS is document-node() (optionally with arguments), and
    if no explicit axis is specified, then the axis in step PS is taken as
    self rather than child.
   
  * If PS uses the child axis (explicitly or implicitly), and if the NodeTest
    in PS is not document-node() (optionally with arguments), then the axis in
    step PS is replaced by child-or-top, which is defined as follows. If the
    context node is a parentless element, comment, processing-instruction, or
    text node then the child-or-top axis selects the context node; otherwise
    it selects the children of the context node. It is a forwards axis whose
    principal node kind is element.
   
  * If PS uses the attribute axis, then the axis in step PS is replaced by
    attribute-or-top, which is defined as follows. If the context node is an
    attribute node with no parent, then the attribute-or-top axis selects the
    context node; otherwise it selects the attributes of the context node. It
    is a forwards axis whose principal node kind is attribute.
   
The axes child-or-top and attribute-or-top are introduced only for
definitional purposes. They cannot be used explicitly in a user-written
pattern or expression.

Note:

The purpose of these adjustments is to ensure that a pattern such as person
matches any element named person, even if it has no parent; and similarly,
that the pattern @width matches any attribute named width, even a parentless
attribute. The rule also ensures that a pattern using a NodeTest of the form
document-node(...) matches a document node. The pattern node() will match any
element, text node, comment, or processing instruction, whether or not it has
a parent. For backwards compatibility reasons, the pattern node(), when used
without an explicit axis, does not match document nodes, attribute nodes, or
namespace nodes. The rules are also phrased to ensure that positional patterns
of the form para[1] continue to count nodes relative to their parent, if they
have one.

Let the equivalent expression, calculated according to these rules, be EE.

To determine whether a node N matches the pattern, evaluate the expression
root(.)//(EE) with a singleton focus based on N. If the result is a sequence
of nodes that includes N, then node N matches the pattern; otherwise node N
does not match the pattern.

Example: The Semantics of Patterns

The pattern p matches any p element, because a p element will always be
present in the result of evaluating the expression root(.)//(child-or-top::p).
Similarly, / matches a document node, and only a document node, because the
result of the expression root(.)//(/) returns the root node of the tree
containing the context node if and only if it is a document node.

The pattern node() matches all nodes selected by the expression root(.)//
(child-or-top::node()), that is, all element, text, comment, and processing
instruction nodes, whether or not they have a parent. It does not match
attribute or namespace nodes because the expression does not select nodes
using the attribute or namespace axes. It does not match document nodes
because for backwards compatibility reasons the child-or-top axis does not
match a document node.

Although the semantics of patterns are specified formally in terms of
expression evaluation, it is possible to understand pattern matching using a
different model. In a pattern, | indicates alternatives; a pattern with one or
more | separated alternatives matches if any one of the alternatives matches.
A pattern such as book/chapter/section can be examined from right to left. A
node will only match this pattern if it is a section element; and then, only
if its parent is a chapter; and then, only if the parent of that chapter is a
book. When the pattern uses the // operator, one can still read it from right
to left, but this time testing the ancestors of a node rather than its parent.
For example appendix//section matches every section element that has an
ancestor appendix element.

The formal definition, however, is useful for understanding the meaning of a
pattern such as para[1]. This matches any node selected by the expression root
(.)//(child-or-top::para[1]): that is, any para element that is the first para
child of its parent, or a para element that has no parent.

Note:

An implementation, of course, may use any algorithm it wishes for evaluating
patterns, so long as the result corresponds with the formal definition above.
An implementation that followed the formal definition by evaluating the
equivalent expression and then testing the membership of a specific node in
the result would probably be very inefficient.

5.5.4 Errors in Patterns

Any dynamic error or type error that occurs during the evaluation of a pattern
against a particular node is treated as a recoverable error even if the error
would not be recoverable under other circumstances. The optional recovery
action is to treat the pattern as not matching that node.

Note:

The reason for this provision is that it is difficult for the stylesheet
author to predict which predicates in a pattern will actually be evaluated. In
the case of match patterns in template rules, it is not even possible to
predict which patterns will be evaluated against a particular node. Making
errors in patterns recoverable enables an implementation, if it chooses to do
so, to report such errors while stylesheets are under development, while
masking them if they occur during production running.

One particular optimization is required by this specification: for a 
PathPattern that starts with / or // or with an IdKeyPattern, the result of
testing this pattern against a node in a tree whose root is not a document
node must be a non-match, rather than a dynamic error. This rule applies to
each PathPattern within a Pattern.

Note:

Without the above rule, any attempt to apply templates to a parentless element
node would create the risk of a dynamic error if the stylesheet has a template
rule specifying match="/".

5.6 Attribute Value Templates

[Definition: In an attribute that is designated as an attribute value template
, such as an attribute of a literal result element, an expression can be used
by surrounding the expression with curly brackets ({})].

An attribute value template consists of an alternating sequence of fixed parts
and variable parts. A variable part consists of an XPath expression enclosed
in curly brackets ({}). A fixed part may contain any characters, except that a
left curly bracket must be written as {{ and a right curly bracket must be
written as }}.

Note:

An expression within a variable part may contain an unescaped curly bracket
within a StringLiteral^ XP or within a comment.

[ERR XTSE0350] It is a static error if an unescaped left curly bracket appears
in a fixed part of an attribute value template without a matching right curly
bracket.

It is a static error if the string contained between matching curly brackets
in an attribute value template does not match the XPath production Expr^ XP,
or if it contains other XPath static errors. The error is signaled using the
appropriate XPath error code.

[ERR XTSE0370] It is a static error if an unescaped right curly bracket occurs
in a fixed part of an attribute value template.

[Definition: The result of evaluating an attribute value template is referred
to as the effective value of the attribute.] The effective value is the string
obtained by concatenating the expansions of the fixed and variable parts:

  * The expansion of a fixed part is obtained by replacing any double curly
    brackets ({{ or }}) by the corresponding single curly bracket.
   
  * The expansion of a variable part is obtained by evaluating the enclosed
    XPath expression and converting the resulting value to a string. This
    conversion is done using the rules given in 5.7.2 Constructing Simple
    Content.
   
Note:

This process can generate dynamic errors, for example if the sequence contains
an element with a complex content type (which cannot be atomized).

If backwards compatible behavior is enabled for the attribute, the rules for
converting the value of the expression to a string are modified as follows.
After atomizing the result of the expression, all items other than the first
item in the resulting sequence are discarded, and the effective value is
obtained by converting the first item in the sequence to a string. If the
atomized sequence is empty, the result is a zero-length string.

Curly brackets are not treated specially in an attribute value in an XSLT 
stylesheet unless the attribute is specifically designated as one that permits
an attribute value template; in an element syntax summary, the value of such
attributes is surrounded by curly brackets.

Note:

Not all attributes are designated as attribute value templates. Attributes
whose value is an expression or pattern, attributes of declaration elements
and attributes that refer to named XSLT objects are generally not designated
as attribute value templates (an exception is the format attribute of 
xsl:result-document). Namespace declarations are not XDM attribute nodes and
are therefore never treated as attribute value templates.

Example: Attribute Value Templates

The following example creates an img result element from a photograph element
in the source; the value of the src and width attributes are computed using
XPath expressions enclosed in attribute value templates:

<xsl:variable name="image-dir" select="'/images'"/>

<xsl:template match="photograph">
  <img src="{$image-dir}/{href}" width="{size/@width}"/>
</xsl:template>

With this source

<photograph>
  <href>headquarters.jpg</href>
  <size width="300"/>
</photograph>

the result would be

<img src="/images/headquarters.jpg" width="300"/>

Example: Producing a Space-Separated List

The following example shows how the values in a sequence are output as a
space-separated list. The following literal result element:

<temperature readings="{10.32, 5.50, 8.31}"/>

produces the output node:

<temperature readings="10.32 5.5 8.31"/>

Curly brackets are not recognized recursively inside expressions.

Example: Curly Brackets can not be Nested

For example:

<a href="#{id({@ref})/title}">

is not allowed. Instead, use simply:

<a href="#{id(@ref)/title}">

5.7 Sequence Constructors

[Definition: A sequence constructor is a sequence of zero or more sibling
nodes in the stylesheet that can be evaluated to return a sequence of nodes
and atomic values. The way that the resulting sequence is used depends on the
containing instruction.]

Many XSLT elements, and also literal result elements, are defined to take a 
sequence constructor as their content.

Four kinds of nodes may be encountered in a sequence constructor:

  * Text nodes appearing in the stylesheet (if they have not been removed in
    the process of whitespace stripping: see 4.2 Stripping Whitespace from the
    Stylesheet) are copied to create a new parentless text node in the result
    sequence.
   
  * Literal result elements are evaluated to create a new parentless element
    node, having the same expanded-QName as the literal result element, which
    is added to the result sequence: see 11.1 Literal Result Elements
   
  * XSLT instructions produce a sequence of zero, one, or more items as their
    result. These items are added to the result sequence. For most XSLT
    instructions, these items are nodes, but some instructions (xsl:sequence
    and xsl:copy-of) can also produce atomic values. Several instructions,
    such as xsl:element, return a newly constructed parentless node (which may
    have its own attributes, namespaces, children, and other descendants).
    Other instructions, such as xsl:if, pass on the items produced by their
    own nested sequence constructors. The xsl:sequence instruction may return
    atomic values, or existing nodes.
   
  * Extension instructions (see 18.2 Extension Instructions) also produce a
    sequence of items as their result. The items in this sequence are added to
    the result sequence.
   
There are several ways the result of a sequence constructor may be used.

  * The sequence may be bound to a variable or returned from a stylesheet
    function, in which case it becomes available as a value to be manipulated
    in arbitrary ways by XPath expressions. The sequence is bound to a
    variable when the sequence constructor appears within one of the elements 
    xsl:variable, xsl:param, or xsl:with-param, when this instruction has an
    as attribute. The sequence is returned from a stylesheet function when the
    sequence constructor appears within the xsl:function element.
   
    Note:
   
    This will typically expose to the stylesheet elements, attributes, and
    other nodes that have not yet been attached to a parent node in a result
    tree. The semantics of XPath expressions when applied to parentless nodes
    are well-defined; however, such expressions should be used with care. For
    example, the expression / causes a type error if the root of the tree
    containing the context node is not a document node..
   
    Parentless attribute nodes require particular care because they have no
    namespace nodes associated with them. A parentless attribute node is not
    permitted to contain namespace-sensitive content (for example, a QName or
    an XPath expression) because there is no information enabling the prefix
    to be resolved to a namespace URI. Parentless attributes can be useful in
    an application (for example, they provide an alternative to the use of
    attribute sets: see 10.2 Named Attribute Sets) but they need to be handled
    with care.
   
  * The sequence may be returned as the result of the containing element. This
    happens when the instruction containing the sequence constructor is 
    xsl:analyze-string, xsl:apply-imports, xsl:apply-templates, 
    xsl:call-template, xsl:choose, xsl:fallback, xsl:for-each, 
    xsl:for-each-group, xsl:if, xsl:matching-substring, xsl:next-match, 
    xsl:non-matching-substring, xsl:otherwise, xsl:perform-sort, xsl:sequence,
    or xsl:when
   
  * The sequence may be used to construct the content of a new element or
    document node. This happens when the sequence constructor appears as the
    content of a literal result element, or of one of the instructions 
    xsl:copy, xsl:element, xsl:document, xsl:result-document, or xsl:message.
    It also happens when the sequence constructor is contained in one of the
    elements xsl:variable, xsl:param, or xsl:with-param, when this instruction
    has no as attribute. For details, see 5.7.1 Constructing Complex Content.
   
  * The sequence may be used to construct the string value of an attribute
    node, text node, namespace node, comment node, or processing instruction
    node. This happens when the sequence constructor is contained in one of
    the elements xsl:attribute, xsl:value-of, xsl:namespace, xsl:comment, or 
    xsl:processing-instruction. For details, see 5.7.2 Constructing Simple
    Content.
   
Note:

The term sequence constructor replaces template as used in XSLT 1.0. The
change is made partly for clarity (to avoid confusion with template rules and 
named templates), but also to reflect a more formal definition of the
semantics. Whereas XSLT 1.0 described a template as a sequence of instructions
that write to the result tree, XSLT 2.0 describes a sequence constructor as
something that can be evaluated to return a sequence of items; what happens to
these items depends on the containing instruction.

5.7.1 Constructing Complex Content

This section describes how the sequence obtained by evaluating a sequence
constructor may be used to construct the children of a newly constructed
document node, or the children, attributes and namespaces of a newly
constructed element node. The sequence of items may be obtained by evaluating
the sequence constructor contained in an instruction such as xsl:copy, 
xsl:element, xsl:document, xsl:result-document, or a literal result element.

When constructing the content of an element, the inherit-namespaces attribute
of the xsl:element or xsl:copy instruction, or the xsl:inherit-namespaces
property of the literal result element, determines whether namespace nodes are
to be inherited. The effect of this attribute is described in the rules that
follow.

The sequence is processed as follows (applying the rules in the order they are
listed):

 1. The containing instruction may generate attribute nodes and/or namespace
    nodes, as specified in the rules for the individual instruction. For
    example, these nodes may be produced by expanding an [xsl:]
    use-attribute-sets attribute, or by expanding the attributes of a literal
    result element. Any such nodes are prepended to the sequence produced by
    evaluating the sequence constructor.
   
 2. Any atomic value in the sequence is cast to a string.
   
    Note:
   
    Casting from xs:QName or xs:NOTATION to xs:string always succeeds, because
    these values retain a prefix for this purpose. However, there is no
    guarantee that the prefix used will always be meaningful in the context
    where the resulting string is used.
   
 3. Any consecutive sequence of strings within the result sequence is
    converted to a single text node, whose string value contains the content
    of each of the strings in turn, with a single space (#x20) used as a
    separator between successive strings.
   
 4. Any document node within the result sequence is replaced by a sequence
    containing each of its children, in document order.
   
 5. Zero-length text nodes within the result sequence are removed.
   
 6. Adjacent text nodes within the result sequence are merged into a single
    text node.
   
 7. Invalid namespace and attribute nodes are detected as follows.
   
    [ERR XTDE0410] It is a non-recoverable dynamic error if the result
    sequence used to construct the content of an element node contains a
    namespace node or attribute node that is preceded in the sequence by a
    node that is neither a namespace node nor an attribute node.
   
    [ERR XTDE0420] It is a non-recoverable dynamic error if the result
    sequence used to construct the content of a document node contains a
    namespace node or attribute node.
   
    [ERR XTDE0430] It is a non-recoverable dynamic error if the result
    sequence contains two or more namespace nodes having the same name but
    different string values (that is, namespace nodes that map the same prefix
    to different namespace URIs).
   
    [ERR XTDE0440] It is a non-recoverable dynamic error if the result
    sequence contains a namespace node with no name and the element node being
    constructed has a null namespace URI (that is, it is an error to define a
    default namespace when the element is in no namespace).
   
 8. If the result sequence contains two or more namespace nodes with the same
    name (or no name) and the same string value (that is, two namespace nodes
    mapping the same prefix to the same namespace URI), then all but one of
    the duplicate nodes are discarded.
   
    Note:
   
    Since the order of namespace nodes is undefined, it is not significant
    which of the duplicates is retained.
   
 9. If an attribute A in the result sequence has the same name as another
    attribute B that appears later in the result sequence, then attribute A is
    discarded from the result sequence.
   
10. Each node in the resulting sequence is attached as a namespace, attribute,
    or child of the newly constructed element or document node. Conceptually
    this involves making a deep copy of the node; in practice, however,
    copying the node will only be necessary if the existing node can be
    referenced independently of the parent to which it is being attached. When
    copying an element or processing instruction node, its base URI property
    is changed to be the same as that of its new parent, unless it has an
    xml:base attribute (see [XML Base]) that overrides this. If the copied
    element has an xml:base attribute, its base URI is the value of that
    attribute, resolved (if it is relative) against the base URI of the new
    parent node.
   
11. If the newly constructed node is an element node, then namespace fixup is
    applied to this node, as described in 5.7.3 Namespace Fixup.
   
12. If the newly constructed node is an element node, and if namespaces are
    inherited, then each namespace node of the newly constructed element
    (including any produced as a result of the namespace fixup process) is
    copied to each descendant element of the newly constructed element, unless
    that element or an intermediate element already has a namespace node with
    the same name (or absence of a name) or that descendant element or an
    intermediate element is in no namespace and the namespace node has no name
    .
   
Example: A Sequence Constructor for Complex Content

Consider the following stylesheet fragment:

<td>
  <xsl:attribute name="valign">top</xsl:attribute>
  <xsl:value-of select="@description"/>
</td>

This fragment consists of a literal result element td, containing a sequence
constructor that consists of two instructions: xsl:attribute and xsl:value-of.
The sequence constructor is evaluated to produce a sequence of two nodes: a
parentless attribute node, and a parentless text node. The td instruction
causes a td element to be created; the new attribute therefore becomes an
attribute of the new td element, while the text node created by the 
xsl:value-of instruction becomes a child of the td element (unless it is
zero-length, in which case it is discarded).

Example: Space Separators in Element Content

Consider the following stylesheet fragment:

<doc>
  <e><xsl:sequence select="1 to 5"/></e>
  <f>
    <xsl:for-each select="1 to 5">
      <xsl:value-of select="."/>
    </xsl:for-each>
  </f>
</doc>

This produces the output (when indented):

<doc>
  <e>1 2 3 4 5</e>
  <f>12345</f>
</doc>

The difference between the two cases is that for the e element, the sequence
constructor generates a sequence of five atomic values, which are therefore
separated by spaces. For the f element, the content is a sequence of five text
nodes, which are concatenated without space separation.

It is important to be aware of the distinction between xsl:sequence, which
returns the value of its select expression unchanged, and xsl:value-of, which
constructs a text node.

5.7.2 Constructing Simple Content

The xsl:attribute, xsl:comment, xsl:processing-instruction, xsl:namespace, and
xsl:value-of elements create nodes that cannot have children. Specifically,
the xsl:attribute instruction creates an attribute node, xsl:comment creates a
comment node, xsl:processing-instruction creates a processing instruction
node, xsl:namespace creates a namespace node, and xsl:value-of creates a text
node. The string value of the new node is constructed using either the select
attribute of the instruction, or the sequence constructor that forms the
content of the instruction. The select attribute allows the content to be
specified by means of an XPath expression, while the sequence constructor
allows it to be specified by means of a sequence of XSLT instructions. The
select attribute or sequence constructor is evaluated to produce a result
sequence, and the string value of the new node is derived from this result
sequence according to the rules below.

These rules are also used to compute the effective value of an attribute value
template. In this case the sequence being processed is the result of
evaluating an XPath expression enclosed between curly brackets, and the
separator is a single space character.

 1. Zero-length text nodes in the sequence are discarded.
   
 2. Adjacent text nodes in the sequence are merged into a single text node.
   
 3. The sequence is atomized.
   
 4. Every value in the atomized sequence is cast to a string.
   
 5. The strings within the resulting sequence are concatenated, with a
    (possibly zero-length) separator inserted between successive strings. The
    default separator is a single space. In the case of xsl:attribute and 
    xsl:value-of, a different separator can be specified using the separator
    attribute of the instruction; it is permissible for this to be a
    zero-length string, in which case the strings are concatenated with no
    separator. In the case of xsl:comment, xsl:processing-instruction, and 
    xsl:namespace , and when expanding an attribute value template, the
    default separator cannot be changed.
   
 6. In the case of xsl:processing-instruction, any leading spaces in the
    resulting string are removed.
   
 7. The resulting string forms the string value of the new attribute,
    namespace, comment, processing-instruction, or text node.
   
Example: Space Separators in Attribute Content

Consider the following stylesheet fragment:

<doc>
  <xsl:attribute name="e" select="1 to 5"/>
  <xsl:attribute name="f">
    <xsl:for-each select="1 to 5">
      <xsl:value-of select="."/>
    </xsl:for-each>
  </xsl:attribute>
</doc>

This produces the output:

<doc e="1 2 3 4 5" f="12345"/>

The difference between the two cases is that for the e attribute, the sequence
constructor generates a sequence of five atomic values, which are therefore
separated by spaces. For the f attribute, the content is supplied as a
sequence of five text nodes, which are concatenated without space separation.

Specifying separator="" on the first xsl:attribute instruction would cause the
attribute value to be e="12345". A separator attribute on the second 
xsl:attribute instruction would have no effect, since the separator only
affects the way adjacent atomic values are handled: separators are never
inserted between adjacent text nodes.

Note:

If an attribute value template contains a sequence of fixed and variable
parts, no additional whitespace is inserted between the expansions of the
fixed and variable parts. For example, the effective value of the attribute a=
"chapters{4 to 6}" is a="chapters4 5 6".

5.7.3 Namespace Fixup

In a tree supplied to or constructed by an XSLT processor, the constraints
relating to namespace nodes that are specified in [Data Model] must be
satisfied. For example

  * If an element node has an expanded-QName with a non-null namespace URI,
    then that element node must have at least one namespace node whose string
    value is the same as that namespace URI.
   
  * If an element node has an attribute node whose expanded-QName has a
    non-null namespace URI, then the element must have at least one namespace
    node whose string value is the same as that namespace URI and whose name
    is non-empty.
   
  * Every element must have a namespace node whose expanded-QName has
    local-part xml and whose string value is 
    http://www.w3.org/XML/1998/namespace. The namespace prefix xml must not be
    associated with any other namespace URI, and the namespace URI 
    http://www.w3.org/XML/1998/namespace must not be associated with any other
    prefix.
   
  * A namespace node must not have the name xmlns.
   
[Definition: The rules for the individual XSLT instructions that construct a 
result tree (see 11 Creating Nodes and Sequences) prescribe some of the
situations in which namespace nodes are written to the tree. These rules,
however, are not sufficient to ensure that the prescribed constraints are
always satisfied. The XSLT processor must therefore add additional namespace
nodes to satisfy these constraints. This process is referred to as namespace
fixup.]

The actual namespace nodes that are added to the tree by the namespace fixup
process are implementation-dependent, provided firstly, that at the end of the
process the above constraints must all be satisfied, and secondly, that a
namespace node must not be added to the tree unless the namespace node is
necessary either to satisfy these constraints, or to enable the tree to be
serialized using the original namespace prefixes from the source document or 
stylesheet.

Namespace fixup must not result in an element having multiple namespace nodes
with the same name.

Namespace fixup may, if necessary to resolve conflicts, change the namespace
prefix contained in the QName value that holds the name of an element or
attribute node. This includes the option to add or remove a prefix. However,
namespace fixup must not change the prefix component contained in a value of
type xs:QName or xs:NOTATION that forms the typed value of an element or
attribute node.

Note:

Namespace fixup is not used to create namespace declarations for xs:QName or
xs:NOTATION values appearing in the content of an element or attribute.

Where values acquire such types as the result of validation, namespace fixup
does not come into play, because namespace fixup happens before validation: in
this situation, it is the user's responsibility to ensure that the element
being validated has the required namespace nodes to enable validation to
succeed.

Where existing elements are copied along with their existing type annotations
(validation="preserve") the rules require that existing namespace nodes are
also copied, so that any namespace-sensitive values remain valid.

Where existing attributes are copied along with their existing type
annotations, the rules of the XDM data model require that a parentless
attribute node cannot contain a namespace-sensitive typed value; this means
that it is an error to copy an attribute using validation="preserve" if it
contains namespace-sensitive content.

[ERR XTDE0485] It is a non-recoverable dynamic error if namespace fixup is
performed on an element that contains among the typed values of the element
and its attributes two values of type xs:QName or xs:NOTATION containing
conflicting namespace prefixes, that is, two values that use the same prefix
to refer to different namespace URIs.

Namespace fixup is applied to every element that is constructed using a 
literal result element, or one of the instructions xsl:element, xsl:copy, or 
xsl:copy-of. An implementation is not required to perform namespace fixup for
elements in any source document, that is, for a document in the initial input
sequence, documents loaded using the document, doc^ FO or collection^FO
function, documents supplied as the value of a stylesheet parameter, or
documents returned by an extension function or extension instruction.

Note:

A source document (an input document, a document returned by the document, doc
^FO or collection^FO functions, a document returned by an extension function
or extension instruction, or a document supplied as a stylesheet parameter) is
required to satisfy the constraints described in [Data Model], including the
constraints imposed by the namespace fixup process. The effect of supplying a
pseudo-document that does not meet these constraints is undefined.

In an Infoset (see [XML Information Set]) created from a document conforming
to [Namespaces in XML 1.0], it will always be true that if a parent element
has an in-scope namespace with a non-empty namespace prefix, then its child
elements will also have an in-scope namespace with the same namespace prefix,
though possibly with a different namespace URI. This constraint is removed in 
[Namespaces in XML 1.1]. XSLT 2.0 supports the creation of result trees that
do not satisfy this constraint: the namespace fixup process does not add a
namespace node to an element merely because its parent node in the result tree
has such a namespace node. However, the process of constructing the children
of a new element, which is described in 5.7.1 Constructing Complex Content,
does cause the namespaces of a parent element to be inherited by its children
unless this is prevented using [xsl:]inherit-namespaces="no" on the
instruction that creates the parent element.

Note:

This has implications on serialization, defined in [XSLT and XQuery
Serialization]. It means that it is possible to create final result trees that
cannot be faithfully serialized as XML 1.0 documents. When such a result tree
is serialized as XML 1.0, namespace declarations written for the parent
element will be inherited by its child elements as if the corresponding
namespace nodes were present on the child element, except in the case of the
default namespace, which can be undeclared using the construct xmlns="". When
the same result tree is serialized as XML 1.1, however, it is possible to
undeclare any namespace on the child element (for example, xmlms:foo="") to
prevent this inheritance taking place.

5.8 URI References

[Definition: Within this specification, the term URI Reference, unless
otherwise stated, refers to a string in the lexical space of the xs:anyURI
data type as defined in [XML Schema Part 2].] Note that this is a wider
definition than that in [RFC3986]: in particular, it is designed to
accommodate Internationalized Resource Identifiers (IRIs) as described in 
[RFC3987], and thus allows the use of non-ASCII characters without escaping.

URI References are used in XSLT with three main roles:

    As namespace URIs
    As collation URIs
    As identifiers for resources such as stylesheet modules; these resources
    are typically accessible using a protocol such as HTTP. Examples of such
    identifiers are the URIs used in the href attributes of xsl:import, 
    xsl:include, and xsl:result-document.
   
The rules for namespace URIs are given in [Namespaces in XML 1.0] and 
[Namespaces in XML 1.1]. Those specifications deprecate the use of relative
URIs as namespace URIs.

The rules for collation URIs are given in [Functions and Operators].

URI references used to identify external resources must conform to the same
rules as the locator attribute (href) defined in section 5.4 of [XLink]. If
the URI reference is relative, then it is resolved (unless otherwise
specified) against the base URI of the containing element node, according to
the rules of [RFC3986], after first escaping all characters that need to be
escaped to make it a valid RFC3986 URI reference. (But a relative URI in the
href attribute of xsl:result-document is resolved against the Base Output URI
.)

Other URI references appearing in an XSLT stylesheet document, for example the
system identifiers of external entities or the value of the xml:base
attribute, must follow the rules in their respective specifications.

6 Template Rules

Template rules define the processing that can be applied to nodes that match a
particular pattern.

6.1 Defining Templates

<!-- Category: declaration -->
<xsl:template
  match? = pattern
  name? = qname
  priority? = number
  mode? = tokens
  as? = sequence-type>
  <!-- Content: (xsl:param*, sequence-constructor) -->
</xsl:template>

[Definition: An xsl:template declaration defines a template, which contains a 
sequence constructor for creating nodes and/or atomic values. A template can
serve either as a template rule, invoked by matching nodes against a pattern,
or as a named template, invoked explicitly by name. It is also possible for
the same template to serve in both capacities.]

[ERR XTSE0500] An xsl:template element must have either a match attribute or a
name attribute, or both. An xsl:template element that has no match attribute 
must have no mode attribute and no priority attribute.

If an xsl:template element has a match attribute, then it is a template rule.
If it has a name attribute, then it is a named template.

A template may be invoked in a number of ways, depending on whether it is a 
template rule, a named template, or both. The result of invoking the template
is the result of evaluating the sequence constructor contained in the 
xsl:template element (see 5.7 Sequence Constructors).

If an as attribute is present, the as attribute defines the required type of
the result. The result of evaluating the sequence constructor is then
converted to the required type using the function conversion rules. If no as
attribute is specified, the default value is item()*, which permits any value.
No conversion then takes place.

[ERR XTTE0505] It is a type error if the result of evaluating the sequence
constructor cannot be converted to the required type.

6.2 Defining Template Rules

This section describes template rules. Named templates are described in 10.1
Named Templates.

A template rule is specified using the xsl:template element with a match
attribute. The match attribute is a Pattern that identifies the node or nodes
to which the rule applies. The result of applying the template rule is the
result of evaluating the sequence constructor contained in the xsl:template
element, with the matching node used as the context node.

Example: A simple Template Rule

For example, an XML document might contain:

This is an <emph>important</emph> point.

The following template rule matches emph elements and produces a fo:wrapper
element with a font-weight property of bold.

<xsl:template match="emph">
  <fo:wrapper font-weight="bold" xmlns:fo="http://www.w3.org/1999/XSL/Format">
    <xsl:apply-templates/>
  </fo:wrapper>
</xsl:template>

A template rule is evaluated when an xsl:apply-templates instruction selects a
node that matches the pattern specified in the match attribute. The 
xsl:apply-templates instruction is described in the next section. If several
template rules match a selected node, only one of them is evaluated, as
described in 6.4 Conflict Resolution for Template Rules.

6.3 Applying Template Rules

<!-- Category: instruction -->
<xsl:apply-templates
  select? = expression
  mode? = token>
  <!-- Content: (xsl:sort | xsl:with-param)* -->
</xsl:apply-templates>

The xsl:apply-templates instruction takes as input a sequence of nodes
(typically nodes in a source tree), and produces as output a sequence of
items; these will often be nodes to be added to a result tree.

If the instruction has one or more xsl:sort children, then the input sequence
is sorted as described in 13 Sorting. The result of this sort is referred to
below as the sorted sequence; if there are no xsl:sort elements, then the
sorted sequence is the same as the input sequence.

Each node in the input sequence is processed by finding a template rule whose 
pattern matches that node. If there is more than one, the best among them is
chosen, using rules described in 6.4 Conflict Resolution for Template Rules.
If there is no template rule whose pattern matches the node, a built-in
template rule is used (see 6.6 Built-in Template Rules). The chosen template
rule is evaluated. The rule that matches the Nth node in the sorted sequence
is evaluated with that node as the context item, with N as the context
position, and with the length of the sorted sequence as the context size. Each
template rule that is evaluated produces a sequence of items as its result.
The resulting sequences (one for each node in the sorted sequence) are then
concatenated, to form a single sequence. They are concatenated retaining the
order of the nodes in the sorted sequence. The final concatenated sequence
forms the result of the xsl:apply-templates instruction.

Example: Applying Template Rules

Suppose the source document is as follows:

<message>Proceed <emph>at once</emph> to the exit!</message>

This can be processed using the two template rules shown below.

<xsl:template match="message">
  <p>
    <xsl:apply-templates select="child::node()"/>
  </p>
</xsl:template>

<xsl:template match="emph">
  <b>
    <xsl:apply-templates select="child::node()"/>
  </b>
</xsl:template>

There is no template rule for the document node; the built-in template rule
for this node will cause the message element to be processed. The template
rule for the message element causes a p element to be written to the result
tree; the contents of this p element are constructed as the result of the 
xsl:apply-templates instruction. This instruction selects the three child
nodes of the message element (a text node containing the value "Proceed ", an
emph element node, and a text node containing the value " to the exit!"). The
two text nodes are processed using the built-in template rule for text nodes,
which returns a copy of the text node. The emph element is processed using the
explicit template rule that specifies match="emph".

When the emph element is processed, this template rule constructs a b element.
The contents of the b element are constructed by means of another 
xsl:apply-templates instruction, which in this case selects a single node (the
text node containing the value "at once"). This is again processed using the
built-in template rule for text nodes, which returns a copy of the text node.

The final result of the match="message" template rule thus consists of a p
element node with three children: a text node containing the value "Proceed ",
a b element that is the parent of a text node containing the value "at once",
and a text node containing the value " to the exit!". This result tree might
be serialized as:

<p>Proceed <b>at once</b> to the exit!</p>

The default value of the select attribute is child::node(), which causes all
the children of context node to be processed.

[ERR XTTE0510] It is a type error if an xsl:apply-templates instruction with
no select attribute is evaluated when the context item is not a node.

A select attribute can be used to process nodes selected by an expression
instead of processing all children. The value of the select attribute is an 
expression. The expression must evaluate to a sequence of nodes (it can
contain zero, one, or more nodes).

[ERR XTTE0520] It is a type error if the sequence returned by the select
expression contains an item that is not a node.

Note:

In XSLT 1.0, the select attribute selected a set of nodes, which by default
were processed in document order. In XSLT 2.0, it selects a sequence of nodes.
In cases that would have been valid in XSLT 1.0, the expression will return a
sequence of nodes in document order, so the effect is the same.

Example: Applying Templates to Selected Nodes

The following example processes all of the given-name children of the author
elements that are children of author-group:

<xsl:template match="author-group">
  <fo:wrapper>
    <xsl:apply-templates select="author/given-name"/>
  </fo:wrapper>
</xsl:template>

Example: Applying Templates to Nodes that are not Descendants

It is also possible to process elements that are not descendants of the
context node. This example assumes that a department element has group
children and employee descendants. It finds an employee's department and then
processes the group children of the department.

<xsl:template match="employee">
  <fo:block>
    Employee <xsl:apply-templates select="name"/> belongs to group
    <xsl:apply-templates select="ancestor::department/group"/>
  </fo:block>
</xsl:template>

Example: Matching by Schema-Defined Types

It is possible to write template rules that are matched according to the
schema-defined type of an element or attribute. The following example applies
different formatting to the children of an element depending on their type:

<xsl:template match="product">
  <table>
    <xsl:apply-templates select="*"/>
  </table>
</xsl:template>

<xsl:template match="product/*" priority="3">
  <tr>
    <td><xsl:value-of select="name()"/></td>
    <td><xsl:next-match/></td>
  </tr>
</xsl:template>

<xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2">  
  <xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/>
</xsl:template>

<xsl:template match="product/element(*, xs:date)" priority="2">
  <xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/>
</xsl:template>

<xsl:template match="product/*" priority="1.5">
  <xsl:value-of select="."/>
</xsl:template>

The xsl:next-match instruction is described in 6.7 Overriding Template Rules.

Example: Re-ordering Elements in the Result Tree

Multiple xsl:apply-templates elements can be used within a single template to
do simple reordering. The following example creates two HTML tables. The first
table is filled with domestic sales while the second table is filled with
foreign sales.

<xsl:template match="product">
  <table>
    <xsl:apply-templates select="sales/domestic"/>
  </table>
  <table>
    <xsl:apply-templates select="sales/foreign"/>
  </table>
</xsl:template>

Example: Processing Recursive Structures

It is possible for there to be two matching descendants where one is a
descendant of the other. This case is not treated specially: both descendants
will be processed as usual.

For example, given a source document

<doc><div><div></div></div></doc>

the rule

<xsl:template match="doc">
  <xsl:apply-templates select=".//div"/>
</xsl:template>

will process both the outer div and inner div elements.

This means that if the template rule for the div element processes its own
children, then these grandchildren will be processed more than once, which is
probably not what is required. The solution is to process one level at a time
in a recursive descent, by using select="div" in place of select=".//div"

Note:

The xsl:apply-templates instruction is most commonly used to process nodes
that are descendants of the context node. Such use of xsl:apply-templates
cannot result in non-terminating processing loops. However, when 
xsl:apply-templates is used to process elements that are not descendants of
the context node, the possibility arises of non-terminating loops. For
example,

<xsl:template match="foo">
  <xsl:apply-templates select="."/>
</xsl:template>

Implementations may be able to detect such loops in some cases, but the
possibility exists that a stylesheet may enter a non-terminating loop that an
implementation is unable to detect. This may present a denial of service
security risk.

6.4 Conflict Resolution for Template Rules

It is possible for a node in a source document to match more than one template
rule. When this happens, only one template rule is evaluated for the node. The
template rule to be used is determined as follows:

 1. First, only the matching template rule or rules with the highest import
    precedence are considered. Other matching template rules with lower
    precedence are eliminated from consideration.
   
 2. Next, of the remaining matching rules, only those with the highest
    priority are considered. Other matching template rules with lower priority
    are eliminated from consideration. The priority of a template rule is
    specified by the priority attribute on the xsl:template declaration.
   
    [ERR XTSE0530] The value of this attribute must conform to the rules for
    the xs:decimal type defined in [XML Schema Part 2]. Negative values are
    permitted..
   
    [Definition: If no priority attribute is specified on the xsl:template
    element, a default priority is computed, based on the syntax of the
    pattern supplied in the match attribute.] The rules are as follows:
   
      + If the pattern contains multiple alternatives separated by | , then
        the template rule is treated equivalently to a set of template rules,
        one for each alternative. However, it is not an error if a node
        matches more than one of the alternatives.
       
      + If the pattern has the form /, then the priority is −0.5.
       
      + If the pattern has the form of a QName optionally preceded by a 
        PatternAxis or has the form processing-instruction( StringLiteral^XP)
        or processing-instruction(NCName^ Names) optionally preceded by a 
        PatternAxis, then the priority is 0.
       
      + If the pattern has the form of an ElementTest^XP or AttributeTest^XP,
        optionally preceded by a PatternAxis, then the priority is as shown in
        the table below. In this table, the symbols E, A, and T represent an
        arbitrary element name, attribute name, and type name respectively,
        while the symbol * represents itself. The presence or absence of the 
        symbol ? following a type name does not affect the priority.
       
        +--------------------------------------------------------------------+
        | Format            | Priority | Notes                               |
        |-------------------+----------+-------------------------------------|
        | element()         | −0.5     | (equivalent to *)                   |
        |-------------------+----------+-------------------------------------|
        | element(*)        | −0.5     | (equivalent to *)                   |
        |-------------------+----------+-------------------------------------|
        | attribute()       | −0.5     | (equivalent to @*)                  |
        |-------------------+----------+-------------------------------------|
        | attribute(*)      | −0.5     | (equivalent to @*)                  |
        |-------------------+----------+-------------------------------------|
        | element(E)        | 0        | (equivalent to E)                   |
        |-------------------+----------+-------------------------------------|
        | element(*,T)      | 0        | (matches by type only)              |
        |-------------------+----------+-------------------------------------|
        | attribute(A)      | 0        | (equivalent to @A)                  |
        |-------------------+----------+-------------------------------------|
        | attribute(*,T)    | 0        | (matches by type only)              |
        |-------------------+----------+-------------------------------------|
        | element(E,T)      | 0.25     | (matches by name and type)          |
        |-------------------+----------+-------------------------------------|
        | schema-element(E) | 0.25     | (matches by substitution group and  |
        |                   |          | type)                               |
        |-------------------+----------+-------------------------------------|
        | attribute(A,T)    | 0.25     | (matches by name and type)          |
        |-------------------+----------+-------------------------------------|
        | schema-attribute  | 0.25     | (matches by name and type)          |
        | (A)               |          |                                     |
        +--------------------------------------------------------------------+
      + If the pattern has the form of a DocumentTest^XP, then if it includes
        no ElementTest^XP or SchemaElementTest^XP the priority is −0.5. If it
        does include an ElementTest^XP or SchemaElementTest^XP, then the
        priority is the same as the priority of that ElementTest^XP or 
        SchemaElementTest^XP, computed according to the table above.
       
      + If the pattern has the form NCName^ Names:* or *:NCName^ Names,
        optionally preceded by a PatternAxis, then the priority is −0.25.
       
      + If the pattern is any other NodeTest^ XP, optionally preceded by a 
        PatternAxis, then the priority is −0.5.
       
      + Otherwise, the priority is 0.5.
       
    Note:
   
    In many cases this means that highly selective patterns have higher
    priority than less selective patterns. The most common kind of pattern (a
    pattern that tests for a node of a particular kind, with a particular 
    expanded-QName or a particular type) has priority 0. The next less
    specific kind of pattern (a pattern that tests for a node of a particular
    kind and an expanded-QName with a particular namespace URI) has priority
    −0.25. Patterns less specific than this (patterns that just test for nodes
    of a given kind) have priority −0.5. Patterns that specify both the name
    and the required type have a priority of +0.25, putting them above
    patterns that only specify the name or the type. Patterns more specific
    than this, for example patterns that include predicates or that specify
    the ancestry of the required node, have priority 0.5.
   
    However, it is not invariably true that a more selective pattern has
    higher priority than a less selective pattern. For example, the priority
    of the pattern node()[self::*] is higher than that of the pattern salary. 
    Similarly, the patterns attribute(*, xs:decimal) and attribute(*,
    xs:short) have the same priority, despite the fact that the latter pattern
    matches a subset of the nodes matched by the former. Therefore, to achieve
    clarity in a stylesheet it is good practice to allocate explicit
    priorities.
   
[ERR XTRE0540] It is a recoverable dynamic error if the conflict resolution
algorithm for template rules leaves more than one matching template rule. The 
optional recovery action is to select, from the matching template rules that
are left, the one that occurs last in declaration order.

6.5 Modes

[Definition: Modes allow a node in a source tree to be processed multiple
times, each time producing a different result. They also allow different sets
of template rules to be active when processing different trees, for example
when processing documents loaded using the document function (see 16.1
Multiple Source Documents) or when processing temporary trees.]

[Definition: There is always a default mode available. The default mode is an
unnamed mode, and it is used when no mode attribute is specified on an 
xsl:apply-templates instruction.]

Every mode other than the default mode is identified by a QName.

A template rule is applicable to one or more modes. The modes to which it is
applicable are defined by the mode attribute of the xsl:template element. If
the attribute is omitted, then the template rule is applicable to the default
mode. If the attribute is present, then its value must be a non-empty
whitespace-separated list of tokens, each of which defines a mode to which the
template rule is applicable. Each token must be one of the following:

  * a QName, which is expanded as described in 5.1 Qualified Names to define
    the name of the mode
   
  * the token #default, to indicate that the template rule is applicable to
    the default mode
   
  * the token #all, to indicate that the template rule is applicable to all
    modes (that is, to the default mode and to every mode that is named in an 
    xsl:apply-templates instruction or xsl:template declaration anywhere in
    the stylesheet).
   
[ERR XTSE0550] It is a static error if the list is empty, if the same token is
included more than once in the list, if the list contains an invalid token, or
if the token #all appears together with any other value.

The xsl:apply-templates element also has an optional mode attribute. The value
of this attribute must either be a QName, which is expanded as described in 
5.1 Qualified Names to define the name of a mode, or the token #default, to
indicate that the default mode is to be used, or the token #current, to
indicate that the current mode is to be used. If the attribute is omitted, the
default mode is used.

When searching for a template rule to process each node selected by the 
xsl:apply-templates instruction, only those template rules that are applicable
to the selected mode are considered.

[Definition: At any point in the processing of a stylesheet, there is a 
current mode. When the transformation is initiated, the current mode is the 
default mode, unless a different initial mode has been supplied, as described
in 2.3 Initiating a Transformation. Whenever an xsl:apply-templates
instruction is evaluated, the current mode becomes the mode selected by this
instruction.] When a stylesheet function is called, the current mode becomes
the default mode. No other instruction changes the current mode. On completion
of the xsl:apply-templates instruction, or on return from a stylesheet
function call, the current mode reverts to its previous value. The current
mode is used when an xsl:apply-templates instruction uses the syntax mode="#
current"; it is also used by the xsl:apply-imports and xsl:next-match
instructions (see 6.7 Overriding Template Rules).

6.6 Built-in Template Rules

When a node is selected by xsl:apply-templates and there is no template rule
in the stylesheet that can be used to process that node, a built-in template
rule is evaluated instead.

The built-in template rules apply to all modes.

The built-in rule for document nodes and element nodes is equivalent to
calling xsl:apply-templates with no select attribute, and with the mode
attribute set to #current. If the built-in rule was invoked with parameters,
those parameters are passed on in the implicit xsl:apply-templates
instruction.

Example: Using a Built-In Template Rule

For example, suppose the stylesheet contains the following instruction:

<xsl:apply-templates select="title" mode="mm">
  <xsl:with-param name="init" select="10"/>
</xsl:apply-templates>

If there is no explicit template rule that matches the title element, then the
following implicit rule is used:

<xsl:template match="title" mode="#all">
  <xsl:param name="init"/>
  <xsl:apply-templates mode="#current">
    <xsl:with-param name="init" select="$init"/>
  </xsl:apply-templates>
</xsl:template>

The built-in template rule for text and attribute nodes returns a text node
containing the string value of the context node. It is effectively:

<xsl:template match="text()|@*" mode="#all">
  <xsl:value-of select="string(.)"/>
</xsl:template>

Note:

This text node may have a string value that is zero-length.

The built-in template rule for processing instructions and comments does
nothing (it returns the empty sequence).

<xsl:template match="processing-instruction()|comment()" mode="#all"/>

The built-in template rule for namespace nodes is also to do nothing. There is
no pattern that can match a namespace node, so the built-in template rule is
always used when xsl:apply-templates selects a namespace node.

The built-in template rules have lower import precedence than all other
template rules. Thus, the stylesheet author can override a built-in template
rule by including an explicit template rule.

6.7 Overriding Template Rules

<!-- Category: instruction -->
<xsl:apply-imports>
  <!-- Content: xsl:with-param* -->
</xsl:apply-imports>

<!-- Category: instruction -->
<xsl:next-match>
  <!-- Content: (xsl:with-param | xsl:fallback)* -->
</xsl:next-match>

A template rule that is being used to override another template rule (see 6.4
Conflict Resolution for Template Rules) can use the xsl:apply-imports or 
xsl:next-match instruction to invoke the overridden template rule. The 
xsl:apply-imports instruction only considers template rules in imported
stylesheet modules; the xsl:next-match instruction considers all other
template rules of lower import precedence and/or priority. Both instructions
will invoke the built-in template rule for the node (see 6.6 Built-in Template
Rules) if no other template rule is found.

[Definition: At any point in the processing of a stylesheet, there may be a 
current template rule. Whenever a template rule is chosen as a result of
evaluating xsl:apply-templates, xsl:apply-imports, or xsl:next-match, the
template rule becomes the current template rule for the evaluation of the
rule's sequence constructor. When an xsl:for-each, xsl:for-each-group, or 
xsl:analyze-string instruction is evaluated, or when evaluating a sequence
constructor contained in an xsl:sort or xsl:key element, or when a stylesheet
function is called (see 10.3 Stylesheet Functions), the current template rule
becomes null for the evaluation of that instruction or function.]

The current template rule is not affected by invoking named templates (see 
10.1 Named Templates) or named attribute sets (see 10.2 Named Attribute Sets).
While evaluating a global variable or the default value of a stylesheet
parameter (see 9.5 Global Variables and Parameters) the current template rule
is null.

Note:

These rules ensure that when xsl:apply-imports or xsl:next-match is called,
the context item is the same as when the current template rule was invoked,
and is always a node.

Both xsl:apply-imports and xsl:next-match search for a template rule that
matches the context node, and that is applicable to the current mode (see 6.5
Modes). In choosing a template rule, they use the usual criteria such as the
priority and import precedence of the template rules, but they consider as
candidates only a subset of the template rules in the stylesheet. This subset
differs between the two instructions:

  * The xsl:apply-imports instruction considers as candidates only those
    template rules contained in stylesheet levels that are descendants in the 
    import tree of the stylesheet level that contains the current template
    rule.
   
    Note:
   
    This is not the same as saying that the search considers all template
    rules whose import precedence is lower than that of the current template
    rule.
   
  * The xsl:next-match instruction considers as candidates all those template
    rules that come after the current template rule in the ordering of
    template rules implied by the conflict resolution rules given in 6.4
    Conflict Resolution for Template Rules. That is, it considers all template
    rules with lower import precedence than the current template rule, plus
    the template rules that are at the same import precedence that have lower
    priority than the current template rule. If the processor has recovered
    from the error that occurs when two matching template rules have the same
    import precedence and priority, then it also considers all matching
    template rules with the same import precedence and priority that occur
    before the current template rule in declaration order.
   
    Note:
   
    As explained in 6.4 Conflict Resolution for Template Rules, a template
    rule whose match pattern contains multiple alternatives separated by | is
    treated equivalently to a set of template rules, one for each alternative.
    This means that where the same node matches more than one alternative, and
    the alternatives have different priority, it is possible for an 
    xsl:next-match instruction to cause the current template rule to be
    invoked recursively. This situation does not occur when the alternatives
    have the same priority.
   
If no matching template rule is found that satisfies these criteria, the
built-in template rule for the node kind is used (see 6.6 Built-in Template
Rules).

An xsl:apply-imports or xsl:next-match instruction may use xsl:with-param
child elements to pass parameters to the chosen template rule (see 10.1.1
Passing Parameters to Templates). It also passes on any tunnel parameters as
described in 10.1.2 Tunnel Parameters.

[ERR XTDE0560] It is a non-recoverable dynamic error if xsl:apply-imports or 
xsl:next-match is evaluated when the current template rule is null.

Example: Using xsl:apply-imports

For example, suppose the stylesheet doc.xsl contains a template rule for
example elements:

<xsl:template match="example">
  <pre><xsl:apply-templates/></pre>
</xsl:template>

Another stylesheet could import doc.xsl and modify the treatment of example
elements as follows:

<xsl:import href="doc.xsl"/>

<xsl:template match="example">
  <div style="border: solid red">
     <xsl:apply-imports/>
  </div>
</xsl:template>

The combined effect would be to transform an example into an element of the
form:

<div style="border: solid red"><pre>...</pre></div>

An xsl:fallback instruction appearing as a child of an xsl:next-match
instruction is ignored by an XSLT 2.0 processor, but can be used to define
fallback behavior when the stylesheet is processed by an XSLT 1.0 processor in
forwards-compatible mode.

7 Repetition

<!-- Category: instruction -->
<xsl:for-each
  select = expression>
  <!-- Content: (xsl:sort*, sequence-constructor) -->
</xsl:for-each>

The xsl:for-each instruction processes each item in a sequence of items,
evaluating the sequence constructor within the xsl:for-each instruction once
for each item in that sequence.

The select attribute is required, and the expression must evaluate to a
sequence, called the input sequence. If there is an xsl:sort element present
(see 13 Sorting) the input sequence is sorted to produce a sorted sequence.
Otherwise, the sorted sequence is the same as the input sequence.

The xsl:for-each instruction contains a sequence constructor. The sequence
constructor is evaluated once for each item in the sorted sequence, with the 
focus set as follows:

  * The context item is the item being processed. If this is a node, it will
    also be the context node. If it is not a node, there will be no context
    node: that is, any attempt to reference the context node will result in a 
    non-recoverable dynamic error.
   
  * The context position is the position of this item in the sorted sequence.
   
  * The context size is the size of the sorted sequence (which is the same as
    the size of the input sequence).
   
For each item in the input sequence, evaluating the sequence constructor
produces a sequence of items (see 5.7 Sequence Constructors). These output
sequences are concatenated; if item Q follows item P in the sorted sequence,
then the result of evaluating the sequence constructor with Q as the context
item is concatenated after the result of evaluating the sequence constructor
with P as the context item. The result of the xsl:for-each instruction is the
concatenated sequence of items.

Note:

With XSLT 1.0, the selected nodes were processed in document order. With XSLT
2.0, XPath expressions that would have been valid under XPath 1.0 (such as
path expressions and union expressions) will return a sequence of nodes that
is already in document order, so backwards compatibility is maintained.

Example: Using xsl:for-each

For example, given an XML document with this structure

<customers>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
</customers>

the following would create an HTML document containing a table with a row for
each customer element

<xsl:template match="/">
  <html>
    <head>
      <title>Customers</title>
    </head>
    <body>
      <table>
        <tbody>
          <xsl:for-each select="customers/customer">
            <tr>
              <th>
                <xsl:apply-templates select="name"/>
              </th>
              <xsl:for-each select="order">
                <td>
                  <xsl:apply-templates/>
                </td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </tbody>
      </table>
    </body>
  </html>
</xsl:template>

8 Conditional Processing

There are two instructions in XSLT that support conditional processing: xsl:if
and xsl:choose. The xsl:if instruction provides simple if-then conditionality;
the xsl:choose instruction supports selection of one choice when there are
several possibilities.

8.1 Conditional Processing with xsl:if

<!-- Category: instruction -->
<xsl:if
  test = expression>
  <!-- Content: sequence-constructor -->
</xsl:if>

The xsl:if element has a mandatory test attribute, which specifies an 
expression. The content is a sequence constructor.

The result of the xsl:if instruction depends on the effective boolean value^XP
of the expression in the test attribute. The rules for determining the
effective boolean value of an expression are given in [XPath 2.0]: they are
the same as the rules used for XPath conditional expressions.

If the effective boolean value of the expression is true, then the sequence
constructor is evaluated (see 5.7 Sequence Constructors), and the resulting
node sequence is returned as the result of the xsl:if instruction; otherwise, 
the sequence constructor is not evaluated, and the empty sequence is returned.

Example: Using xsl:if

In the following example, the names in a group of names are formatted as a
comma separated list:

<xsl:template match="namelist/name">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>

The following colors every other table row yellow:

<xsl:template match="item">
  <tr>
    <xsl:if test="position() mod 2 = 0">
       <xsl:attribute name="bgcolor">yellow</xsl:attribute>
    </xsl:if>
    <xsl:apply-templates/>
  </tr>
</xsl:template>

8.2 Conditional Processing with xsl:choose

<!-- Category: instruction -->
<xsl:choose>
  <!-- Content: (xsl:when+, xsl:otherwise?) -->
</xsl:choose>

<xsl:when
  test = expression>
  <!-- Content: sequence-constructor -->
</xsl:when>

<xsl:otherwise>
  <!-- Content: sequence-constructor -->
</xsl:otherwise>

The xsl:choose element selects one among a number of possible alternatives. It
consists of a sequence of one or more xsl:when elements followed by an
optional xsl:otherwise element. Each xsl:when element has a single attribute,
test, which specifies an expression. The content of the xsl:when and 
xsl:otherwise elements is a sequence constructor.

When an xsl:choose element is processed, each of the xsl:when elements is
tested in turn (that is, in the order that the elements appear in the
stylesheet), until one of the xsl:when elements is satisfied. If none of the 
xsl:when elements is satisfied, then the xsl:otherwise element is considered,
as described below.

An xsl:when element is satisfied if the effective boolean value^XP of the 
expression in its test attribute is true. The rules for determining the
effective boolean value of an expression are given in [XPath 2.0]: they are
the same as the rules used for XPath conditional expressions.

The content of the first, and only the first, xsl:when element that is
satisfied is evaluated, and the resulting sequence is returned as the result
of the xsl:choose instruction. If no xsl:when element is satisfied, the
content of the xsl:otherwise element is evaluated, and the resulting sequence
is returned as the result of the xsl:choose instruction. If no xsl:when
element is satisfied, and no xsl:otherwise element is present, the result of
the xsl:choose instruction is an empty sequence.

Only the sequence constructor of the selected xsl:when or xsl:otherwise
instruction is evaluated. The test expressions for xsl:when instructions after
the selected one are not evaluated.

Example: Using xsl:choose

The following example enumerates items in an ordered list using arabic
numerals, letters, or roman numerals depending on the depth to which the
ordered lists are nested.

<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>

9 Variables and Parameters

[Definition: The two elements xsl:variable and xsl:param are referred to as 
variable-binding elements ].

[Definition: The xsl:variable element declares a variable, which may be a 
global variable or a local variable.]

[Definition: The xsl:param element declares a parameter, which may be a 
stylesheet parameter, a template parameter, or a function parameter. A
parameter is a variable with the additional property that its value can be set
by the caller when the stylesheet, the template, or the function is invoked.]

[Definition: A variable is a binding between a name and a value. The value of
a variable is any sequence (of nodes and/or atomic values), as defined in 
[Data Model].]

9.1 Variables

<!-- Category: declaration -->
<!-- Category: instruction -->
<xsl:variable
  name = qname
  select? = expression
  as? = sequence-type>
  <!-- Content: sequence-constructor -->
</xsl:variable>

The xsl:variable element has a required name attribute, which specifies the
name of the variable. The value of the name attribute is a QName, which is
expanded as described in 5.1 Qualified Names.

The xsl:variable element has an optional as attribute, which specifies the 
required type of the variable. The value of the as attribute is a SequenceType
^ XP, as defined in [XPath 2.0].

[Definition: The value of the variable is computed using the expression given
in the select attribute or the contained sequence constructor, as described in
9.3 Values of Variables and Parameters. This value is referred to as the 
supplied value of the variable.] If the xsl:variable element has a select
attribute, then the sequence constructor must be empty.

If the as attribute is specified, then the supplied value of the variable is
converted to the required type, using the function conversion rules.

[ERR XTTE0570] It is a type error if the supplied value of a variable cannot
be converted to the required type.

If the as attribute is omitted, the supplied value of the variable is used
directly, and no conversion takes place.

9.2 Parameters

<!-- Category: declaration -->
<xsl:param
  name = qname
  select? = expression
  as? = sequence-type
  required? = "yes" | "no"
  tunnel? = "yes" | "no">
  <!-- Content: sequence-constructor -->
</xsl:param>

The xsl:param element may be used as a child of xsl:stylesheet, to define a
parameter to the transformation; or as a child of xsl:template to define a
parameter to a template, which may be supplied when the template is invoked
using xsl:call-template, xsl:apply-templates, xsl:apply-imports or 
xsl:next-match; or as a child of xsl:function to define a parameter to a
stylesheet function, which may be supplied when the function is called from an
XPath expression.

The xsl:param element has a required name attribute, which specifies the name
of the parameter. The value of the name attribute is a QName, which is
expanded as described in 5.1 Qualified Names.

[ERR XTSE0580] It is a static error if two parameters of a template or of a
stylesheet function have the same name.

Note:

For rules concerning stylesheet parameters, see 9.5 Global Variables and
Parameters. Local variables may shadow template parameters and function
parameters: see 9.7 Scope of Variables.

The supplied value of the parameter is the value supplied by the caller. If no
value was supplied by the caller, and if the parameter is not mandatory, then
the supplied value is computed using the expression given in the select
attribute or the contained sequence constructor, as described in 9.3 Values of
Variables and Parameters. If the xsl:param element has a select attribute,
then the sequence constructor must be empty.

Note:

This specification does not dictate whether and when the default value of a
parameter is evaluated. For example, if the default is specified as <xsl:param
name="p"><foo/></xsl:param>, then it is not specified whether a distinct foo
element node will be created on each invocation of the template, or whether
the same foo element node will be used for each invocation. However, it is
permissible for the default value to depend on the values of other parameters,
or on the evaluation context, in which case the default must effectively be
evaluated on each invocation.

The xsl:param element has an optional as attribute, which specifies the 
required type of the parameter. The value of the as attribute is a 
SequenceType^ XP, as defined in [XPath 2.0].

If the as attribute is specified, then the supplied value of the parameter is
converted to the required type, using the function conversion rules.

[ERR XTTE0590] It is a type error if the conversion of the supplied value of a
parameter to its required type fails.

If the as attribute is omitted, the supplied value of the parameter is used
directly, and no conversion takes place.

The optional required attribute may be used to indicate that a parameter is
mandatory. This attribute may be specified for stylesheet parameters and for 
template parameters; it must not be specified for function parameters, which
are always mandatory. A parameter is mandatory if it is a function parameter
or if the required attribute is present and has the value yes. Otherwise, the
parameter is optional. If the parameter is mandatory, then the xsl:param
element must be empty and must not have a select attribute.

[ERR XTTE0600] If a default value is given explicitly, that is, if there is
either a select attribute or a non-empty sequence constructor, then it is a 
type error if the default value cannot be converted to the required type,
using the function conversion rules.

If an optional parameter has no select attribute and has an empty sequence
constructor, and if there is no as attribute, then the default value of the
parameter is a zero length string.

[ERR XTDE0610] If an optional parameter has no select attribute and has an
empty sequence constructor, and if there is an as attribute, then the default
value of the parameter is an empty sequence. If the empty sequence is not a
valid instance of the required type defined in the as attribute, then the
parameter is treated as a required parameter, which means that it is a 
non-recoverable dynamic error if the caller supplies no value for the
parameter.

Note:

The effect of these rules is that specifying <xsl:param name="p" as="xs:date"
select="2"/> is an error, but if the default value of the parameter is never
used, then the processor has discretion whether or not to report the error. By
contrast, <xsl:param name="p" as="xs:date"/> is treated as if required="yes"
had been specified: the empty sequence is not a valid instance of xs:date, so
in effect there is no default value and the parameter is therefore treated as
being mandatory.

The optional tunnel attribute may be used to indicate that a parameter is a 
tunnel parameter. The default is no; the value yes may be specified only for 
template parameters. Tunnel parameters are described in 10.1.2 Tunnel
Parameters

9.3 Values of Variables and Parameters

A variable-binding element may specify the supplied value of the variable or 
parameter in four different ways.

  * If the variable-binding element has a select attribute, then the value of
    the attribute must be an expression and the supplied value of the variable
    is the value that results from evaluating the expression. In this case,
    the content of the variable-binding element must be empty.
   
  * If the variable-binding element has empty content and has neither a select
    attribute nor an as attribute, then the supplied value of the variable is
    a zero-length string. Thus
   
    <xsl:variable name="x"/>
    
    is equivalent to
   
    <xsl:variable name="x" select="''"/>
    
  * If a variable-binding element has no select attribute and has non-empty
    content (that is, the variable-binding element has one or more child
    nodes), and has no as attribute, then the content of the variable-binding
    element specifies the supplied value. The content of the variable-binding
    element is a sequence constructor; a new document is constructed with a
    document node having as its children the sequence of nodes that results
    from evaluating the sequence constructor and then applying the rules given
    in 5.7.1 Constructing Complex Content. The value of the variable is then a
    singleton sequence containing this document node. For further information,
    see 9.4 Creating implicit document nodes.
   
  * If a variable-binding element has an as attribute but no select attribute,
    then the supplied value is the sequence that results from evaluating the
    (possibly empty) sequence constructor contained within the
    variable-binding element (see 5.7 Sequence Constructors).
   
These combinations are summarized in the table below.

+----------------------------------------------------------------------------+
| select    | as        | content | Effect                                   |
| attribute | attribute |         |                                          |
|-----------+-----------+---------+------------------------------------------|
| present   | absent    | empty   | Value is obtained by evaluating the      |
|           |           |         | select attribute                         |
|-----------+-----------+---------+------------------------------------------|
| present   | present   | empty   | Value is obtained by evaluating the      |
|           |           |         | select attribute, adjusted to the type   |
|           |           |         | required by the as attribute             |
|-----------+-----------+---------+------------------------------------------|
| present   | absent    | present | Static error                             |
|-----------+-----------+---------+------------------------------------------|
| present   | present   | present | Static error                             |
|-----------+-----------+---------+------------------------------------------|
| absent    | absent    | empty   | Value is a zero-length string            |
|-----------+-----------+---------+------------------------------------------|
| absent    | present   | empty   | Value is an empty sequence, provided the |
|           |           |         | as attribute permits an empty sequence   |
|-----------+-----------+---------+------------------------------------------|
| absent    | absent    | present | Value is a document node whose content   |
|           |           |         | is obtained by evaluating the sequence   |
|           |           |         | constructor                              |
|-----------+-----------+---------+------------------------------------------|
| absent    | present   | present | Value is obtained by evaluating the      |
|           |           |         | sequence constructor, adjusted to the    |
|           |           |         | type required by the as attribute        |
+----------------------------------------------------------------------------+

[ERR XTSE0620] It is a static error if a variable-binding element has a select
attribute and has non-empty content.

Example: Values of Variables

The value of the following variable is the sequence of integers (1, 2, 3):

<xsl:variable name="i" as="xs:integer*" select="1 to 3"/>

The value of the following variable is an integer, assuming that the attribute
@size exists, and is annotated either as an integer, or as xs:untypedAtomic:

<xsl:variable name="i" as="xs:integer" select="@size"/>

The value of the following variable is a zero-length string:

<xsl:variable name="z"/>

The value of the following variable is document node containing an empty
element as a child:

<xsl:variable name="doc"><c/></xsl:variable>

The value of the following variable is sequence of integers (2, 4, 6):

<xsl:variable name="seq" as="xs:integer*">
  <xsl:for-each select="1 to 3">
    <xsl:sequence select=".*2"/>
  </xsl:for-each>
</xsl:variable>

The value of the following variable is sequence of parentless attribute nodes:

<xsl:variable name="attset" as="attribute()+">
  <xsl:attribute name="x">2</xsl:attribute>
  <xsl:attribute name="y">3</xsl:attribute>
  <xsl:attribute name="z">4</xsl:attribute>    
</xsl:variable>

The value of the following variable is an empty sequence:

<xsl:variable name="empty" as="empty-sequence()"/>

The actual value of the variable depends on the supplied value, as described
above, and the required type, which is determined by the value of the as
attribute.

Example: Pitfalls with Numeric Predicates

When a variable is used to select nodes by position, be careful not to do:

<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="td[$n]"/>

This will output the values of all the td elements, space-separated (or in
backwards compatibility mode, the value of the first td element), because the
variable n will be bound to a node, not a number. Instead, do one of the
following:

<xsl:variable name="n" select="2"/>
...
<xsl:value-of select="td[$n]"/>

or

<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="td[position()=$n]"/>

or

<xsl:variable name="n" as="xs:integer">2</xsl:variable>
...
<xsl:value-of select="td[$n]"/>

9.4 Creating implicit document nodes

A document node is created implicitly when evaluating an xsl:variable, 
xsl:param, or xsl:with-param element that has non-empty content and that has
no as attribute. This element is referred to as the variable-binding element.
The value of the variable is a single node, the document node of the temporary
tree. The content of the document node is formed from the result of evaluating
the sequence constructor contained within the variable-binding element, as
described in 5.7.1 Constructing Complex Content.

Note:

The construct:

<xsl:variable name="tree">
  <a/>
</xsl:variable>

can be regarded as a shorthand for:

<xsl:variable name="tree" as="document-node()">
  <xsl:document validation="preserve">
    <a/>
  </xsl:document>  
</xsl:variable>

The base URI of the document node is taken from the base URI of the variable
binding element in the stylesheet. (See Section 5.2 base-uri Accessor^DM in 
[Data Model])

No document-level validation takes place (which means, for example, that there
is no checking that ID values are unique). However, type annotations on nodes
within the new tree are copied unchanged.

Note:

The base URI of other nodes in the tree is determined by the rules for
constructing complex content. The effect of these rules is that the base URI
of a node in the temporary tree is determined as if all the nodes in the
temporary tree came from a single entity whose URI was the base URI of the 
variable-binding element. Thus, the base URI of the document node will be
equal to the base URI of the variable-binding element; an xml:base attribute
within the temporary tree will change the base URI for its parent element and
that element's descendants, just as it would within a document constructed by
parsing.

The document-uri and unparsed-entities properties of the new document node are
set to empty.

A temporary tree is available for processing in exactly the same way as any
source document. For example, its nodes are accessible using path expressions,
and they can be processed using instructions such as xsl:apply-templates and 
xsl:for-each. Also, the key and id^ FO functions can be used to find nodes
within a temporary tree rooted at a document node, provided that at the time
the function is called, the context item is a node within the temporary tree.

Example: Two-Phase Transformation

For example, the following stylesheet uses a temporary tree as the
intermediate result of a two-phase transformation, using different modes for
the two phases (see 6.5 Modes). Typically, the template rules in module
phase1.xsl will be declared with mode="phase1", while those in module
phase2.xsl will be declared with mode="phase2":

<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:import href="phase1.xsl"/>
<xsl:import href="phase2.xsl"/>

<xsl:variable name="intermediate">
  <xsl:apply-templates select="/" mode="phase1"/>
</xsl:variable>

<xsl:template match="/">
  <xsl:apply-templates select="$intermediate" mode="phase2"/>
</xsl:template>

</xsl:stylesheet>

Note:

The algorithm for matching nodes against template rules is exactly the same
regardless which tree the nodes come from. If different template rules are to
be used when processing different trees, then unless nodes from different
trees can be distinguished by means of patterns, it is a good idea to use 
modes to ensure that each tree is processed using the appropriate set of
template rules.

9.5 Global Variables and Parameters

Both xsl:variable and xsl:param are allowed as declaration elements: that is,
they may appear as children of the xsl:stylesheet element.

[Definition: A top-level variable-binding element declares a global variable
that is visible everywhere (except where it is shadowed by another binding).]

[Definition: A top-level xsl:param element declares a stylesheet parameter. A
stylesheet parameter is a global variable with the additional property that
its value can be supplied by the caller when a transformation is initiated.] 
As described in 9.2 Parameters, a stylesheet parameter may be declared as
being mandatory, or may have a default value specified for use when no value
is supplied by the caller. The mechanism by which the caller supplies a value
for a stylesheet parameter is implementation-defined. An XSLT processor must
provide such a mechanism.

It is an error if no value is supplied for a mandatory stylesheet parameter 
[see ERR XTDE0050].

If a stylesheet contains more than one binding for a global variable of a
particular name, then the binding with the highest import precedence is used.

[ERR XTSE0630] It is a static error if a stylesheet contains more than one
binding of a global variable with the same name and same import precedence,
unless it also contains another binding with the same name and higher import
precedence.

For a global variable or the default value of a stylesheet parameter, the 
expression or sequence constructor specifying the variable value is evaluated
with a singleton focus based on the root node of the tree containing the 
initial context node. An XPath error will be reported if the evaluation of a
global variable or parameter references the context item, context position, or
context size when no initial context node is supplied. The values of other
components of the dynamic context are the initial values as defined in 5.4.3
Initializing the Dynamic Context and 5.4.4 Additional Dynamic Context
Components used by XSLT.

Example: A Stylesheet Parameter

The following example declares a global parameter para-font-size, which is
referenced in an attribute value template.

<xsl:param name="para-font-size" as="xs:string">12pt</xsl:param>

<xsl:template match="para">
 <fo:block font-size="{$para-font-size}">
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>

The implementation must provide a mechanism allowing the user to supply a
value for the parameter para-font-size when invoking the stylesheet; the value
12pt acts as a default.

9.6 Local Variables and Parameters

[Definition: As well as being allowed as declaration elements, the 
xsl:variable element is also allowed in sequence constructors. Such a variable
is known as a local variable.]

[Definition:  An xsl:param element may appear as a child of an xsl:template
element, before any non-xsl:param children of that element. Such a parameter
is known as a template parameter. A template parameter is a local variable
with the additional property that its value can be set when the template is
called, using any of the instructions xsl:call-template, xsl:apply-templates, 
xsl:apply-imports, or xsl:next-match. ]

[Definition:  An xsl:param element may appear as a child of an xsl:function
element, before any non-xsl:param children of that element. Such a parameter
is known as a function parameter. A function parameter is a local variable
with the additional property that its value can be set when the function is
called, using a function call in an XPath expression.]

The result of evaluating a local xsl:variable or xsl:param element (that is,
the contribution it makes to the result of the sequence constructor it is part
of) is an empty sequence.

9.7 Scope of Variables

For any variable-binding element, there is a region (more specifically, a set
of element nodes) of the stylesheet within which the binding is visible. The
set of variable bindings in scope for an XPath expression consists of those
bindings that are visible at the point in the stylesheet where the expression
occurs.

A global variable binding element is visible everywhere in the stylesheet
(including other stylesheet modules) except within the xsl:variable or 
xsl:param element itself and any region where it is shadowed by another
variable binding.

A local variable binding element is visible for all following siblings and
their descendants, with two exceptions: it is not visible in any region where
it is shadowed by another variable binding, and it is not visible within the
subtree rooted at an xsl:fallback instruction that is a sibling of the
variable binding element. The binding is not visible for the xsl:variable or 
xsl:param element itself.

[Definition: A binding shadows another binding if the binding occurs at a
point where the other binding is visible, and the bindings have the same name.
] It is not an error if a binding established by a local xsl:variable or 
xsl:param shadows a global binding. In this case, the global binding will not
be visible in the region of the stylesheet where it is shadowed by the other
binding.

Example: Local Variable Shadowing a Global Variable

The following is allowed:

<xsl:param name="x" select="1"/>
<xsl:template name="foo">
  <xsl:variable name="x" select="2"/>
</xsl:template>

It is also not an error if a binding established by a local xsl:variable
element shadows a binding established by another local xsl:variable or 
xsl:param.

Example: Misuse of Variable Shadowing

The following is not an error, but the effect is probably not what was
intended. The template outputs <x value="1"/>, because the declaration of the
inner variable named $x has no effect on the value of the outer variable named
$x.

<xsl:variable name="x" select="1"/>
<xsl:template name="foo">
  <xsl:for-each select="1 to 5">
    <xsl:variable name="x" select="$x+1"/>
  </xsl:for-each>
  <x value="{$x}"/>
</xsl:template>

Note:

Once a variable has been given a value, the value cannot subsequently be
changed. XSLT does not provide an equivalent to the assignment operator
available in many procedural programming languages.

This is because an assignment operator would make it harder to create an
implementation that processes a document other than in a batch-like way,
starting at the beginning and continuing through to the end.

As well as global variables and local variables, an XPath expression may also
declare range variables for use locally within an expression. For details, see
[XPath 2.0].

Where a reference to a variable occurs in an XPath expression, it is resolved
first by reference to range variables that are in scope, then by reference to
local variables and parameters, and finally by reference to global variables
and parameters. A range variable may shadow a local variable or a global
variable. XPath also allows a range variable to shadow another range variable.

9.8 Circular Definitions

[Definition: A circularity is said to exist if a construct such as a global
variable, an attribute set, or a key is defined in terms of itself. For
example, if the expression or sequence constructor specifying the value of a 
global variable X references a global variable Y, then the value for Y must be
computed before the value of X. A circularity exists if it is impossible to do
this for all global variable definitions.]

Example: Circular Variable Definitions

The following two declarations create a circularity:

<xsl:variable name="x" select="$y+1"/>
<xsl:variable name="y" select="$x+1"/>

Example: Circularity involving Variables and Functions

The definition of a global variable can be circular even if no other variable
is involved. For example the following two declarations (see 10.3 Stylesheet
Functions for an explanation of the xsl:function element) also create a
circularity:

<xsl:variable name="x" select="my:f()"/>

<xsl:function name="my:f">
  <xsl:sequence select="$x"/>
</xsl:function>

Example: Circularity involving Variables and Templates

The definition of a variable is also circular if the evaluation of the
variable invokes an xsl:apply-templates instruction and the variable is
referenced in the pattern used in the match attribute of any template rule in
the stylesheet. For example the following definition is circular:

<xsl:variable name="x">
  <xsl:apply-templates select="//param[1]"/>
</xsl:variable>

<xsl:template match="param[$x]">1</xsl:template>

Example: Circularity involving Variables and Keys

Similarly, a variable definition is circular if it causes a call on the key
function, and the definition of that key refers to that variable in its match
or use attributes. So the following definition is circular:

<xsl:variable name="x" select="my:f(10)"/>

<xsl:function name="my:f">
  <xsl:param name="arg1"/>
  <xsl:sequence select="key('k', $arg1)"/>
</xsl:function>

<xsl:key name="k" match="item[@code=$x]" use="@desc"/>

[ERR XTDE0640] In general, a circularity in a stylesheet is a non-recoverable
dynamic error. However, as with all other dynamic errors, an implementation
will signal the error only if it actually executes the instructions and
expressions that participate in the circularity. Because different
implementations may optimize the execution of a stylesheet in different ways,
it is implementation-dependent whether a particular circularity will actually
be signaled.

For example, in the following declarations, the function declares a local
variable $b, but it returns a result that does not require the variable to be
evaluated. It is implementation-dependent whether the value is actually
evaluated, and it is therefore implementation-dependent whether the
circularity is signaled as an error:

<xsl:variable name="x" select="my:f(1)/>

<xsl:function name="my:f">
  <xsl:param name="a"/>
  <xsl:variable name="b" select="$x"/>  
  <xsl:sequence select="$a + 2"/>
</xsl:function>

Circularities usually involve global variables or parameters, but they can
also exist between key definitions (see 16.3 Keys), between named attribute
sets (see 10.2 Named Attribute Sets), or between any combination of these
constructs. For example, a circularity exists if a key definition invokes a
function that references an attribute set that calls the key function,
supplying the name of the original key definition as an argument.

Circularity is not the same as recursion. Stylesheet functions (see 10.3
Stylesheet Functions) and named templates (see 10.1 Named Templates) may call
other functions and named templates without restriction. With careless coding,
recursion may be non-terminating. Implementations are required to signal
circularity as a dynamic error, but they are not required to detect
non-terminating recursion.

10 Callable Components

This section describes three constructs that can be used to provide
subroutine-like functionality that can be invoked from anywhere in the
stylesheet: named templates (see 10.1 Named Templates), named attribute sets
(see 10.2 Named Attribute Sets) and stylesheet functions (see 10.3 Stylesheet
Functions).

10.1 Named Templates

<!-- Category: instruction -->
<xsl:call-template
  name = qname>
  <!-- Content: xsl:with-param* -->
</xsl:call-template>

[Definition: Templates can be invoked by name. An xsl:template element with a
name attribute defines a named template.] The value of the name attribute is a
QName, which is expanded as described in 5.1 Qualified Names. If an 
xsl:template element has a name attribute, it may, but need not, also have a
match attribute. An xsl:call-template instruction invokes a template by name;
it has a required name attribute that identifies the template to be invoked.
Unlike xsl:apply-templates, the xsl:call-template instruction does not change
the focus.

The match, mode and priority attributes on an xsl:template element have no
effect when the template is invoked by an xsl:call-template instruction.
Similarly, the name attribute on an xsl:template element has no effect when
the template is invoked by an xsl:apply-templates instruction.

[ERR XTSE0650] It is a static error if a stylesheet contains an 
xsl:call-template instruction whose name attribute does not match the name
attribute of any xsl:template in the stylesheet.

[ERR XTSE0660] It is a static error if a stylesheet contains more than one 
template with the same name and the same import precedence, unless it also
contains a template with the same name and higher import precedence.

The target template for an xsl:call-template instruction is the template whose
name attribute matches the name attribute of the xsl:call-template instruction
and that has higher import precedence than any other template with this name.
The result of evaluating an xsl:call-template instruction is the sequence
produced by evaluating the sequence constructor contained in its target 
template (see 5.7 Sequence Constructors).

10.1.1 Passing Parameters to Templates

<xsl:with-param
  name = qname
  select? = expression
  as? = sequence-type
  tunnel? = "yes" | "no">
  <!-- Content: sequence-constructor -->
</xsl:with-param>

Parameters are passed to templates using the xsl:with-param element. The 
required name attribute specifies the name of the template parameter (the
variable the value of whose binding is to be replaced). The value of the name
attribute is a QName, which is expanded as described in 5.1 Qualified Names.

xsl:with-param is allowed within xsl:call-template, xsl:apply-templates, 
xsl:apply-imports, and xsl:next-match.

[ERR XTSE0670] It is a static error if a single xsl:call-template, 
xsl:apply-templates, xsl:apply-imports, or xsl:next-match element contains two
or more xsl:with-param elements with matching name attributes.

The value of the parameter is specified in the same way as for xsl:variable
and xsl:param (see 9.3 Values of Variables and Parameters), taking account of
the values of the select and as attributes and the content of the 
xsl:with-param element, if any.

Note:

It is possible to have an as attribute on the xsl:with-param element that
differs from the as attribute on the corresponding xsl:param element
describing the formal parameters of the called template.

In this situation, the supplied value of the parameter will first be processed
according to the rules of the as attribute on the xsl:with-param element, and
the resulting value will then be further processed according to the rules of
the as attribute on the xsl:param element.

For example, suppose the supplied value is a node with type annotation 
xs:untypedAtomic, and the xsl:with-param element specifies as="xs:integer",
while the xsl:param element specifies as="xs:double". Then the node will first
be atomized and the resulting untyped atomic value will be cast to xs:integer.
If this succeeds, the xs:integer will then be promoted to an xs:double.

The focus used for computing the value specified by the xsl:with-param element
is the same as that used for the xsl:apply-templates, xsl:apply-imports, 
xsl:next-match, or xsl:call-template element within which it occurs.

[ERR XTSE0680] In the case of xsl:call-template, it is a static error to pass
a non-tunnel parameter named x to a template that does not have a template
parameter named x, unless backwards compatible behavior is enabled for the 
xsl:call-template instruction. This is not an error in the case of 
xsl:apply-templates, xsl:apply-imports, and xsl:next-match; in these cases the
parameter is simply ignored.

The optional tunnel attribute may be used to indicate that a parameter is a 
tunnel parameter. The default is no. Tunnel parameters are described in 10.1.2
Tunnel Parameters

[ERR XTSE0690] It is a static error if a template that is invoked using 
xsl:call-template declares a template parameter specifying required="yes" and
not specifying tunnel="yes", if no value for this parameter is supplied by the
calling instruction.

[ERR XTDE0700] In other cases, it is a non-recoverable dynamic error if the
template that is invoked declares a template parameter with required="yes" and
no value for this parameter is supplied by the calling instruction.

Example: A Named Template

This example defines a named template for a numbered-block with an argument to
control the format of the number.

<xsl:template name="numbered-block">
  <xsl:param name="format">1. </xsl:param>
  <fo:block>
    <xsl:number format="{$format}"/>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="ol//ol/li">
  <xsl:call-template name="numbered-block">
    <xsl:with-param name="format">a. </xsl:with-param>
  </xsl:call-template>
</xsl:template>

Note:

Arguments to stylesheet functions are supplied as part of an XPath function
call: see 10.3 Stylesheet Functions

10.1.2 Tunnel Parameters

[Definition: A parameter passed to a template may be defined as a tunnel
parameter. Tunnel parameters have the property that they are automatically
passed on by the called template to any further templates that it calls, and
so on recursively.] Tunnel parameters thus allow values to be set that are
accessible during an entire phase of stylesheet processing, without the need
for each template that is used during that phase to be aware of the parameter.

Note:

Tunnel parameters are conceptually similar to dynamically-scoped variables in
some functional programming languages.

A tunnel parameter is created by using an xsl:with-param element that
specifies tunnel="yes". A template that requires access to the value of a
tunnel parameter must declare it using an xsl:param element that also
specifies tunnel="yes".

On any template call using an xsl:apply-templates, xsl:call-template, 
xsl:apply-imports or xsl:next-match instruction, a set of tunnel parameters is
passed from the calling template to the called template. This set consists of
any parameters explicitly created using <xsl:with-param tunnel="yes">,
overlaid on a base set of tunnel parameters. If the xsl:apply-templates, 
xsl:call-template, xsl:apply-imports or xsl:next-match instruction has an 
xsl:template declaration as an ancestor element in the stylesheet, then the
base set consists of the tunnel parameters that were passed to that template;
otherwise (for example, if the instruction is within a global variable
declaration, an attribute set declaration, or a stylesheet function), the base
set is empty. If a parameter created using <xsl:with-param tunnel="yes"> has
the same expanded-QName as a parameter in the base set, then the parameter
created using xsl:with-param overrides the parameter in the base set;
otherwise, the parameter created using xsl:with-param is added to the base
set.

When a template accesses the value of a tunnel parameter by declaring it with
xsl:param tunnel="yes", this does not remove the parameter from the base set
of tunnel parameters that is passed on to any templates called by this
template.

Two sibling xsl:with-param elements must have distinct parameter names, even
if one is a tunnel parameter and the other is not. Equally, two sibling 
xsl:param elements representing template parameters must have distinct
parameter names, even if one is a tunnel parameter and the other is not.
However, the tunnel parameters that are implicitly passed in a template call
may have names that duplicate the names of non-tunnel parameters that are
explicitly passed on the same call.

Tunnel parameters are not passed in calls to stylesheet functions.

All other options of xsl:with-param and xsl:param are available with tunnel
parameters just as with non-tunnel parameters. For example, parameters may be
declared as mandatory or optional, a default value may be specified, and a
required type may be specified. If any conversion is required from the
supplied value of a tunnel parameter to the required type specified in 
xsl:param, then the converted value is used within the receiving template, but
the value that is passed on in any further template calls is the original
supplied value before conversion. Equally, any default value is local to the
template: specifying a default value for a tunnel parameter does not change
the set of tunnel parameters that is passed on in further template calls.

The set of tunnel parameters that is passed to the initial template is empty.

Tunnel parameters are passed unchanged through a built-in template rule (see 
6.6 Built-in Template Rules).

Example: Using Tunnel Parameters

Suppose that the equations in a scientific paper are to be sequentially
numbered, but that the format of the number depends on the context in which
the equations appear. It is possible to reflect this using a rule of the form:

<xsl:template match="equation">
  <xsl:param name="equation-format" select="'(1)'" tunnel="yes"/>
  <xsl:number level="any" format="{$equation-format}"/>
</xsl:template>

At any level of processing above this level, it is possible to determine how
the equations will be numbered, for example:

<xsl:template match="appendix">
  ...
  <xsl:apply-templates>
    <xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/>
  </xsl:apply-templates>
  ...
</xsl:template>

The parameter value is passed transparently through all the intermediate
layers of template rules until it reaches the rule with match="equation". The
effect is similar to using a global variable, except that the parameter can
take different values during different phases of the transformation.

10.2 Named Attribute Sets

<!-- Category: declaration -->
<xsl:attribute-set
  name = qname
  use-attribute-sets? = qnames>
  <!-- Content: xsl:attribute* -->
</xsl:attribute-set>

[Definition: The xsl:attribute-set element defines a named attribute set: that
is, a collection of attribute definitions that can be used repeatedly on
different constructed elements.]

The required name attribute specifies the name of the attribute set. The value
of the name attribute is a QName, which is expanded as described in 5.1
Qualified Names. The content of the xsl:attribute-set element consists of zero
or more xsl:attribute instructions that are evaluated to produce the
attributes in the set.

The result of evaluating an attribute set is a sequence of attribute nodes.
Evaluating the same attribute set more than once can produce different
results, because although an attribute set does not have parameters, it may
contain expressions or instructions whose value depends on the evaluation
context.

Attribute sets are used by specifying a use-attribute-sets attribute on the 
xsl:element or xsl:copy instruction, or by specifying an
xsl:use-attribute-sets attribute on a literal result element. An attribute set
may be defined in terms of other attribute sets by using the
use-attribute-sets attribute on the xsl:attribute-set element itself. The
value of the [xsl:]use-attribute-sets attribute is in each case a
whitespace-separated list of names of attribute sets. Each name is specified
as a QName, which is expanded as described in 5.1 Qualified Names.

Specifying a use-attribute-sets attribute is broadly equivalent to adding 
xsl:attribute instructions for each of the attributes in each of the named
attribute sets to the beginning of the content of the instruction with the
[xsl:]use-attribute-sets attribute, in the same order in which the names of
the attribute sets are specified in the use-attribute-sets attribute.

More formally, an xsl:use-attribute-sets attribute is expanded using the
following recursive algorithm, or any algorithm that produces the same
results:

  * The value of the attribute is tokenized as a list of QNames.
   
  * Each QName in the list is processed, in order, as follows:
   
      + The QName must match the name attribute of one or more 
        xsl:attribute-set declarations in the stylesheet.
       
      + Each xsl:attribute-set declaration whose name matches is processed as
        follows. Where two such declarations have different import precedence,
        the one with lower import precedence is processed first. Where two
        declarations have the same import precedence, they are processed in 
        declaration order.
       
          o If the xsl:attribute-set declaration has a use-attribute-sets
            attribute, the attribute is expanded by applying this algorithm
            recursively.
           
          o If the xsl:attribute-set declaration contains one or more 
            xsl:attribute instructions, these instructions are evaluated
            (following the rules for evaluating a sequence constructor: see 
            5.7 Sequence Constructors) to produce a sequence of attribute
            nodes. These attribute nodes are appended to the result sequence.
           
The xsl:attribute instructions are evaluated using the same focus as is used
for evaluating the element that is the parent of the [xsl:]use-attribute-sets
attribute forming the initial input to the algorithm. However, the static
context for the evaluation depends on the position of the xsl:attribute
instruction in the stylesheet: thus, only local variables declared within an 
xsl:attribute instruction, and global variables, are visible.

The set of attribute nodes produced by expanding xsl:use-attribute-sets may
include several attributes with the same name. When the attributes are added
to an element node, only the last of the duplicates will take effect.

The way in which each instruction uses the results of expanding the [xsl:]
use-attribute-sets attribute is described in the specification for the
relevant instruction: see 11.1 Literal Result Elements, 11.2 Creating Element
Nodes Using xsl:element , and 11.9 Copying Nodes.

[ERR XTSE0710] It is a static error if the value of the use-attribute-sets
attribute of an xsl:copy, xsl:element, or xsl:attribute-set element, or the
xsl:use-attribute-sets attribute of a literal result element, is not a 
whitespace-separated sequence of QNames, or if it contains a QName that does
not match the name attribute of any xsl:attribute-set declaration in the
stylesheet.

[ERR XTSE0720] It is a static error if an xsl:attribute-set element directly
or indirectly references itself via the names contained in the
use-attribute-sets attribute.

Each attribute node produced by expanding an attribute set has a type
annotation determined by the rules for the xsl:attribute instruction that
created the attribute node: see 11.3.1 Setting the Type Annotation for a
Constructed Attribute Node. These type annotations may be preserved, stripped,
or replaced as determined by the rules for the instruction that creates the
element in which the attributes are used.

Attribute sets are used as follows:

  * The xsl:copy and xsl:element instructions have an use-attribute-sets
    attribute. The sequence of attribute nodes produced by evaluating this
    attribute is prepended to the sequence produced by evaluating the sequence
    constructor contained within the instruction.
   
  * Literal result elements allow an xsl:use-attribute-sets attribute, which
    is evaluated in the same way as the use-attribute-sets attribute of 
    xsl:element and xsl:copy. The sequence of attribute nodes produced by
    evaluating this attribute is prepended to the sequence of attribute nodes
    produced by evaluating the attributes of the literal result element, which
    in turn is prepended to the sequence produced by evaluating the sequence
    constructor contained with the literal result element.
   
Example: Using Attribute Sets

The following example creates a named attribute set title-style and uses it in
a template rule.

<xsl:template match="chapter/heading">
  <fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:attribute-set name="title-style">
  <xsl:attribute name="font-size">12pt</xsl:attribute>
  <xsl:attribute name="font-weight">bold</xsl:attribute>
</xsl:attribute-set>

Example: Overriding Attributes in an Attribute Set

The following example creates a named attribute set base-style and uses it in
a template rule with multiple specifications of the attributes:

font-family
   
    is specified only in the attribute set
   
font-size
   
    is specified in the attribute set, is specified on the literal result
    element, and in an xsl:attribute instruction
   
font-style
   
    is specified in the attribute set, and on the literal result element
   
font-weight
   
    is specified in the attribute set, and in an xsl:attribute instruction
   
Stylesheet fragment:

<xsl:attribute-set name="base-style">
  <xsl:attribute name="font-family">Univers</xsl:attribute>
  <xsl:attribute name="font-size">10pt</xsl:attribute>
  <xsl:attribute name="font-style">normal</xsl:attribute>
  <xsl:attribute name="font-weight">normal</xsl:attribute>
</xsl:attribute-set>

<xsl:template match="o">
  <fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic">
    <xsl:attribute name="font-size">14pt</xsl:attribute>
    <xsl:attribute name="font-weight">bold</xsl:attribute>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

Result:

<fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold">
...
</fo:block>

10.3 Stylesheet Functions

[Definition: An xsl:function declaration declares the name, parameters, and
implementation of a stylesheet function that can be called from any XPath 
expression within the stylesheet.]

<!-- Category: declaration -->
<xsl:function
  name = qname
  as? = sequence-type
  override? = "yes" | "no">
  <!-- Content: (xsl:param*, sequence-constructor) -->
</xsl:function>

The xsl:function declaration defines a stylesheet function that can be called
from any XPath expression used in the stylesheet (including an XPath
expression used within a predicate in a pattern). The name attribute specifies
the name of the function. The value of the name attribute is a QName, which is
expanded as described in 5.1 Qualified Names.

An xsl:function declaration can only appear as a top-level element in a 
stylesheet module.

[ERR XTSE0740] A stylesheet function must have a prefixed name, to remove any
risk of a clash with a function in the default function namespace. It is a 
static error if the name has no prefix..

Note:

To prevent the namespace declaration used for the function name appearing in
the result document, use the exclude-result-prefixes attribute on the 
xsl:stylesheet element: see 11.1.3 Namespace Nodes for Literal Result Elements
.

The prefix must not refer to a reserved namespace: [see ERR XTSE0080]

The content of the xsl:function element consists of zero or more xsl:param
elements that specify the formal arguments of the function, followed by a 
sequence constructor that defines the value to be returned by the function.

[Definition: The arity of a stylesheet function is the number of xsl:param
elements in the function definition.] Optional arguments are not allowed.

[ERR XTSE0760] Because arguments to a stylesheet function call must all be
specified, the xsl:param elements within an xsl:function element must not
specify a default value: this means they must be empty, and must not have a
select attribute.

A stylesheet function is included in the in-scope functions of the static
context for all XPath expressions used in the stylesheet, unless

  * there is another stylesheet function with the same name and arity, and
    higher import precedence, or
   
  * the override attribute has the value no and there is already a function
    with the same name and arity in the in-scope functions.
   
The optional override attribute defines what happens if this function has the
same name and arity as a function provided by the implementer or made
available in the static context using an implementation-defined mechanism. If
the override attribute has the value yes, then this function is used in
preference; if it has the value no, then the other function is used in
preference. The default value is yes.

Note:

Specifying override="yes" ensures interoperable behavior: the same code will
execute with all processors. Specifying override="no" is useful when writing a
fallback implementation of a function that is available with some processors
but not others: it allows the vendor's implementation of the function (or a
user's implementation written as an extension function) to be used in
preference to the stylesheet implementation, which is useful when the 
extension function is more efficient.

The override attribute does not affect the rules for deciding which of several
stylesheet functions with the same name and arity takes precedence.

[ERR XTSE0770] It is a static error for a stylesheet to contain two or more
functions with the same expanded-QName, the same arity, and the same import
precedence, unless there is another function with the same expanded-QName and
arity, and a higher import precedence.

As defined in XPath, the function that is executed as the result of a function
call is identified by looking in the in-scope functions of the static context
for a function whose name and arity matches the name and number of arguments
in the function call.

Note:

Functions are not polymorphic. Although the XPath function call mechanism
allows two functions to have the same name and different arity, it does not
allow them to be distinguished by the types of their arguments.

The optional as attribute indicates the required type of the result of the
function. The value of the as attribute is a SequenceType^ XP, as defined in 
[XPath 2.0].

[ERR XTTE0780] If the as attribute is specified, then the result evaluated by
the sequence constructor (see 5.7 Sequence Constructors) is converted to the
required type, using the function conversion rules. It is a type error if this
conversion fails. If the as attribute is omitted, the calculated result is
used as supplied, and no conversion takes place.

If a stylesheet function has been defined with a particular expanded-QName,
then a call on function-available will return true when called with an
argument that is a lexical QName that expands to this same expanded-QName.

The xsl:param elements define the formal arguments to the function. These are
interpreted positionally. When the function is called using a function-call in
an XPath expression, the first argument supplied is assigned to the first 
xsl:param element, the second argument supplied is assigned to the second 
xsl:param element, and so on.

The as attribute of the xsl:param element defines the required type of the
parameter. The rules for converting the values of the actual arguments
supplied in the function call to the types required by each xsl:param element
are defined in [XPath 2.0]. The rules that apply are those for the case where 
XPath 1.0 compatibility mode is set to false.

[ERR XTTE0790] If the value of a parameter to a stylesheet function cannot be
converted to the required type, a type error is signaled.

If the as attribute is omitted, no conversion takes place and any value is
accepted.

Within the body of a stylesheet function, the focus is initially undefined;
this means that any attempt to reference the context item, context position,
or context size is a non-recoverable dynamic error. [XPDY0002]

It is not possible within the body of the stylesheet function to access the
values of local variables that were in scope in the place where the function
call was written. Global variables, however, remain available.

Example: A Stylesheet Function

The following example creates a recursive stylesheet function named
str:reverse that reverses the words in a supplied sentence, and then invokes
this function from within a template rule.

<xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="2.0"
  exclude-result-prefixes="str">

<xsl:function name="str:reverse" as="xs:string">
  <xsl:param name="sentence" as="xs:string"/>
  <xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/>
</xsl:function>

<xsl:template match="/">
<output>
  <xsl:value-of select="str:reverse('DOG BITES MAN')"/>
</output>
</xsl:template>

</xsl:transform>

An alternative way of writing the same function is to implement the
conditional logic at the XSLT level, thus:

<xsl:function name="str:reverse" as="xs:string">
  <xsl:param name="sentence" as="xs:string"/>
  <xsl:choose>
    <xsl:when test="contains($sentence, ' ')">  
      <xsl:sequence select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="$sentence"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>

Example: Declaring the Return Type of a Function

The following example illustrates the use of the as attribute in a function
definition. It returns a string containing the representation of its integer
argument, expressed as a roman numeral. For example, the function call
num:roman(7) will return the string "vii". This example uses the xsl:number
instruction, described in 12 Numbering. The xsl:number instruction returns a
text node, and the function conversion rules are invoked to convert this text
node to the type declared in the xsl:function element, namely xs:string. So
the text node is atomized to a string.

<xsl:function name="num:roman" as="xs:string">
  <xsl:param name="value" as="xs:integer"/>
  <xsl:number value="$value" format="i"/>
</xsl:function>

11 Creating Nodes and Sequences

This section describes instructions that directly create new nodes, or
sequences of nodes and atomic values.

11.1 Literal Result Elements

[Definition: In a sequence constructor, an element in the stylesheet that does
not belong to the XSLT namespace and that is not an extension instruction (see
18.2 Extension Instructions) is classified as a literal result element.] A
literal result element is evaluated to construct a new element node with the
same expanded-QName (that is, the same namespace URI, local name, and
namespace prefix). The result of evaluating a literal result element is a node
sequence containing one element, the newly constructed element node.

The content of the element is a sequence constructor (see 5.7 Sequence
Constructors). The sequence obtained by evaluating this sequence constructor,
after prepending any attribute nodes produced as described in 11.1.2 Attribute
Nodes for Literal Result Elements and namespace nodes produced as described in
11.1.3 Namespace Nodes for Literal Result Elements, is used to construct the
content of the element, following the rules in 5.7.1 Constructing Complex
Content

The base URI of the new element is copied from the base URI of the literal
result element in the stylesheet, unless the content of the new element
includes an xml:base attribute, in which case the base URI of the new element
is the value of that attribute, resolved (if it is a relative URI) against the
base URI of the literal result element in the stylesheet. (Note, however, that
this is only relevant when creating a parentless element. When the literal
result element is copied to form a child of an element or document node, the
base URI of the new copy is taken from that of its new parent.)

11.1.1 Setting the Type Annotation for Literal Result Elements

The attributes xsl:type and xsl:validation may be used on a literal result
element to invoke validation of the contents of the element against a type
definition or element declaration in a schema, and to determine the type
annotation that the new element node will carry. These attributes also affect
the type annotation carried by any elements and attributes that have the new
element node as an ancestor. These two attributes are both optional, and if
one is specified then the other must be omitted.

The value of the xsl:validation attribute, if present, must be one of the
values strict, lax, preserve, or strip. The value of the xsl:type attribute,
if present, must be a QName identifying a type definition that is present in
the in-scope schema components for the stylesheet. Neither attribute may be
specified as an attribute value template. The effect of these attributes is
described in 19.2 Validation.

11.1.2 Attribute Nodes for Literal Result Elements

Attribute nodes for a literal result element may be created by including 
xsl:attribute instructions within the sequence constructor. Additionally,
attribute nodes are created corresponding to the attributes of the literal
result element in the stylesheet, and as a result of expanding the
xsl:use-attribute-sets attribute of the literal result element, if present.

The sequence that is used to construct the content of the literal result
element (as described in 5.7.1 Constructing Complex Content) is the
concatenation of the following four sequences, in order:

 1. The sequence of namespace nodes produced as described in 11.1.3 Namespace
    Nodes for Literal Result Elements.
   
 2. The sequence of attribute nodes produced by expanding the
    xsl:use-attribute-sets attribute (if present) following the rules given in
    10.2 Named Attribute Sets
   
 3. The attributes produced by processing the attributes of the literal result
    element itself, other than attributes in the XSLT namespace. The way these
    are processed is described below.
   
 4. The sequence produced by evaluating the contained sequence constructor, if
    the element is not empty.
   
Note:

The significance of this order is that an attribute produced by an
xsl:attribute, xsl:copy, or xsl:copy-of instruction in the content of the
literal result element takes precedence over an attribute produced by
expanding an attribute of the literal result element itself, which in turn
takes precedence over an attribute produced by expanding the
xsl:use-attribute-sets attribute. This is because of the rules in 5.7.1
Constructing Complex Content, which specify that when two or more attributes
in the sequence have the same name, all but the last of the duplicates are
discarded.

Although the above rules place namespace nodes before attributes, this is not
strictly necessary, because the rules in 5.7.1 Constructing Complex Content
allow the namespaces and attributes to appear in any order so long as both
come before other kinds of node. The order of namespace nodes and attribute
nodes in the sequence has no effect on the relative position of the nodes in
document order once they are added to a tree.

Each attribute of the literal result element, other than an attribute in the 
XSLT namespace, is processed to produce an attribute for the element in the 
result tree.

The value of such an attribute is interpreted as an attribute value template:
it can therefore contain expressions contained in curly brackets ({}). The new
attribute node will have the same expanded-QName (that is, the same namespace
URI, local name, and namespace prefix) as the attribute in the stylesheet
tree, and its string value will be the same as the effective value of the
attribute in the stylesheet tree. The type annotation on the attribute will
initially be xs:untypedAtomic, and the typed value of the attribute node will
be the same as its string value.

Note:

The eventual type annotation of the attribute in the result tree depends on
the xsl:validation and xsl:type attributes of the parent literal result
element, and on the instructions used to create its ancestor elements. If the
xsl:validation attribute is set to preserve or strip, the type annotation will
be xs:untypedAtomic, and the typed value of the attribute node will be the
same as its string value. If the xsl:validation attribute is set to strict or
lax, or if the xsl:type attribute is used, the type annotation on the
attribute will be set as a result of the schema validation process applied to
the parent element. If neither attribute is present, the type annotation on
the attribute will be xs:untypedAtomic.

If the name of a constructed attribute is xml:id, the processor must perform
attribute value normalization by effectively applying the normalize-space^FO
function to the value of the attribute, and the resulting attribute node must
be given the is-id property.

[ERR XTRE0795] It is a recoverable dynamic error if the name of a constructed
attribute is xml:space and the value is not either default or preserve. The 
optional recovery action is to construct the attribute with the value as
requested.. This applies whether the attribute is constructed using a literal
result element, or by using the xsl:attribute, xsl:copy, or xsl:copy-of
instructions.

Note:

The xml:base, xml:lang, xml:space, and xml:id attributes have two effects in
XSLT. They behave as standard XSLT attributes, which means for example that if
they appear on a literal result element, they will be copied to the result
tree in the same way as any other attribute. In addition, they have their
standard meaning as defined in the core XML specifications. Thus, an xml:base
attribute in the stylesheet affects the base URI of the element on which it
appears, and an xml:space attribute affects the interpretation of whitespace
text nodes within that element. One consequence of this is that it is
inadvisable to write these attributes as attribute value templates: although
an XSLT processor will understand this notation, the XML parser will not. See
also 11.1.4 Namespace Aliasing which describes how to use xsl:namespace-alias
with these attributes.

The same is true of the schema-defined attributes xsi:type, xsi:nil, 
xsi:noNamespaceSchemaLocation, and xsi:schemaLocation. If the stylesheet is
processed by a schema processor, these attributes will be recognized and
interpreted by the schema processor, but in addition the XSLT processor treats
them like any other attribute on a literal result element: that is, their 
effective value (after expanding attribute value templates) is copied to the
result tree in the same way as any other attribute. If the result tree is
validated, the copied attributes will again be recognized and interpreted by
the schema processor.

None of these attributes will be generated in the result tree unless the
stylesheet writes them to the result tree explicitly, in the same way as any
other attribute.

[ERR XTSE0805] It is a static error if an attribute on a literal result
element is in the XSLT namespace, unless it is one of the attributes
explicitly defined in this specification.

Note:

If there is a need to create attributes in the XSLT namespace, this can be
achieved using xsl:attribute, or by means of the xsl:namespace-alias
declaration.

11.1.3 Namespace Nodes for Literal Result Elements

The created element node will have a copy of the namespace nodes that were
present on the element node in the stylesheet tree with the exception of any
namespace node whose string value is designated as an excluded namespace.
Special considerations apply to aliased namespaces: see 11.1.4 Namespace
Aliasing

The following namespaces are designated as excluded namespaces:

  * The XSLT namespace URI (http://www.w3.org/1999/XSL/Transform)
   
  * A namespace URI declared as an extension namespace (see 18.2 Extension
    Instructions)
   
  * A namespace URI designated by using an [xsl:]exclude-result-prefixes
    attribute either on the literal result element itself or on an ancestor
    element. The attribute must be in the XSLT namespace only if its parent
    element is not in the XSLT namespace.
   
    The value of the attribute is either #all, or a whitespace-separated list
    of tokens, each of which is either a namespace prefix or #default. The
    namespace bound to each of the prefixes is designated as an excluded
    namespace.
   
    [ERR XTSE0808] It is a static error if a namespace prefix is used within
    the [xsl:]exclude-result-prefixes attribute and there is no namespace
    binding in scope for that prefix.
   
    The default namespace of the parent element of the [xsl:]
    exclude-result-prefixes attribute (see Section 6.2 Element Nodes^DM) may
    be designated as an excluded namespace by including #default in the list
    of namespace prefixes.
   
    [ERR XTSE0809] It is a static error if the value #default is used within
    the [xsl:]exclude-result-prefixes attribute and the parent element of the
    [xsl:]exclude-result-prefixes attribute has no default namespace.
   
    The value #all indicates that all namespaces that are in scope for the
    stylesheet element that is the parent of the [xsl:]exclude-result-prefixes
    attribute are designated as excluded namespaces.
   
    The designation of a namespace as an excluded namespace is effective
    within the subtree of the stylesheet module rooted at the element bearing
    the [xsl:]exclude-result-prefixes attribute; a subtree rooted at an 
    xsl:stylesheet element does not include any stylesheet modules imported or
    included by children of that xsl:stylesheet element.
   
The excluded namespaces, as described above, only affect namespace nodes
copied from the stylesheet when processing a literal result element. There is
no guarantee that an excluded namespace will not appear on the result tree for
some other reason. Namespace nodes are also written to the result tree as part
of the process of namespace fixup (see 5.7.3 Namespace Fixup), or as the
result of instructions such as xsl:copy and xsl:element.

Note:

When a stylesheet uses a namespace declaration only for the purposes of
addressing a source tree, specifying the prefix in the [xsl:]
exclude-result-prefixes attribute will avoid superfluous namespace
declarations in the serialized result tree. The attribute is also useful to
prevent namespaces used solely for the naming of stylesheet functions or
extension functions from appearing in the serialized result tree.

Example: Excluding Namespaces from the Result Tree

For example, consider the following stylesheet:

<xsl:stylesheet xsl:version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri">
  exclude-result-prefixes="#all">
  
<xsl:template match="/">
  <foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/>
</xsl:template>

</xsl:stylesheet>

The result of this stylesheet will be:

<foo xmlns:d="d.uri"/>

The namespaces a.uri and b.uri are excluded by virtue of the
exclude-result-prefixes attribute on the xsl:stylesheet element, and the
namespace c.uri is excluded by virtue of the xsl:exclude-result-prefixes
attribute on the foo element. The setting #all does not affect the namespace
d.uri because d.uri is not an in-scope namespace for the xsl:stylesheet
element. The element in the result tree does not have a namespace node
corresponding to xmlns:a2="a.uri" because the effect of
exclude-result-prefixes is to designate the namespace URI a.uri as an excluded
namespace, irrespective of how many prefixes are bound to this namespace URI.

If the stylesheet is changed so that the literal result element has an
attribute b:bar="3", then the element in the result tree will typically have a
namespace declaration xmlns:b="b.uri" (the processor may choose a different
namespace prefix if this is necessary to avoid conflicts). The
exclude-result-prefixes attribute makes b.uri an excluded namespace, so the
namespace node is not automatically copied from the stylesheet, but the
presence of an attribute whose name is in the namespace b.uri forces the
namespace fixup process (see 5.7.3 Namespace Fixup) to introduce a namespace
node for this namespace.

A literal result element may have an optional xsl:inherit-namespaces
attribute, with the value yes or no. The default value is yes. If the value is
set to yes, or is omitted, then the namespace nodes created for the newly
constructed element are copied to the children and descendants of the newly
constructed element, as described in 5.7.1 Constructing Complex Content. If
the value is set to no, then these namespace nodes are not automatically
copied to the children. This may result in namespace undeclarations (such as
xmlns="" or, in the case of XML 1.1, xmlns:p="") appearing on the child
elements when a final result tree is serialized.

11.1.4 Namespace Aliasing

When a stylesheet is used to define a transformation whose output is itself a
stylesheet module, or in certain other cases where the result document uses
namespaces that it would be inconvenient to use in the stylesheet, namespace
aliasing can be used to declare a mapping between a namespace URI used in the
stylesheet and the corresponding namespace URI to be used in the result
document.

[Definition: A namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the result tree is called a literal namespace URI.]

[Definition: The namespace URI that is to be used in the result tree as a
substitute for a literal namespace URI is called the target namespace URI.]

Either of the literal namespace URI or the target namespace URI can be null:
this is treated as a reference to the set of names that are in no namespace.

<!-- Category: declaration -->
<xsl:namespace-alias
  stylesheet-prefix = prefix | "#default"
  result-prefix = prefix | "#default" />

[Definition: A stylesheet can use the xsl:namespace-alias element to declare
that a literal namespace URI is being used as an alias for a target namespace
URI.]

The effect is that when names in the namespace identified by the literal
namespace URI are copied to the result tree, the namespace URI in the result
tree will be the target namespace URI, instead of the literal namespace URI.
This applies to:

  * the namespace URI in the expanded-QName of a literal result element in the
    stylesheet
   
  * the namespace URI in the expanded-QName of an attribute specified on a
    literal result element in the stylesheet
   
Where namespace aliasing changes the namespace URI part of the expanded-QName
containing the name of an element or attribute node, the namespace prefix in
that expanded-QName is replaced by the prefix indicated by the result-prefix
attribute of the xsl:namespace-alias declaration.

The xsl:namespace-alias element declares that the namespace URI bound to the
prefix specified by the stylesheet-prefix is the literal namespace URI, and
the namespace URI bound to the prefix specified by the result-prefix attribute
is the target namespace URI. Thus, the stylesheet-prefix attribute specifies
the namespace URI that will appear in the stylesheet, and the result-prefix
attribute specifies the corresponding namespace URI that will appear in the 
result tree.

The default namespace (as declared by xmlns) may be specified by using #
default instead of a prefix. If no default namespace is in force, specifying #
default denotes the null namespace URI. This allows elements that are in no
namespace in the stylesheet to acquire a namespace in the result document, or
vice versa.

If a literal namespace URI is declared to be an alias for multiple different 
target namespace URIs, then the declaration with the highest import precedence
is used.

[ERR XTSE0810] It is a static error if there is more than one such declaration
with the same literal namespace URI and the same import precedence and
different values for the target namespace URI, unless there is also an 
xsl:namespace-alias declaration with the same literal namespace URI and a
higher import precedence.

[ERR XTSE0812] It is a static error if a value other than #default is
specified for either the stylesheet-prefix or the result-prefix attributes of
the xsl:namespace-alias element when there is no in-scope binding for that
namespace prefix.

When a literal result element is processed, its namespace nodes are handled as
follows:

  * A namespace node whose string value is a literal namespace URI is not
    copied to the result tree.
   
  * A namespace node whose string value is a target namespace URI is copied to
    the result tree, whether or not the URI identifies an excluded namespace.
   
In the event that the same URI is used as a literal namespace URI and a target
namespace URI, the second of these rules takes precedence.

Note:

These rules achieve the effect that the element generated from the literal
result element will have an in-scope namespace node that binds the
result-prefix to the target namespace URI, provided that the namespace
declaration associating this prefix with this URI is in scope for both the 
xsl:namespace-alias instruction and for the literal result element.
Conversely, the stylesheet-prefix and the literal namespace URI will not
normally appear in the result tree.

Example: Using xsl:namespace-alias to Generate a Stylesheet

When literal result elements are being used to create element, attribute, or
namespace nodes that use the XSLT namespace URI, the stylesheet may use an
alias.

For example, the stylesheet

<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias">

<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>

<xsl:template match="/">
  <axsl:stylesheet version="2.0">
    <xsl:apply-templates/>
  </axsl:stylesheet>
</xsl:template>

<xsl:template match="elements">
  <axsl:template match="/">
     <axsl:comment select="system-property('xsl:version')"/>
     <axsl:apply-templates/>
  </axsl:template>
</xsl:template>

<xsl:template match="block">
  <axsl:template match="{.}">
     <fo:block><axsl:apply-templates/></fo:block>
  </axsl:template>
</xsl:template>

</xsl:stylesheet>

will generate an XSLT stylesheet from a document of the form:

<elements>
<block>p</block>
<block>h1</block>
<block>h2</block>
<block>h3</block>
<block>h4</block>
</elements>

The output of the transformation will be a stylesheet such as the following.
Whitespace has been added for clarity. Note that an implementation may output
different namespace prefixes from those appearing in this example; however,
the rules guarantee that there will be a namespace node that binds the prefix
xsl to the URI http://www.w3.org/1999/XSL/Transform, which makes it safe to
use the QName xsl:version in the content of the generated stylesheet.

<xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format">

<xsl:template match="/">
  <xsl:comment select="system-property('xsl:version')"/>
  <xsl:apply-templates/>
</xsl:template>
  
<xsl:template match="p">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h1">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h2">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h3">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

<xsl:template match="h4">
  <fo:block><xsl:apply-templates/></fo:block>
</xsl:template>

</xsl:stylesheet>

Note:

It may be necessary also to use aliases for namespaces other than the XSLT
namespace URI. For example, it can be useful to define an alias for the
namespace http://www.w3.org/2001/XMLSchema-instance, so that the stylesheet
can use the attributes xsi:type, xsi:nil, and xsi:schemaLocation on a literal
result element, without running the risk that a schema processor will
interpret these as applying to the stylesheet itself. Equally, literal result
elements belonging to a namespace dealing with digital signatures might cause
XSLT stylesheets to be mishandled by general-purpose security software; using
an alias for the namespace would avoid the possibility of such mishandling.

Example: Aliasing the XML Namespace

It is possible to define an alias for the XML namespace.

<xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0">

<xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/>

<xsl:template match="/">
  <name axml:space="preserve">
    <first>James</first>
    <xsl:text> </xsl:text>
    <last>Clark</last>
  </name>
</xsl:template>

</xsl:stylesheet>

produces the output:

<name xml:space="preserve"><first>James</first> <last>Clark</last></name>

This allows an xml:space attribute to be generated in the output without
affecting the way the stylesheet is parsed. The same technique can be used for
other attributes such as xml:lang, xml:base, and xml:id.

Note:

Namespace aliasing is only necessary when literal result elements are used.
The problem of reserved namespaces does not arise when using xsl:element and 
xsl:attribute to construct the result tree. Therefore, as an alternative to
using xsl:namespace-alias, it is always possible to achieve the desired effect
by replacing literal result elements with xsl:element and xsl:attribute
instructions.

11.2 Creating Element Nodes Using xsl:element

<!-- Category: instruction -->
<xsl:element
  name = { qname }
  namespace? = { uri-reference }
  inherit-namespaces? = "yes" | "no"
  use-attribute-sets? = qnames
  type? = qname
  validation? = "strict" | "lax" | "preserve" | "strip">
  <!-- Content: sequence-constructor -->
</xsl:element>

The xsl:element instruction allows an element to be created with a computed
name. The expanded-QName of the element to be created is specified by a 
required name attribute and an optional namespace attribute.

The content of the xsl:element instruction is a sequence constructor for the
children, attributes, and namespaces of the created element. The sequence
obtained by evaluating this sequence constructor (see 5.7 Sequence
Constructors) is used to construct the content of the element, as described in
5.7.1 Constructing Complex Content.

The xsl:element element may have a use-attribute-sets attribute, whose value
is a whitespace-separated list of QNames that identify xsl:attribute-set
declarations. If this attribute is present, it is expanded as described in 
10.2 Named Attribute Sets to produce a sequence of attribute nodes. This
sequence is prepended to the sequence produced as a result of evaluating the 
sequence constructor, as described in 5.7.1 Constructing Complex Content.

The result of evaluating the xsl:element instruction, except in error cases,
is the newly constructed element node.

The name attribute is interpreted as an attribute value template, whose 
effective value must be a lexical QName.

[ERR XTDE0820] It is a non-recoverable dynamic error if the effective value of
the name attribute is not a lexical QName.

[ERR XTDE0830] In the case of an xsl:element instruction with no namespace
attribute, it is a non-recoverable dynamic error if the effective value of the
name attribute is a QName whose prefix is not declared in an in-scope
namespace declaration for the xsl:element instruction.

If the namespace attribute is not present then the QName is expanded into an 
expanded-QName using the namespace declarations in effect for the xsl:element
element, including any default namespace declaration.

If the namespace attribute is present, then it too is interpreted as an 
attribute value template. The effective value must be in the lexical space of
the xs:anyURI type. If the string is zero-length, then the expanded-QName of
the element has a null namespace URI. Otherwise, the string is used as the
namespace URI of the expanded-QName of the element to be created. The local
part of the lexical QName specified by the name attribute is used as the local
part of the expanded-QName of the element to be created.

[ERR XTDE0835] It is a non-recoverable dynamic error if the effective value of
the namespace attribute is not in the lexical space of the xs:anyURI data
type.

Note:

The XDM data model requires the name of a node to be an instance of xs:QName,
and XML Schema defines the namespace part of an xs:QName to be an instance of
xs:anyURI. However, the schema specification, and the specifications that it
refers to, give implementations some flexibility in how strictly they enforce
these constraints.

The prefix of the lexical QName specified in the name attribute (or the
absence of a prefix) is copied to the prefix part of the expanded-QName
representing the name of the new element node. In the event of a conflict a
prefix may subsequently be added, changed, or removed during the namespace
fixup process (see 5.7.3 Namespace Fixup).

The xsl:element instruction has an optional inherit-namespaces attribute, with
the value yes or no. The default value is yes. If the value is set to yes, or
is omitted, then the namespace nodes created for the newly constructed element
(whether these were copied from those of the source node, or generated as a
result of namespace fixup) are copied to the children and descendants of the
newly constructed element, as described in 5.7.1 Constructing Complex Content.
If the value is set to no, then these namespace nodes are not automatically
copied to the children. This may result in namespace undeclarations (such as
xmlns="" or, in the case of XML Namespaces 1.1, xmlns:p="") appearing on the
child elements when a final result tree is serialized.

The base URI of the new element is copied from the base URI of the xsl:element
instruction in the stylesheet, unless the content of the new element includes
an xml:base attribute, in which case the base URI of the new element is the
value of that attribute, resolved (if it is a relative URI) against the base
URI of the xsl:element instruction in the stylesheet. (Note, however, that
this is only relevant when creating parentless elements. When the new element
is copied to form a child of an element or document node, the base URI of the
new copy is taken from that of its new parent.)

11.2.1 Setting the Type Annotation for a Constructed Element Node

The optional attributes type and validation may be used on the xsl:element
instruction to invoke validation of the contents of the element against a type
definition or element declaration in a schema, and to determine the type
annotation that the new element node will carry. These attributes also affect
the type annotation carried by any elements and attributes that have the new
element node as an ancestor. These two attributes are both optional, and if
one is specified then the other must be omitted. The permitted values of these
attributes and their semantics are described in 19.2 Validation.

Note:

The final type annotation of the element in the result tree also depends on
the type and validation attributes of the instructions used to create the
ancestors of the element.

11.3 Creating Attribute Nodes Using xsl:attribute

<!-- Category: instruction -->
<xsl:attribute
  name = { qname }
  namespace? = { uri-reference }
  select? = expression
  separator? = { string }
  type? = qname
  validation? = "strict" | "lax" | "preserve" | "strip">
  <!-- Content: sequence-constructor -->
</xsl:attribute>

The xsl:attribute element can be used to add attributes to result elements
whether created by literal result elements in the stylesheet or by
instructions such as xsl:element or xsl:copy. The expanded-QName of the
attribute to be created is specified by a required name attribute and an
optional namespace attribute. Except in error cases, the result of evaluating
an xsl:attribute instruction is the newly constructed attribute node.

The string value of the new attribute node may be defined either by using the
select attribute, or by the sequence constructor that forms the content of the
xsl:attribute element. These are mutually exclusive. If neither is present,
the value of the new attribute node will be a zero-length string. The way in
which the value is constructed is specified in 5.7.2 Constructing Simple
Content.

[ERR XTSE0840] It is a static error if the select attribute of the 
xsl:attribute element is present unless the element has empty content.

If the separator attribute is present, then the effective value of this
attribute is used to separate adjacent items in the result sequence, as
described in 5.7.2 Constructing Simple Content. In the absence of this
attribute, the default separator is a single space (#x20) when the content is
specified using the select attribute, or a zero-length string when the content
is specified using a sequence constructor.

The name attribute is interpreted as an attribute value template, whose 
effective value must be a lexical QName.

[ERR XTDE0850] It is a non-recoverable dynamic error if the effective value of
the name attribute is not a lexical QName.

[ERR XTDE0855] In the case of an xsl:attribute instruction with no namespace
attribute, it is a non-recoverable dynamic error if the effective value of the
name attribute is the string xmlns.

[ERR XTDE0860] In the case of an xsl:attribute instruction with no namespace
attribute, it is a non-recoverable dynamic error if the effective value of the
name attribute is a lexical QName whose prefix is not declared in an in-scope
namespace declaration for the xsl:attribute instruction.

If the namespace attribute is not present, then the lexical QName is expanded
into an expanded-QName using the namespace declarations in effect for the 
xsl:attribute element, not including any default namespace declaration.

If the namespace attribute is present, then it too is interpreted as an 
attribute value template. The effective value must be in the lexical space of
the xs:anyURI type. If the string is zero-length, then the expanded-QName of
the attribute has a null namespace URI. Otherwise, the string is used as the
namespace URI of the expanded-QName of the attribute to be created. The local
part of the lexical QName specified by the name attribute is used as the local
part of the expanded-QName of the attribute to be created.

[ERR XTDE0865] It is a non-recoverable dynamic error if the effective value of
the namespace attribute is not in the lexical space of the xs:anyURI data
type.

Note:

The same considerations apply as for elements: [see ERR XTDE0835] in 11.2
Creating Element Nodes Using xsl:element .

The prefix of the lexical QName specified in the name attribute (or the
absence of a prefix) is copied to the prefix part of the expanded-QName
representing the name of the new attribute node. In the event of a conflict
this prefix (or absence of a prefix) may subsequently be changed during the
namespace fixup process (see 5.7.3 Namespace Fixup). If the attribute is in a
non-null namespace and no prefix is specified, then the namespace fixup
process will invent a prefix.

If the name of a constructed attribute is xml:id, the processor must perform
attribute value normalization by effectively applying the normalize-space^FO
function to the value of the attribute, and the resulting attribute node must
be given the is-id property. This applies whether the attribute is constructed
using the xsl:attribute instruction or whether it is constructed using an
attribute of a literal result element. This does not imply any constraints on
the value of the attribute, or on its uniqueness, and it does not affect the 
type annotation of the attribute, unless the containing document is validated.

Note:

The effect of setting the is-id property is that the parent element can be
located within the containing document by use of the id^ FO function. In
effect, XSLT when constructing a document performs some of the functions of an
xml:id processor, as defined in [xml:id]; the other aspects of xml:id
processing are performed during validation.

Example: Creating a List-Valued Attribute

The following instruction creates the attribute colors="red green blue":

<xsl:attribute name="colors" select="'red', 'green', 'blue'"/>

Example: Namespaces are not Attributes

It is not an error to write:

<xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace">http://www.w3.org/1999/XSL/Transform</xsl:attribute>

However, this will not result in the namespace declaration xmlns:xsl="
http://www.w3.org/1999/XSL/Transform" being output. Instead, it will produce
an attribute node with local name xsl, and with a system-allocated namespace
prefix mapped to the namespace URI file://some.namespace. This is because the
namespace fixup process is not allowed to use xmlns as the name of a namespace
node.

As described in 5.7.1 Constructing Complex Content, in a sequence that is used
to construct the content of an element, any attribute nodes must appear in the
sequence before any element, text, comment, or processing instruction nodes.
Where the sequence contains two or more attribute nodes with the same 
expanded-QName, the one that comes last is the only one that takes effect.

Note:

If a collection of attributes is generated repeatedly, this can be done
conveniently by using named attribute sets: see 10.2 Named Attribute Sets

11.3.1 Setting the Type Annotation for a Constructed Attribute Node

The optional attributes type and validation may be used on the xsl:attribute
instruction to invoke validation of the contents of the attribute against a
type definition or attribute declaration in a schema, and to determine the 
type annotation that the new attribute node will carry. These two attributes
are both optional, and if one is specified then the other must be omitted. The
permitted values of these attributes and their semantics are described in 19.2
Validation.

Note:

The final type annotation of the attribute in the result tree also depends on
the type and validation attributes of the instructions used to create the
ancestors of the attribute.

11.4 Creating Text Nodes

This section describes three different ways of creating text nodes: by means
of literal text nodes in the stylesheet, or by using the xsl:text and 
xsl:value-of instructions. It is also possible to create text nodes using the 
xsl:number instruction described in 12 Numbering.

If and when the sequence that results from evaluating a sequence constructor
is used to form the content of a node, as described in 5.7.2 Constructing
Simple Content and 5.7.1 Constructing Complex Content, adjacent text nodes in
the sequence are merged. Within the sequence itself, however, they exist as
distinct nodes.

Example: A sequence of text nodes

The following function returns a sequence of three text nodes:

<xsl:function name="f:wrap">
  <xsl:param name="s"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="$s"/>
  <xsl:text>)</xsl:text>
</xsl:function>

When this function is called as follows:

<xsl:value-of select="f:wrap('---')"/>

the result is:

(---)

No additional spaces are inserted, because the calling xsl:value-of
instruction merges adjacent text nodes before atomizing the sequence. However,
the result of the instruction:

<xsl:value-of select="data(f:wrap('---'))"/>

is:

( --- )

because in this case the three text nodes are atomized to form three strings,
and spaces are inserted between adjacent strings.

It is possible to construct text nodes whose string value is zero-length. A
zero-length text node, when atomized, produces a zero-length string. However,
zero-length text nodes are ignored when they appear in a sequence that is used
to form the content of a node, as described in 5.7.1 Constructing Complex
Content and 5.7.2 Constructing Simple Content.

11.4.1 Literal Text Nodes

A sequence constructor can contain text nodes. Each text node in a sequence
constructor remaining after whitespace text nodes have been stripped as
specified in 4.2 Stripping Whitespace from the Stylesheet will construct a new
text node with the same string value. The resulting text node is added to the
result of the containing sequence constructor.

Text is processed at the tree level. Thus, markup of &lt; in a template will
be represented in the stylesheet tree by a text node that includes the
character <. This will create a text node in the result tree that contains a <
character, which will be represented by the markup &lt; (or an equivalent
character reference) when the result tree is serialized as an XML document,
unless otherwise specified using character maps (see 20.1 Character Maps) or
disable-output-escaping (see 20.2 Disabling Output Escaping).

11.4.2 Creating Text Nodes Using xsl:text

<!-- Category: instruction -->
<xsl:text
  [disable-output-escaping]? = "yes" | "no">
  <!-- Content: #PCDATA -->
</xsl:text>

The xsl:text element is evaluated to contruct a new text node. The content of
the xsl:text element is a single text node whose value forms the string value
of the new text node. An xsl:text element may be empty, in which case the
result of evaluating the instruction is a text node whose string value is the
zero-length string.

The result of evaluating an xsl:text instruction is the newly constructed text
node.

A text node that is an immediate child of an xsl:text instruction will not be
stripped from the stylesheet tree, even if it consists entirely of whitespace
(see 4.4 Stripping Whitespace from a Source Tree).

For the effect of the deprecated disable-output-escaping attribute, see 20.2
Disabling Output Escaping

Note:

It is not always necessary to use the xsl:text instruction to write text nodes
to the result tree. Literal text can be written to the result tree by
including it anywhere in a sequence constructor, while computed text can be
output using the xsl:value-of instruction. The principal reason for using 
xsl:text is that it offers improved control over whitespace handling.

11.4.3 Generating Text with xsl:value-of

Within a sequence constructor, the xsl:value-of instruction can be used to
generate computed text nodes. The xsl:value-of instruction computes the text
using an expression that is specified as the value of the select attribute, or
by means of contained instructions. This might, for example, extract text from
a source tree or insert the value of a variable.

<!-- Category: instruction -->
<xsl:value-of
  select? = expression
  separator? = { string }
  [disable-output-escaping]? = "yes" | "no">
  <!-- Content: sequence-constructor -->
</xsl:value-of>

The xsl:value-of instruction is evaluated to construct a new text node; the
result of the instruction is the newly constructed text node.

The string value of the new text node may be defined either by using the
select attribute, or by the sequence constructor (see 5.7 Sequence
Constructors) that forms the content of the xsl:value-of element. These are
mutually exclusive, and one of them must be present. The way in which the
value is constructed is specified in 5.7.2 Constructing Simple Content.

[ERR XTSE0870] It is a static error if the select attribute of the 
xsl:value-of element is present when the content of the element is non-empty,
or if the select attribute is absent when the content is empty.

If the separator attribute is present, then the effective value of this
attribute is used to separate adjacent items in the result sequence, as
described in 5.7.2 Constructing Simple Content. In the absence of this
attribute, the default separator is a single space (#x20) when the content is
specified using the select attribute, or a zero-length string when the content
is specified using a sequence constructor.

Special rules apply when backwards compatible behavior is enabled for the
instruction. If no separator attribute is present, and if the select attribute
is present, then all items in the atomized result sequence other than the
first are ignored.

Example: Generating a List with Separators

The instruction:

<x><xsl:value-of select="1 to 4" separator="|"/></x>

produces the output:

<x>1|2|3|4</x>

Note:

The xsl:copy-of element can be used to copy a sequence of nodes to the result
tree without atomization. See 11.9.2 Deep Copy.

For the effect of the deprecated disable-output-escaping attribute, see 20.2
Disabling Output Escaping

11.5 Creating Document Nodes

<!-- Category: instruction -->
<xsl:document
  validation? = "strict" | "lax" | "preserve" | "strip"
  type? = qname>
  <!-- Content: sequence-constructor -->
</xsl:document>

The xsl:document instruction is used to create a new document node. The
content of the xsl:document element is a sequence constructor for the children
of the new document node. A document node is created, and the sequence
obtained by evaluating the sequence constructor is used to construct the
content of the document, as described in 5.7.1 Constructing Complex Content.
The temporary tree rooted at this document node forms the result tree.

Except in error situations, the result of evaluating the xsl:document
instruction is a single node, the newly constructed document node.

Note:

The new document is not serialized. To construct a document that is to form a
final result rather than an intermediate result, use the xsl:result-document
instruction described in 19.1 Creating Final Result Trees.

The optional attributes type and validation may be used on the xsl:document
instruction to validate the contents of the new document, and to determine the
type annotation that elements and attributes within the result tree will
carry. The permitted values and their semantics are described in 19.2.2
Validating Document Nodes.

The base URI of the new document node is taken from the base URI of the 
xsl:document instruction.

The document-uri and unparsed-entities properties of the new document node are
set to empty.

Example: Checking Uniqueness Constraints in a Temporary Tree

The following example creates a temporary tree held in a variable. The use of
an enclosed xsl:document instruction ensures that uniqueness constraints
defined in the schema for the relevant elements are checked.

<xsl:variable name="tree" as="document-node()">
  <xsl:document validation="strict">
    <xsl:apply-templates/>
  </xsl:document>
</xsl:variable>

11.6 Creating Processing Instructions

<!-- Category: instruction -->
<xsl:processing-instruction
  name = { ncname }
  select? = expression>
  <!-- Content: sequence-constructor -->
</xsl:processing-instruction>

The xsl:processing-instruction element is evaluated to create a processing
instruction node.

The xsl:processing-instruction element has a required name attribute that
specifies the name of the processing instruction node. The value of the name
attribute is interpreted as an attribute value template.

The string value of the new processing-instruction node may be defined either
by using the select attribute, or by the sequence constructor that forms the
content of the xsl:processing-instruction element. These are mutually
exclusive. If neither is present, the string value of the new
processing-instruction node will be a zero-length string. The way in which the
value is constructed is specified in 5.7.2 Constructing Simple Content.

[ERR XTSE0880] It is a static error if the select attribute of the 
xsl:processing-instruction element is present unless the element has empty
content.

Except in error situations, the result of evaluating the 
xsl:processing-instruction instruction is a single node, the newly constructed
processing instruction node.

Example: Creating a Processing Instruction

This instruction:

<xsl:processing-instruction name="xml-stylesheet"
  select="('href=&quot;book.css&quot;', 'type=&quot;text/css&quot;)"/>

creates the processing instruction

<?xml-stylesheet href="book.css" type="text/css"?>

Note that the xml-stylesheet processing instruction contains pseudo-attributes
in the form name="value". Although these have the same textual form as
attributes in an element start tag, they are not represented as XDM attribute
nodes, and cannot therefore be constructed using xsl:attribute instructions.

[ERR XTDE0890] It is a non-recoverable dynamic error if the effective value of
the name attribute is not both an NCName^ Names and a PITarget^ XML.

Note:

Because these rules disallow the name xml, the xsl:processing-instruction
cannot be used to output an XML declaration. The xsl:output declaration should
be used to control this instead (see 20 Serialization).

If the result of evaluating the content of the xsl:processing-instruction
contains the string ?>, this string is modified by inserting a space between
the ? and > characters.

The base URI of the new processing-instruction is copied from the base URI of
the xsl:processing-instruction element in the stylesheet. (Note, however, that
this is only relevant when creating a parentless processing instruction. When
the new processing instruction is copied to form a child of an element or
document node, the base URI of the new copy is taken from that of its new
parent.)

11.7 Creating Namespace Nodes

<!-- Category: instruction -->
<xsl:namespace
  name = { ncname }
  select? = expression>
  <!-- Content: sequence-constructor -->
</xsl:namespace>

The xsl:namespace element is evaluated to create a namespace node. Except in
error situations, the result of evaluating the xsl:namespace instruction is a
single node, the newly constructed namespace node.

The xsl:namespace element has a required name attribute that specifies the
name of the namespace node (that is, the namespace prefix). The value of the
name attribute is interpreted as an attribute value template. If the effective
value of the name attribute is a zero-length string, a namespace node is added
for the default namespace.

The string value of the new namespace node (that is, the namespace URI) may be
defined either by using the select attribute, or by the sequence constructor
that forms the content of the xsl:namespace element. These are mutually
exclusive. Since the string value of a namespace node cannot be a zero-length
string, one of them must be present. The way in which the value is constructed
is specified in 5.7.2 Constructing Simple Content.

[ERR XTDE0905] It is a non-recoverable dynamic error if the string value of
the new namespace node is not valid in the lexical space of the data type
xs:anyURI. [see ERR XTDE0835]

[ERR XTSE0910] It is a static error if the select attribute of the 
xsl:namespace element is present when the element has content other than one
or more xsl:fallback instructions, or if the select attribute is absent when
the element has empty content.

Note the restrictions described in 5.7.1 Constructing Complex Content for the
position of a namespace node relative to other nodes in the node sequence
returned by a sequence constructor.

Example: Constructing a QName-Valued Attribute

This literal result element:

<data xsi:type="xs:integer" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <xsl:namespace name="xs" select="'http://www.w3.org/2001/XMLSchema'"/>
  <xsl:text>42</xsl:text>
</data>

would typically cause the output document to contain the element:

<data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">42</data>

In this case, the element is constructed using a literal result element, and
the namespace xmlns:xs="http://www.w3.org/2001/XMLSchema" could therefore have
been added to the result tree simply by declaring it as one of the in-scope
namespaces in the stylesheet. In practice, the xsl:namespace instruction is
more likely to be useful in situations where the element is constructed using
an xsl:element instruction, which does not copy all the in-scope namespaces
from the stylesheet.

[ERR XTDE0920] It is a non-recoverable dynamic error if the effective value of
the name attribute is neither a zero-length string nor an NCName^ Names, or if
it is xmlns.

[ERR XTDE0925] It is a non-recoverable dynamic error if the xsl:namespace
instruction generates a namespace node whose name is xml and whose string
value is not http://www.w3.org/XML/1998/namespace, or a namespace node whose
string value is http://www.w3.org/XML/1998/namespace and whose name is not
xml.

[ERR XTDE0930] It is a non-recoverable dynamic error if evaluating the select
attribute or the contained sequence constructor of an xsl:namespace
instruction results in a zero-length string.

For details of other error conditions that may arise, see 5.7 Sequence
Constructors.

Note:

It is rarely necessary to use xsl:namespace to create a namespace node in the 
result tree; in most circumstances, the required namespace nodes will be
created automatically, as a side-effect of writing elements or attributes that
use the namespace. An example where xsl:namespace is needed is a situation
where the required namespace is used only within attribute values in the
result document, not in element or attribute names; especially where the
required namespace prefix or namespace URI is computed at run-time and is not
present in either the source document or the stylesheet.

Adding a namespace node to the result tree will never change the 
expanded-QName of any element or attribute node in the result tree: that is,
it will never change the namespace URI of an element or attribute. It might,
however, constrain the choice of prefixes when namespace fixup is performed.

Namespace prefixes for element and attribute names are effectively established
by the namespace fixup process described in 5.7.3 Namespace Fixup. The fixup
process ensures that an element has in-scope namespace nodes for the namespace
URIs used in the element name and in its attribute names, and the serializer
will typically use these namespace nodes to determine the prefix to use in the
serialized output. The fixup process cannot generate namespace nodes that are
inconsistent with those already present in the tree. This means that it is not
possible for the processor to decide the prefix to use for an element or for
any of its attributes until all the namespace nodes for the element have been
added.

If a namespace prefix is mapped to a particular namespace URI using the 
xsl:namespace instruction, or by using xsl:copy or xsl:copy-of to copy a
namespace node, this prevents the namespace fixup process (and hence the
serializer) from using the same prefix for a different namespace URI on the
same element.

Example: Conflicting Namespace Prefixes

Given the instruction:

<xsl:element name="p:item" xmlns:p="http://www.example.com/p">
  <xsl:namespace name="p">http://www.example.com/q</xsl:namespace>
</xsl:element>

a possible serialization of the result tree is:

<ns0:item xmlns:ns0="http://www.example.com/p" xmlns:p="http://www.example.com/q"/>

The processor must invent a namespace prefix for the URI p.uri; it cannot use
the prefix p because that prefix has been explicitly associated with a
different URI.

Note:

The xsl:namespace instruction cannot be used to generate a namespace
undeclaration of the form xmlns="" (nor the new forms of namespace
undeclaration permitted in [Namespaces in XML 1.1]). Namespace undeclarations
are generated automatically by the serializer if undeclare-prefixes="yes" is
specified on xsl:output, whenever a parent element has a namespace node for
the default namespace prefix, and a child element has no namespace node for
that prefix.

11.8 Creating Comments

<!-- Category: instruction -->
<xsl:comment
  select? = expression>
  <!-- Content: sequence-constructor -->
</xsl:comment>

The xsl:comment element is evaluated to contruct a new comment node. Except in
error cases, the result of evaluating the xsl:comment instruction is a single
node, the newly constructed comment node.

The string value of the new comment node may be defined either by using the
select attribute, or by the sequence constructor that forms the content of the
xsl:comment element. These are mutually exclusive. If neither is present, the
value of the new comment node will be a zero-length string. The way in which
the value is constructed is specified in 5.7.2 Constructing Simple Content.

[ERR XTSE0940] It is a static error if the select attribute of the xsl:comment
element is present unless the element has empty content.

Example: Generating a Comment Node

For example, this

<xsl:comment>This file is automatically generated. Do not edit!</xsl:comment>

would create the comment

<!--This file is automatically generated. Do not edit!-->

In the generated comment node, the processor must insert a space after any
occurrence of - that is followed by another - or that ends the comment.

11.9 Copying Nodes

11.9.1 Shallow Copy

<!-- Category: instruction -->
<xsl:copy
  copy-namespaces? = "yes" | "no"
  inherit-namespaces? = "yes" | "no"
  use-attribute-sets? = qnames
  type? = qname
  validation? = "strict" | "lax" | "preserve" | "strip">
  <!-- Content: sequence-constructor -->
</xsl:copy>

The xsl:copy instruction provides a way of copying the context item. If the 
context item is a node, evaluating the xsl:copy instruction constructs a copy
of the context node, and the result of the xsl:copy instruction is this newly
constructed node. By default, the namespace nodes of the context node are
automatically copied as well, but the attributes and children of the node are
not automatically copied.

When the context item is an atomic value, the xsl:copy instruction returns
this value. The sequence constructor, if present, is not evaluated.

When the context item is an attribute node, text node, comment node,
processing instruction node, or namespace node, the xsl:copy instruction
returns a new node that is a copy of the context node. The new node will have
the same node kind, name, and string value as the context node. In the case of
an attribute node, it will also have the same values for the is-id and
is-idrefs properties. The sequence constructor, if present, is not evaluated.

When the context item is a document node or element node, the xsl:copy
instruction returns a new node that has the same node kind and name as the
context node. The content of the new node is formed by evaluating the sequence
constructor contained in the xsl:copy instruction. The sequence obtained by
evaluating this sequence constructor is used (after prepending any attribute
nodes or namespace nodes as described in the following paragraphs) to
construct the content of the document or element node, as described in 5.7.1
Constructing Complex Content.

Example: Identity Transformation

The identity transformation can be written using xsl:copy as follows:

<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>

This template rule can be used to copy any node in a tree by applying template
rules to its attributes and children. It can be combined with additional
template rules that modify selected nodes, for example if all nodes are to be
copied except note elements and their contents, this can be achieved by using
the identity template rule together with the template rule:

<xsl:template match="note"/>

Note:

The xsl:copy instruction is most useful when copying element nodes. In other
cases, the xsl:copy-of instruction is more flexible, because it has a select
attribute allowing selection of the nodes or values to be copied.

The xsl:copy instruction has an optional use-attribute-sets attribute, whose
value is a whitespace-separated list of QNames that identify xsl:attribute-set
declarations. This attribute is used only when copying element nodes. This
list is expanded as described in 10.2 Named Attribute Sets to produce a
sequence of attribute nodes. This sequence is prepended to the sequence
produced as a result of evaluating the sequence constructor.

The xsl:copy instruction has an optional copy-namespaces attribute, with the
value yes or no. The default value is yes. The attribute is used only when
copying element nodes. If the value is set to yes, or is omitted, then all the
namespace nodes of the source element are copied as namespace nodes for the
result element. These copied namespace nodes are prepended to the sequence
produced as a result of evaluating the sequence constructor (it is immaterial
whether they come before or after any attribute nodes produced by expanding
the use-attribute-sets attribute). If the value is set to no, then the
namespace nodes are not copied. However, namespace nodes will still be added
to the result element as required by the namespace fixup process: see 5.7.3
Namespace Fixup.

The xsl:copy instruction has an optional inherit-namespaces attribute, with
the value yes or no. The default value is yes. The attribute is used only when
copying element nodes. If the value is set to yes, or is omitted, then the
namespace nodes created for the newly constructed element (whether these were
copied from those of the source node, or generated as a result of namespace
fixup) are copied to the children and descendants of the newly constructed
element, as described in 5.7.1 Constructing Complex Content. If the value is
set to no, then these namespace nodes are not automatically copied to the
children. This may result in namespace undeclarations (such as xmlns="" or, in
the case of XML Namespaces 1.1, xmlns:p="") appearing on the child elements
when a final result tree is serialized.

[ERR XTTE0950] It is a type error to use the xsl:copy or xsl:copy-of
instruction to copy a node that has namespace-sensitive content if the
copy-namespaces attribute has the value no and its explicit or implicit
validation attribute has the value preserve. It is also a type error if either
of these instructions (with validation="preserve") is used to copy an
attribute having namespace-sensitive content, unless the parent element is
also copied. A node has namespace-sensitive content if its typed value
contains an item of type xs:QName or xs:NOTATION or a type derived therefrom.
The reason this is an error is because the validity of the content depends on
the namespace context being preserved.

Note:

When attribute nodes are copied, whether with xsl:copy or with xsl:copy-of,
the processor does not automatically copy any associated namespace
information. The namespace used in the attribute name itself will be declared
by virtue of the namespace fixup process (see 5.7.3 Namespace Fixup) when the
attribute is added to an element in the result tree, but if namespace prefixes
are used in the content of the attribute (for example, if the value of the
attribute is an XPath expression) then it is the responsibility of the
stylesheet author to ensure that suitable namespace nodes are added to the 
result tree. This can be achieved by copying the namespace nodes using 
xsl:copy, or by generating them using xsl:namespace.

The optional attributes type and validation may be used on the xsl:copy
instruction to validate the contents of an element, attribute or document node
against a type definition, element declaration, or attribute declaration in a
schema, and thus to determine the type annotation that the new copy of an
element or attribute node will carry. These attributes are ignored when
copying an item that is not an element, attribute or document node. When the
node being copied is an element or document node, these attributes also affect
the type annotation carried by any elements and attributes that have the
copied element or document node as an ancestor. These two attributes are both
optional, and if one is specified then the other must be omitted. The
permitted values of these attributes and their semantics are described in 19.2
Validation.

Note:

The final type annotation of the node in the result tree also depends on the
type and validation attributes of the instructions used to create the
ancestors of the node.

The base URI of a node is copied, except in the case of an element node having
an xml:base attribute, in which case the base URI of the new node is taken as
the value of the xml:base attribute, resolved if it is relative against the
base URI of the xsl:copy instruction. If the copied node is subsequently
attached as a child to a new element or document node, the final copy of the
node inherits its base URI from its parent node, unless this is overridden
using an xml:base attribute.

When an xml:id attribute is copied, using either the xsl:copy or xsl:copy-of
instruction, it is implementation-defined whether the value of the attribute
is subjected to attribute value normalization (that is, effectively applying
the normalize-space^FO function).

Note:

In most cases the value will already have been subjected to attribute value
normalization on the source tree, but if this processing has not been
performed on the source tree, it is not an error for it to be performed on the
result tree.

11.9.2 Deep Copy

<!-- Category: instruction -->
<xsl:copy-of
  select = expression
  copy-namespaces? = "yes" | "no"
  type? = qname
  validation? = "strict" | "lax" | "preserve" | "strip" />

The xsl:copy-of instruction can be used to construct a copy of a sequence of
nodes and/or atomic values, with each new node containing copies of all the
children, attributes, and (by default) namespaces of the original node,
recursively. The result of evaluating the instruction is a sequence of items
corresponding one-to-one with the supplied sequence, and retaining its order.

The required select attribute contains an expression, whose value may be any
sequence of nodes and atomic values. The items in this sequence are processed
as follows:

  * If the item is an element node, a new element is constructed and appended
    to the result sequence. The new element will have the same expanded-QName
    as the original, and it will have deep copies of the attribute nodes and
    children of the element node.
   
    The new element will also have namespace nodes copied from the original
    element node, unless they are excluded by specifying copy-namespaces="no".
    If this attribute is omitted, or takes the value yes, then all the
    namespace nodes of the original element are copied to the new element. If
    it takes the value no, then none of the namespace nodes are copied:
    however, namespace nodes will still be created in the result tree as 
    required by the namespace fixup process: see 5.7.3 Namespace Fixup. This
    attribute affects all elements copied by this instruction: both elements
    selected directly by the select expression, and elements that are
    descendants of nodes selected by the select expression.
   
    The new element will have the same values of the is-id, is-idrefs, and
    nilled properties as the original element.
   
  * If the item is a document node, the instruction adds a new document node
    to the result sequence; the children of this document node will be
    one-to-one copies of the children of the original document node (each
    copied according to the rules for its own node kind).
   
  * If the item is an attribute or namespace node, or a text node, a comment,
    or a processing instruction, the same rules apply as with xsl:copy (see 
    11.9.1 Shallow Copy).
   
  * If the item is an atomic value, the value is appended to the result
    sequence, as with xsl:sequence.
   
The optional attributes type and validation may be used on the xsl:copy-of
instruction to validate the contents of an element, attribute or document node
against a type definition, element declaration, or attribute declaration in a
schema and thus to determine the type annotation that the new copy of an
element or attribute node will carry. These attributes are applied
individually to each element, attribute, and document node that is selected by
the expression in the select attribute. These attributes are ignored when
copying an item that is not an element, attribute or document node.

The specified type and validation apply directly only to elements, attributes
and document nodes created as copies of nodes actually selected by the select
expression, they do not apply to nodes that are implicitly copied because they
have selected nodes as an ancestor. However, these attributes do indirectly
affect the type annotation carried by such implicitly copied nodes, as a
consequence of the validation process.

These two attributes are both optional, and if one is specified then the other
must be omitted. The permitted values of these attributes and their semantics
are described in 19.2 Validation.

Errors may occur when copying namespace-sensitive elements or attributes using
validation="preserve". [see ERR XTTE0950].

The base URI of a node is copied, except in the case of an element node having
an xml:base attribute, in which case the base URI of the new node is taken as
the value of the xml:base attribute, resolved if it is relative against the
base URI of the xsl:copy-of instruction. If the copied node is subsequently
attached as a child to a new element or document node, the final copy of the
node inherits its base URI from its parent node, unless this is overridden
using an xml:base attribute.

11.10 Constructing Sequences

<!-- Category: instruction -->
<xsl:sequence
  select = expression>
  <!-- Content: xsl:fallback* -->
</xsl:sequence>

The xsl:sequence instruction may be used within a sequence constructor to
construct a sequence of nodes and/or atomic values. This sequence is returned
as the result of the instruction. Unlike most other instructions, xsl:sequence
can return a sequence containing existing nodes, rather than constructing new
nodes. When xsl:sequence is used to add atomic values to a sequence, the
effect is very similar to the xsl:copy-of instruction.

The items comprising the result sequence are selected using the select
attribute.

Any contained xsl:fallback instructions are ignored by an XSLT 2.0 processor,
but can be used to define fallback behavior for an XSLT 1.0 processor running
in forwards compatibility mode.

Example: Constructing a Sequence of Integers

For example, the following code:

<xsl:variable name="values" as="xs:integer*">
    <xsl:sequence select="(1,2,3,4)"/>
    <xsl:sequence select="(8,9,10)"/>
</xsl:variable>
<xsl:value-of select="sum($values)"/>

produces the output: 37

Example: Using xsl:for-each to Construct a Sequence

The following code constructs a sequence containing the value of the @price
attribute for selected elements (which we assume to be typed as xs:decimal),
or a computed price for those elements that have no @price attribute. It then
returns the average price:

<xsl:variable name="prices" as="xs:decimal*">
  <xsl:for-each select="//product">
    <xsl:choose>
      <xsl:when test="@price">
        <xsl:sequence select="@price"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="@cost * 1.5"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
</xsl:variable>
<xsl:value-of select="avg($prices)"/>

Note that the existing @price attributes could equally have been added to the
$prices sequence using xsl:copy-of or xsl:value-of. However, xsl:copy-of would
create a copy of the attribute node, which is not needed in this situation,
while xsl:value-of would create a new text node, which then has to be
converted to an xs:decimal. Using xsl:sequence, which in this case atomizes
the existing attribute node and adds an xs:decimal atomic value to the result
sequence, is a more direct way of achieving the same result.

This example could alternatively be solved at the XPath level:

<xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/>

(The apparently redundant + operator is there to atomize the attribute value:
the expression on the right hand side of the / operator must not return a
mixture of nodes and atomic values.)

12 Numbering

<!-- Category: instruction -->
<xsl:number
  value? = expression
  select? = expression
  level? = "single" | "multiple" | "any"
  count? = pattern
  from? = pattern
  format? = { string }
  lang? = { nmtoken }
  letter-value? = { "alphabetic" | "traditional" }
  ordinal? = { string }
  grouping-separator? = { char }
  grouping-size? = { number } />

The xsl:number instruction is used to create a formatted number. The result of
the instruction is a newly constructed text node containing the formatted
number as its string value.

[Definition: The xsl:number instruction performs two tasks: firstly,
determining a place marker (this is a sequence of integers, to allow for
hierarchic numbering schemes such as 1.12.2 or 3(c)ii), and secondly,
formatting the place marker for output as a text node in the result sequence.]
The place marker to be formatted can either be supplied directly, in the value
attribute, or it can be computed based on the position of a selected node
within the tree that contains it.

[ERR XTSE0975] It is a static error if the value attribute of xsl:number is
present unless the select, level, count, and from attributes are all absent.

Note:

The facilities described in this section are specifically designed to enable
the calculation and formatting of section numbers, paragraph numbers, and the
like. For formatting of other numeric quantities, the format-number function
may be more suitable: see 16.4 Number Formatting.

12.1 Formatting a Supplied Number

The place marker to be formatted may be specified by an expression. The value
attribute contains the expression. The value of this expression is atomized
using the procedure defined in [XPath 2.0], and each value $V in the atomized
sequence is then converted to the integer value returned by the XPath
expression xs:integer(round(number($V))). The resulting sequence of integers
is used as the place marker to be formatted.

If backwards compatible behavior is enabled for the instruction, then:

  * all items in the atomized sequence after the first are discarded;
   
  * If the atomized sequence is empty, it is replaced by a sequence containing
    the xs:double value NaN as its only item;
   
  * If any value in the sequence cannot be converted to an integer (this
    includes the case where the sequence contains a NaN value) then the string
    NaN is inserted into the formatted result string in its proper position.
    The error described in the following paragraph does not apply in this
    case.
   
[ERR XTDE0980] It is a non-recoverable dynamic error if any undiscarded item
in the atomized sequence supplied as the value of the value attribute of 
xsl:number cannot be converted to an integer, or if the resulting integer is
less than 0 (zero).

Note:

The value zero does not arise when numbering nodes in a source document, but
it can arise in other numbering sequences. It is permitted specifically
because the rules of the xsl:number instruction are also invoked by functions
such as format-time: the minutes and seconds component of a time value can
legitimately be zero.

The resulting sequence is formatted as a string using the effective values of
the attributes specified in 12.3 Number to String Conversion Attributes; each
of these attributes is interpreted as an attribute value template. After
conversion, the xsl:number element constructs a new text node containing the
resulting string, and returns this node.

Example: Numbering a Sorted List

The following example numbers a sorted list:

<xsl:template match="items">
  <xsl:for-each select="item">
    <xsl:sort select="."/>
    <p>
      <xsl:number value="position()" format="1. "/>
      <xsl:value-of select="."/>
    </p>
  </xsl:for-each>
</xsl:template>

12.2 Numbering based on Position in a Document

If no value attribute is specified, then the xsl:number instruction returns a
new text node containing a formatted place marker that is based on the
position of a selected node within its containing document. If the select
attribute is present, then the expression contained in the select attribute is
evaluated to determine the selected node. If the select attribute is omitted,
then the selected node is the context node.

[ERR XTTE0990] It is a type error if the xsl:number instruction is evaluated,
with no value or select attribute, when the context item is not a node.

[ERR XTTE1000] It is a type error if the result of evaluating the select
attribute of the xsl:number instruction is anything other than a single node.

The following attributes control how the selected node is to be numbered:

  * The level attribute specifies rules for selecting the nodes that are taken
    into account in allocating a number; it has the values single, multiple or
    any. The default is single.
   
  * The count attribute is a pattern that specifies which nodes are to be
    counted at those levels. If count attribute is not specified, then it
    defaults to the pattern that matches any node with the same node kind as
    the selected node and, if the selected node has an expanded-QName, with
    the same expanded-QName as the selected node.
   
  * The from attribute is a pattern that specifies where counting starts.
   
In addition, the attributes specified in 12.3 Number to String Conversion
Attributes are used for number to string conversion, as in the case when the
value attribute is specified.

The xsl:number element first constructs a sequence of positive integers using
the level, count and from attributes. Where level is single or any, this
sequence will either be empty or contain a single number; where level is
multiple, the sequence may be of any length. The sequence is constructed as
follows:

Let matches-count($node) be a function that returns true if and only if the
given node $node matches the pattern given in the count attribute, or the
implied pattern (according to the rules given above) if the count attribute is
omitted.

Let matches-from($node) be a function that returns true if and only if the
given node $node matches the pattern given in the from attribute, or if $node
is the root node of a tree. If the from attribute is omitted, then the
function returns true if and only if $node is the root node of a tree.

Let $S be the selected node.

When level="single":

  * Let $A be the node sequence selected by the following expression:
   
       $S/ancestor-or-self::node()[matches-count(.)][1]
   
    (this selects the innermost ancestor-or-self node that matches the count
    pattern)
   
  * Let $F be the node sequence selected by the expression
   
       $S/ancestor-or-self::node()[matches-from(.)][1]
   
    (this selects the innermost ancestor-or-self node that matches the from
    pattern):
   
  * Let $AF be the value of:
   
       $A[ancestor-or-self::node()[. is $F]]
   
    (this selects $A if it is in the subtree rooted at $F, or the empty
    sequence otherwise)
   
  * If $AF is empty, return the empty sequence, ()
   
  * Otherwise return the value of:
   
       1 + count($AF/preceding-sibling::node()[matches-count(.)])
   
    (the number of preceding siblings of the counted node that match the count
    pattern, plus one).
   
When level="multiple":

  * Let $A be the node sequence selected by the expression
   
       $S/ancestor-or-self::node()[matches-count(.)]
   
    (the set of ancestor-or-self nodes that match the count pattern)
   
  * Let $F be the node sequence selected by the expression
   
       $S/ancestor-or-self::node()[matches-from(.)][1]
   
    (the innermost ancestor-or-self node that matches the from pattern)
   
  * Let $AF be the value of
   
       $A[ancestor-or-self::node()[. is $F]]
   
    (the nodes selected in the first step that are in the subtree rooted at
    the node selected in the second step)
   
  * Return the result of the expression
   
       for $af in $AF return 1+count($af/preceding-sibling::node()
    [matches-count(.)])
   
    (a sequence of integers containing, for each of these nodes, one plus the
    number of preceding siblings that match the count pattern)
   
When level="any":

  * Let $A be the node sequence selected by the expression
   
       $S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]
   
    (the set of nodes consisting of the selected node together with all nodes,
    other than attributes and namespaces, that precede the selected node in
    document order, provided that they match the count pattern)
   
  * Let $F be the node sequence selected by the expression
   
       $S/(preceding::node()|ancestor::node())[matches-from(.)][last()]
   
    (the last node in document order that matches the from pattern and that
    precedes the selected node, using the same definition)
   
  * Let $AF be the node sequence $A[. is $F or . >> $F].
   
    (the nodes selected in the first step, excluding those that precede the
    node selected in the second step)
   
  * If $AF is empty, return the empty sequence, ()
   
  * Otherwise return the value of the expression count($AF)
   
The sequence of numbers (the place marker) is then converted into a string
using the effective values of the attributes specified in 12.3 Number to
String Conversion Attributes; each of these attributes is interpreted as an 
attribute value template. After conversion, the resulting string is used to
create a text node, which forms the result of the xsl:number instruction.

Example: Numbering the Items in an Ordered List

The following will number the items in an ordered list:

<xsl:template match="ol/item">
  <fo:block>
    <xsl:number/>
    <xsl:text>. </xsl:text>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

Example: Multi-Level Numbering

The following two rules will number title elements. This is intended for a
document that contains a sequence of chapters followed by a sequence of
appendices, where both chapters and appendices contain sections, which in turn
contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A,
B, C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices
are numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1,
1.1.2, 1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.

<xsl:template match="title">
  <fo:block>
     <xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="appendix//title" priority="1">
  <fo:block>
     <xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

Example: Numbering Notes within a Chapter

This example numbers notes sequentially within a chapter:

<xsl:template match="note">
  <fo:block>
     <xsl:number level="any" from="chapter" format="(1) "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

12.3 Number to String Conversion Attributes

The following attributes are used to control conversion of a sequence of
numbers into a string. The numbers are integers greater than or equal to 0
(zero). The attributes are all optional.

The main attribute is format. The default value for the format attribute is 1.
The format attribute is split into a sequence of tokens where each token is a
maximal sequence of alphanumeric characters or a maximal sequence of
non-alphanumeric characters. Alphanumeric means any character that has a
Unicode category of Nd, Nl, No, Lu, Ll, Lt, Lm or Lo. The alphanumeric tokens
(format tokens) indicate the format to be used for each number in the
sequence; in most cases the format token is the same as the required
representation of the number 1 (one).

Each non-alphanumeric token is either a prefix, a separator, or a suffix. If
there is a non-alphanumeric token but no format token, then the single
non-alphanumeric token is used as both the prefix and the suffix. The prefix,
if it exists, is the non-alphanumeric token that precedes the first format
token: the prefix always appears exactly once in the constructed string, at
the start. The suffix, if it exists, is the non-alphanumeric token that
follows the last format token: the suffix always appears exactly once in the
constructed string, at the end. All other non-alphanumeric tokens (those that
occur between two format tokens) are separator tokens and are used to separate
numbers in the sequence.

The nth format token is used to format the nth number in the sequence. If
there are more numbers than format tokens, then the last format token is used
to format remaining numbers. If there are no format tokens, then a format
token of 1 is used to format all numbers. Each number after the first is
separated from the preceding number by the separator token preceding the
format token used to format that number, or, if that is the first format token
, then by . (dot).

Example: Formatting a List of Numbers

Given the sequence of numbers 5, 13, 7 and the format token A-001(i), the
output will be the string E-013(vii)

Format tokens are interpreted as follows:

  * Any token where the last character has a decimal digit value of 1 (as
    specified in the Unicode character property database), and the Unicode
    value of preceding characters is one less than the Unicode value of the
    last character generates a decimal representation of the number where each
    number is at least as long as the format token. The digits used in the
    decimal representation are the set of digits containing the digit
    character used in the format token. Thus, a format token 1 generates the
    sequence 0 1 2 ... 10 11 12 ..., and a format token 01 generates the
    sequence 00 01 02 ... 09 10 11 12 ... 99 100 101. A format token of &#
    x661; (Arabic-Indic digit one) generates the sequence ١ then ٢ then ٣ ...
   
  * A format token A generates the sequence A B C ... Z AA AB AC....
   
  * A format token a generates the sequence a b c ... z aa ab ac....
   
  * A format token i generates the sequence i ii iii iv v vi vii viii ix x
    ....
   
  * A format token I generates the sequence I II III IV V VI VII VIII IX X
    ....
   
  * A format token w generates numbers written as lower-case words, for
    example in English, one two three four ...
   
  * A format token W generates numbers written as upper-case words, for
    example in English, ONE TWO THREE FOUR ...
   
  * A format token Ww generates numbers written as title-case words, for
    example in English, One Two Three Four ...
   
  * Any other format token indicates a numbering sequence in which that token
    represents the number 1 (one) (but see the note below). It is 
    implementation-defined which numbering sequences, additional to those
    listed above, are supported. If an implementation does not support a
    numbering sequence represented by the given token, it must use a format
    token of 1.
   
    Note:
   
    In some traditional numbering sequences additional signs are added to
    denote that the letters should be interpreted as numbers; these are not
    included in the format token. An example, see also the example below, is
    classical Greek where a dexia keraia and sometimes an aristeri keraia is
    added.
   
For all format tokens other than the first kind above (one that consists of
decimal digits), there may be implementation-defined lower and upper bounds on
the range of numbers that can be formatted using this format token; indeed,
for some numbering sequences there may be intrinsic limits. For example, the
formatting token &#x2460; (circled digit one) has a range of 1 to 20 imposed
by the Unicode character repertoire. For the numbering sequences described
above any upper bound imposed by the implementation must not be less than 1000
(one thousand) and any lower bound must not be greater than 1. Numbers that
fall outside this range must be formatted using the format token 1. The
numbering sequence associated with the format token 1 has a lower bound of 0
(zero).

The above expansions of numbering sequences for format tokens such as a and i
are indicative but not prescriptive. There are various conventions in use for
how alphabetic sequences continue when the alphabet is exhausted, and
differing conventions for how roman numerals are written (for example, IV
versus IIII as the representation of the number 4). Sometimes alphabetic
sequences are used that omit letters such as i and o. This specification does
not prescribe the detail of any sequence other than those sequences consisting
entirely of decimal digits.

Many numbering sequences are language-sensitive. This applies especially to
the sequence selected by the tokens w, W and Ww. It also applies to other
sequences, for example different languages using the Cyrillic alphabet use
different sequences of characters, each starting with the letter #x410
(Cyrillic capital letter A). In such cases, the lang attribute specifies which
language's conventions are to be used; it has the same range of values as
xml:lang (see [XML 1.0]). If no lang value is specified, the language that is
used is implementation-defined. The set of languages for which numbering is
supported is implementation-defined. If a language is requested that is not
supported, the processor uses the language that it would use if the lang
attribute were omitted.

If the optional ordinal attribute is present, and if its value is not a
zero-length string, this indicates a request to output ordinal numbers rather
than cardinal numbers. For example, in English, the value ordinal="yes" when
used with the format token 1 outputs the sequence 1st 2nd 3rd 4th ..., and
when used with the format token w outputs the sequence first second third
fourth .... In some languages, ordinal numbers vary depending on the
grammatical context, for example they may have different genders and may
decline with the noun that they qualify. In such cases the value of the
ordinal attribute may be used to indicate the variation of the ordinal number
required. The way in which the variation is indicated will depend on the
conventions of the language. For inflected languages that vary the ending of
the word, the preferred approach is to indicate the required ending, preceded
by a hyphen: for example in German, appropriate values are -e, -er, -es, -en. 
It is implementation-defined what combinations of values of the format token,
the language, and the ordinal attribute are supported. If ordinal numbering is
not supported for the combination of the format token, the language, and the
actual value of the ordinal attribute, the request is ignored and cardinal
numbers are generated instead.

Example: Ordinal Numbering in Italian

The specification format="1" ordinal="-º" lang="it", if supported, should
produce the sequence:

1º 2º 3º 4º ...

The specification format="Ww" ordinal="-o" lang="it", if supported, should
produce the sequence:

Primo Secondo Terzo Quarto Quinto ...

The letter-value attribute disambiguates between numbering sequences that use
letters. In many languages there are two commonly used numbering sequences
that use letters. One numbering sequence assigns numeric values to letters in
alphabetic sequence, and the other assigns numeric values to each letter in
some other manner traditional in that language. In English, these would
correspond to the numbering sequences specified by the format tokens a and i.
In some languages, the first member of each sequence is the same, and so the
format token alone would be ambiguous. A value of alphabetic specifies the
alphabetic sequence; a value of traditional specifies the other sequence. If
the letter-value attribute is not specified, then it is 
implementation-dependent how any ambiguity is resolved.

Note:

Implementations may use extension attributes on xsl:number to provide
additional control over the way in which numbers are formatted.

The grouping-separator attribute gives the separator used as a grouping (for
example, thousands) separator in decimal numbering sequences, and the optional
grouping-size specifies the size (normally 3) of the grouping. For example,
grouping-separator="," and grouping-size="3" would produce numbers of the form
1,000,000 while grouping-separator="." and grouping-size="2" would produce
numbers of the form 1.00.00.00. If only one of the grouping-separator and
grouping-size attributes is specified, then it is ignored.

Example: Format Tokens and the Resulting Sequences

These examples use non-Latin characters which might not display correctly in
all browsers, depending on the system configuration.

+----------------------------------------------------------------------------+
| Description | Format Token  | Sequence                                     |
|-------------+---------------+----------------------------------------------|
| French      | format="Ww"   |                                              |
| cardinal    | lang="fr"     | Un, Deux, Trois, Quatre                      |
| words       |               |                                              |
|-------------+---------------+----------------------------------------------|
| German      | format="w"    |                                              |
| ordinal     | ordinal="-e"  | erste, zweite, dritte, vierte                |
| words       | lang="de"     |                                              |
|-------------+---------------+----------------------------------------------|
|             |               | ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ,  |
| Katakana    | format="&#    | シ, ス, セ, ソ, タ, チ, ツ, テ, ト, ナ, ニ,  |
| numbering   | x30A2;"       | ヌ, ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム,  |
|             |               | メ, モ, ヤ, ユ, ヨ, ラ, リ, ル, レ, ロ, ワ,  |
|             |               | ヰ, ヱ, ヲ, ン                               |
|-------------+---------------+----------------------------------------------|
| Katakana    |               | イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル,  |
| numbering   | format="&#    | ヲ, ワ, カ, ヨ, タ, レ, ソ, ツ, ネ, ナ, ラ,  |
| in iroha    | x30A4;"       | ム, ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ,  |
| order       |               | エ, テ, ア, サ, キ, ユ, メ, ミ, シ, ヱ, ヒ,  |
|             |               | モ, セ, ス                                   |
|-------------+---------------+----------------------------------------------|
| Thai        | format="&#    | ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑, ๑๒, ๑๓,   |
| numbering   | x0E51;"       | ๑๔, ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, ๒๐                   |
|-------------+---------------+----------------------------------------------|
| Traditional | format="&#    |                                              |
| Hebrew      | x05D0;"       | א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב, יג,    |
| numbering   | letter-value= | יד, טו, טז, יז, יח, יט, כ                    |
|             | "traditional" |                                              |
|-------------+---------------+----------------------------------------------|
| Traditional | format="&#    |                                              |
| Georgian    | x10D0;"       | ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ, იგ,    |
| numbering   | letter-value= | იდ, იე, ივ, იზ, იჱ, ით, კ                    |
|             | "traditional" |                                              |
|-------------+---------------+----------------------------------------------|
| Classical   | format="&#    |                                              |
| Greek       | x03B1;"       | αʹ, βʹ, γʹ, δʹ, εʹ, ϛʹ, ζʹ, ηʹ, θʹ, ιʹ, ιαʹ, |
| numbering   | letter-value= | ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, ιζʹ, ιηʹ, ιθʹ, κʹ   |
| (see note)  | "traditional" |                                              |
|-------------+---------------+----------------------------------------------|
|             | format="&#    |                                              |
| Old Slavic  | x0430;"       | А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ, ГӀ,    |
| numbering   | letter-value= | ДӀ, ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, К                    |
|             | "traditional" |                                              |
+----------------------------------------------------------------------------+

Note that Glassical Greek is an example where the format token is not the same
as the representation of the number 1.

13 Sorting

[Definition: A sort key specification is a sequence of one or more adjacent 
xsl:sort elements which together define rules for sorting the items in an
input sequence to form a sorted sequence.]

[Definition: Within a sort key specification, each xsl:sort element defines
one sort key component.] The first xsl:sort element specifies the primary
component of the sort key specification, the second xsl:sort element specifies
the secondary component of the sort key specification and so on.

A sort key specification may occur immediately within an xsl:apply-templates, 
xsl:for-each, xsl:perform-sort, or xsl:for-each-group element.

Note:

When used within xsl:for-each, xsl:for-each-group, or xsl:perform-sort, 
xsl:sort elements must occur before any other children.

13.1 The xsl:sort Element

<xsl:sort
  select? = expression
  lang? = { nmtoken }
  order? = { "ascending" | "descending" }
  collation? = { uri }
  stable? = { "yes" | "no" }
  case-order? = { "upper-first" | "lower-first" }
  data-type? = { "text" | "number" | qname-but-not-ncname }>
  <!-- Content: sequence-constructor -->
</xsl:sort>

The xsl:sort element defines a sort key component. A sort key component
specifies how a sort key value is to be computed for each item in the sequence
being sorted, and also how two sort key values are to be compared.

The value of a sort key component is determined either by its select
attribute, or by the contained sequence constructor. If neither is present,
the default is select=".", which has the effect of sorting on the actual value
of the item if it is an atomic value, or on the typed-value of the item if it
is a node. If a select attribute is present, its value must be an XPath 
expression.

[ERR XTSE1015] It is a static error if an xsl:sort element with a select
attribute has non-empty content.

Those attributes of the xsl:sort elements whose values are attribute value
templates are evaluated using the same focus as is used to evaluate the select
attribute of the containing instruction (specifically, xsl:apply-templates, 
xsl:for-each, xsl:for-each-group, or xsl:perform-sort).

The stable attribute is permitted only on the first xsl:sort element within a 
sort key specification

[ERR XTSE1017] It is a static error if an xsl:sort element other than the
first in a sequence of sibling xsl:sort elements has a stable attribute.

[Definition: A sort key specification is said to be stable if its first 
xsl:sort element has no stable attribute, or has a stable attribute whose 
effective value is yes.]

13.1.1 The Sorting Process

[Definition: The sequence to be sorted is referred to as the initial sequence.
]

[Definition: The sequence after sorting as defined by the xsl:sort elements is
referred to as the sorted sequence.]

[Definition:  For each item in the initial sequence, a value is computed for
each sort key component within the sort key specification. The value computed
for an item by using the Nth sort key component is referred to as the Nth sort
key value of that item.]

The items in the initial sequence are ordered into a sorted sequence by
comparing their sort key values. The relative position of two items A and B in
the sorted sequence is determined as follows. The first sort key value of A is
compared with the first sort key value of B, according to the rules of the
first sort key component. If, under these rules, A is less than B, then A will
precede B in the sorted sequence, unless the order attribute of this sort key
component specifies descending, in which case B will precede A in the sorted
sequence. If, however, the relevant sort key values compare equal, then the
second sort key value of A is compared with the second sort key value of B,
according to the rules of the second sort key component. This continues until
two sort key values are found that compare unequal. If all the sort key values
compare equal, and the sort key specification is stable, then A will precede B
in the sorted sequence if and only if A preceded B in the initial sequence. If
all the sort key values compare equal, and the sort key specification is not 
stable, then the relative order of A and B in the sorted sequence is 
implementation-dependent.

Note:

If two items have equal sort key values, and the sort is stable, then their
order in the sorted sequence will be the same as their order in the initial
sequence, regardless of whether order="descending" was specified on any or all
of the sort key components.

The Nth sort key value is computed by evaluating either the select attribute
or the contained sequence constructor of the Nth xsl:sort element, or the
expression . (dot) if neither is present. This evaluation is done with the 
focus set as follows:

  * The context item is the item in the initial sequence whose sort key value
    is being computed.
   
  * The context position is the position of that item in the initial sequence.
   
  * The context size is the size of the initial sequence.
   
Note:

As in any other XPath expression, the current function may be used within the
select expression of xsl:sort to refer to the item that is the context item
for the expression as a whole; that is, the item whose sort key value is being
computed.

The sort key values are atomized, and are then compared. The way they are
compared depends on their data type, as described in the next section.

13.1.2 Comparing Sort Key Values

It is possible to force the system to compare sort key values using the rules
for a particular data type by including a cast as part of the sort key
component. For example, <xsl:sort select="xs:date(@dob)"/> will force the
attributes to be compared as dates. In the absence of such a cast, the sort
key values are compared using the rules appropriate to their data type. Any
values of type xs:untypedAtomic are cast to xs:string.

For backwards compatibility with XSLT 1.0, the data-type attribute remains
available. If this has the effective value text, the atomized sort key values
are converted to strings before being compared. If it has the effective value
number, the atomized sort key values are converted to doubles before being
compared. The conversion is done by using the string^FO or number^FO function
as appropriate. If the data-type attribute has any other effective value, then
the value must be a lexical QName with a non-empty prefix, and the effect of
the attribute is implementation-defined.

[ERR XTTE1020] If any sort key value, after atomization and any type
conversion required by the data-type attribute, is a sequence containing more
than one item, then the effect depends on whether the xsl:sort element is
evaluated with backwards compatible behavior. With backwards compatible
behavior, the effective sort key value is the first item in the sequence. In
other cases, this is a type error.

The set of sort key values (after any conversion) is first divided into two
categories: empty values, and ordinary values. The empty sort key values
represent those items where the sort key value is an empty sequence. These
values are considered for sorting purposes to be equal to each other, but less
than any other value. The remaining values are classified as ordinary values.

[ERR XTDE1030] It is a non-recoverable dynamic error if, for any sort key
component, the set of sort key values evaluated for all the items in the 
initial sequence, after any type conversion requested, contains a pair of
ordinary values for which the result of the XPath lt operator is an error.

Note:

The above error condition may occur if the values to be sorted are of a type
that does not support ordering (for example, xs:QName) or if the sequence is
heterogeneous (for example, if it contains both strings and numbers). The
error can generally be prevented by invoking a cast or constructor function
within the sort key component.

The error condition is subject to the usual caveat that a processor is not
required to evaluate any expression solely in order to determine whether it
raises an error. For example, if there are several sort key components, then a
processor is not required to evaluate or compare minor sort key values unless
the corresponding major sort key values are equal.

In general, comparison of two ordinary values is performed according to the
rules of the XPath lt operator. To ensure a total ordering, the same
implementation of the lt operator must be used for all the comparisons: the
one that is chosen is the one appropriate to the most specific type to which
all the values can be converted by subtype substitution and/or type promotion.
For example, if the sequence contains both xs:decimal and xs:double values,
then the values are compared using xs:double comparison, even when comparing
two xs:decimal values. NaN values, for sorting purposes, are considered to be
equal to each other, and less than any other numeric value. Special rules also
apply to the xs:string and xs:anyURI types, and types derived by restriction
therefrom,, as described in the next section.

13.1.3 Sorting Using Collations

The rules given in this section apply when comparing values whose type is
xs:string or a type derived by restriction from xs:string, or whose type is
xs:anyURI or a type derived by restriction from xs:anyURI.

[Definition: Facilities in XSLT 2.0 and XPath 2.0 that require strings to be
ordered rely on the concept of a named collation. A collation is a set of
rules that determine whether two strings are equal, and if not, which of them
is to be sorted before the other.] A collation is identified by a URI, but the
manner in which this URI is associated with an actual rule or algorithm is 
implementation-defined.

The one collation URI that must be recognized by every implementation is 
http://www.w3.org/2005/xpath-functions/collation/codepoint, which provides the
ability to compare strings based on the Unicode codepoint values of the
characters in the string.

For more information about collations, see Section 7.3 Equality and Comparison
of Strings^FO in [Functions and Operators]. Some specifications, for example 
[UNICODE TR10], use the term "collation" to describe rules that can be
tailored or parameterized for various purposes. In this specification, a
collation URI refers to a collation in which all such parameters have already
been fixed. Therefore, if a collation URI is specified, other attributes such
as case-order and lang are ignored.

Note:

The reason XSLT does not provide detailed mechanisms for defining collating
sequences is that many implementations will re-use collating mechanisms
available from the underlying implementation platform (for example, from the
operating system or from the run-time library of a chosen programming
language). These will inevitably differ from one XSLT implementation to
another.

If the xsl:sort element has a collation attribute, then the strings are
compared according to the rules for the named collation: that is, they are
compared using the XPath function call compare($a, $b, $collation).

If the effective value of the collation attribute of xsl:sort is a relative
URI, then it is resolved against the base URI of the xsl:sort element.

[ERR XTDE1035] It is a non-recoverable dynamic error if the collation
attribute of xsl:sort (after resolving against the base URI) is not a URI that
is recognized by the implementation as referring to a collation.

Note:

It is entirely for the implementation to determine whether it recognizes a
particular collation URI. For example, if the implementation allows collation
URIs to contain parameters in the query part of the URI, it is the
implementation that determines whether a URI containing an unknown or invalid
parameter is or is not a recognized collation URI. The fact that this error is
described as non-recoverable thus does not prevent an implementation applying
a fallback collation if it chooses to do so.

The lang and case-order attributes are ignored if a collation attribute is
present. But in the absence of a collation attribute, these attributes provide
input to an implementation-defined algorithm to locate a suitable collation:

  * The lang attribute indicates that a collation suitable for a particular
    natural language should be used. The effective value of the attribute must
    be a value that would be valid for the xml:lang attribute (see [XML 1.0]).
   
  * The case-order attribute indicates whether the desired collation should
    sort upper-case letters before lower-case or vice versa. The effective
    value of the attribute must be either lower-first (indicating that
    lower-case letters precede upper-case letters in the collating sequence)
    or upper-first (indicating that upper-case letters precede lower-case).
   
If none of the collation, lang or case-order attributes is present, the
collation is chosen in an implementation-defined way. It is not required that
the default collation for sorting should be the same as the default collation
used when evaluating XPath expressions, as described in 5.4.1 Initializing the
Static Context and 3.6.1 The default-collation attribute.

Note:

It is usually appropriate, when sorting, to use a strong collation, that is,
one that takes account of secondary differences (accents) and tertiary
differences (case) between strings that are otherwise equal. A weak collation,
which ignores such differences, may be more suitable when comparing strings
for equality.

Useful background information on international sorting is provided in [UNICODE
TR10]. The case-order attribute may be interpreted as described in section 6.6
of [UNICODE TR10].

13.2 Creating a Sorted Sequence

<!-- Category: instruction -->
<xsl:perform-sort
  select? = expression>
  <!-- Content: (xsl:sort+, sequence-constructor) -->
</xsl:perform-sort>

The xsl:perform-sort instruction is used to return a sorted sequence.

The initial sequence is obtained either by evaluating the select attribute or
by evaluating the contained sequence constructor (but not both). If there is
no select attribute and no sequence constructor then the initial sequence (and
therefore, the sorted sequence) is an empty sequence.

[ERR XTSE1040] It is a static error if an xsl:perform-sort instruction with a
select attribute has any content other than xsl:sort and xsl:fallback
instructions.

The result of the xsl:perform-sort instruction is the result of sorting its 
initial sequence using its contained sort key specification.

Example: Sorting a Sequence of Atomic Values

The following stylesheet function sorts a sequence of atomic values using the
value itself as the sort key.

<xsl:function name="local:sort" as="xs:anyAtomicType*">
  <xsl:param name="in" as="xs:anyAtomicType*"/>
  <xsl:perform-sort select="$in">
    <xsl:sort select="."/>
  </xsl:perform-sort>
</xsl:function>

Example: Writing a Function to Perform a Sort

The following example defines a function that sorts books by price, and uses
this function to output the five books that have the lowest prices:

<xsl:function name="bib:books-by-price" as="schema-element(bib:book)*">
  <xsl:param name="in" as="schema-element(bib:book)*"/>
  <xsl:perform-sort select="$in">
    <xsl:sort select="xs:decimal(bib:price)"/>
  </xsl:perform-sort>
</xsl:function>
   ...
   <xsl:copy-of select="bib:books-by-price(//bib:book)[position() = 1 to 5]"/>

13.3 Processing a Sequence in Sorted Order

When used within xsl:for-each or xsl:apply-templates, a sort key specification
indicates that the sequence of items selected by that instruction is to be
processed in sorted order, not in the order of the supplied sequence.

Example: Processing Elements in Sorted Order

For example, suppose an employee database has the form

<employees>
  <employee>
    <name>
      <given>James</given>
      <family>Clark</family>
    </name>
    ...
  </employee>
</employees>

Then a list of employees sorted by name could be generated using:

<xsl:template match="employees">
  <ul>
    <xsl:apply-templates select="employee">
      <xsl:sort select="name/family"/>
      <xsl:sort select="name/given"/>
    </xsl:apply-templates>
  </ul>
</xsl:template>

<xsl:template match="employee">
  <li>
    <xsl:value-of select="name/given"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name/family"/>
  </li>
</xsl:template>

When used within xsl:for-each-group, a sort key specification indicates the
order in which the groups are to be processed. For the effect of 
xsl:for-each-group, see 14 Grouping.

14 Grouping

The facilities described in this section are designed to allow items in a
sequence to be grouped based on common values; for example it allows grouping
of elements having the same value for a particular attribute, or elements with
the same name, or elements with common values for any other expression. Since
grouping identifies items with duplicate values, the same facilities also
allow selection of the distinct values in a sequence of items, that is, the
elimination of duplicates.

Note:

Simple elimination of duplicates can also be achieved using the function 
distinct-values^FO in the core function library: see [Functions and Operators]
.

In addition these facilities allow grouping based on sequential position, for
example selecting groups of adjacent para elements. The facilities also
provide an easy way to do fixed-size grouping, for example identifying groups
of three adjacent nodes, which is useful when arranging data in multiple
columns.

For each group of items identified, it is possible to evaluate a sequence
constructor for the group. Grouping is nestable to multiple levels so that
groups of distinct items can be identified, then from among the distinct
groups selected, further sub-grouping of distinct items in the current group
can be done.

It is also possible for one item to participate in more than one group.

14.1 The Current Group

current-group() as item()*

[Definition: The evaluation context for XPath expressions includes a component
called the current group, which is a sequence. The current group is the
collection of related items that are processed collectively in one iteration
of the xsl:for-each-group element.]

While an xsl:for-each-group instruction is being evaluated, the current group
will be non-empty. At other times, it will be an empty sequence.

The function current-group returns the current group.

The function takes no arguments.

[ERR XTSE1060] It is a static error if the current-group function is used
within a pattern.

14.2 The Current Grouping Key

current-grouping-key() as xs:anyAtomicType?

[Definition: The evaluation context for XPath expressions includes a component
called the current grouping key, which is an atomic value. The current
grouping key is the grouping key shared in common by all the items within the 
current group.]

While an xsl:for-each-group instruction with a group-by or group-adjacent
attribute is being evaluated, the current grouping key will be a single atomic
value. At other times, it will be the empty sequence.

The function current-grouping-key returns the current grouping key.

Although the grouping keys of all items in a group are by definition equal,
they are not necessarily identical. For example, one might be an xs:float
while another is an xs:decimal. The current-grouping-key function is defined
to return the grouping key of the initial item in the group, after atomization
and casting of xs:untypedAtomic to xs:string.

The function takes no arguments.

[ERR XTSE1070] It is a static error if the current-grouping-key function is
used within a pattern.

14.3 The xsl:for-each-group Element

<!-- Category: instruction -->
<xsl:for-each-group
  select = expression
  group-by? = expression
  group-adjacent? = expression
  group-starting-with? = pattern
  group-ending-with? = pattern
  collation? = { uri }>
  <!-- Content: (xsl:sort*, sequence-constructor) -->
</xsl:for-each-group>

This element is an instruction that may be used anywhere within a sequence
constructor.

[Definition: The xsl:for-each-group instruction allocates the items in an
input sequence into groups of items (that is, it establishes a collection of
sequences) based either on common values of a grouping key, or on a pattern
that the initial or final node in a group must match.] The sequence
constructor that forms the content of the xsl:for-each-group instruction is
evaluated once for each of these groups.

[Definition: The sequence of items to be grouped, which is referred to as the 
population, is determined by evaluating the XPath expression contained in the
select attribute.]

[Definition: The population is treated as a sequence; the order of items in
this sequence is referred to as population order].

A group is never empty. If the population is empty, the number of groups will
be zero. The assignment of items to groups depends on the group-by,
group-adjacent, group-starting-with, and group-ending-with attributes.

[ERR XTSE1080] These four attributes are mutually exclusive: it is a static
error if none of these four attributes is present, or if more than one of them
is present.

[ERR XTSE1090] It is an error to specify the collation attribute if neither
the group-by attribute nor group-adjacent attribute is specified.

[Definition: If either of the group-by attribute or group-adjacent attributes
is present, then grouping keys are calculated for each item in the population.
The grouping keys are the items in the sequence obtained by evaluating the
expression contained in the group-by attribute or group-adjacent attribute,
atomizing the result, and then casting an xs:untypedAtomic value to xs:string.
]

When calculating grouping keys for an item in the population, the expression
contained in the group-by or group-adjacent attribute is evaluated with that
item as the context item, with its position in population order as the context
position, and with the size of the population as the context size. The
resulting sequence is atomized, and each atomic value in the atomized sequence
acts as a grouping key for that item in the population.

If the group-by attribute is present, then an item in the population may have
multiple grouping keys: that is, the group-by expression evaluates to a
sequence. The item is included in as many groups as there are distinct
grouping keys (which may be zero). If the group-adjacent attribute is used,
then each item in the population must have exactly one grouping key value.

[ERR XTTE1100] It is a type error if the grouping key evaluated using the
group-adjacent attribute is an empty sequence, or a sequence containing more
than one item.

Grouping keys are compared using the rules for the eq operator appropriate to
their dynamic type. Values of type xs:untypedAtomic are cast to xs:string
before the comparison. Two items that are not comparable using the eq operator
are considered to be not equal, that is, they are allocated to different
groups. If the values are strings, or untyped atomic values, then if there is
a collation attribute the values are compared using the collation specified as
the effective value of the collation attribute, resolved if relative against
the base URI of the xsl:for-each-group element. If there is no collation
attribute then the default collation is used.

For the purposes of grouping, the value NaN is considered equal to itself.

[ERR XTDE1110] It is a non-recoverable dynamic error if the collation URI
specified to xsl:for-each-group (after resolving against the base URI) is a
collation that is not recognized by the implementation. (For notes, [see ERR
XTDE1035].)

For more information on collations, see 13.1.3 Sorting Using Collations.

[ERR XTTE1120] When the group-starting-with or group-ending-with attribute is
used, it is a type error if the result of evaluating the select expression
contains an item that is not a node.

  * If the group-by attribute is present, the items in the population are
    examined, in population order. For each item J, the expression in the
    group-by attribute is evaluated to produce a sequence of zero or more 
    grouping key values. For each one of these grouping keys, if there is
    already a group created to hold items having that grouping key value, J is
    added to that group; otherwise a new group is created for items with that
    grouping key value, and J becomes its first member.
   
    An item in the population may thus be assigned to zero, one, or many
    groups. An item will never be assigned more than once to the same group;
    if two or more grouping keys for the same item are equal, then the
    duplicates are ignored. An item here means the item at a particular
    position within the population—if the population contains the same node at
    several different positions in the sequence then a group may indeed
    contain duplicate nodes.
   
    The number of groups will be the same as the number of distinct grouping
    key values present in the population.
   
  * If the group-adjacent attribute is present, the items in the population
    are examined, in population order. If an item has the same value for the 
    grouping key as its preceding item within the population (in population
    order), then it is assigned to the same group as its preceding item;
    otherwise a new group is created and the item becomes its first member.
   
  * If the group-starting-with attribute is present, then its value must be a 
    pattern. In this case, the items in the population must all be nodes.
   
    The nodes in the population are examined in population order. If a node
    matches the pattern, or is the first node in the population, then a new
    group is created and the node becomes its first member. Otherwise, the
    node is assigned to the same group as its preceding node within the
    population.
   
  * If the group-ending-with attribute is present, then its value must be a 
    pattern. In this case, the items in the population must all be nodes.
   
    The nodes in the population are examined in population order. If a node is
    the first node in the population, or if the previous node in the
    population matches the pattern, then a new group is created and the node
    becomes its first member. Otherwise, the node is assigned to the same
    group as its preceding node within the population.
   
[Definition: For each group, the item within the group that is first in 
population order is known as the initial item of the group.]

[Definition: There is an ordering among groups referred to as the order of
first appearance. A group G is defined to precede a group H in order of first
appearance if the initial item of G precedes the initial item of H in
population order. If two groups G and H have the same initial item (because
the item is in both groups) then G precedes H if the grouping key of G
precedes the grouping key of H in the sequence that results from evaluating
the group-by expression of this initial item.]

[Definition: There is another ordering among groups referred to as processing
order. If group R precedes group S in processing order, then in the result
sequence returned by the xsl:for-each-group instruction the items generated by
processing group R will precede the items generated by processing group S.]

If there are no xsl:sort elements immediately within the xsl:for-each-group
element, the processing order of the groups is the order of first appearance.

Otherwise, the xsl:sort elements immediately within the xsl:for-each-group
element define the processing order of the groups (see 13 Sorting). They do
not affect the order of items within each group. Multiple sort key components
are allowed, and are evaluated in major-to-minor order. If two groups have the
same values for all their sort key components, they are processed in order of
first appearance.

The select expression of an xsl:sort element is evaluated once for each group.
During this evaluation, the context item is the initial item of the group, the
context position is the position of this item within the set of initial items
(that is, one item for each group in the population) in population order, the 
context size is the number of groups, the current group is the group whose 
sort key value is being determined, and the current grouping key is the
grouping key for that group. If the xsl:for-each-group instruction uses the
group-starting-with or group-ending-with attributes, then the current grouping
key is the empty sequence.

Example: Sorting Groups

For example, this means that if the grouping key is @category, you can sort
the groups in order of their grouping key by writing <xsl:sort select=
"current-grouping-key()"/>; or you can sort the groups in order of size by
writing <xsl:sort select="count(current-group())"/>

The sequence constructor contained in the xsl:for-each-group element is
evaluated once for each of the groups, in processing order. The sequences that
result are concatenated, in processing order, to form the result of the 
xsl:for-each-group element. Within the sequence constructor, the context item
is the initial item of the relevant group, the context position is the
position of this item among the sequence of initial items (one item for each
group) arranged in processing order of the groups, the context size is the
number of groups, the current group is the group being processed, and the 
current grouping key is the grouping key for that group. If the 
xsl:for-each-group instruction uses the group-starting-with or
group-ending-with attributes, then the current grouping key is the empty
sequence. This has the effect that within the sequence constructor, a call on
position() takes successive values 1, 2, ... last().

During the evaluation of a stylesheet function, the current group and current
grouping key are set to the empty sequence, and revert to their previous
values on completion of evaluation of the stylesheet function.

On completion of the evaluation of the xsl:for-each-group instruction, the 
current group and current grouping key revert to their previous value.

14.4 Examples of Grouping

Example: Grouping Nodes based on Common Values

The following example groups a list of nodes based on common values. The
resulting groups are numbered but unsorted, and a total is calculated for each
group.

Source XML document:

<cities>
  <city name="Milano"  country="Italia"      pop="5"/>
  <city name="Paris"   country="France"      pop="7"/>
  <city name="München" country="Deutschland" pop="4"/>
  <city name="Lyon"    country="France"      pop="2"/>
  <city name="Venezia" country="Italia"      pop="1"/>
</cities>

More specifically, the aim is to produce a four-column table, containing one
row for each distinct country. The four columns are to contain first, a
sequence number giving the number of the row; second, the name of the country,
third, a comma-separated alphabetical list of the city names within that
country, and fourth, the sum of the pop attribute for the cities in that
country.

Desired output:

<table>
  <tr>
    <th>Position</th>
    <th>Country</th>
    <th>List of Cities</th>
    <th>Population</th>
  </tr>
  <tr>
    <td>1</td>
    <td>Italia</td>
    <td>Milano, Venezia</td>
    <td>6</td>
  </tr>
  <tr>
    <td>2</td>
    <td>France</td>
    <td>Lyon, Paris</td>
    <td>9</td>
  </tr>  
  <tr>
    <td>3</td>
    <td>Deutschland</td>
    <td>München</td>
    <td>4</td>
  </tr>  
</table>

Solution:

<table xsl:version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <tr>
    <th>Position</th>
    <th>Country</th>
    <th>City List</th>
    <th>Population</th>
  </tr>
  <xsl:for-each-group select="cities/city" group-by="@country">
    <tr>
      <td><xsl:value-of select="position()"/></td>
      <td><xsl:value-of select="@country"/></td>
      <td>
        <xsl:value-of select="current-group()/@name" separator=", "/>
      </td>
      <td><xsl:value-of select="sum(current-group()/@pop)"/></td>
    </tr>
  </xsl:for-each-group>
</table>

Example: A Composite Grouping Key

Sometimes it is necessary to use a composite grouping key: for example,
suppose the source document is similar to the one used in the previous
examples, but allows multiple entries for the same country and city, such as:

<cities>
  <city name="Milano"  country="Italia"  year="1950"   pop="5.23"/>
  <city name="Milano"  country="Italia"  year="1960"   pop="5.29"/>  
  <city name="Padova"  country="Italia"  year="1950"   pop="0.69"/>
  <city name="Padova"  country="Italia"  year="1960"   pop="0.93"/>    
  <city name="Paris"   country="France"  year="1951"   pop="7.2"/>
  <city name="Paris"   country="France"  year="1961"   pop="7.6"/>
</cities>

Now suppose we want to list the average value of @pop for each (country, name)
combination. One way to handle this is to concatenate the parts of the key,
for example <xsl:for-each-group select="concat(@country, '/', @name)">. A more
flexible solution is to nest one xsl:for-each-group element directly inside
another:

<xsl:for-each-group select="cities/city" group-by="@country">
  <xsl:for-each-group select="current-group()" group-by="@name">
    <p><xsl:value-of select="@name"/>, <xsl:value-of select="@country"/>:
        <xsl:value-of select="avg(current-group()/@pop)"/></p>
  </xsl:for-each-group>
</xsl:for-each-group>

The two approaches are not precisely equivalent. If the code were changed to
output the value of position() alongside @name then the first approach (a
single xsl:for-each-group element with a compound key) would number the groups
(1, 2, 3), while the second approach (two nested xsl:for-each-group elements)
would number them (1, 2, 1).

Example: Identifying a Group by its Initial Element

The next example identifies a group not by the presence of a common value, but
rather by adjacency in document order. A group consists of an h2 element,
followed by all the p elements up to the next h2 element.

Source XML document:

<body>
  <h2>Introduction</h2>
  <p>XSLT is used to write stylesheets.</p>
  <p>XQuery is used to query XML databases.</p>
  <h2>What is a stylesheet?</h2>
  <p>A stylesheet is an XML document used to define a transformation.</p>
  <p>Stylesheets may be written in XSLT.</p>
  <p>XSLT 2.0 introduces new grouping constructs.</p>
</body>

Desired output:

<chapter>
  <section title="Introduction">
    <para>XSLT is used to write stylesheets.</para>
    <para>XQuery is used to query XML databases.</para>
  </section> 
  <section title="What is a stylesheet?">
    <para>A stylesheet is an XML document used to define a transformation.</para>
    <para>Stylesheets may be written in XSLT.</para>
    <para>XSLT 2.0 introduces new grouping constructs.</para>
  </section>
</chapter>

Solution:

<xsl:template match="body">
  <chapter>
        <xsl:for-each-group select="*" group-starting-with="h2"      >
          <section title="{self::h2}">
            <xsl:for-each select="current-group()[self::p]">
              <para><xsl:value-of select="."/></para>
            </xsl:for-each> 
          </section>
        </xsl:for-each-group>
  </chapter>
</xsl:template>

The use of title="{self::h2}" rather than title="{.}" is to handle the case
where the first element is not an h2 element.

Example: Identifying a Group by its Final Element

The next example illustrates how a group of related elements can be identified
by the last element in the group, rather than the first. Here the absence of
the attribute continued="yes" indicates the end of the group.

Source XML document:

<doc>
  <page continued="yes">Some text</page>
  <page continued="yes">More text</page>    
  <page>Yet more text</page>
  <page continued="yes">Some words</page>
  <page continued="yes">More words</page>    
  <page>Yet more words</page>        
</doc>

Desired output:

<doc>
  <pageset>
    <page>Some text</page>
    <page>More text</page>    
    <page>Yet more text</page>
  </pageset>
  <pageset>
    <page>Some words</page>
    <page>More words</page>    
    <page>Yet more words</page>
  </pageset>
</doc>

Solution:

<xsl:template match="doc">
<doc>
  <xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]">
    <pageset>
      <xsl:for-each select="current-group()">
        <page><xsl:value-of select="."/></page>
      </xsl:for-each> 
    </pageset>
  </xsl:for-each-group>
</doc>
</xsl:template>

Example: Adding an Element to Several Groups

The next example shows how an item can be added to multiple groups. Book
titles will be added to one group for each indexing term marked up within the
title.

Source XML document:

<titles>
    <title>A Beginner's Guide to <ix>Java</ix></title>
    <title>Learning <ix>XML</ix></title>
    <title>Using <ix>XML</ix> with <ix>Java</ix></title>
</titles>

Desired output:

<h2>Java</h2>
    <p>A Beginner's Guide to Java</p>
    <p>Using XML with Java</p>
<h2>XML</h2>
    <p>Learning XML</p>
    <p>Using XML with Java</p>

Solution:

<xsl:template match="titles">
    <xsl:for-each-group select="title" group-by="ix">
      <h2><xsl:value-of select="current-grouping-key()"/></h2>
      <xsl:for-each select="current-group()">
        <p><xsl:value-of select="."/></p>
      </xsl:for-each>
    </xsl:for-each-group>
</xsl:template>

Example: Grouping Alternating Sequences of Elements

In the final example, the membership of a node within a group is based both on
adjacency of the nodes in document order, and on common values. In this case,
the grouping key is a boolean condition, true or false, so the effect is that
a grouping establishes a maximal sequence of nodes for which the condition is
true, followed by a maximal sequence for which it is false, and so on.

Source XML document:

<p>Do <em>not</em>:
    <ul>
    <li>talk,</li>
    <li>eat, or</li>
    <li>use your mobile telephone</li>
    </ul>
    while you are in the cinema.</p>

Desired output:

<p>Do <em>not</em>:</p>
    <ul>
    <li>talk,</li>
    <li>eat, or</li>
    <li>use your mobile telephone</li>
    </ul>
    <p>while you are in the cinema.</p>

Solution:

This requires creating a p element around the maximal sequence of sibling
nodes that does not include a ul or ol element.

This can be done by using group-adjacent, with a grouping key that is true if
the element is a ul or ol element, and false otherwise:

<xsl:template match="p">
    <xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol">
        <xsl:choose>
            <xsl:when test="current-grouping-key()">
                <xsl:copy-of select="current-group()"/>  
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <xsl:copy-of select="current-group()"/>
                </p>
            </xsl:otherwise>  
        </xsl:choose>
    </xsl:for-each-group>
</xsl:template>

15 Regular Expressions

The core function library for XPath 2.0 defines three functions that make use
of regular expressions:

  * matches^FO returns a boolean result that indicates whether or not a string
    matches a given regular expression.
   
  * replace^FO takes a string as input and returns a string obtained by
    replacing all substrings that match a given regular expression with a
    replacement string.
   
  * tokenize^FO returns a sequence of strings formed by breaking a supplied
    input string at any separator that matches a given regular expression.
   
These functions are described in [Functions and Operators].

For more complex string processing than is possible using these functions,
XSLT provides an instruction xsl:analyze-string, which is defined in this
section.

The regular expressions used by this instruction, and the flags that control
the interpretation of these regular expressions, must conform to the syntax
defined in [Functions and Operators] (see Section 7.6.1 Regular Expression
Syntax^FO), which is itself based on the syntax defined in [XML Schema Part 2]
.

15.1 The xsl:analyze-string instruction

<!-- Category: instruction -->
<xsl:analyze-string
  select = expression
  regex = { string }
  flags? = { string }>
  <!-- Content: (xsl:matching-substring?, xsl:non-matching-substring?, 
xsl:fallback*) -->
</xsl:analyze-string>

<xsl:matching-substring>
  <!-- Content: sequence-constructor -->
</xsl:matching-substring>

<xsl:non-matching-substring>
  <!-- Content: sequence-constructor -->
</xsl:non-matching-substring>

The xsl:analyze-string instruction takes as input a string (the result of
evaluating the expression in the select attribute) and a regular expression
(the effective value of the regex attribute).

If the result of evaluating the select expression is not a string, it is
converted to a string by applying the function conversion rules.

The flags attribute may be used to control the interpretation of the regular
expression. If the attribute is omitted, the effect is the same as supplying a
zero-length string. This is interpreted in the same way as the $flags
attribute of the functions matches^ FO, replace^ FO, and tokenize^FO. 
Specifically, if it contains the letter m, the match operates in multiline
mode. If it contains the letter s, it operates in dot-all mode. If it contains
the letter i, it operates in case-insensitive mode. If it contains the letter
x, then whitespace within the regular expression is ignored. For more detailed
specifications of these modes, see [Functions and Operators] (Section 7.6.1.1
Flags^FO).

Note:

Because the regex attribute is an attribute value template, curly brackets
within the regular expression must be doubled. For example, to match a
sequence of one to five characters, write regex=".{{1,5}}". For regular
expressions containing many curly brackets it may be more convenient to use a
notation such as regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}", or to use a
variable.

The content of the xsl:analyze-string instruction must take one of the
following forms:

 1. A single xsl:matching-substring instruction, followed by zero or more 
    xsl:fallback instructions
   
 2. A single xsl:non-matching-substring instruction, followed by zero or more 
    xsl:fallback instructions
   
 3. A single xsl:matching-substring instruction, followed by a single 
    xsl:non-matching-substring instruction, followed by zero or more 
    xsl:fallback instructions
   
[ERR XTSE1130] It is a static error if the xsl:analyze-string instruction
contains neither an xsl:matching-substring nor an xsl:non-matching-substring
element.

Any xsl:fallback elements among the children of the xsl:analyze-string
instruction are ignored by an XSLT 2.0 processor, but allow fallback behavior
to be defined when the stylesheet is used with an XSLT 1.0 processor operating
in forwards-compatible mode.

This instruction is designed to process all the non-overlapping substrings of
the input string that match the regular expression supplied.

[ERR XTDE1140] It is a non-recoverable dynamic error if the effective value of
the regex attribute does not conform to the required syntax for regular
expressions, as specified in [Functions and Operators]. If the regular
expression is known statically (for example, if the attribute does not contain
any expressions enclosed in curly brackets) then the processor may signal the
error as a static error.

[ERR XTDE1145] It is a non-recoverable dynamic error if the effective value of
the flags attribute has a value other than the values defined in [Functions
and Operators]. If the value of the attribute is known statically (for
example, if the attribute does not contain any expressions enclosed in curly
brackets) then the processor may signal the error as a static error.

[ERR XTDE1150] It is a non-recoverable dynamic error if the effective value of
the regex attribute is a regular expression that matches a zero-length string:
or more specifically, if the regular expression $r and flags $f are such that
matches("", $r, $f) returns true. If the regular expression is known
statically (for example, if the attribute does not contain any expressions
enclosed in curly brackets) then the processor may signal the error as a 
static error.

The xsl:analyze-string instruction starts at the beginning of the input string
and attempts to find the first substring that matches the regular expression.
If there are several matches, the first match is defined to be the one whose
starting position comes first in the string. If several alternatives within
the regular expression both match at the same position in the input string,
then the match that is chosen is the first alternative that matches. For
example, if the input string is The quick brown fox jumps and the regular
expression is jump|jumps, then the match that is chosen is jump.

Having found the first match, the instruction proceeds to find the second and
subsequent matches by repeating the search, starting at the first character
that was not included in the previous match.

The input string is thus partitioned into a sequence of substrings, some of
which match the regular expression, others which do not match it. Each
substring will contain at least one character. This sequence of substrings is
processed using the xsl:matching-substring and xsl:non-matching-substring
child instructions. A matching substring is processed using the 
xsl:matching-substring element, a non-matching substring using the 
xsl:non-matching-substring element. Each of these elements takes a sequence
constructor as its content. If the element is absent, the effect is the same
as if it were present with empty content. In processing each substring, the
contents of the substring will be the context item (as a value of type
xs:string); the position of the substring within the sequence of matching and
non-matching substrings will be the context position; and the number of
matching and non-matching substrings will be the context size.

If the input is a zero-length string, the number of substrings will be zero,
so neither the xsl:matching-substring nor xsl:non-matching-substring elements
will be evaluated.

15.2 Captured Substrings

regex-group($group-number as xs:integer) as xs:string

[Definition: While the xsl:matching-substring instruction is active, a set of 
current captured substrings is available, corresponding to the parenthesized
sub-expressions of the regular expression.] These captured substrings are
accessible using the function regex-group. This function takes an integer
argument to identify the group, and returns a string representing the captured
substring.

The Nth captured substring (where N > 0) is the string matched by the
subexpression contained by the Nth left parenthesis in the regex. The zeroeth
captured substring is the string that matches the entire regex. This means
that the value of regex-group(0) is initially the same as the value of .
(dot).

The function returns the zero-length string if there is no captured substring
with the relevant number. This can occur for a number of reasons:

 1. The number is negative.
   
 2. The regular expression does not contain a parenthesized sub-expression
    with the given number.
   
 3. The parenthesized sub-expression exists, and did not match any part of the
    input string.
   
 4. The parenthesized sub-expression exists, and matched a zero-length
    substring of the input string.
   
The set of captured substrings is a context variable with dynamic scope. It is
initially an empty sequence. During the evaluation of an 
xsl:matching-substring instruction it is set to the sequence of matched
substrings for that regex match. During the evaluation of an 
xsl:non-matching-substring instruction or a pattern or a stylesheet function
it is set to an empty sequence. On completion of an instruction that changes
the value, the variable reverts to its previous value.

The value of the current captured substrings is unaffected through calls of 
xsl:apply-templates, xsl:call-template, xsl:apply-imports or xsl:next-match,
or by expansion of named attribute sets.

15.3 Examples of Regular Expression Matching

Example: Replacing Characters by Elements

Problem: replace all newline characters in the abstract element by empty br
elements:

Solution:

<xsl:analyze-string select="abstract" regex="\n">
  <xsl:matching-substring>
    <br/>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
    <xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>

Example: Recognizing non-XML Markup Structure

Problem: replace all occurrences of [...] in the body by cite elements,
retaining the content between the square brackets as the content of the new
element.

Solution:

<xsl:analyze-string select="body" regex="\[(.*?)\]">
  <xsl:matching-substring>
    <cite><xsl:value-of select="regex-group(1)"/></cite>
  </xsl:matching-substring>
  <xsl:non-matching-substring>
    <xsl:value-of select="."/>
  </xsl:non-matching-substring>
</xsl:analyze-string>

Note that this simple approach fails if the body element contains markup that
needs to be retained. In this case it is necessary to apply the regular
expression processing to each text node individually. If the [...] constructs
span multiple text nodes (for example, because there are elements within the
square brackets) then it probably becomes necessary to make two or more passes
over the data.

Example: Parsing a Date

Problem: the input string contains a date such as 23 March 2002. Convert it to
the form 2002-03-23.

Solution (with no error handling if the input format is incorrect):

<xsl:variable name="months" select="'January', 'February', 'March', ..."/>

<xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})">
    <xsl:matching-substring>
        <xsl:number value="regex-group(3)" format="0001"/>          
        <xsl:text>-</xsl:text>
        <xsl:number value="index-of($months, regex-group(2))" format="01"/>
        <xsl:text>-</xsl:text>
        <xsl:number value="regex-group(1)" format="01"/>
    </xsl:matching-substring>
</xsl:analyze-string>

Note the use of normalize-space to simplify the work done by the regular
expression, and the use of doubled curly brackets because the regex attribute
is an attribute value template.

16 Additional Functions

This section describes XSLT-specific additions to the core function library.
Some of these additional functions also make use of information specified by 
declarations in the stylesheet; this section also describes these
declarations.

16.1 Multiple Source Documents

document($uri-sequence as item()*) as node()*
document($uri-sequence as item()*, $base-node as node()) as node()*

The document function allows access to XML documents identified by a URI.

The first argument contains a sequence of URI references. The second argument,
if present, is a node whose base URI is used to resolve any relative URI
references contained in the first argument.

A sequence of absolute URI references is obtained as follows.

  * For an item in $uri-sequence that is an instance of xs:string, xs:anyURI,
    or xs:untypedAtomic, the value is cast to xs:anyURI. If the resulting URI
    reference is an absolute URI reference then it is used as is. If it is a
    relative URI reference, then it is resolved against the base URI of
    $base-node if supplied, or against the base URI from the static context
    otherwise (this will usually be the base URI of the stylesheet module). A
    relative URI is resolved against a base URI using the rules defined in 
    [RFC3986].
   
  * For an item in $uri-sequence that is a node, the node is atomized. The
    result must be a sequence whose items are all instances of xs:string,
    xs:anyURI, or xs:untypedAtomic. Each of these values is cast to xs:anyURI,
    and if the resulting URI reference is an absolute URI reference then it is
    used as is. If it is a relative URI reference, then it is resolved against
    the base URI of $base-node if supplied, or against the base URI of the
    node that contained it otherwise.
   
Note:

The XPath rules for function calling ensure that it is a type error if the
supplied value of the second argument is anything other than a single node. If
XPath 1.0 compatibility mode is enabled, then a sequence of nodes may be
supplied, and the first node in the sequence will be used.

Each of these absolute URI references is then processed as follows. Any
fragment identifier that is present in the URI reference is removed, and the
resulting absolute URI is cast to a string and then passed to the doc^ FO
function defined in [Functions and Operators]. This returns a document node.
If an error occurs during evaluation of the doc^ FO function, the processor 
may either signal this error in the normal way, or may recover by ignoring the
failure, in which case the failing URI will not contribute any nodes to the
result of the document function.

If the URI reference contained no fragment identifier, then this document node
is included in the sequence of nodes returned by the document function.

If the URI reference contained a fragment identifier, then the fragment
identifier is interpreted according to the rules for the media type of the
resource representation identified by the URI, and is used to select zero or
more nodes that are descendant-or-self nodes of the returned document node. As
described in 2.3 Initiating a Transformation, the media type is available as
part of the evaluation context for a transformation.

[ERR XTRE1160] When a URI reference contains a fragment identifier, it is a 
recoverable dynamic error if the media type is not one that is recognized by
the processor, or if the fragment identifier does not conform to the rules for
fragment identifiers for that media type, or if the fragment identifier
selects something other than a sequence of nodes (for example, if it selects a
range of characters within a text node). The optional recovery action is to
ignore the fragment identifier and return the document node. The set of media
types recognized by a processor is implementation-defined.

Note:

The recovery action here is different from XSLT 1.0

The sequence of nodes returned by the function is in document order, with no
duplicates. This order has no necessary relationship to the order in which
URIs were supplied in the $uri-sequence argument.

Note:

One effect of these rules is that unless XML entities or xml:base are used,
and provided that the base URI of the stylesheet module is known, document("")
refers to the document node of the containing stylesheet module (the
definitive rules are in [RFC3986]). The XML resource containing the stylesheet
module is processed exactly as if it were any other XML document, for example
there is no special recognition of xsl:text elements, and no special treatment
of comments and processing instructions.

16.2 Reading Text Files

unparsed-text($href as xs:string?) as xs:string?
unparsed-text($href as xs:string?, $encoding as xs:string) as xs:string?

The unparsed-text function reads an external resource (for example, a file)
and returns its contents as a string.

The $href argument must be a string in the form of a URI. The URI must contain
no fragment identifier, and must identify a resource that can be read as text.
If the URI is a relative URI, then it is resolved relative to the base URI
from the static context.

If the value of the $href argument is an empty sequence, the function returns
an empty sequence.

Note:

If a different base URI is appropriate (for example, when resolving a relative
URI read from a source document) then the relative URI should be resolved
using the resolve-uri^FO function before passing it to the unparsed-text
function.

The $encoding argument, if present, is the name of an encoding. The values for
this attribute follow the same rules as for the encoding attribute in an XML
declaration. The only values which every implementation is required to
recognize are utf-8 and utf-16.

The encoding of the external resource is determined as follows:

 1. external encoding information is used if available, otherwise
   
 2. if the media type of the resource is text/xml or application/xml (see 
    [RFC2376]), or if it matches the conventions text/*+xml or application/
    *+xml (see [RFC3023] and/or its successors), then the encoding is
    recognized as specified in [XML 1.0], otherwise
   
 3. the value of the $encoding argument is used if present, otherwise
   
 4. the processor may use implementation-defined heuristics to determine the
    likely encoding, otherwise
   
 5. UTF-8 is assumed.
   
Note:

The above rules are chosen for consistency with [XInclude]. Files with an XML
media type are treated specially because there are use cases for this function
where the retrieved text is to be included as unparsed XML within a CDATA
section of a containing document, and because processors are likely to be able
to reuse the code that performs encoding detection for XML external entities.

[ERR XTDE1170] It is a non-recoverable dynamic error if a URI contains a
fragment identifier, or if it cannot be used to retrieve a resource containing
text.

[ERR XTDE1190] It is a non-recoverable dynamic error if a resource contains
octets that cannot be decoded into Unicode characters using the specified
encoding, or if the resulting characters are not permitted XML characters.
This includes the case where the processor does not support the requested
encoding.

[ERR XTDE1200] It is a non-recoverable dynamic error if the second argument of
the unparsed-text function is omitted and the processor cannot infer the
encoding using external information and the encoding is not UTF-8.

The result is a string containing the text of the resource retrieved using the
URI.

Note:

If the text file contains characters such as < and &, these will typically be
output as &lt; and &amp; when the string is written to a final result tree and
serialized as XML or HTML. If these characters actually represent markup (for
example, if the text file contains HTML), then the stylesheet can attempt to
write them as markup to the output file using the disable-output-escaping
attribute of the xsl:value-of instruction (see 20.2 Disabling Output Escaping
). Note, however, that implementations are not required to support this
feature.

Example: Copying Unparsed HTML Boilerplate

This example attempts to read an HTML file and copy it, as HTML, to the
serialized output file:

<xsl:output method="html"/>

<xsl:template match="/">
  <xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
  <xsl:apply-templates/>
  <xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
</xsl:template>

Example: Splitting an Input File into a Sequence of Lines

Often it is necessary to split a text file into a sequence of lines,
representing each line as a string. This can be achieved by using the 
unparsed-text function in conjunction with the XPath tokenize^FO function. For
example:

<xsl:for-each select="tokenize(unparsed-text($in), '\r?\n')">
 ...
</xsl:for-each>

Note that the unparsed-text function does not normalize line endings. This
example has therefore been written to recognize both Unix and Windows
conventions for end-of-line, namely a single newline (#x0A) character or a
carriage return / line feed pair (#x0D #x0A).

Because errors in evaluating the unparsed-text function are non-recoverable,
two functions are provided to allow a stylesheet to determine whether a call
with particular arguments would succeed:

unparsed-text-available($href as xs:string?) as xs:boolean
unparsed-text-available( $href      as xs:string?,              
                         $encoding  as xs:string?) as xs:boolean

The unparsed-text-available function determines whether a call on the 
unparsed-text function with identical arguments would return a string.

If the first argument is an empty sequence, the function returns false. If the
second argument is an empty sequence, the function behaves as if the second
argument were omitted.

In other cases, the function returns true if a call on unparsed-text with the
same arguments would succeed, and false if a call on unparsed-text with the
same arguments would fail with a non-recoverable dynamic error.

Note:

This requires that the unparsed-text-available function should actually
attempt to read the resource identified by the URI, and check that it is
correctly encoded and contains no characters that are invalid in XML.
Implementations may avoid the cost of repeating these checks for example by
caching the validated contents of the resource, to anticipate a subsequent
call on the unparsed-text function. Alternatively, implementations may be able
to rewrite an expression such as if (unparsed-text-available(A)) then
unparsed-text(A) else ... to generate a single call internally.

The functions unparsed-text and unparsed-text-available have the same
requirement for stability as the functions doc^ FO and doc-available^FO
defined in [Functions and Operators]. This means that unless the user has
explicitly stated a requirement for a reduced level of stability, either of
these functions if called twice with the same arguments during the course of a
transformation must return the same results each time; moreover, the results
of a call on unparsed-text-available must be consistent with the results of a
subsequent call on unparsed-text with the same arguments.

16.3 Keys

Keys provide a way to work with documents that contain an implicit
cross-reference structure. They make it easier to locate the nodes within a
document that have a given value for a given attribute or child element, and
they provide a hint to the implementation that certain access paths in the
document need to be efficient.

16.3.1 The xsl:key Declaration

<!-- Category: declaration -->
<xsl:key
  name = qname
  match = pattern
  use? = expression
  collation? = uri>
  <!-- Content: sequence-constructor -->
</xsl:key>

The xsl:key declaration is used to declare keys. The name attribute specifies
the name of the key. The value of the name attribute is a QName, which is
expanded as described in 5.1 Qualified Names. The match attribute is a Pattern
; an xsl:key element applies to all nodes that match the pattern specified in
the match attribute.

[Definition: A key is defined as a set of xsl:key declarations in the 
stylesheet that share the same name.]

The value of the key may be specified either using the use attribute or by
means of the contained sequence constructor.

[ERR XTSE1205] It is a static error if an xsl:key declaration has a use
attribute and has non-empty content, or if it has empty content and no use
attribute.

If the use attribute is present, its value is an expression specifying the
values of the key. The expression will be evaluated with the node that matches
the pattern as the context node. The result of evaluating the expression is 
atomized.

Similarly, if a sequence constructor is present, it is used to determine the
values of the key. The sequence constructor will be evaluated with the node
that matches the pattern as the context node. The result of evaluating the
sequence constructor is atomized.

[Definition: The expression in the use attribute and the sequence constructor
within an xsl:key declaration are referred to collectively as the key
specifier. The key specifier determines the values that may be used to find a
node using this key.]

Note:

There is no requirement that all the values of a key should have the same
type.

The presence of an xsl:key declaration makes it easy to find a node that
matches the match pattern if any of the values of the key specifier (when
applied to that node) are known. It also provides a hint to the implementation
that access to the nodes by means of these values needs to be efficient (many
implementations are likely to construct an index or hash table to achieve
this). Note that the key specifier in general returns a sequence of values,
and any one of these may be used to locate the node.

Note:

An xsl:key declaration is not bound to a specific source document. The source
document to which it applies is determined only when the key function is used
to locate nodes using the key. Keys can be used to locate nodes within any
source document (including temporary trees), but each use of the key function
searches one document only.

The optional collation attribute is used only when deciding whether two
strings are equal for the purposes of key matching. Specifically, two values
$a and $b are considered equal if the result of the function call compare($a,
$b, $collation) is zero. The effective collation for an xsl:key declaration is
the collation specified in its collation attribute if present, resolved
against the base URI of the xsl:key element, or the default collation that is
in scope for the xsl:key declaration otherwise; the effective collation must
be the same for all the xsl:key declarations making up a key.

[ERR XTSE1210] It is a static error if the xsl:key declaration has a collation
attribute whose value (after resolving against the base URI) is not a URI
recognized by the implementation as referring to a collation.

[ERR XTSE1220] It is a static error if there are several xsl:key declarations
in the stylesheet with the same key name and different effective collations.
Two collations are the same if their URIs are equal under the rules for
comparing xs:anyURI values, or if the implementation can determine that they
are different URIs referring to the same collation.

It is possible to have:

  * multiple xsl:key declarations with the same name;
   
  * a node that matches the match patterns of several different xsl:key
    declarations, whether these have the same key name or different key names;
   
  * a node that returns more than one value from its key specifier;
   
  * a key value that identifies more than one node (the key values for
    different nodes do not need to be unique).
   
An xsl:key declaration with higher import precedence does not override another
of lower import precedence; all the xsl:key declarations in the stylesheet are
effective regardless of their import precedence.

16.3.2 The key Function

key($key-name as xs:string, $key-value as xs:anyAtomicType*) as node()*
key( $key-name   as xs:string,        
     $key-value  as xs:anyAtomicType*,
     $top        as node()) as node()*

The key function does for keys what the id^ FO function does for IDs.

The $key-name argument specifies the name of the key. The value of the
argument must be a lexical QName, which is expanded as described in 5.1
Qualified Names.

[ERR XTDE1260] It is a non-recoverable dynamic error if the value is not a
valid QName, or if there is no namespace declaration in scope for the prefix
of the QName, or if the name obtained by expanding the QName is not the same
as the expanded name of any xsl:key declaration in the stylesheet. If the
processor is able to detect the error statically (for example, when the
argument is supplied as a string literal), then the processor may optionally
signal this as a static error.

The $key-value argument to the key function is considered as a sequence. The
set of requested key values is formed by atomizing the supplied value of the
argument, using the standard function conversion rules. Each of the resulting
atomic values is considered as a requested key value. The result of the
function is a sequence of nodes, in document order and with duplicates
removed, comprising those nodes in the selected subtree (see below) that are
matched by an xsl:key declaration whose name is the same as the supplied key
name, where the result of evaluating the key specifier contains a value that
is equal to one of these requested key values, under the rules appropriate to
the XPath eq operator for the two values in question, using the collation
attributes of the xsl:key declaration when comparing strings. No error is
reported if two values are encountered that are not comparable; they are
regarded for the purposes of this function as being not equal.

Note:

Under the rules for the eq operator, untyped atomic values are converted to
strings, not to the type of the other operand. This means, for example, that
if the expression in the use attribute returns a date, supplying an untyped
atomic value in the call to the key function will return an empty sequence.

If the second argument is an empty sequence, the result of the function will
be an empty sequence.

Different rules apply when backwards compatible behavior is enabled.
Specifically, if any of the xsl:key elements in the definition of the key
enables backwards compatible behavior, then the value of the key specifier and
the value of the second argument of the key function are both converted after
atomization to a sequence of strings, by applying a cast to each item in the
sequence, before performing the comparison.

The third argument is used to identify the selected subtree. If the argument
is present, the selected subtree is the set of nodes that have $top as an
ancestor-or-self node. If the argument is omitted, the selected subtree is the
document containing the context node. This means that the third argument
effectively defaults to /.

[ERR XTDE1270] It is a non-recoverable dynamic error to call the key function
with two arguments if there is no context node, or if the root of the tree
containing the context node is not a document node; or to call the function
with three arguments if the root of the tree containing the node supplied in
the third argument is not a document node.

The result of the key function can be described more specifically as follows.
The result is a sequence containing every node $N that satisfies the following
conditions:

  * $N/ancestor-or-self::node() intersect $top is non-empty. (If the third
    argument is omitted, $top defaults to /)
   
  * $N matches the pattern specified in the match attribute of an xsl:key
    declaration whose name attribute matches the name specified in the
    $key-name argument.
   
  * When the key specifier of that xsl:key declaration is evaluated with a 
    singleton focus based on $N, the atomized value of the resulting sequence
    includes a value that compares equal to at least one item in the atomized
    value of the sequence supplied as $key-value, under the rules of the eq
    operator with the collation selected as described above.
   
The sequence returned by the key function will be in document order, with
duplicates (that is, nodes having the same identity) removed.

Example: Using a Key to Follow Cross-References

For example, given a declaration

<xsl:key name="idkey" match="div" use="@id"/>

an expression key("idkey",@ref) will return the same nodes as id(@ref),
assuming that the only ID attribute declared in the XML source document is:

<!ATTLIST div id ID #IMPLIED>

and that the ref attribute of the context node contains no whitespace.

Suppose a document describing a function library uses a prototype element to
define functions

<prototype name="sqrt" return-type="xs:double">
  <arg type="xs:double"/>
</prototype>

and a function element to refer to function names

<function>sqrt</function>

Then the stylesheet could generate hyperlinks between the references and
definitions as follows:

<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
  <p>
    <a name="{generate-id()}">
      <b>Function: </b>
      ...
    </a>
  </p>
</xsl:template>

When called with two arguments, the key function always returns nodes that are
in the same document as the context node. To retrieve a node from any other
document, it is necessary either to change the context node, or to supply a
third argument.

Example: Using Keys to Reference other Documents

For example, suppose a document contains bibliographic references in the form
<bibref>XSLT</bibref>, and there is a separate XML document bib.xml containing
a bibliographic database with entries in the form:

<entry name="XSLT">...</entry>

Then the stylesheet could use the following to transform the bibref elements:

<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/>
</xsl:template>

Note:

This relies on the ability in XPath 2.0 to have a function call on the
right-hand side of the / operator in a path expression.

The following code would also work:

<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:apply-templates select="key('bib', ., document('bib.xml'))"/>
</xsl:template>

16.4 Number Formatting

format-number($value as numeric?, $picture as xs:string) as xs:string
format-number( $value                as numeric?,              
               $picture              as xs:string,             
               $decimal-format-name  as xs:string) as xs:string

The format-number function formats $value as a string using the picture string
specified by the $picture argument and the decimal-format named by the
$decimal-format-name argument, or the default decimal-format, if there is no
$decimal-format-name argument. The syntax of the picture string is described
in 16.4.2 Processing the Picture String.

The $value argument may be of any numeric data type (xs:double, xs:float,
xs:decimal, or their subtypes including xs:integer). Note that if an
xs:decimal is supplied, it is not automatically promoted to an xs:double, as
such promotion can involve a loss of precision.

If the supplied value of the $value argument is an empty sequence, the
function behaves as if the supplied value were the xs:double value NaN.

The value of $decimal-format-name must be a lexical QName, which is expanded
as described in 5.1 Qualified Names. The result of the function is the
formatted string representation of the supplied number.

[ERR XTDE1280] It is a non-recoverable dynamic error if the name specified as
the $decimal-format-name argument is not a valid QName, or if its prefix has
not been declared in an in-scope namespace declaration, or if the stylesheet
does not contain a declaration of a decimal-format with a matching 
expanded-QName. If the processor is able to detect the error statically (for
example, when the argument is supplied as a string literal), then the
processor may optionally signal this as a static error.

16.4.1 Defining a Decimal Format

<!-- Category: declaration -->
<xsl:decimal-format
  name? = qname
  decimal-separator? = char
  grouping-separator? = char
  infinity? = string
  minus-sign? = char
  NaN? = string
  percent? = char
  per-mille? = char
  zero-digit? = char
  digit? = char
  pattern-separator? = char />

The xsl:decimal-format element controls the interpretation of a picture string
used by the format-number function.

A stylesheet may contain multiple xsl:decimal-format declarations and may
include or import stylesheet modules that also contain xsl:decimal-format
declarations. The name of an xsl:decimal-format declaration is the value of
its name attribute, if any.

[Definition: All the xsl:decimal-format declarations in a stylesheet that
share the same name are grouped into a named decimal format; those that have
no name are grouped into a single unnamed decimal format.]

If a stylesheet does not contain a declaration of the unnamed decimal format,
a declaration equivalent to an xsl:decimal-format element with no attributes
is implied.

The attributes of the xsl:decimal-format declaration establish values for a
number of variables used as input to the algorithm followed by the 
format-number function. An outline of the purpose of each attribute is given
below; however, the definitive explanations are given later, as part of the
description of this algorithm.

For any named decimal format, the effective value of each attribute is taken
from an xsl:decimal-format declaration that has that name, and that specifies
an explicit value for the required attribute. If there is no such declaration,
the default value of the attribute is used. If there is more than one such
declaration, the one with highest import precedence is used.

For any unnamed decimal format, the effective value of each attribute is taken
from an xsl:decimal-format declaration that is unnamed, and that specifies an
explicit value for the required attribute. If there is no such declaration,
the default value of the attribute is used. If there is more than one such
declaration, the one with highest import precedence is used.

[ERR XTSE1290] It is a static error if a named or unnamed decimal format
contains two conflicting values for the same attribute in different 
xsl:decimal-format declarations having the same import precedence, unless
there is another definition of the same attribute with higher import
precedence.

The following attributes control the interpretation of characters in the 
picture string supplied to the format-number function, and also specify
characters that may appear in the result of formatting the number. In each
case the value must be a single character [see ERR XTSE0020].

  * decimal-separator specifies the character used for the
    decimal-separator-sign; the default value is the period character (.)
   
  * grouping-separator specifies the character used for the grouping-sign,
    which is typically used as a thousands separator; the default value is the
    comma character (,)
   
  * percent specifies the character used for the percent-sign; the default
    value is the percent character (%)
   
  * per-mille specifies the character used for the per-mille-sign; the default
    value is the Unicode per-mille character (#x2030)
   
  * zero-digit specifies the character used for the digit-zero-sign; the
    default value is the digit zero (0). This character must be a digit
    (category Nd in the Unicode property database), and it must have the
    numeric value zero. This attribute implicitly defines the Unicode
    character that is used to represent each of the values 0 to 9 in the final
    result string: Unicode is organized so that each set of decimal digits
    forms a contiguous block of characters in numerical sequence.
   
[ERR XTSE1295] It is a static error if the character specified in the
zero-digit attribute is not a digit or is a digit that does not have the
numeric value zero.

The following attributes control the interpretation of characters in the 
picture string supplied to the format-number function. In each case the value 
must be a single character [see ERR XTSE0020].

  * digit specifies the character used for the digit-sign in the picture
    string; the default value is the number sign character (#)
   
  * pattern-separator specifies the character used for the
    pattern-separator-sign, which separates positive and negative sub-pictures
    in a picture string; the default value is the semi-colon character (;)
   
The following attributes specify characters or strings that may appear in the
result of formatting the number:

  * infinity specifies the string used for the infinity-symbol; the default
    value is the string Infinity
   
  * NaN specifies the string used for the NaN-symbol, which is used to
    represent the value NaN (not-a-number); the default value is the string
    NaN
   
  * minus-sign specifies the character used for the minus-symbol; the default
    value is the hyphen-minus character (-, #x2D). The value must be a single
    character.
   
[ERR XTSE1300] It is a static error if, for any named or unnamed decimal
format, the variables representing characters used in a picture string do not
each have distinct values. These variables are decimal-separator-sign,
grouping-sign, percent-sign, per-mille-sign, digit-zero-sign, digit-sign, and
pattern-separator-sign.

16.4.2 Processing the Picture String

[Definition: The formatting of a number is controlled by a picture string. The
picture string is a sequence of characters, in which the characters assigned
to the variables decimal-separator-sign, grouping-sign, zero-digit-sign,
digit-sign and pattern-separator-sign are classified as active characters, and
all other characters (including the percent-sign and per-mille-sign) are
classified as passive characters.]

The integer part of the sub-picture is defined as the part that appears to the
left of the decimal-separator-sign if there is one, or the entire sub-picture
otherwise. The fractional part of the sub-picture is defined as the part that
appears to the right of the decimal-separator-sign if there is one; it is a
zero-length string otherwise.

[ERR XTDE1310] The picture string must conform to the following rules. It is a
non-recoverable dynamic error if the picture string does not satisfy these
rules.

Note that in these rules the words "preceded" and "followed" refer to
characters anywhere in the string, they are not to be read as "immediately
preceded" and "immediately followed".

  * A picture-string consists either of a sub-picture, or of two sub-pictures
    separated by a pattern-separator-sign. A picture-string must not contain
    more than one pattern-separator-sign. If the picture-string contains two
    sub-pictures, the first is used for positive values and the second for
    negative values.
   
  * A sub-picture must not contain more than one decimal-separator-sign.
   
  * A sub-picture must not contain more than one percent-sign or
    per-mille-sign, and it must not contain one of each.
   
  * A sub-picture must contain at least one digit-sign or zero-digit-sign.
   
  * A sub-picture must not contain a passive character that is preceded by an
    active character and that is followed by another active character.
   
  * A sub-picture must not contain a grouping-separator-sign adjacent to a
    decimal-separator-sign.
   
  * The integer part of a sub-picture must not contain a zero-digit-sign that
    is followed by a digit-sign. The fractional part of a sub-picture must not
    contain a digit-sign that is followed by a zero-digit-sign.
   
The evaluation of the format-number function is described below in two phases,
an analysis phase and a formatting phase. The analysis phase takes as its
inputs the picture string and the variables derived from the relevant 
xsl:decimal-format declaration, and produces as its output a number of
variables with defined values. The formatting phase takes as its inputs the
number to be formatted and the variables produced by the analysis phase, and
produces as its output a string containing a formatted representation of the
number.

Note:

Numbers will always be formatted with the most significant digit on the left.

16.4.3 Analysing the Picture String

This phase of the algorithm analyses the picture string and the attribute
settings of the xsl:decimal-format declaration, and has the effect of setting
the values of various variables, which are used in the subsequent formatting
phase. These variables are listed below. Each is shown with its initial
setting and its data type.

Several variables are associated with each sub-picture. If there are two
sub-pictures, then these rules are applied to one sub-picture to obtain the
values that apply to positive numbers, and to the other to obtain the values
that apply to negative numbers. If there is only one sub-picture, then the
values for both cases are derived from this sub-picture.

The variables are as follows:

  * The integer-part-grouping-positions is a sequence of integers representing
    the positions of grouping separators within the integer part of the
    sub-picture. For each grouping-separator-sign that appears within the
    integer part of the sub-picture, this sequence contains an integer that is
    equal to the total number of digit-sign and zero-digit-sign characters
    that appear within the integer part of the sub-picture and to the right of
    the grouping-separator-sign. In addition, if these
    integer-part-grouping-positions are at regular intervals (that is, if they
    form a sequence N, 2N, 3N, ... for some integer value N, including the
    case where there is only one number in the list), then the sequence
    contains all integer multiples of N as far as necessary to accommodate the
    largest possible number.
   
  * The minimum-integer-part-size is an integer indicating the minimum number
    of digits that will appear to the left of the decimal-separator-sign. It
    is normally set to the number of zero-digit-sign characters found in the
    integer part of the sub-picture. But if the sub-picture contains no
    zero-digit-sign and no decimal-separator-sign, it is set to one.
   
    Note:
   
    There is no maximum integer part size. All significant digits in the
    integer part of the number will be displayed, even if this exceeds the
    number of digit-sign and zero-digit-sign characters in the subpicture.
   
  * The prefix is set to contain all passive characters in the sub-picture to
    the left of the leftmost active character. If the picture string contains
    only one sub-picture, the prefix for the negative sub-picture is set by
    concatenating the minus-sign character and the prefix for the positive
    sub-picture (if any), in that order.
   
  * The fractional-part-grouping-positions is a sequence of integers
    representing the positions of grouping separators within the fractional
    part of the sub-picture. For each grouping-separator-sign that appears
    within the fractional part of the sub-picture, this sequence contains an
    integer that is equal to the total number of digit-sign and
    zero-digit-sign characters that appear within the fractional part of the
    sub-picture and to the left of the grouping-separator-sign.
   
  * The minimum-fractional-part-size is set to the number of zero-digit-sign
    characters found in the fractional part of the sub-picture.
   
  * The maximum-fractional-part-size is set to the total number of digit-sign
    and zero-digit-sign characters found in the fractional part of the
    sub-picture.
   
  * The suffix is set to contain all passive characters to the right of the
    rightmost active character in the fractional part of the sub-picture.
   
Note:

If there is only one sub-picture, then all variables for positive numbers and
negative numbers will be the same, except for prefix: the prefix for negative
numbers will be preceded by the minus-sign character.

16.4.4 Formatting the Number

This section describes the second phase of processing of the format-number
function. This phase takes as input a number to be formatted (referred to as
the input number), and the variables set up by analysing the 
xsl:decimal-format declaration and the picture string, as described above. The
result of this phase is a string, which forms the return value of the 
format-number function.

The algorithm for this second stage of processing is as follows:

 1. If the input number is NaN (not a number), the result is the specified
    NaN-symbol (with no prefix or suffix).
   
 2. In the rules below, the positive sub-picture and its associated variables
    are used if the input number is positive, and the negative sub-picture and
    its associated variables are used otherwise. Negative zero is taken as
    negative, positive zero as positive.
   
 3. If the input number is positive or negative infinity, the result is the
    concatenation of the appropriate prefix, the infinity-symbol, and the
    appropriate suffix.
   
 4. If the sub-picture contains a percent-sign, the number is multiplied by
    100. If the sub-picture contains a per-mille-sign, the number is
    multiplied by 1000. The resulting number is referred to below as the
    adjusted number.
   
 5. The adjusted number is converted (if necessary) to an xs:decimal value,
    using an implementation of xs:decimal that imposes no limits on the
    totalDigits or fractionDigits facets. If there are several such values
    that are numerically equal to the adjusted number (bearing in mind that if
    the adjusted number is an xs:double or xs:float, the comparison will be
    done by converting the decimal value back to an xs:double or xs:float),
    the one that is chosen should be one with the smallest possible number of
    digits not counting leading or trailing zeroes (whether significant or
    insignificant). For example, 1.0 is preferred to 0.9999999999, and
    100000000 is preferred to 100000001. This value is then rounded so that it
    uses no more than maximum-fractional-part-size digits in its fractional
    part. The rounded number is defined to be the result of converting the
    adjusted number to an xs:decimal value, as described above, and then
    calling the function round-half-to-even^FO with this converted number as
    the first argument and the maximum-fractional-part-size as the second
    argument, again with no limits on the totalDigits or fractionDigits in the
    result.
   
 6. The absolute value of the rounded number is converted to a string in
    decimal notation, with no insignificant leading or trailing zeroes, using
    the characters implied by the choice of zero-digit-sign to represent the
    ten decimal digits, and the decimal-separator-sign to separate the integer
    part and the fractional part. (The value zero will at this stage be
    represented by a decimal-separator-sign on its own.)
   
 7. If the number of digits to the left of the decimal-separator-sign is less
    than minimum-integer-part-size, leading zero-digit-sign characters are
    added to pad out to that size.
   
 8. If the number of digits to the right of the decimal-separator-sign is less
    than minimum-fractional-part-size, trailing zero-digit-sign characters are
    added to pad out to that size.
   
 9. For each integer N in the integer-part-grouping-positions list, a
    grouping-separator-sign character is inserted into the string immediately
    after that digit that appears in the integer part of the number and has N
    digits between it and the decimal-separator-sign, if there is such a
    digit.
   
10. For each integer N in the fractional-part-grouping-positions list, a
    grouping-separator-sign character is inserted into the string immediately
    before that digit that appears in the fractional part of the number and
    has N digits between it and the decimal-separator-sign, if there is such a
    digit.
   
11. If there is no decimal-separator-sign in the sub-picture, or if there are
    no digits to the right of the decimal-separator-sign character in the
    string, then the decimal-separator-sign character is removed from the
    string (it will be the rightmost character in the string).
   
12. The result of the function is the concatenation of the appropriate prefix,
    the string conversion of the number as obtained above, and the appropriate
    suffix.
   
16.5 Formatting Dates and Times

Three functions are provided to represent dates and times as a string, using
the conventions of a selected calendar, language, and country. Each has two
variants.

format-dateTime( $value     as xs:dateTime?,            
                 $picture   as xs:string,               
                 $language  as xs:string?,              
                 $calendar  as xs:string?,              
                 $country   as xs:string?) as xs:string?
format-dateTime($value  as xs:dateTime?, $picture as xs:string) as xs:string?
format-date( $value     as xs:date?,                
             $picture   as xs:string,               
             $language  as xs:string?,              
             $calendar  as xs:string?,              
             $country   as xs:string?) as xs:string?
format-date($value as xs:date?, $picture as xs:string) as xs:string?
format-time( $value     as xs:time?,                
             $picture   as xs:string,               
             $language  as xs:string?,              
             $calendar  as xs:string?,              
             $country   as xs:string?) as xs:string?
format-time($value as xs:time?, $picture as xs:string) as xs:string?

The format-dateTime, format-date, and format-time functions format $value as a
string using the picture string specified by the $picture argument, the
calendar specified by the $calendar argument, the language specified by the
$language argument, and the country specified by the $country argument. The
result of the function is the formatted string representation of the supplied
dateTime, date, or time value.

[Definition: The three functions format-date, format-time, and format-dateTime
are referred to collectively as the date formatting functions.]

If $value is the empty sequence, the empty sequence is returned.

Calling the two-argument form of each of the three functions is equivalent to
calling the five-argument form with each of the last three arguments set to an
empty sequence.

For details of the language, calendar, and country arguments, see 16.5.2 The
Language, Calendar, and Country Arguments.

In general, the use of an invalid picture, language, calendar, or country
argument is classified as a non-recoverable dynamic error. By contrast, use of
an option in any of these arguments that is valid but not supported by the
implementation is not an error, and in these cases the implementation is
required to output the value in a fallback representation.

16.5.1 The Picture String

The picture consists of a sequence of variable markers and literal substrings.
A substring enclosed in square brackets is interpreted as a variable marker;
substrings not enclosed in square brackets are taken as literal substrings.
The literal substrings are optional and if present are rendered unchanged,
including any whitespace. If an opening or closing square bracket is required
within a literal substring, it must be doubled. The variable markers are
replaced in the result by strings representing aspects of the date and/or time
to be formatted. These are described in detail below.

A variable marker consists of a component specifier followed optionally by one
or two presentation modifiers and/or optionally by a width modifier.
Whitespace within a variable marker is ignored.

The component specifier indicates the component of the date or time that is
required, and takes the following values:

+----------------------------------------------------------------------------+
|           |                                                 | Default      |
| Specifier | Meaning                                         | Presentation |
|           |                                                 | Modifier     |
|-----------+-------------------------------------------------+--------------|
| Y         | year (absolute value)                           | 1            |
|-----------+-------------------------------------------------+--------------|
| M         | month in year                                   | 1            |
|-----------+-------------------------------------------------+--------------|
| D         | day in month                                    | 1            |
|-----------+-------------------------------------------------+--------------|
| d         | day in year                                     | 1            |
|-----------+-------------------------------------------------+--------------|
| F         | day of week                                     | n            |
|-----------+-------------------------------------------------+--------------|
| W         | week in year                                    | 1            |
|-----------+-------------------------------------------------+--------------|
| w         | week in month                                   | 1            |
|-----------+-------------------------------------------------+--------------|
| H         | hour in day (24 hours)                          | 1            |
|-----------+-------------------------------------------------+--------------|
| h         | hour in half-day (12 hours)                     | 1            |
|-----------+-------------------------------------------------+--------------|
| P         | am/pm marker                                    | n            |
|-----------+-------------------------------------------------+--------------|
| m         | minute in hour                                  | 01           |
|-----------+-------------------------------------------------+--------------|
| s         | second in minute                                | 01           |
|-----------+-------------------------------------------------+--------------|
| f         | fractional seconds                              | 1            |
|-----------+-------------------------------------------------+--------------|
| Z         | timezone as a time offset from UTC, or if an    | 1            |
|           | alphabetic modifier is present the conventional |              |
|           | name of a timezone (such as PST)                |              |
|-----------+-------------------------------------------------+--------------|
| z         | timezone as a time offset using GMT, for        | 1            |
|           | example GMT+1                                   |              |
|-----------+-------------------------------------------------+--------------|
| C         | calendar: the name or abbreviation of a         | n            |
|           | calendar name                                   |              |
|-----------+-------------------------------------------------+--------------|
| E         | era: the name of a baseline for the numbering   | n            |
|           | of years, for example the reign of a monarch    |              |
+----------------------------------------------------------------------------+

[ERR XTDE1340] It is a non-recoverable dynamic error if the syntax of the
picture is incorrect.

[ERR XTDE1350] It is a non-recoverable dynamic error if a component specifier
within the picture refers to components that are not available in the given
type of $value, for example if the picture supplied to the format-time refers
to the year, month, or day component.

It is not an error to include a timezone component when the supplied value has
no timezone. In these circumstances the timezone component will be ignored.

The first presentation modifier indicates the style in which the value of a
component is to be represented. Its value may be either:

  * any format token permitted in the format string of the xsl:number
    instruction (see 12 Numbering), indicating that the value of the component
    is to be output numerically using the specified number format (for
    example, 1, 01, i, I, w, W, or Ww) or
   
  * the format token n, N, or Nn, indicating that the value of the component
    is to be output by name, in lower-case, upper-case, or title-case
    respectively. Components that can be output by name include (but are not
    limited to) months, days of the week, timezones, and eras. If the
    processor cannot output these components by name for the chosen calendar
    and language then it must use an implementation-defined fallback
    representation.
   
If the implementation does not support the use of the requested format token,
it must use the default presentation modifier for that component.

If the first presentation modifier is present, then it may optionally be
followed by a second presentation modifier as follows:

+----------------------------------------------------------------------------+
| Modifier | Meaning                                                         |
|----------+-----------------------------------------------------------------|
| t        | traditional numbering. This has the same meaning as             |
|          | letter-value="traditional" in xsl:number.                       |
|----------+-----------------------------------------------------------------|
| o        | ordinal form of a number, for example 8th or 8º. The actual     |
|          | representation of the ordinal form of a number may depend not   |
|          | only on the language, but also on the grammatical context (for  |
|          | example, in some languages it must agree in gender).            |
+----------------------------------------------------------------------------+

Note:

Although the formatting rules are expressed in terms of the rules for format
tokens in xsl:number, the formats actually used may be specialized to the
numbering of date components where appropriate. For example, in Italian, it is
conventional to use an ordinal number (primo) for the first day of the month,
and cardinal numbers (due, tre, quattro ...) for the remaining days. A
processor may therefore use this convention to number days of the month,
ignoring the presence or absence of the ordinal presentation modifier.

Whether or not a presentation modifier is included, a width modifier may be
supplied. This indicates the number of characters or digits to be included in
the representation of the value.

The width modifier, if present, is introduced by a comma. It takes the form:

   ,  min-width ("-" max-width)?

where min-width is either an unsigned integer indicating the minimum number of
characters to be output, or * indicating that there is no explicit minimum,
and max-width is either an unsigned integer indicating the maximum number of
characters to be output, or * indicating that there is no explicit maximum; if
max-width is omitted then * is assumed. Both integers, if present, must be
greater than zero.

A format token containing leading zeroes, such as 001, sets the minimum and
maximum width to the number of digits appearing in the format token; if a
width modifier is also present, then the width modifier takes precedence.

Note:

A format token consisting of a one-digit on its own, such as 1, does not
constrain the number of digits in the output. In the case of fractional
seconds in particular, [f001] requests three decimal digits, [f01] requests
two digits, but [f1] will produce an implementation-defined number of digits.
If exactly one digit is required, this can be achieved using the component
specifier [f1,1-1].

If the minumum and maximum width are unspecified, then the output uses as many
characters as are required to represent the value of the component without
truncation and without padding: this is referred to below as the full
representation of the value.

If the full representation of the value exceeds the specified maximum width,
then the processor should attempt to use an alternative shorter representation
that fits within the maximum width. Where the presentation modifier is N, n,
or Nn, this is done by abbreviating the name, using either conventional
abbreviations if available, or crude right-truncation if not. For example,
setting max-width to 4 indicates that four-letter abbreviations should be
used, though it would be acceptable to use a three-letter abbreviation if this
is in conventional use. (For example, "Tuesday" might be abbreviated to
"Tues", and "Friday" to "Fri".) In the case of the year component, setting
max-width requests omission of high-order digits from the year, for example,
if max-width is set to 2 then the year 2003 will be output as 03. In the case
of the fractional seconds component, the value is rounded to the specified
size as if by applying the function round-half-to-even(fractional-seconds,
max-width). If no mechanism is available for fitting the value within the
specified maximum width (for example, when roman numerals are used), then the
value should be output in its full representation.

If the full representation of the value is shorter than the specified minimum
width, then the processor should pad the value to the specified width. For
decimal representations of numbers, this should be done by prepending zero
digits from the appropriate set of digit characters, or appending zero digits
in the case of the fractional seconds component. In other cases, it should be
done by appending spaces.

16.5.2 The Language, Calendar, and Country Arguments

The set of languages, calendars, and countries that are supported in the date
formatting functions is implementation-defined. When any of these arguments is
omitted or is an empty sequence, an implementation-defined default value is
used.

If the fallback representation uses a different calendar from that requested,
the output string must be prefixed with [Calendar: X] where X identifies the
calendar actually used. The string Calendar should be localized using the
requested language if available. If the fallback representation uses a
different language from that requested, the output string should be prefixed
with [Language: Y] where Y identifies the language actually used. The string
Language may be localized in an implementation-dependent way. If a particular
component of the value cannot be output in the requested format, it should be
output in the default format for that component.

The language argument specifies the language to be used for the result string
of the function. The value of the argument must be either the empty sequence
or a value that would be valid for the xml:lang attribute (see [XML]). Note
that this permits the identification of sublanguages based on country codes
(from [ISO 3166-1]) as well as identification of dialects and of regions
within a country.

If the language argument is omitted or is set to an empty sequence, or if it
is set to an invalid value or a value that the implementation does not
recognize, then the processor uses an implementation-defined language.

The language is used to select the appropriate language-dependent forms of:

    names (for example, of months)
    numbers expressed as words or as ordinals (twenty, 20th, twentieth)
    hour convention (0-23 vs 1-24, 0-11 vs 1-12)
    first day of week, first week of year
   
Where appropriate this choice may also take into account the value of the
country argument, though this should not be used to override the language or
any sublanguage that is specified as part of the language argument.

The choice of the names and abbreviations used in any given language is 
implementation-defined. For example, one implementation might abbreviate July
as Jul while another uses Jly. In German, one implementation might represent
Saturday as Samstag while another uses Sonnabend. Implementations may provide
mechanisms allowing users to control such choices.

Where ordinal numbers are used, the selection of the correct representation of
the ordinal (for example, the linguistic gender) may depend on the component
being formatted and on its textual context in the picture string.

The calendar attribute specifies that the dateTime, date, or time supplied in
the $value argument must be converted to a value in the specified calendar and
then converted to a string using the conventions of that calendar.

A calendar value must be a valid QName. If the QName does not have a prefix,
then it identifies a calendar with the designator specified below. If the
QName has a prefix, then the QName is expanded into an expanded-QName as
described in 5.1 Qualified Names; the expanded-QName identifies the calendar;
the behavior in this case is implementation-defined.

If the calendar attribute is omitted an implementation-defined value is used.

Note:

The calendars listed below were known to be in use during the last hundred
years. Many other calendars have been used in the past.

This specification does not define any of these calendars, nor the way that
they map to the value space of the xs:date data type in [XML Schema Part 2].
There may be ambiguities when dates are recorded using different calendars.
For example, the start of a new day is not simultaneous in different
calendars, and may also vary geographically (for example, based on the time of
sunrise or sunset). Translation of dates is therefore more reliable when the
time of day is also known, and when the geographic location is known. When
translating dates between one calendar and another, the processor may take
account of the values of the country and/or language arguments, with the
country argument taking precedence.

Information about some of these calendars, and algorithms for converting
between them, may be found in [Calendrical Calculations].

+---------------------------------------------------------------+
| Designator | Calendar                                         |
|------------+--------------------------------------------------|
| AD         | Anno Domini (Christian Era)                      |
|------------+--------------------------------------------------|
| AH         | Anno Hegirae (Muhammedan Era)                    |
|------------+--------------------------------------------------|
| AME        | Mauludi Era (solar years since Mohammed's birth) |
|------------+--------------------------------------------------|
| AM         | Anno Mundi (Jewish Calendar)                     |
|------------+--------------------------------------------------|
| AP         | Anno Persici                                     |
|------------+--------------------------------------------------|
| AS         | Aji Saka Era (Java)                              |
|------------+--------------------------------------------------|
| BE         | Buddhist Era                                     |
|------------+--------------------------------------------------|
| CB         | Cooch Behar Era                                  |
|------------+--------------------------------------------------|
| CE         | Common Era                                       |
|------------+--------------------------------------------------|
| CL         | Chinese Lunar Era                                |
|------------+--------------------------------------------------|
| CS         | Chula Sakarat Era                                |
|------------+--------------------------------------------------|
| EE         | Ethiopian Era                                    |
|------------+--------------------------------------------------|
| FE         | Fasli Era                                        |
|------------+--------------------------------------------------|
| ISO        | ISO 8601 calendar                                |
|------------+--------------------------------------------------|
| JE         | Japanese Calendar                                |
|------------+--------------------------------------------------|
| KE         | Khalsa Era (Sikh calendar)                       |
|------------+--------------------------------------------------|
| KY         | Kali Yuga                                        |
|------------+--------------------------------------------------|
| ME         | Malabar Era                                      |
|------------+--------------------------------------------------|
| MS         | Monarchic Solar Era                              |
|------------+--------------------------------------------------|
| NS         | Nepal Samwat Era                                 |
|------------+--------------------------------------------------|
| OS         | Old Style (Julian Calendar)                      |
|------------+--------------------------------------------------|
| RS         | Rattanakosin (Bangkok) Era                       |
|------------+--------------------------------------------------|
| SE         | Saka Era                                         |
|------------+--------------------------------------------------|
| SH         | Mohammedan Solar Era (Iran)                      |
|------------+--------------------------------------------------|
| SS         | Saka Samvat                                      |
|------------+--------------------------------------------------|
| TE         | Tripurabda Era                                   |
|------------+--------------------------------------------------|
| VE         | Vikrama Era                                      |
|------------+--------------------------------------------------|
| VS         | Vikrama Samvat Era                               |
+---------------------------------------------------------------+

At least one of the above calendars must be supported. It is 
implementation-defined which calendars are supported.

The ISO 8601 calendar ([ISO 8601]), which is included in the above list and
designated ISO, is very similar to the Gregorian calendar designated AD, but
it differs in several ways. The ISO calendar is intended to ensure that date
and time formats can be read easily by other software, as well as being
legible for human users. The ISO calendar prescribes the use of particular
numbering conventions as defined in ISO 8601, rather than allowing these to be
localized on a per-language basis. In particular it provides a numeric 'week
date' format which identifies dates by year, week of the year, and day in the
week; in the ISO calendar the days of the week are numbered from 1 (Monday) to
7 (Sunday), and week 1 in any calendar year is the week (from Monday to
Sunday) that includes the first Thursday of that year. The numeric values of
the components year, month, day, hour, minute, and second are the same in the
ISO calendar as the values used in the lexical representation of the date and
time as defined in [XML Schema Part 2]. The era ("E" component) with this
calendar is either a minus sign (for negative years) or a zero-length string
(for positive years). For dates before 1 January, AD 1, year numbers in the
ISO and AD calendars are off by one from each other: ISO year 0000 is 1 BC,
-0001 is 2 BC, etc.

Note:

The value space of the date and time data types, as defined in XML Schema, is
based on absolute points in time. The lexical space of these data types
defines a representation of these absolute points in time using the proleptic
Gregorian calendar, that is, the modern Western calendar extrapolated into the
past and the future; but the value space is calendar-neutral. The date
formatting functions produce a representation of this absolute point in time,
but denoted in a possibly different calendar. So, for example, the date whose
lexical representation in XML Schema is 1502-01-11 (the day on which Pope
Gregory XIII was born) might be formatted using the Old Style (Julian)
calendar as 1 January 1502. This reflects the fact that there was at that time
a ten-day difference between the two calendars. It would be incorrect, and
would produce incorrect results, to represent this date in an element or
attribute of type xs:date as 1502-01-01, even though this might reflect the
way the date was recorded in contemporary documents.

When referring to years occurring in antiquity, modern historians generally
use a numbering system in which there is no year zero (the year before 1 CE is
thus 1 BCE). This is the convention that should be used when the requested
calendar is OS (Julian) or AD (Gregorian). When the requested calendar is ISO,
however, the conventions of ISO 8601 should be followed: here the year before
+0001 is numbered zero. In [XML Schema Part 2] (version 1.0), the value space
for xs:date and xs:dateTime does not include a year zero: however, a future
edition is expected to endorse the ISO 8601 convention. This means that the
date on which Julius Caesar was assassinated has the ISO 8601 lexical
representation -0043-03-13, but will be formatted as 15 March 44 BCE in the
Julian calendar or 13 March 44 BCE in the Gregorian calendar (dependant on the
chosen localization of the names of months and eras).

The intended use of the country argument is to identify the place where an
event represented by the dateTime, date, or time supplied in the $value
argument took place or will take place. If the value is supplied, and is not
the empty sequence, then it should be a country code defined in [ISO 3166-1].
Implementations may also allow the use of codes representing subdivisions of a
country from ISO 3166-2, or codes representing formerly used names of
countries from ISO 3166-3. This argument is not intended to identify the
location of the user for whom the date or time is being formatted; that should
be done by means of the language attribute. This information may be used to
provide additional information when converting dates between calendars or when
deciding how individual components of the date and time are to be formatted.
For example, different countries using the Old Style (Julian) calendar started
the new year on different days, and some countries used variants of the
calendar that were out of synchronization as a result of differences in
calculating leap years. The geographical area identified by a country code is
defined by the boundaries as they existed at the time of the date to be
formatted, or the present-day boundaries for dates in the future.

16.5.3 Examples of Date and Time Formatting

Example: Gregorian Calendar

The following examples show a selection of dates and times and the way they
might be formatted. These examples assume the use of the Gregorian calendar as
the default calendar.

+----------------------------------------------------------------------------+
| Required Output          | Expression                                      |
|--------------------------+-------------------------------------------------|
| 2002-12-31               | format-date($d, "[Y0001]-[M01]-[D01]")          |
|--------------------------+-------------------------------------------------|
| 12-31-2002               | format-date($d, "[M]-[D]-[Y]")                  |
|--------------------------+-------------------------------------------------|
| 31-12-2002               | format-date($d, "[D]-[M]-[Y]")                  |
|--------------------------+-------------------------------------------------|
| 31 XII 2002              | format-date($d, "[D1] [MI] [Y]")                |
|--------------------------+-------------------------------------------------|
| 31st December, 2002      | format-date($d, "[D1o] [MNn], [Y]", "en", (),   |
|                          | ())                                             |
|--------------------------+-------------------------------------------------|
| 31 DEC 2002              | format-date($d, "[D01] [MN,*-3] [Y0001]", "en", |
|                          | (), ())                                         |
|--------------------------+-------------------------------------------------|
| December 31, 2002        | format-date($d, "[MNn] [D], [Y]", "en", (), ()) |
|--------------------------+-------------------------------------------------|
| 31 Dezember, 2002        | format-date($d, "[D] [MNn], [Y]", "de", (), ()) |
|--------------------------+-------------------------------------------------|
| Tisdag 31 December 2002  | format-date($d, "[FNn] [D] [MNn] [Y]", "sv",    |
|                          | (), ())                                         |
|--------------------------+-------------------------------------------------|
| [2002-12-31]             | format-date($d, "[[[Y0001]-[M01]-[D01]]]")      |
|--------------------------+-------------------------------------------------|
| Two Thousand and Three   | format-date($d, "[YWw]", "en", (), ())          |
|--------------------------+-------------------------------------------------|
| einunddreißigste         | format-date($d, "[Dwo] [MNn]", "de", (), ())    |
| Dezember                 |                                                 |
|--------------------------+-------------------------------------------------|
| 3:58 PM                  | format-time($t, "[h]:[m01] [PN]", "en", (), ()) |
|--------------------------+-------------------------------------------------|
| 3:58:45 pm               | format-time($t, "[h]:[m01]:[s01] [Pn]", "en",   |
|                          | (), ())                                         |
|--------------------------+-------------------------------------------------|
| 3:58:45 PM PDT           | format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]  |
|                          | ", "en", (), ())                                |
|--------------------------+-------------------------------------------------|
| 3:58:45 o'clock PM PDT   | format-time($t, "[h]:[m01]:[s01] o'clock [PN]   |
|                          | [ZN,*-3]", "en")                                |
|--------------------------+-------------------------------------------------|
| 15:58                    | format-time($t,"[H01]:[m01]")                   |
|--------------------------+-------------------------------------------------|
| 15:58:45.762             | format-time($t,"[H01]:[m01]:[s01].[f001]")      |
|--------------------------+-------------------------------------------------|
| 15:58:45 GMT+02:00       | format-time($t,"[H01]:[m01]:[s01] [z]", "en",   |
|                          | (), ())                                         |
|--------------------------+-------------------------------------------------|
| 15.58 Uhr GMT+02:00      | format-time($t,"[H01]:[m01] Uhr [z]", "de", (), |
|                          | ())                                             |
|--------------------------+-------------------------------------------------|
| 3.58pm on Tuesday, 31st  | format-dateTime($dt, "[h].[m01][Pn] on [FNn],   |
| December                 | [D1o] [MNn]")                                   |
|--------------------------+-------------------------------------------------|
| 12/31/2002 at 15:58:45   | format-dateTime($dt, "[M01]/[D01]/[Y0001] at    |
|                          | [H01]:[m01]:[s01]")                             |
+----------------------------------------------------------------------------+

Example: Non-Gregorian Calendars

The following examples use calendars other than the Gregorian calendar.

These examples use non-Latin characters which might not display correctly in
all browsers, depending on the system configuration.

+----------------------------------------------------------------------------+
| Description         | Request                                  | Result    |
|---------------------+------------------------------------------+-----------|
| Islamic             | format-date($d, "[D&#x0661;] [Mn] [Y&#   | ٢٦ ﺸﻭّﺍﻝ   |
|                     | x0661;]", "Islamic", "ar", "AH", ())     | ١٤٢٣      |
|---------------------+------------------------------------------+-----------|
| Jewish (with        | format-date($d, "[D] [Mn] [Y]", "he",    | ‏26 טבת   |
| Western numbering)  | "AM", ())                                | 5763      |
|---------------------+------------------------------------------+-----------|
| Jewish (with        | format-date($d, "[D&#x05D0;t] [Mn] [Y&#  | כ״ו טבת   |
| traditional         | x05D0;t]", "he", "AM", ())               | תשס״ג     |
| numbering)          |                                          |           |
|---------------------+------------------------------------------+-----------|
| Julian (Old Style)  | format-date($d, "[D] [MNn] [Y]", "en",   | 18        |
|                     | "OS", ())                                | December  |
|                     |                                          | 2002      |
|---------------------+------------------------------------------+-----------|
| Thai                | format-date($d, "[D&#x0E51;] [Mn] [Y&#   | ๓๑ ธันวาคม |
|                     | x0E51;]", "th", "BE", ())                | ๒๕๔๕      |
+----------------------------------------------------------------------------+

16.6 Miscellaneous Additional Functions

16.6.1 current

current() as item()

The current function, used within an XPath expression, returns the item that
was the context item at the point where the expression was invoked from the
XSLT stylesheet. This is referred to as the current item. For an outermost
expression (an expression not occurring within another expression), the
current item is always the same as the context item. Thus,

<xsl:value-of select="current()"/>

means the same as

<xsl:value-of select="."/>

However, within square brackets, or on the right-hand side of the / operator,
the current item is generally different from the context item.

Example: Using the current Function

For example,

<xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/>

will process all entry elements that have a glossary parent element and that
have a name attribute with value equal to the value of the current item's ref
attribute. This is different from

<xsl:apply-templates select="//glossary/entry[@name=./@ref]"/>

which means the same as

<xsl:apply-templates select="//glossary/entry[@name=@ref]"/>

and so would process all entry elements that have a glossary parent element
and that have a name attribute and a ref attribute with the same value.

If the current function is used within a pattern, its value is the node that
is being matched against the pattern.

[ERR XTDE1360] If the current function is evaluated within an expression that
is evaluated when the context item is undefined, a non-recoverable dynamic
error occurs.

16.6.2 unparsed-entity-uri

unparsed-entity-uri($entity-name as xs:string) as xs:anyURI

The unparsed-entity-uri function returns the URI of the unparsed entity whose
name is given by the value of the $entity-name argument, in the document
containing the context node. It returns the zero-length xs:anyURI if there is
no such entity. This function maps to the dm:unparsed-entity-system-id
accessor defined in [Data Model].

[ERR XTDE1370] It is a non-recoverable dynamic error if the 
unparsed-entity-uri function is called when there is no context node, or when
the root of the tree containing the context node is not a document node.

16.6.3 unparsed-entity-public-id

unparsed-entity-public-id( $entity-name as xs:string) as xs:string

The unparsed-entity-public-id function returns the public identifier of the
unparsed entity whose name is given by the value of the $entity-name argument,
in the document containing the context node. It returns the zero-length string
if there is no such entity, or if the entity has no public identifier. This
function maps to the dm:unparsed-entity-public-id accessor defined in [Data
Model].

[ERR XTDE1380] It is a non-recoverable dynamic error if the 
unparsed-entity-public-id function is called when there is no context node, or
when the root of the tree containing the context node is not a document node.

16.6.4 generate-id

generate-id() as xs:string
generate-id($node as node()?) as xs:string

The generate-id function returns a string that uniquely identifies a given
node. The unique identifier must consist of ASCII alphanumeric characters and 
must start with an alphabetic character. Thus, the string is syntactically an
XML name. An implementation is free to generate an identifier in any
convenient way provided that it always generates the same identifier for the
same node and that different identifiers are always generated from different
nodes. An implementation is under no obligation to generate the same
identifiers each time a document is transformed. There is no guarantee that a
generated unique identifier will be distinct from any unique IDs specified in
the source document. If the argument is the empty sequence, the result is the 
zero-length string. If the argument is omitted, it defaults to the context
node.

16.6.5 system-property

system-property($property-name as xs:string) as xs:string

The $property-name argument must evaluate to a lexical QName. The lexical
QName is expanded as described in 5.1 Qualified Names.

[ERR XTDE1390] It is a non-recoverable dynamic error if the value is not a
valid QName, or if there is no namespace declaration in scope for the prefix
of the QName. If the processor is able to detect the error statically (for
example, when the argument is supplied as a string literal), then the
processor may optionally signal this as a static error.

The system-property function returns a string representing the value of the
system property identified by the name. If there is no such system property,
the zero-length string is returned.

Implementations must provide the following system properties, which are all in
the XSLT namespace:

  * xsl:version, a number giving the version of XSLT implemented by the 
    processor; for implementations conforming to the version of XSLT specified
    by this document, this is the string "2.0". The value will always be a
    string in the lexical space of the decimal data type defined in XML Schema
    (see [XML Schema Part 2]). This allows the value to be converted to a
    number for the purpose of magnitude comparisons.
   
  * xsl:vendor, a string identifying the implementer of the processor
   
  * xsl:vendor-url, a string containing a URL identifying the implementer of
    the processor; typically this is the host page (home page) of the
    implementer's Web site.
   
  * xsl:product-name, a string containing the name of the implementation, as
    defined by the implementer. This should normally remain constant from one
    release of the product to the next. It should also be constant across
    platforms in cases where the same source code is used to produce
    compatible products for multiple execution platforms.
   
  * xsl:product-version, a string identifying the version of the
    implementation, as defined by the implementer. This should normally vary
    from one release of the product to the next, and at the discretion of the
    implementer it may also vary across different execution platforms.
   
  * xsl:is-schema-aware, returns the string "yes" in the case of a processor
    that claims conformance as a schema-aware XSLT processor, or "no" in the
    case of a basic XSLT processor.
   
  * xsl:supports-serialization, returns the string "yes" in the case of a
    processor that offers the serialization feature, or "no" otherwise.
   
  * xsl:supports-backwards-compatibility, returns the string "yes" in the case
    of a processor that offers the backwards compatibility feature, or "no"
    otherwise.
   
Some of these properties relate to the conformance levels and features offered
by the processor: these options are described in 21 Conformance.

The actual values returned for the above properties are implementation-defined
.

The set of system properties that are supported, in addition to those listed
above, is also implementation-defined. Implementations must not define
additional system properties in the XSLT namespace.

Note:

An implementation must not return the value 2.0 as the value of the
xsl:version system property unless it is conformant to XSLT 2.0.

It is recognized that vendors who are enhancing XSLT 1.0 processors may wish
to release interim implementations before all the mandatory features of this
specification are implemented. Since such products are not conformant to XSLT
2.0, this specification cannot define their behavior. However, implementers of
such products are encouraged to return a value for the xsl:version system
property that is intermediate between 1.0 and 2.0, and to provide the 
element-available and function-available functions to allow users to test
which features have been fully implemented.

17 Messages

<!-- Category: instruction -->
<xsl:message
  select? = expression
  terminate? = { "yes" | "no" }>
  <!-- Content: sequence-constructor -->
</xsl:message>

The xsl:message instruction sends a message in an implementation-defined way.
The xsl:message instruction causes the creation of a new document, which is
typically serialized and output to an implementation-defined destination. The
result of the xsl:message instruction is an empty sequence.

The content of the message may be specified by using either or both of the
optional select attribute and the sequence constructor that forms the content
of the xsl:message instruction.

If the xsl:message instruction contains a sequence constructor, then the
sequence obtained by evaluating this sequence constructor is used to construct
the content of the new document node, as described in 5.7.1 Constructing
Complex Content.

If the xsl:message instruction has a select attribute, then the value of the
attribute must be an XPath expression. The effect of the xsl:message
instruction is then the same as if a single xsl:copy-of instruction with this
select attribute were added to the start of the sequence constructor.

If the xsl:message instruction has no content and no select attribute, then an
empty message is produced.

The tree produced by the xsl:message instruction is not technically a final
result tree. The tree has no URI and processors are not required to make the
tree accessible to applications.

Note:

In many cases, the XML document produced using xsl:message will consist of a
document node owning a single text node. However, it may contain a more
complex structure.

Note:

An implementation might implement xsl:message by popping up an alert box or by
writing to a log file. Because the order of execution of instructions is
implementation-defined, the order in which such messages appear is not
predictable.

The terminate attribute is interpreted as an attribute value template.

If the effective value of the terminate attribute is yes, then the processor 
must terminate processing after sending the message. The default value is no.
Note that because the order of evaluation of instructions is 
implementation-dependent, this gives no guarantee that any particular
instruction will or will not be evaluated before processing terminates.

[ERR XTMM9000] When a transformation is terminated by use of xsl:message
terminate="yes", the effect is the same as when a non-recoverable dynamic
error occurs during the transformation.

Example: Localizing Messages

One convenient way to do localization is to put the localized information
(message text, etc.) in an XML document, which becomes an additional input
file to the stylesheet. For example, suppose messages for a language L are
stored in an XML file resources/L.xml in the form:

<messages>
  <message name="problem">A problem was detected.</message>
  <message name="error">An error was detected.</message>
</messages>

Then a stylesheet could use the following approach to localize messages:

<xsl:param name="lang" select="'en'"/>
<xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/>

<xsl:template name="localized-message">
  <xsl:param name="name"/>
  <xsl:message select="string($messages/message[@name=$name])"/>
</xsl:template>

<xsl:template name="problem">
  <xsl:call-template name="localized-message">
    <xsl:with-param name="name">problem</xsl:with-param>
  </xsl:call-template>
</xsl:template>

18 Extensibility and Fallback

XSLT allows two kinds of extension, extension instructions and extension
functions.

[Definition: An extension instruction is an element within a sequence
constructor that is in a namespace (not the XSLT namespace) designated as an
extension namespace.]

[Definition: An extension function is a function that is available for use
within an XPath expression, other than a core function defined in [Functions
and Operators], an additional function defined in this XSLT specification, a
constructor function named after an atomic type, or a stylesheet function
defined using an xsl:function declaration.].

This specification does not define any mechanism for creating or binding
implementations of extension instructions or extension functions, and it is
not required that implementations support any such mechanism. Such mechanisms,
if they exist, are implementation-defined. Therefore, an XSLT stylesheet that 
must be portable between XSLT implementations cannot rely on particular
extensions being available. XSLT provides mechanisms that allow an XSLT
stylesheet to determine whether the implementation makes particular extensions
available, and to specify what happens if those extensions are not available.
If an XSLT stylesheet is careful to make use of these mechanisms, it is
possible for it to take advantage of extensions and still retain portability.

18.1 Extension Functions

The set of functions that can be called from a FunctionCall^ XP within an
XPath expression may include one or more extension functions. The 
expanded-QName of an extension function always has a non-null namespace URI.

18.1.1 Testing Availability of Functions

The function-available function can be used with the [xsl:]use-when attribute
(see 3.12 Conditional Element Inclusion) to explicitly control how a
stylesheet behaves if a particular extension function is not available.

function-available($function-name as xs:string) as xs:boolean
function-available( $function-name  as xs:string,               
                    $arity          as xs:integer) as xs:boolean

A function is said to be available within an XPath expression if it is present
in the in-scope functions^XP for that expression (see 5.4.1 Initializing the
Static Context). Functions in the static context are uniquely identified by
the name of the function (a QName) in combination with its arity.

The value of the $function-name argument must be a string containing a lexical
QName. The lexical QName is expanded into an expanded-QName using the
namespace declarations in scope for the expression. If the lexical QName is
unprefixed, then the standard function namespace is used in the expanded
QName.

The two-argument version of the function-available function returns true if
and only if there is an available function whose name matches the value of the
$function-name argument and whose arity matches the value of the $arity
argument.

The single-argument version of the function-available function returns true if
and only if there is at least one available function (with some arity) whose
name matches the value of the $function-name argument.

[ERR XTDE1400] It is a non-recoverable dynamic error if the argument does not
evaluate to a string that is a valid QName, or if there is no namespace
declaration in scope for the prefix of the QName. If the processor is able to
detect the error statically (for example, when the argument is supplied as a
string literal), then the processor may optionally signal this as a static
error.

When backwards compatible behavior is enabled, the function-available function
returns false in respect of a function name and arity for which no
implementation is available (other than the fallback error function that
raises a dynamic error whenever it is called). This means that it is possible
(as in XSLT 1.0) to use logic such as the following to test whether a function
is available before calling it:

Example: Calling an extension function with backwards-compatibility enabled

<summary xsl:version="1.0">
  <xsl:choose>
    <xsl:when test="function-available('my:summary')">
      <xsl:value-of select="my:summary()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Summary not available</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</summary>

Note:

The fact that a function with a given name is available gives no guarantee
that any particular call on the function will be successful. For example, it
is not possible to determine the types of the arguments expected.

Note:

In XSLT 2.0 (without backwards compatibility enabled) a static error occurs
when an XPath expression references a function that is not available. This is
true even in a part of the stylesheet that uses forwards-compatible behavior.
Therefore, the conditional logic to test whether a function is available
before calling it should normally be written in a use-when attribute (see 3.12
Conditional Element Inclusion).

Example: Stylesheet portable between XSLT 1.0 and XSLT 2.0

A stylesheet that is designed to use XSLT 2.0 facilities when they are
available, but to fall back to XSLT 1.0 capabilities when not, might be
written using the code:

<out xsl:version="2.0">
  <xsl:choose>
    <xsl:when test="function-available('matches')">
      <xsl:value-of select="matches($input, '[a-z]*')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="string-length(
                          translate($in, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/>
    </xsl:otherwise>
  </xsl:choose>
</out>

Here an XSLT 2.0 processor will always take the xsl:when branch, while a 1.0
processor will follow the xsl:otherwise branch. The single-argument version of
the function-available function is used here, because that is the only version
available in XSLT 1.0. Under the rules of XSLT 1.0, the call on the matches
function is not an error, because it is never evaluated.

Example: Stylesheet portable between XSLT 2.0 and a future version of XSLT

A stylesheet that is designed to use facilities in some future XSLT version
when they are available, but to fall back to XSLT 2.0 capabilities when not,
might be written using code such as the following. This hypothesizes the
availability in some future version of a function pad which pads a string to a
fixed length with spaces:

 <xsl:value-of select="pad($input, 10)" 
               use-when="function-available('pad', 2)"/>
 <xsl:value-of select="concat($input, string-join(
                          for $i in 1 to 10 - string-length($input) 
                                                  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/>

In this case the two-argument version of function-available is used, because
there is no requirement for this code to run under XSLT 1.0.

18.1.2 Calling Extension Functions

If the function name used in a FunctionCall^ XP within an XPath expression
identifies an extension function, then to evaluate the FunctionCall^ XP, the
processor will first evaluate each of the arguments in the FunctionCall^ XP.
If the processor has information about the data types expected by the
extension function, then it may perform any necessary type conversions between
the XPath data types and those defined by the implementation language. If
multiple extension functions are available with the same name, the processor 
may decide which one to invoke based on the number of arguments, the types of
the arguments, or any other criteria. The result returned by the
implementation is returned as the result of the function call, again after any
necessary conversions between the data types of the implementation language
and those of XPath. The details of such type conversions are outside the scope
of this specification.

[ERR XTDE1420] It is a non-recoverable dynamic error if the arguments supplied
to a call on an extension function do not satisfy the rules defined for that
particular extension function, or if the extension function reports an error,
or if the result of the extension function cannot be converted to an XPath
value.

Note:

Implementations may also provide mechanisms allowing extension functions to
report recoverable dynamic errors, or to execute within an environment that
treats some or all of the errors listed above as recoverable.

[ERR XTDE1425] When backwards compatible behavior is enabled, it is a 
non-recoverable dynamic error to evaluate an extension function call if no
implementation of the extension function is available.

Note:

When backwards-compatible behavior is not enabled, this is a static error
[XPST0017].

Note:

There is no prohibition on calling extension functions that have side-effects
(for example, an extension function that writes data to a file). However, the
order of execution of XSLT instructions is not defined in this specification,
so the effects of such functions are unpredictable.

Implementations are not required to perform full validation of values returned
by extension functions. It is an error for an extension function to return a
string containing characters that are not permitted in XML, but the
consequences of this error are implementation-defined. The implementation may
raise an error, may convert the string to a string containing valid characters
only, or may treat the invalid characters as if they were permitted
characters.

Note:

The ability to execute extension functions represents a potential security
weakness, since untrusted stylesheets may invoke code that has privileged
access to resources on the machine where the processor executes.
Implementations may therefore provide mechanisms that restrict the use of
extension functions by untrusted stylesheets.

All observations in this section regarding the errors that can occur when
invoking extension functions apply equally when invoking extension
instructions.

18.1.3 External Objects

An implementation may allow an extension function to return an object that
does not have any natural representation in the XDM data model, either as an
atomic value or as a node. For example, an extension function sql:connect
might return an object that represents a connection to a relational database;
the resulting connection object might be passed as an argument to calls on
other extension functions such as sql:insert and sql:select.

The way in which such objects are represented in the type system is 
implementation-defined. They might be represented by a completely new data
type, or they might be mapped to existing data types such as integer, string,
or anyURI.

18.1.4 Testing Availability of Types

The type-available function can be used, for example with the [xsl:]use-when
attribute (see 3.12 Conditional Element Inclusion), to explicitly control how
a stylesheet behaves if a particular schema type is not available in the
static context.

type-available($type-name as xs:string) as xs:boolean

A schema type (that is, a simple type or a complex type) is said to be
available within an XPath expression if it is a type definition that is
present in the in-scope schema types^XP for that expression (see 5.4.1
Initializing the Static Context). This includes built-in types, types imported
using xsl:import-schema, and extension types defined by the implementation.

The value of the $type-name argument must be a string containing a lexical
QName. The lexical QName is expanded into an expanded-QName using the
namespace declarations in scope for the expression. If the lexical QName is
unprefixed, then the default namespace is used in the expanded QName.

The function returns true if and only if there is an available type whose name
matches the value of the $type-name argument.

[ERR XTDE1428] It is a non-recoverable dynamic error if the argument does not
evaluate to a string that is a valid QName, or if there is no namespace
declaration in scope for the prefix of the QName. If the processor is able to
detect the error statically (for example, when the argument is supplied as a
string literal), then the processor may optionally signal this as a static
error.

18.2 Extension Instructions

[Definition: The extension instruction mechanism allows namespaces to be
designated as extension namespaces. When a namespace is designated as an
extension namespace and an element with a name from that namespace occurs in a
sequence constructor, then the element is treated as an instruction rather
than as a literal result element.] The namespace determines the semantics of
the instruction.

Note:

Since an element that is a child of an xsl:stylesheet element is not occurring
in a sequence constructor, user-defined data elements (see 3.6.2 User-defined
Data Elements) are not extension elements as defined here, and nothing in this
section applies to them.

18.2.1 Designating an Extension Namespace

A namespace is designated as an extension namespace by using an [xsl:]
extension-element-prefixes attribute on an element in the stylesheet (see 3.5
Standard Attributes). The attribute must be in the XSLT namespace only if its
parent element is not in the XSLT namespace. The value of the attribute is a
whitespace-separated list of namespace prefixes. The namespace bound to each
of the prefixes is designated as an extension namespace.

The default namespace (as declared by xmlns) may be designated as an extension
namespace by including #default in the list of namespace prefixes.

[ERR XTSE1430] It is a static error if there is no namespace bound to the
prefix on the element bearing the [xsl:]extension-element-prefixes attribute 
or, when #default is specified, if there is no default namespace.

The designation of a namespace as an extension namespace is effective for the
element bearing the [xsl:]extension-element-prefixes attribute and for all
descendants of that element within the same stylesheet module.

18.2.2 Testing Availability of Instructions

The element-available function can be used with the xsl:choose and xsl:if
instructions, or with the [xsl:]use-when attribute (see 3.12 Conditional
Element Inclusion) to explicitly control how a stylesheet behaves when a
particular XSLT instruction or extension instruction is (or is not) available.

element-available($element-name as xs:string) as xs:boolean

The value of the $element-name argument must be a string containing a QName.
The QName is expanded into an expanded-QName using the namespace declarations
in scope for the expression. If there is a default namespace in scope, then it
is used to expand an unprefixed QName. The element-available function returns
true if and only if the expanded-QName is the name of an instruction. If the 
expanded-QName has a namespace URI equal to the XSLT namespace URI, then it
refers to an element defined by XSLT. Otherwise, it refers to an extension
instruction. If the expanded-QName has a null namespace URI, the 
element-available function will return false.

[ERR XTDE1440] It is a non-recoverable dynamic error if the argument does not
evaluate to a string that is a valid QName, or if there is no namespace
declaration in scope for the prefix of the QName. If the processor is able to
detect the error statically (for example, when the argument is supplied as a
string literal), then the processor may optionally signal this as a static
error.

If the expanded-QName is in the XSLT namespace, the function returns true if
and only if the expanded QName is the name of an XSLT instruction, that is, an
XSLT element whose syntax summary in this specification classifies it as an 
instruction.

Note:

Although the result of applying this function to a name in the XSLT namespace
when using a conformant XSLT 2.0 processor is entirely predictable, the
function is useful in cases where the stylesheet might be executing under a
processor that implements some other version of XSLT with different rules.

If the expanded-QName is not in the XSLT namespace, the function returns true
if and only if the processor has an implementation available of an extension
instruction with the given expanded QName. This applies whether or not the
namespace has been designated as an extension namespace.

If the processor does not have an implementation of a particular extension
instruction available, and such an extension instruction is evaluated, then
the processor must perform fallback for the element as specified in 18.2.3
Fallback. An implementation must not signal an error merely because the
stylesheet contains an extension instruction for which no implementation is
available.

18.2.3 Fallback

<!-- Category: instruction -->
<xsl:fallback>
  <!-- Content: sequence-constructor -->
</xsl:fallback>

The content of an xsl:fallback element is a sequence constructor, and when
performing fallback, the value returned by the xsl:fallback element is the
result of evaluating this sequence constructor.

When not performing fallback, evaluating an xsl:fallback element returns an
empty sequence: the content of the xsl:fallback element is ignored.

There are two situations where a processor performs fallback: when an
extension instruction that is not available is evaluated, and when an
instruction in the XSLT namespace, that is not defined in XSLT 2.0, is
evaluated within a region of the stylesheet for which forwards compatible
behavior is enabled.

Note:

Fallback processing is not invoked in other situations, for example it is not
invoked when an XPath expression uses unrecognized syntax or contains a call
to an unknown function. To handle such situations dynamically, the stylesheet
should call functions such as system-property and function-available to decide
what capabilities are available.

[ERR XTDE1450] When a processor performs fallback for an extension instruction
that is not recognized, if the instruction element has one or more 
xsl:fallback children, then the content of each of the xsl:fallback children 
must be evaluated; it is a non-recoverable dynamic error if it has no 
xsl:fallback children.

Note:

This is different from the situation with unrecognized XSLT elements. As
explained in 3.9 Forwards-Compatible Processing, an unrecognized XSLT element
appearing within a sequence constructor is a static error unless (a) 
forwards-compatible behavior is enabled, and (b) the instruction has an 
xsl:fallback child.

19 Final Result Trees

The output of a transformation is a set of one or more final result trees.

A final result tree can be created explicitly, by evaluating an 
xsl:result-document instruction. As explained in 2.4 Executing a
Transformation, a final result tree is also created implicitly if no 
xsl:result-document instruction is evaluated, or if the result of evaluating
the initial template is a non-empty sequence.

The way in which a final result tree is delivered to an application is 
implementation-defined.

Serialization of final result trees is described further in 20 Serialization

19.1 Creating Final Result Trees

<!-- Category: instruction -->
<xsl:result-document
  format? = { qname }
  href? = { uri-reference }
  validation? = "strict" | "lax" | "preserve" | "strip"
  type? = qname
  method? = { "xml" | "html" | "xhtml" | "text" | qname-but-not-ncname }
  byte-order-mark? = { "yes" | "no" }
  cdata-section-elements? = { qnames }
  doctype-public? = { string }
  doctype-system? = { string }
  encoding? = { string }
  escape-uri-attributes? = { "yes" | "no" }
  include-content-type? = { "yes" | "no" }
  indent? = { "yes" | "no" }
  media-type? = { string }
  normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized"
| "none" | nmtoken }
  omit-xml-declaration? = { "yes" | "no" }
  standalone? = { "yes" | "no" | "omit" }
  undeclare-prefixes? = { "yes" | "no" }
  use-character-maps? = qnames
  output-version? = { nmtoken }>
  <!-- Content: sequence-constructor -->
</xsl:result-document>

The xsl:result-document instruction is used to create a final result tree. The
content of the xsl:result-document element is a sequence constructor for the
children of the document node of the tree. A document node is created, and the
sequence obtained by evaluating the sequence constructor is used to construct
the content of the document, as described in 5.7.1 Constructing Complex
Content. The tree rooted at this document node forms the final result tree.

The xsl:result-document instruction defines the URI of the result tree, and
may optionally specify the output format to be used for serializing this tree.

The effective value of the format attribute, if specified, must be a lexical
QName. The QName is expanded using the namespace declarations in scope for the
xsl:result-document element. The expanded-QName must match the expanded QName
of a named output definition in the stylesheet. This identifies the xsl:output
declaration that will control the serialization of the final result tree (see 
20 Serialization), if the result tree is serialized. If the format attribute
is omitted, the unnamed output definition is used to control serialization of
the result tree.

[ERR XTDE1460] It is a non-recoverable dynamic error if the effective value of
the format attribute is not a valid lexical QName, or if it does not match the
expanded-QName of an output definition in the stylesheet. If the processor is
able to detect the error statically (for example, when the format attribute
contains no curly brackets), then the processor may optionally signal this as
a static error.

Note:

The only way to select the unnamed output definition is to omit the format
attribute.

The attributes method, byte-order-mark cdata-section-elements, doctype-public,
doctype-system, encoding, escape-uri-attributes, indent, media-type,
normalization-form, omit-xml-declaration, standalone, undeclare-prefixes,
use-character-maps, and output-version may be used to override attributes
defined in the selected output definition.

With the exception of use-character-maps, these attributes are all defined as 
attribute value templates, so their values may be set dynamically. For any of
these attributes that is present on the xsl:result-document instruction, the 
effective value of the attribute overrides or supplements the corresponding
value from the output definition. This works in the same way as when one 
xsl:output declaration overrides another:

  * In the case of cdata-section-elements, the value of the serialization
    parameter is the union of the expanded names of the elements named in this
    instruction and the elements named in the selected output definition;
   
  * In the case of use-character-maps, the character maps referenced in this
    instruction supplement and take precedence over those defined in the
    selected output definition;
   
  * In all other cases, the effective value of an attribute actually present
    on this instruction takes precedence over the value defined in the
    selected output definition.
   
Note:

In the case of the attributes method, cdata-section-elements, and
use-character-maps, the effective value of the attribute contains one or more
lexical QNames. The prefix in such a QName is expanded using the in-scope
namespaces for the xsl:result-document element. In the case of
cdata-section-elements, an unprefixed element name is expanded using the
default namespace.

The output-version attribute on the xsl:result-document instruction overrides
the version attribute on xsl:output (it has been renamed because version is
available with a different meaning as a standard attribute: see 3.5 Standard
Attributes). In all other cases, attributes correspond if they have the same
name.

There are some serialization parameters that apply to some output methods but
not to others. For example, the indent attribute has no effect on the text
output method. If a value is supplied for an attribute that is inapplicable to
the output method, its value is not passed to the serializer. The processor 
may validate the value of such an attribute, but is not required to do so.

The href attribute is optional. The default value is the zero-length string.
The effective value of the attribute must be a URI Reference, which may be
absolute or relative. There may be implementation-defined restrictions on the
form of absolute URI that may be used, but the implementation is not required
to enforce any restrictions. Any legal relative URI must be accepted. Note
that the zero-length string is a legal relative URI.

The base URI of the document node at the root of the final result tree is
based on the effective value of the href attribute. If the effective value is
a relative URI, then it is resolved relative to the base output URI. If the
implementation provides an API to access final result trees, then it must
allow a final result tree to be identified by means of this base URI.

Note:

The base URI of the final result tree is not necessarily the same thing as the
URI of its serialized representation on disk, if any. For example, a server
(or browser client) might store final result trees only in memory, or in an
internal disk cache. As long as the processor satisfies requests for those
URIs, it is irrelevant where they are actually written on disk, if at all.

Note:

It will often be the case that one final result tree contains links to another
final result tree produced during the same transformation, in the form of a
relative URI. The mechanism of associating a URI with a final result tree has
been chosen to allow the integrity of such links to be preserved when the
trees are serialized.

As well as being potentially significant in any API that provides access to
final result trees, the base URI of the new document node is relevant if the
final result tree, rather than being serialized, is supplied as input to a
further transformation.

The optional attributes type and validation may be used on the 
xsl:result-document instruction to validate the contents of the new document,
and to determine the type annotation that elements and attributes within the 
final result tree will carry. The permitted values and their semantics are
described in 19.2.2 Validating Document Nodes.

A processor may allow a final result tree to be serialized. Serialization is
described in 20 Serialization. However, an implementation (for example, a 
processor running in an environment with no access to writable filestore) is
not required to support the serialization of final result trees. An
implementation that does not support the serialization of final result trees 
may ignore the format attribute and the serialization attributes. Such an
implementation must provide the application with some means of access to the
(un-serialized) result tree, using its URI to identify it.

Implementations may provide additional mechanisms, outside the scope of this
specification, for defining the way in which final result trees are processed.
Such mechanisms may make use of the XSLT-defined attributes on the 
xsl:result-document and/or xsl:output elements, or they may use additional
elements or attributes in an implementation-defined namespace.

Example: Multiple Result Documents

The following example takes an XHTML document as input, and breaks it up so
that the text following each <h1> element is included in a separate document.
A new document toc.html is constructed to act as an index:

<xsl:stylesheet
        version="2.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xhtml="http://www.w3.org/1999/xhtml">
        
<xsl:output name="toc-format" method="xhtml" indent="yes"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/>
            
<xsl:output name="section-format" method="xhtml" indent="no"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/>        
         
<xsl:template match="/">
  <xsl:result-document href="toc.html" format="toc-format" validation="strict">
    <html xmlns="http://www.w3.org/1999/xhtml">
      <head><title>Table of Contents</title></head>
      <body>
        <h1>Table of Contents</h1>
        <xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)">
          <p><a href="section{position()}.html"><xsl:value-of select="."/></a></p>
        </xsl:for-each>
      </body>
    </html>
  </xsl:result-document>
  <xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1">
    <xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip">         
      <html xmlns="http://www.w3.org/1999/xhtml">
        <head><title><xsl:value-of select="."/></title></head>
        <body>
          <xsl:copy-of select="current-group()"/>
        </body>
      </html>
    </xsl:result-document>
  </xsl:for-each-group>
</xsl:template>

</xsl:stylesheet>

There are restrictions on the use of the xsl:result-document instruction,
designed to ensure that the results are fully interoperable even when
processors optimize the sequence in which instructions are evaluated.
Informally, the restriction is that the xsl:result-document instruction can
only be used while writing a final result tree, not while writing to a
temporary tree or a sequence. This restriction is defined formally as follows.

[Definition: Each instruction in the stylesheet is evaluated in one of two
possible output states: final output state or temporary output state].

[Definition: The first of the two output states is called final output state.
This state applies when instructions are writing to a final result tree.]

[Definition: The second of the two output states is called temporary output
state. This state applies when instructions are writing to a temporary tree or
any other non-final destination.]

The instructions in the initial template are evaluated in final output state.
An instruction is evaluated in the same output state as its calling
instruction, except that xsl:variable, xsl:param, xsl:with-param, 
xsl:attribute, xsl:comment, xsl:processing-instruction, xsl:namespace, 
xsl:value-of, xsl:function, xsl:key, xsl:sort, and xsl:message always evaluate
the instructions in their contained sequence constructor in temporary output
state.

[ERR XTDE1480] It is a non-recoverable dynamic error to evaluate the 
xsl:result-document instruction in temporary output state.

[ERR XTDE1490] It is a non-recoverable dynamic error for a transformation to
generate two or more final result trees with the same URI.

Note:

Note, this means that it is an error to evaluate more than one 
xsl:result-document instruction that omits the href attribute, or to evaluate
any xsl:result-document instruction that omits the href attribute if an
initial final result tree is created implicitly.

Technically, the result of evaluating the xsl:result-document instruction is
an empty sequence. This means it does not contribute any nodes to the result
of the sequence constructor it is part of.

[ERR XTRE1495] It is a recoverable dynamic error for a transformation to
generate two or more final result trees with URIs that identify the same
physical resource. The optional recovery action is implementation-dependent,
since it may be impossible for the processor to detect the error.

[ERR XTRE1500] It is a recoverable dynamic error for a stylesheet to write to
an external resource and read from the same resource during a single
transformation, whether or not the same URI is used to access the resource in
both cases. The optional recovery action is implementation-dependent:
implementations are not required to detect the error condition. Note that if
the error is not detected, it is undefined whether the document that is read
from the resource reflects its state before or after the result tree is
written.

19.2 Validation

It is possible to control the type annotation applied to individual element
and attribute nodes as they are constructed. This is done using the type and
validation attributes of the xsl:element, xsl:attribute, xsl:copy, xsl:copy-of
, xsl:document, and xsl:result-document instructions, or the xsl:type and
xsl:validation attributes of a literal result element.

The [xsl:]type attribute is used to request validation of an element or
attribute against a specific simple or complex type defined in a schema. The
[xsl:]validation attribute is used to request validation against the global
element or attribute declaration whose name matches the name of the element or
attribute being validated.

The [xsl:]type and [xsl:]validation attributes are mutually exclusive. Both
are optional, but if one is present then the other must be omitted. If both
attributes are omitted, the effect is the same as specifying the validation
attribute with the value specified in the default-validation attribute of the
containing xsl:stylesheet element; if this is not specified, the effect is the
same as specifying validation="strip".

[ERR XTSE1505] It is a static error if both the [xsl:]type and [xsl:]
validation attributes are present on the xsl:element, xsl:attribute, xsl:copy,
xsl:copy-of, xsl:document, or xsl:result-document instructions, or on a 
literal result element.

The detailed rules for validation vary depending on the kind of node being
validated. The rules for element and attribute nodes are given in 19.2.1
Validating Constructed Elements and Attributes, while those for document nodes
are given in 19.2.2 Validating Document Nodes.

19.2.1 Validating Constructed Elements and Attributes

19.2.1.1 Validation using the [xsl:]validation Attribute

The [xsl:]validation attribute defines the validation action to be taken. It
determines not only the type annotation of the node that is constructed by the
relevant instruction itself, but also the type annotations of all element and
attribute nodes that have the constructed node as an ancestor. Conceptually,
the validation requested for a child element or attribute node is applied
before the validation requested for its parent element. For example, if the
instruction that constructs a child element specifies validation="strict",
this will cause the child element to be checked against an element
declaration, but if the instruction that constructs its parent element
specifies validation="strip", then the final effect will be that the child
node is annotated as xs:untyped.

In the paragraphs below, the term contained nodes means the elements and
attributes that have the newly constructed node as an ancestor.

  * The value strip indicates that the new node and each of the contained
    nodes will have the type annotation xs:untyped if it is an element, or 
    xs:untypedAtomic if it is an attribute. Any previous type annotation
    present on a contained element or attribute node (for example, a type
    annotation that is present on an element copied from a source document) is
    also replaced by xs:untyped or xs:untypedAtomic as appropriate. The typed
    value of the node is changed to be the same as its string value, as an
    instance of xs:untypedAtomic. In the case of elements the nilled property
    is set to false. The values of the is-id and is-idrefs properties are
    unchanged. Schema validation is not invoked.
   
  * The value preserve indicates that nodes that are copied will retain their 
    type annotations, but nodes whose content is newly constructed will be
    annotated as xs:anyType in the case of elements, or xs:untypedAtomic in
    the case of attributes. Schema validation is not invoked. The detailed
    effect depends on the instruction:
   
      + In the case of xsl:element and literal result elements, the new
        element has a type annotation of xs:anyType, and the type annotations
        of contained nodes are retained unchanged.
       
      + In the case of xsl:attribute, the effect is exactly the same as
        specifying validation="strip": that is, the new attribute will have
        the type annotation xs:untypedAtomic.
       
      + In the case of xsl:copy-of, all the nodes that are copied will retain
        their type annotations unchanged.
       
      + In the case of xsl:copy, the effect depends on the kind of node being
        copied.
       
         1. Where the node being copied is an attribute, the copied attribute
            will retain its type annotation.
           
         2. Where the node being copied is an element, the copied element will
            have a type annotation of xs:anyType (because this instruction
            does not copy the content of the element, it would be wrong to
            assume that the type is unchanged); but any contained nodes will
            have their type annotations retained in the same way as with 
            xsl:element.
           
  * The value strict indicates that type annotations are established by
    performing strict schema validity assessment on the element or attribute
    node created by this instruction as follows:
   
      + In the case of an element, a top-level element declaration is
        identified whose local name and namespace (if any) match the name of
        the element, and schema-validity assessment is carried out according
        to the rules defined in [XML Schema Part 1] (section 3.3.4 "Element
        Declaration Validation Rules", validation rule "Schema-Validity
        Assessment (Element)", clauses 1.1 and 2, using the top-level element
        declaration as the "declaration stipulated by the processor", which is
        mentioned in clause 1.1.1.1). The element is considered valid if the
        result of the schema validity assessment is a PSVI in which the
        relevant element node has a validity property whose value is valid. If
        there is no matching element declaration, or if the element is not
        considered valid, the transformation fails [see ERR XTTE1510], [see 
        ERR XTTE1512]. In effect this means that the element being validated 
        must be declared using a top-level declaration in the schema, and must
        conform to its declaration. The process of validation applies
        recursively to contained elements and attributes to the extent
        required by the schema definition.
       
        Note:
       
        It is not an error if the identified type definition is a simple type,
        although [XML Schema Part 1] does not define explicitly that this case
        is permitted.
       
      + In the case of an attribute, a top-level attribute declaration is
        identified whose local name and namespace (if any) match the name of
        the attribute, and schema-validity assessment is carried out according
        to the rules defined in [XML Schema Part 1] (section 3.2.4 "Attribute
        Declaration Validation Rules", validation rule "Schema-Validity
        Assessment (Attribute)"). The attribute is considered valid if the
        result of the schema validity assessment is a PSVI in which the
        relevant attribute node has a validity property whose value is valid.
        If the attribute is not considered valid, the transformation fails 
        [see ERR XTTE1510]. In effect this means that the attribute being
        validated must be declared using a top-level declaration in the
        schema, and must conform to its declaration.
       
      + The schema components used to validate an element or attribute may be
        located in any way described by [XML Schema Part 1] (see section
        4.3.2, How schema documents are located on the Web). The components in
        the schema constructed from the synthetic schema document (see 3.14
        Importing Schema Components) will always be available for validating
        constructed nodes; if additional schema components are needed, they 
        may be located in other ways, for example implicitly from knowledge of
        the namespace in which the elements and attributes appear, or using
        the xsi:schemaLocation attribute of elements within the tree being
        validated.
       
      + If no validation is performed for a node, which can happen when the
        schema specifies lax or skip validation for that node or for a
        subtree, then the node is annotated as xs:anyType in the case of an
        element, and xs:untypedAtomic in the case of an attribute.
       
  * The value lax has the same effect as the value strict, except that whereas
    strict validation fails if there is no matching top-level element
    declaration or if the outcome of validity assessment is a validity
    property of invalid or notKnown, lax validation fails only if the outcome
    of validity assessment is a validity property of invalid. That is, lax
    validation does not cause a type error when the outcome is notKnown.
   
    In practice this means that the element or attribute being validated must
    conform to its declaration if a top-level declaration is available. If no
    such declaration is available, then the element or attribute is not
    validated, but its attributes and children are validated, again with lax
    validation. Any nodes whose validation outcome is a validity property of
    notKnown are annotated as xs:anyType in the case of an element, and 
    xs:untypedAtomic in the case of an attribute.
   
    Note:
   
    When the parent element lacks a declaration, the XML Schema specification
    defines the recursive checking of children and attributes as optional. For
    this specification, this recursive checking is required.
   
    Note:
   
    If an element that is being validated has an xsi:type attribute, then the
    value of the xsi:type attribute will be taken into account when performing
    the validation. However, the presence of an xsi:type attribute will not of
    itself cause an element to be validated: if validation against a named
    type is required, as distinct from validation against a top-level element
    declaration, then it must be requested using the XSLT [xsl:]type attribute
    on the instruction that invokes the validation, as described in section 
    19.2.1.2 Validation using the [xsl:]type Attribute
   
[ERR XTTE1510] If the validation attribute of an xsl:element, xsl:attribute, 
xsl:copy, xsl:copy-of, or xsl:result-document instruction, or the
xsl:validation attribute of a literal result element, has the effective value
strict, and schema validity assessment concludes that the validity of the
element or attribute is invalid or unknown, a type error occurs. As with other
type errors, the error may be signaled statically if it can be detected
statically.

[ERR XTTE1512] If the validation attribute of an xsl:element, xsl:attribute, 
xsl:copy, xsl:copy-of, or xsl:result-document instruction, or the
xsl:validation attribute of a literal result element, has the effective value
strict, and there is no matching top-level declaration in the schema, then a
type error occurs. As with other type errors, the error may be signaled
statically if it can be detected statically.

[ERR XTTE1515] If the validation attribute of an xsl:element, xsl:attribute, 
xsl:copy, xsl:copy-of, or xsl:result-document instruction, or the
xsl:validation attribute of a literal result element, has the effective value
lax, and schema validity assessment concludes that the element or attribute is
invalid, a type error occurs. As with other type errors, the error may be
signaled statically if it can be detected statically.

Note:

No mechanism is provided to validate an element or attribute against a local
declaration in a schema. Such validation can usually be achieved by applying
validation to a containing element for which a top-level element declaration
exists.

19.2.1.2 Validation using the [xsl:]type Attribute

The [xsl:]type attribute takes as its value a QName. This must be the name of
a type definition included in the in-scope schema components for the
stylesheet. If the QName has no prefix, it is expanded using the default
namespace established using the effective [xsl:]xpath-default-namespace
attribute if there is one; otherwise, it is taken as being a name in no
namespace.

If the [xsl:]type attribute is present, then the newly constructed element or
attribute is validated against the type definition identified by this
attribute.

  * In the case of an element, schema-validity assessment is carried out
    according to the rules defined in [XML Schema Part 1] (section 3.3.4
    "Element Declaration Validation Rules", validation rule "Schema-Validity
    Assessment (Element)", clauses 1.2 and 2), using this type definition as
    the "processor-stipulated type definition". The element is considered
    valid if the result of the schema validity assessment is a PSVI in which
    the relevant element node has a validity property whose value is valid.
   
  * In the case of an attribute, the attribute is considered valid if (in the
    terminology of XML Schema) the attribute's normalized value is locally
    valid with respect to that type definition according to the rules for
    "String Valid" ([XML Schema Part 1], section 3.14.4). (Normalization here
    refers to the process of normalizing whitespace according to the rules of
    the whiteSpace facet for the data type).
   
  * If the element or attribute is not considered valid, as defined above, the
    transformation fails [see ERR XTTE1540].
   
[ERR XTSE1520] It is a static error if the value of the type attribute of an 
xsl:element, xsl:attribute, xsl:copy, xsl:copy-of, xsl:document, or 
xsl:result-document instruction, or the xsl:type attribute of a literal result
element, is not a valid QName, or if it uses a prefix that is not defined in
an in-scope namespace declaration, or if the QName is not the name of a type
definition included in the in-scope schema components for the stylesheet.

[ERR XTSE1530] It is a static error if the value of the type attribute of an 
xsl:attribute instruction refers to a complex type definition.

[ERR XTTE1540] It is a type error if an [xsl:]type attribute is defined for a
constructed element or attribute, and the outcome of schema validity
assessment against that type is that the validity property of that element or
attribute information item is other than valid.

Note:

Like other type errors, this error may be signaled statically if it can be
detected statically. For example, the instruction <xsl:attribute name="dob"
type="xs:date">1999-02-29</xsl:attribute> may result in a static error being
signaled. If the error is not signaled statically, it will be signaled when
the instruction is evaluated.

19.2.1.3 The Validation Process

As well as checking for validity against the schema, the validity assessment
process causes type annotations to be associated with element and attribute
nodes. If default values for elements or attributes are defined in the schema,
the validation process will where necessary create new nodes containing these
default values.

Validation of an element or attribute node only takes into account constraints
on the content of the element or attribute. Validation rules affecting the
document as a whole are not applied. Specifically, this means:

  * The validation rule "Validation Root Valid (ID/IDREF)" is not applied.
    This means that validation will not fail if there are non-unique ID values
    or dangling IDREF values in the subtree being validated.
   
  * The validation rule "Validation Rule: Identity-constraint Satisfied" is
    not applied.
   
  * There is no check that the document contains unparsed entities whose names
    match the values of nodes of type xs:ENTITY or xs:ENTITIES. (XSLT 2.0
    provides no facility to construct unparsed entities within a tree.)
   
  * There is no check that the document contains notations whose names match
    the values of nodes of type xs:NOTATION. (The XDM data model makes no
    provision for notations to be represented in the tree.)
   
With these caveats, validating a newly constructed element, using strict or
lax validation, is equivalent to the following steps:

 1. The element is serialized to textual XML form, according to the rules
    defined in [XSLT and XQuery Serialization] using the XML output method,
    with all parameters defaulted. Note that this process discards any
    existing type annotations.
   
 2. The resulting XML document is parsed to create an XML Information Set (see
    [XML Information Set].)
   
 3. The Information Set produced in the previous step is validated according
    to the rules in [XML Schema Part 1]. The result of this step is a
    Post-Schema Validation Infoset (PSVI). If the validation process is not
    successful (as defined above), a type error is raised.
   
 4. The PSVI produced in the previous step is converted back into the XDM data
    model by the mapping described in [Data Model] (Section 3.3.1 Mapping PSVI
    Additions to Node Properties^DM). This process creates nodes with simple
    or complex type annotations based on the types established during schema
    validation.
   
Validating an attribute using strict or lax validation requires a modified
version of this procedure. A copy of the attribute is first added to an
element node that is created for the purpose, and namespace fixup (see 5.7.3
Namespace Fixup) is performed on this element node. The name of this element
is of no consequence, but it must be the same as the name of a synthesized
element declaration of the form:

<xs:element name="E">
  <xs:complexType>
    <xs:sequence/>
    <xs:attribute ref="A"/>
  </xs:complexType>
</xs:element>

where A is the name of the attribute being validated.

This synthetic element is then validated using the procedure given above for
validating elements, and if it is found to be valid, a copy of the validated
attribute is made, retaining its type annotation, but detaching it from the
containing element (and thus, from any namespace nodes).

The XDM data model does not permit an attribute node with no parent to have a
typed value that includes a namespace-qualified name, that is, a value whose
type is derived from xs:QName or xs:NOTATION. This restriction is imposed
because these types rely on the namespace nodes of a containing element to
resolve namespace prefixes. Therefore, it is an error to validate a parentless
attribute against such a type. This affects the instructions xsl:attribute, 
xsl:copy, and xsl:copy-of.

[ERR XTTE1545] A type error occurs if a type or validation attribute is
defined (explicitly or implicitly) for an instruction that constructs a new
attribute node, if the effect of this is to cause the attribute value to be
validated against a type that is derived from, or constructed by list or union
from, the primitive types xs:QName or xs:NOTATION.

19.2.2 Validating Document Nodes

It is possible to apply validation to a document node. This happens when a new
document node is constructed by one of the instructions xsl:document, 
xsl:result-document, xsl:copy, or xsl:copy-of, and this instruction has a type
attribute, or a validation attribute with the value strict or lax.

Document-level validation is not applied to the document node that is created
implicitly when a variable-binding element has no select attribute and no as
attribute (see 9.4 Creating implicit document nodes). This is equivalent to
using validation="preserve" on xsl:document: nodes within such trees retain
their type annotation. Similarly, validation is not applied to document nodes
created using xsl:message.

The values validation="preserve" and validation="strip" do not request
validation. In the first case, all element and attribute nodes within the tree
rooted at the new document node retain their type annotations. In the second
case, elements within the tree have their type annotation set to xs:untyped,
while attributes have their type annotation set to xs:untypedAtomic.

When validation is requested for a document node (that is, when validation is
set to strict or lax, or when a type attribute is present), the following
processing takes place:

  * [ERR XTTE1550] A type error occurs unless the children of the document
    node comprise exactly one element node, no text nodes, and zero or more
    comment and processing instruction nodes, in any order.
   
  * The single element node child is validated, using the supplied values of
    the validation and type attributes, as described in 19.2.1 Validating
    Constructed Elements and Attributes.
   
    Note:
   
    The type attribute on xsl:document and xsl:result-document, and on 
    xsl:copy and xsl:copy-of when copying a document node, thus refers to the
    required type of the element node that is the only element child of the
    document node. It does not refer to the type of the document node itself.
   
  * The validation rule "Validation Root Valid (ID/IDREF)" is applied to the
    single element node child of the document node. This means that validation
    will fail if there are non-unique ID values or dangling IDREF values in
    the document tree.
   
  * Identity constraints, as defined in section 3.11 of [XML Schema Part 1],
    are checked. (This refers to constraints defined using xs:unique, xs:key,
    and xs:keyref.)
   
  * There is no check that the tree contains unparsed entities whose names
    match the values of nodes of type xs:ENTITY or xs:ENTITIES. This is
    because there is no facility in XSLT 2.0 to create unparsed entities in a 
    result tree. It is possible to add unparsed entity declarations to the
    result document by referencing a suitable DOCTYPE during serialization.
   
  * There is no check that the document contains notations whose names match
    the values of nodes of type xs:NOTATION. This is because notations are not
    part of the XDM data model. It is possible to add notations to the result
    document by referencing a suitable DOCTYPE during serialization.
   
  * All other children of the document node (comments and processing
    instructions) are copied unchanged.
   
[ERR XTTE1555] It is a type error if, when validating a document node,
document-level constraints are not satisfied. These constraints include
identity constraints (xs:unique, xs:key, and xs:keyref) and ID/IDREF
constraints.

20 Serialization

A processor may output a final result tree as a sequence of octets, although
it is not required to be able to do so (see 21 Conformance). Stylesheet
authors can use xsl:output declarations to specify how they wish result trees
to be serialized. If a processor serializes a final result tree, it must do so
as specified by these declarations.

The rules governing the output of the serializer are defined in [XSLT and
XQuery Serialization]. The serialization is controlled using a number of
serialization parameters. The values of these serialization parameters may be
set within the stylesheet, using the xsl:output, xsl:result-document, and 
xsl:character-map declarations.

<!-- Category: declaration -->
<xsl:output
  name? = qname
  method? = "xml" | "html" | "xhtml" | "text" | qname-but-not-ncname
  byte-order-mark? = "yes" | "no"
  cdata-section-elements? = qnames
  doctype-public? = string
  doctype-system? = string
  encoding? = string
  escape-uri-attributes? = "yes" | "no"
  include-content-type? = "yes" | "no"
  indent? = "yes" | "no"
  media-type? = string
  normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" |
"none" | nmtoken
  omit-xml-declaration? = "yes" | "no"
  standalone? = "yes" | "no" | "omit"
  undeclare-prefixes? = "yes" | "no"
  use-character-maps? = qnames
  version? = nmtoken />

The xsl:output declaration is optional; if used, it must always appear as a 
top-level element within a stylesheet module.

A stylesheet may contain multiple xsl:output declarations and may include or
import stylesheet modules that also contain xsl:output declarations. The name
of an xsl:output declaration is the value of its name attribute, if any.

[Definition: All the xsl:output declarations in a stylesheet that share the
same name are grouped into a named output definition; those that have no name
are grouped into a single unnamed output definition.]

A stylesheet always includes an unnamed output definition; in the absence of
an unnamed xsl:output declaration, the unnamed output definition is equivalent
to the one that would be used if the stylesheet contained an xsl:output
declaration having no attributes.

A named output definition is used when its name matches the format attribute
used in an xsl:result-document element. The unnamed output definition is used
when an xsl:result-document element omits the format attribute. It is also
used when serializing the final result tree that is created implicitly in the
absence of an xsl:result-document element.

All the xsl:output elements making up an output definition are effectively
merged. For those attributes whose values are namespace-sensitive, the merging
is done after lexical QNames have been converted into expanded QNames. For the
cdata-section-elements attribute, the output definition uses the union of the
values from all the constituent xsl:output declarations. For the
use-character-maps attribute, the output definition uses the concatenation of
the sequences of expanded QNames values from all the constituent xsl:output
declarations, taking them in order of increasing import precedence, or where
several have the same import precedence, in declaration order. For other
attributes, the output definition uses the value of that attribute from the 
xsl:output declaration with the highest import precedence.

[ERR XTSE1560] It is a static error if two xsl:output declarations within an 
output definition specify explicit values for the same attribute (other than
cdata-section-elements and use-character-maps), with the values of the
attributes being not equal, unless there is another xsl:output declaration
within the same output definition that has higher import precedence and that
specifies an explicit value for the same attribute.

If none of the xsl:output declarations within an output definition specifies a
value for a particular attribute, then the corresponding serialization
parameter takes a default value. The default value depends on the chosen
output method.

There are some serialization parameters that apply to some output methods but
not to others. For example, the indent attribute has no effect on the text
output method. If a value is supplied for an attribute that is inapplicable to
the output method, its value is not passed to the serializer. The processor 
may validate the value of such an attribute, but is not required to do so.

An implementation may allow the attributes of the xsl:output declaration to be
overridden, or the default values to be changed, using the API that controls
the transformation.

The location to which final result trees are serialized (whether in filestore
or elsewhere) is implementation-defined (which in practice may mean that it is
controlled using an implementation-defined API). However, these locations must
satisfy the constraint that when two final result trees are both created
(implicitly or explicitly) using relative URIs in the href attribute of the 
xsl:result-document instruction, then these relative URIs may be used to
construct references from one tree to the other, and such references must
remain valid when both result trees are serialized.

The method attribute on the xsl:output element identifies the overall method
that is to be used for outputting the final result tree.

[ERR XTSE1570] The value must (if present) be a valid QName. If the QName does
not have a prefix, then it identifies a method specified in [XSLT and XQuery
Serialization] and must be one of xml, html, xhtml, or text. If the QName has
a prefix, then the QName is expanded into an expanded-QName as described in 
5.1 Qualified Names; the expanded-QName identifies the output method; the
behavior in this case is not specified by this document.

The default for the method attribute depends on the contents of the tree being
serialized, and is chosen as follows. If the document node of the final result
tree has an element child, and any text nodes preceding the first element
child of the document node of the result tree contain only whitespace
characters, then:

  * If the expanded-QName of this first element child has local part html (in
    lower case), and namespace URI http://www.w3.org/1999/xhtml, then the
    default output method is normally xhtml. However, if the version attribute
    of the xsl:stylesheet element of the principal stylesheet module has the
    value 1.0, and if the result tree is generated implicitly (rather than by
    an explicit xsl:result-document instruction), then the default output
    method in this situation is xml.
   
  * If the expanded-QName of this first element child has local part html (in
    any combination of upper and lower case) and a null namespace URI, then
    the default output method is html.
   
In all other cases, the default output method is xml.

The default output method is used if the selected output definition does not
include a method attribute.

The other attributes on xsl:output provide parameters for the output method.
The following attributes are allowed:

  * The value of the encoding attribute provides the value of the encoding
    parameter to the serialization method. The default value is 
    implementation-defined, but in the case of the xml and xhtml methods it 
    must be either UTF-8 or UTF-16.
   
  * The byte-order-mark attribute defines whether a byte order mark is written
    at the start of the file. If the value yes is specified, a byte order mark
    is written; if no is specified, no byte order mark is written. The default
    value depends on the encoding used. If the encoding is UTF-16, the default
    is yes; for UTF-8 it is implementation-defined, and for all other
    encodings it is no. The value of the byte order mark indicates whether
    high order bytes are written before or after low order bytes; the actual
    byte order used is implementation-dependent , unless it is defined by the
    selected encoding.
   
  * The cdata-section-elements attribute is a whitespace-separated list of
    QNames. The default value is an empty list. After expansion of these names
    using the in-scope namespace declarations for the xsl:output declaration
    in which they appear, this list of names provides the value of the
    cdata-section-elements parameter to the serialization method. In the case
    of an unprefixed name, the default namespace (that is, the namespace
    declared using xmlns="uri") is used.
   
    Note:
   
    This differs from the rule for most other QNames used in a stylesheet. The
    reason is that these names refer to elements in the result document, and
    therefore follow the same convention as the name of a literal result
    element or the name attribute of xsl:element.
   
  * The value of the doctype-system attribute provides the value of the
    doctype-system parameter to the serialization method. By default, the
    parameter is not supplied.
   
  * The value of the doctype-public attribute provides the value of the
    doctype-public parameter to the serialization method. By default, the
    parameter is not supplied.
   
  * The value of the escape-uri-attributes attribute provides the value of the
    escape-uri-attributes parameter to the serialization method. The default
    value is yes.
   
  * The value of the include-content-type attribute provides the value of the
    include-content-type parameter to the serialization method. The default
    value is yes.
   
  * The value of the indent attribute provides the value of the indent
    parameter to the serialization method. The default value is yes in the
    case of the html and xhtml output methods, no in the case of the xml
    output method.
   
  * The value of the media-type attribute provides the value of the media-type
    parameter to the serialization method. The default value is text/xml in
    the case of the xml output method, text/html in the case of the html and
    xhtml output methods, and text/plain in the case of the text output
    method.
   
  * The value of the normalization-form attribute provides the value of the
    normalization-form parameter to the serialization method. A value that is
    an NMTOKEN other than one of those enumerated for the normalization-form
    attribute specifes an implementation-defined normalization form; the
    behavior in this case is not specified by this document. The default value
    is none.
   
  * The value of the omit-xml-declaration attribute provides the value of the
    omit-xml-declaration parameter to the serialization method. The default
    value is no.
   
  * The value of the standalone attribute provides the value of the standalone
    parameter to the serialization method. The default value is omit; this
    means that no standalone attribute is to be included in the XML
    declaration.
   
  * The undeclare-prefixes attribute is relevant only when producing output
    with method="xml" and version="1.1" (or later). It defines whether
    namespace undeclarations (of the form xmlns:foo="") should be output when
    a child element has no namespace node with the same name (that is,
    namespace prefix) as a namespace node of its parent element. The default
    value is no: this means that namespace undeclarations are not output,
    which has the effect that when the resulting XML is reparsed, the new tree
    may contain namespace nodes on the child element that were not there in
    the original tree before serialization.
   
  * The use-character-maps attribute provides a list of named character maps
    that are used in conjunction with this output definition. The way this
    attribute is used is described in 20.1 Character Maps. The default value
    is an empty list.
   
  * The value of the version attribute provides the value of the version
    parameter to the serialization method. The set of permitted values, and
    the default value, are implementation-defined. A serialization error will
    be reported if the requested version is not supported by the
    implementation.
   
If the processor performs serialization, then it must signal any
non-recoverable serialization errors that occur. These have the same effect as
non-recoverable dynamic errors: that is, the processor must signal the error
and must not finish as if the transformation had been successful.

20.1 Character Maps

[Definition: A character map allows a specific character appearing in a text
or attribute node in the final result tree to be substituted by a specified
string of characters during serialization.] The effect of character maps is
defined in [XSLT and XQuery Serialization].

The character map that is supplied as a parameter to the serializer is
determined from the xsl:character-map elements referenced from the xsl:output
declaration for the selected output definition.

The xsl:character-map element is a declaration that may appear as a child of
the xsl:stylesheet element.

<!-- Category: declaration -->
<xsl:character-map
  name = qname
  use-character-maps? = qnames>
  <!-- Content: (xsl:output-character*) -->
</xsl:character-map>

The xsl:character-map declaration declares a character map with a name and a
set of character mappings. The character mappings are specified by means of 
xsl:output-character elements contained either directly within the 
xsl:character-map element, or in further character maps referenced in the
use-character-maps attribute.

The required name attribute provides a name for the character map. When a
character map is used by an output definition or another character map, the
character map with the highest import precedence is used.

[ERR XTSE1580] It is a static error if the stylesheet contains two or more
character maps with the same name and the same import precedence, unless it
also contains another character map with the same name and higher import
precedence.

The optional use-character-maps attribute lists the names of further character
maps that are included into this character map.

[ERR XTSE1590] It is a static error if a name in the use-character-maps
attribute of the xsl:output or xsl:character-map elements does not match the
name attribute of any xsl:character-map in the stylesheet.

[ERR XTSE1600] It is a static error if a character map references itself,
directly or indirectly, via a name in the use-character-maps attribute.

It is not an error if the same character map is referenced more than once,
directly or indirectly.

An output definition, after recursive expansion of character maps referenced
via its use-character-maps attribute, may contain several mappings for the
same character. In this situation, the last character mapping takes
precedence. To establish the ordering, the following rules are used:

  * Within a single xsl:character-map element, the characters defined in
    character maps referenced in the use-character-maps attribute are
    considered before the characters defined in the child xsl:output-character
    elements.
   
  * The character maps referenced in a single use-character-maps attribute are
    considered in the order in which they are listed in that attribute. The
    expansion is depth-first: each referenced character map is fully expanded
    before the next one is considered.
   
  * Two xsl:output-character elements appearing as children of the same 
    xsl:character-map element are considered in document order.
   
The xsl:output-character element is defined as follows:

<xsl:output-character
  character = char
  string = string />

The character map that is passed as a parameter to the serializer contains a
mapping for the character specified in the character attribute to the string
specified in the string attribute.

Character mapping is not applied to characters for which output escaping has
been disabled as described in 20.2 Disabling Output Escaping.

If a character is mapped, then it is not subjected to XML or HTML escaping.

Example: Using Character Maps to Generate Non-XML Output

Character maps can be useful when producing serialized output in a format that
resembles, but is not strictly conformant to, HTML or XML. For example, when
the output is a JSP page, there might be a need to generate the output:

<jsp:setProperty name="user" property="id" value='<%= "id" + idValue %>'/>

Although this output is not well-formed XML or HTML, it is valid in Java
Server Pages. This can be achieved by allocating three Unicode characters
(which are not needed for any other purpose) to represent the strings <%, %>,
and ", for example:

<xsl:character-map name="jsp">
  <xsl:output-character character="«" string="&lt;%"/>   
  <xsl:output-character character="»" string="%&gt;"/>
  <xsl:output-character character="§" string='"'/>
</xsl:character-map>

When this character map is referenced in the xsl:output declaration, the
required output can be produced by writing the following in the stylesheet:

<jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/>

This works on the assumption that when an apostrophe or quotation mark is
generated as part of an attribute value by the use of character maps, the
serializer will (where possible) use the other choice of delimiter around the
attribute value.

Example: Constructing a Composite Character Map

The following example illustrates a composite character map constructed in a
modular fashion:

<xsl:output name="htmlDoc" use-character-maps="htmlDoc" />

<xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" />
  
<xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." />

<xsl:character-map name="latin1">
  <xsl:output-character character="&#160;" string="&amp;nbsp;" />
  <xsl:output-character character="&#161;" string="&amp;iexcl;" />
  ...
</xsl:character-map>

<xsl:character-map name="doc-entities">
  <xsl:output-character character="&#xE400;" string="&amp;t-and-c;" />
  <xsl:output-character character="&#xE401;" string="&amp;chap1;" />
  <xsl:output-character character="&#xE402;" string="&amp;chap2;" />
  ...
</xsl:character-map>

<xsl:character-map name="windows-format">
  <!-- newlines as CRLF -->
  <xsl:output-character character="&#xA;" string="&#xD;&#xA;" />

  <!-- tabs as three spaces -->
  <xsl:output-character character="&#x9;" string="   " />

  <!-- images for special characters -->
  <xsl:output-character character="&#xF001;"
    string="&lt;img src='special1.gif' /&gt;" />
  <xsl:output-character character="&#xF002;"
    string="&lt;img src='special2.gif' /&gt;" />
  ...
</xsl:character-map>

20.2 Disabling Output Escaping

Normally, when using the XML, HTML, or XHTML output method, the serializer
will escape special characters such as & and < when outputting text nodes.
This ensures that the output is well-formed. However, it is sometimes
convenient to be able to produce output that is almost, but not quite
well-formed XML; for example, the output may include ill-formed sections which
are intended to be transformed into well-formed XML by a subsequent
non-XML-aware process. For this reason, XSLT defines a mechanism for disabling
output escaping.

This feature is deprecated.

This is an optional feature: it is not required that a XSLT processor that
implements the serialization option should offer the ability to disable output
escaping, and there is no conformance level that requires this feature.

This feature requires an extension to the serializer described in [XSLT and
XQuery Serialization]. Conceptually, the final result tree provides an
additional boolean property disable-escaping associated with every character
in a text node. When this property is set, the normal action of the serializer
to escape special characters such as & and < is suppressed.

An xsl:value-of or xsl:text element may have a disable-output-escaping
attribute; the allowed values are yes or no. The default is no; if the value
is yes, then every character in the text node generated by evaluating the 
xsl:value-of or xsl:text element should have the disable-output property set.

Example: Disable Output Escaping

For example,

<xsl:text disable-output-escaping="yes">&lt;</xsl:text>

should generate the single character <.

If output escaping is disabled for an xsl:value-of or xsl:text instruction
evaluated when temporary output state is in effect, the request to disable
output escaping is ignored.

If output escaping is disabled for text within an element that would normally
be output using a CDATA section, because the element is listed in the
cdata-section-elements, then the relevant text will not be included in a CDATA
section. In effect, CDATA is treated as an alternative escaping mechanism,
which is disabled by the disable-output-escaping option.

Example: Interaction of Output Escaping and CDATA

For example, if <xsl:output cdata-section-elements="title"/> is specified,
then the following instructions:

<title>
  <xsl:text disable-output-escaping="yes">This is not &lt;hr/&gt; good coding practice</xsl:text>
</title>

should generate the output:

<title><![CDATA[This is not ]]><hr/><![CDATA[ good coding practice]]></title>

The disable-output-escaping attribute may be used with the html output method
as well as with the xml output method. The text output method ignores the
disable-output-escaping attribute, since it does not perform any output
escaping.

A processor will only be able to disable output escaping if it controls how
the final result tree is output. This might not always be the case. For
example, the result tree might be used as a source tree for another XSLT
transformation instead of being output. It is implementation-defined whether
(and under what circumstances) disabling output escaping is supported.

[ERR XTRE1620] It is a recoverable dynamic error if an xsl:value-of or 
xsl:text instruction specifies that output escaping is to be disabled and the
implementation does not support this. The optional recovery action is to
ignore the disable-output-escaping attribute.

[ERR XTRE1630] It is a recoverable dynamic error if an xsl:value-of or 
xsl:text instruction specifies that output escaping is to be disabled when
writing to a final result tree that is not being serialized. The optional
recovery action is to ignore the disable-output-escaping attribute.

If output escaping is disabled for a character that is not representable in
the encoding that the processor is using for output, the request to disable
output escaping is ignored in respect of that character.

Since disabling output escaping might not work with all implementations and
can result in XML that is not well-formed, it should be used only when there
is no alternative.

Note:

The facility to define character maps for use during serialization, as
described in 20.1 Character Maps, has been produced as an alternative
mechanism that can be used in many situations where disabling of output
escaping was previously necessary, without the same difficulties.

21 Conformance

A processor that claims conformance with this specification must claim
conformance either as a basic XSLT processor or as a schema-aware XSLT
processor. The rules for these two conformance levels are defined in the
following sections.

A processor that claims conformance at either of these two levels may
additionally claim conformance with either or both of the following optional
features: the serialization feature, defined in 21.3 Serialization Feature,
and the backwards compatibility feature, defined in 21.4 Backwards
Compatibility Feature.

Note:

There is no conformance level or feature defined in this specification that
requires implementation of the static typing features described in [XPath 2.0]
. An XSLT processor may provide a user option to invoke static typing, but to
be conformant with this specification it must allow a stylesheet to be
processed with static typing disabled. The interaction of XSLT stylesheets
with the static typing feature of XPath 2.0 has not been specified, so the
results of using static typing, if available, are implementation-defined.

An XSLT processor takes as its inputs a stylesheet and one or more XDM trees
conforming to the data model defined in [Data Model]. It is not required that
the processor supports any particular method of constructing XDM trees, but
conformance can only be tested if it provides a mechanism that enables XDM
trees representing the stylesheet and primary source document to be
constructed and supplied as input to the processor.

The output of the XSLT processor consists of zero or more final result trees.
It is not required that the processor supports any particular method of
accessing a final result tree, but if it does not support the serialization
module, conformance can only be tested if it provides some alternative
mechanism that enables access to the results of the transformation.

Certain facilities in this specification are described as producing 
implementation-defined results. A claim that asserts conformance with this
specification must be accompanied by documentation stating the effect of each
implementation-defined feature. For convenience, a non-normative checklist of
implementation-defined features is provided at F Checklist of
Implementation-Defined Features.

A conforming processor must signal any static error occurring in the
stylesheet, or in any XPath expression, except where specified otherwise
either for individual error conditions or under the general provisions for 
forwards compatible behavior (see 3.9 Forwards-Compatible Processing). After
signaling such an error, the processor may continue for the purpose of
signaling additional errors, but must terminate abnormally without performing
any transformation.

When a dynamic error occurs during the course of a transformation, the action
depends on whether the error is classified as a recoverable error. If a
non-recoverable error occurs, the processor must signal it and must eventually
terminate abnormally. If a recoverable error occurs, the processor must either
signal it and terminate abnormally, or it must take the defined recovery
action and continue processing.

Some errors, notably type errors, may be treated as static errors or dynamic
errors at the discretion of the processor.

A conforming processor may impose limits on the processing resources consumed
by the processing of a stylesheet.

21.1 Basic XSLT Processor

[Definition: A basic XSLT processor is an XSLT processor that implements all
the mandatory requirements of this specification with the exception of certain
explicitly-identified constructs related to schema processing.] These
constructs are listed below.

The mandatory requirements of this specification are taken to include the
mandatory requirements of XPath 2.0, as described in [XPath 2.0]. A
requirement is mandatory unless the specification includes wording (such as
the use of the words should or may) that clearly indicates that it is
optional.

A basic XSLT processor must enforce the following restrictions. It must signal
a static or dynamic error when the restriction is violated, as described
below.

[ERR XTSE1650] A basic XSLT processor must signal a static error if the 
stylesheet includes an xsl:import-schema declaration.

Note:

A processor that rejects an xsl:import-schema declaration will also reject any
reference to a user-defined type defined in a schema, or to a user-defined
element or attribute declaration; it will not, however, reject references to
the built-in types listed in 3.13 Built-in Types.

[ERR XTSE1660] A basic XSLT processor must signal a static error if the 
stylesheet includes an [xsl:]type attribute, or an [xsl:]validation or
default-validation attribute with a value other than strip.

A basic XSLT processor constrains the data model as follows:

  * Atomic values must belong to one of the atomic types listed in 3.13
    Built-in Types (except as noted below).
   
    An atomic value may also belong to an implementation-defined type that has
    been added to the context for use with extension functions or extension
    instructions.
   
    The set of constructor functions available are limited to those that
    construct values of the above atomic types.
   
    The static context, which defines the full set of type names recognized by
    an XSLT processor and also by the XPath processor, includes these atomic
    types, plus xs:anyType, xs:anySimpleType, xs:untyped, and xs:anyAtomicType
    .
   
  * Element nodes must be annotated with the type annotation xs:untyped, and
    attribute nodes with the type annotation xs:untypedAtomic.
   
[ERR XTDE1665] A basic XSLT processor must raise a non-recoverable dynamic
error if the input to the processor includes a node with a type annotation
other than xs:untyped or xs:untypedAtomic, or an atomic value of a type other
than those which a basic XSLT processor supports. This error will not arise if
the input-type-annotations attribute is set to strip.

Note:

Although this is expressed in terms of a requirement to detect invalid input,
an alternative approach is for a basic XSLT processor to prevent this error
condition occurring, by not providing any interfaces that would allow the
situation to arise. A processor might, for example, implement a mapping from
the PSVI to the data model that loses all non-trivial type annotations; or it
might not accept input from a PSVI at all.

The phrase input to the processor is deliberately wide: it includes the tree
containing the initial context node, trees passed as stylesheet parameters,
trees accessed using the document, doc^ FO, and collection^FO functions, and
trees returned by extension functions and extension instructions.

21.2 Schema-Aware XSLT Processor

[Definition: A schema-aware XSLT processor is an XSLT processor that
implements all the mandatory requirements of this specification, including
those features that a basic XSLT processor signals as an error. The mandatory
requirements of this specification are taken to include the mandatory
requirements of XPath 2.0, as described in [XPath 2.0]. A requirement is
mandatory unless the specification includes wording (such as the use of the
words should or may) that clearly indicates that it is optional.]

21.3 Serialization Feature

[Definition: A processor that claims conformance with the serialization
feature must support the conversion of a final result tree to a sequence of 
octets following the rules defined in 20 Serialization.] It must respect all
the attributes of the xsl:output and xsl:character-map declarations, and must
provide all four output methods, xml, xhtml, html, and text. Where the
specification uses words such as must and required, then it must serialize the
result tree in precisely the way described; in other cases it may use an
alternative, equivalent representation.

A processor may claim conformance with the serialization feature whether or
not it supports the setting disable-output-escaping="yes" on xsl:text, or 
xsl:value-of.

A processor that does not claim conformance with the serialization feature 
must not signal an error merely because the stylesheet contains xsl:output or 
xsl:character-map declarations, or serialization attributes on the 
xsl:result-document instruction. Such a processor may check that these
declarations and attributes have valid values, but is not required to do so.
Apart from optional validation, these declarations should be ignored.

21.4 Backwards Compatibility Feature

[Definition: A processor that claims conformance with the backwards
compatibility feature must support the processing of stylesheet instructions
and XPath expressions with backwards compatible behavior, as defined in 3.8
Backwards-Compatible Processing.]

Note that a processor that does not claim conformance with the backwards
compatibility feature must raise a non-recoverable dynamic error if an
instruction is evaluated containing an [xsl:]version attribute that invokes
backwards compatible behavior [see ERR XTDE0160].

Note:

The reason this is a dynamic error rather than a static error is to allow
stylesheets to contain conditional logic, following different paths depending
on whether the XSLT processor implements XSLT 1.0 or XSLT 2.0. The selection
of which path to use can be controlled by using the system-property function
to test the xsl:version system property.

A processor that claims conformance with the backwards compatibility feature 
must permit the use of the namespace axis in XPath expressions when backwards
compatible behavior is enabled. In all other circumstances, support for the
namespace axis is optional.

A References

A.1 Normative References

Data Model
    XQuery 1.0 and XPath 2.0 Data Model (XDM), Norman Walsh, Mary Fernández,
    Ashok Malhotra, et. al., Editors. World Wide Web Consortium, 23 Jan 2007.
    This version is http://www.w3.org/TR/2007/REC-xpath-datamodel-20070123/.
    The latest version is available at http://www.w3.org/TR/xpath-datamodel/.
Functions and Operators
    XQuery 1.0 and XPath 2.0 Functions and Operators, Ashok Malhotra, Jim
    Melton, and Norman Walsh, Editors. World Wide Web Consortium, 23 Jan 2007.
    This version is http://www.w3.org/TR/2007/REC-xpath-functions-20070123/.
    The latest version is available at http://www.w3.org/TR/xpath-functions/.
XML Information Set
    XML Information Set (Second Edition), John Cowan and Richard Tobin,
    Editors. World Wide Web Consortium, 04 Feb 2004. This version is 
    http://www.w3.org/TR/2004/REC-xml-infoset-20040204. The latest version is
    available at http://www.w3.org/TR/xml-infoset.
ISO 3166-1
    ISO (International Organization for Standardization) Codes for the
    representation of names of countries and their subdivisions - Part 1:
    Country codes ISO 3166-1:1997.
ISO 8601
    ISO (International Organization for Standardization) Data elements and
    interchange formats - Information interchange - Representation of dates
    and times. ISO 8601:2000(E), Second edition, 2000-12-15.
XSLT and XQuery Serialization
    XSLT 2.0 and XQuery 1.0 Serialization, Joanne Tong, Michael Kay, Norman
    Walsh, et. al., Editors. World Wide Web Consortium, 23 Jan 2007. This
    version is 
    http://www.w3.org/TR/2007/REC-xslt-xquery-serialization-20070123/. The 
    latest version is available at 
    http://www.w3.org/TR/xslt-xquery-serialization/.
XML 1.0
    Extensible Markup Language (XML) 1.0 (Fourth Edition), Eve Maler, Jean
    Paoli, François Yergeau, et. al., Editors. World Wide Web Consortium,
    16 Aug 2006. This version is http://www.w3.org/TR/2006/REC-xml-20060816.
    The latest version is available at http://www.w3.org/TR/xml.
XML 1.1
    Extensible Markup Language (XML) 1.1 (Second Edition), Tim Bray, John
    Cowan, Jean Paoli, et. al., Editors. World Wide Web Consortium,
    16 Aug 2006. This version is http://www.w3.org/TR/2006/REC-xml11-20060816.
    The latest version is available at http://www.w3.org/TR/xml11/.
XML Base
    XML Base, Jonathan Marsh, Editor. World Wide Web Consortium, 27 Jun 2001.
    This version is http://www.w3.org/TR/2001/REC-xmlbase-20010627/. The 
    latest version is available at http://www.w3.org/TR/xmlbase/.
xml:id
    xml:id Version 1.0, Norman Walsh, Daniel Veillard, and Jonathan Marsh,
    Editors. World Wide Web Consortium, 09 Sep 2005. This version is 
    http://www.w3.org/TR/2005/REC-xml-id-20050909/. The latest version is
    available at http://www.w3.org/TR/xml-id/.
Namespaces in XML 1.0
    Namespaces in XML, Andrew Layman, Dave Hollander, and Tim Bray, Editors.
    World Wide Web Consortium, 14 Jan 1999. This version is 
    http://www.w3.org/TR/1999/REC-xml-names-19990114. The latest version is
    available at http://www.w3.org/TR/REC-xml-names.
Namespaces in XML 1.1
    Namespaces in XML 1.1 (Second Edition), Tim Bray, Dave Hollander, Andrew
    Layman, and Richard Tobin, Editors. World Wide Web Consortium,
    16 Aug 2006. This version is 
    http://www.w3.org/TR/2006/REC-xml-names11-20060816. The latest version is
    available at http://www.w3.org/TR/xml-names11/.
XML Schema Part 1
    XML Schema Part 1: Structures Second Edition, Henry S. Thompson, David
    Beech, Noah Mendelsohn, and Murray Maloney, Editors. World Wide Web
    Consortium, 28 Oct 2004. This version is 
    http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The latest version is
    available at http://www.w3.org/TR/xmlschema-1/.
XML Schema Part 2
    XML Schema Part 2: Datatypes Second Edition, Paul V. Biron and Ashok
    Malhotra, Editors. World Wide Web Consortium, 28 Oct 2004. This version is
    http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The latest version is
    available at http://www.w3.org/TR/xmlschema-2/.
XPath 2.0
    XML Path Language (XPath) 2.0, Don Chamberlin , Anders Berglund, Scott
    Boag, et. al., Editors. World Wide Web Consortium, 23 Jan 2007. This
    version is http://www.w3.org/TR/2007/REC-xpath20-20070123/. The latest
    version is available at http://www.w3.org/TR/xpath20/.

A.2 Other References

Calendrical Calculations
    Edward M. Reingold and Nachum Dershowitz. Calendrical Calculations
    Millennium edition (2nd Edition). Cambridge University Press, ISBN 0 521
    77752 6
DOM Level 2
    Document Object Model (DOM) Level 2 Core Specification, Philippe Le
    Hégaret, Steve Byrne, Arnaud Le Hors, et. al., Editors. World Wide Web
    Consortium, 13 Nov 2000. This version is 
    http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113. The latest
    version is available at http://www.w3.org/TR/DOM-Level-2-Core/.
RFC2119
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. IETF
    RFC 2119. See http://www.ietf.org/rfc/rfc2119.txt.
RFC2376
    E. Whitehead, M. Murata. XML Media Types. IETF RFC 2376. See 
    http://www.ietf.org/rfc/rfc2376.txt.
RFC3023
    M. Murata, S. St.Laurent, and D. Cohn. XML Media Types. IETF RFC 3023. See
    http://www.ietf.org/rfc/rfc3023.txt. References to RFC 3023 should be
    taken to refer to any document that supersedes RFC 3023.
RFC3986
    T. Berners-Lee, R. Fielding, and L. Masinter. Uniform Resource Identifiers
    (URI): Generic Syntax. IETF RFC 3986. See 
    http://www.ietf.org/rfc/rfc3986.txt.
RFC3987
    M. Duerst, M. Suignard. Internationalized Resource Identifiers (IRIs).
    IETF RFC 3987. See http://www.ietf.org/rfc/rfc3987.txt.
UNICODE TR10
    Unicode Consortium. Unicode Technical Standard #10. Unicode Collation
    Algorithm. Unicode Technical Report. See 
    http://www.unicode.org/unicode/reports/tr10/.
XInclude
    XML Inclusions (XInclude) Version 1.0 (Second Edition), David Orchard,
    Jonathan Marsh, and Daniel Veillard, Editors. World Wide Web Consortium,
    15 Nov 2006. This version is 
    http://www.w3.org/TR/2006/REC-xinclude-20061115/. The latest version is
    available at http://www.w3.org/TR/xinclude/.
XLink
    XML Linking Language (XLink) Version 1.0, David Orchard, Eve Maler, and
    Steven DeRose, Editors. World Wide Web Consortium, 27 Jun 2001. This
    version is http://www.w3.org/TR/2001/REC-xlink-20010627/. The latest
    version is available at http://www.w3.org/TR/xlink/.
XML Schema 1.0 and XML 1.1
    World Wide Web Consortium. Processing XML 1.1 documents with XML Schema
    1.0 processors. W3C Working Group Note 11 May 2005. See 
    http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/
XML Stylesheet
    Associating Style Sheets with XML documents, James Clark, Editor. World
    Wide Web Consortium, 29 Jun 1999. This version is 
    http://www.w3.org/1999/06/REC-xml-stylesheet-19990629. The latest version
    is available at http://www.w3.org/TR/xml-stylesheet.
XPointer Framework
    XPointer Framework, Paul Grosso, Jonathan Marsh, Eve Maler, and Norman
    Walsh, Editors. World Wide Web Consortium, 25 Mar 2003. This version is 
    http://www.w3.org/TR/2003/REC-xptr-framework-20030325/. The latest version
    is available at http://www.w3.org/TR/xptr-framework/.
Extensible Stylesheet Language (XSL)
    Extensible Stylesheet Language (XSL) Version 1.1, Anders Berglund, Editor.
    World Wide Web Consortium, 05 Dec 2006. This version is 
    http://www.w3.org/TR/2006/REC-xsl11-20061205/. The latest version is
    available at http://www.w3.org/TR/xsl/.
XSLT 1.0
    XSL Transformations (XSLT) Version 1.0, James Clark, Editor. World Wide
    Web Consortium, 16 Nov 1999. This version is 
    http://www.w3.org/TR/1999/REC-xslt-19991116. The latest version is
    available at http://www.w3.org/TR/xslt.
XSLT 2.0 Requirements
    XSLT Requirements Version 2.0, Steve Muench and Mark Scardina, Editors.
    World Wide Web Consortium, 14 Feb 2001. This version is 
    http://www.w3.org/TR/2001/WD-xslt20req-20010214. The latest version is
    available at http://www.w3.org/TR/xslt20req.

B The XSLT Media Type

This appendix registers a new MIME media type, "application/xslt+xml".

This information is being submitted to the IESG (Internet Engineering Steering
Group) for review, approval, and registration with IANA (the Internet Assigned
Numbers Authority).

B.1 Registration of MIME Media Type application/xslt+xml

MIME media type name:
   
    application
   
MIME subtype name:
   
    xslt+xml
   
Required parameters:
   
    None.
   
Optional parameters:
   
    charset
       
        This parameter has identical semantics to the charset parameter of the
        application/xml media type as specified in [RFC3023].
       
Encoding considerations:
   
    By virtue of XSLT content being XML, it has the same considerations when
    sent as "application/xslt+xml" as does XML. See RFC 3023, section 3.2.
   
Security considerations:
   
    Several XSLT instructions may cause arbitrary URIs to be dereferenced. In
    this case, the security issues of [RFC3986], section 7, should be
    considered.
   
    In addition, because of the extensibility features for XSLT, it is
    possible that "application/xslt+xml" may describe content that has
    security implications beyond those described here. However, if the
    processor follows only the normative semantics of this specification, this
    content will be ignored. Only in the case where the processor recognizes
    and processes the additional content, or where further processing of that
    content is dispatched to other processors, would security issues
    potentially arise. And in that case, they would fall outside the domain of
    this registration document.
   
Interoperability considerations:
   
    This specification describes processing semantics that dictate behavior
    that must be followed when dealing with, among other things, unrecognized
    elements.
   
    Because XSLT is extensible, conformant "application/xslt+xml" processors
    can expect that content received is well-formed XML, but it cannot be
    guaranteed that the content is valid XSLT or that the processor will
    recognize all of the elements and attributes in the document.
   
Published specification:
   
    This media type registration is for XSLT stylesheet modules as described
    by the XSLT 2.0 specification, which is located at 
    http://www.w3.org/TR/xslt20/. It is also appropriate to use this media
    type with earlier and later versions of the XSLT language.
   
Applications which use this media type:
   
    Existing XSLT 1.0 stylesheets are most often described using the
    unregistered media type "text/xsl".
   
    There is no experimental, vendor specific, or personal tree predecessor to
    "application/xslt+xml", reflecting the fact that no applications currently
    recognize it. This new type is being registered in order to allow for the
    expected deployment of XSLT 2.0 on the World Wide Web, as a first class
    XML application.
   
Additional information:
   
    Magic number(s):
       
        There is no single initial octet sequence that is always present in
        XSLT documents.
       
    File extension(s):
       
        XSLT documents are most often identified with the extensions ".xsl" or
        ".xslt".
       
    Macintosh File Type Code(s):
       
        TEXT
       
Person & email address to contact for further information:
   
    Norman Walsh, <Norman.Walsh@Sun.COM>.
   
Intended usage:
   
    COMMON
   
Author/Change controller:
   
    The XSLT specification is a work product of the World Wide Web
    Consortium's XSL Working Group. The W3C has change control over these
    specifications.
   
B.2 Fragment Identifiers

For documents labeled as "application/xslt+xml", the fragment identifier
notation is exactly that for "application/xml", as specified in RFC 3023.

C Glossary (Non-Normative)

QName
   
    A QName is always written in the form (NCName ":")? NCName, that is, a
    local name optionally preceded by a namespace prefix. When two QNames are
    compared, however, they are considered equal if the corresponding 
    expanded-QNames are the same, as described below.
   
URI Reference
   
    Within this specification, the term URI Reference, unless otherwise
    stated, refers to a string in the lexical space of the xs:anyURI data type
    as defined in [XML Schema Part 2].
   
XML namespace
   
    The XML namespace, defined in [Namespaces in XML 1.0] as 
    http://www.w3.org/XML/1998/namespace, is used for attributes such as
    xml:lang, xml:space, and xml:id.
   
XPath 1.0 compatibility mode
   
    The term XPath 1.0 compatibility mode is defined in Section 2.1.1 Static
    Context^XP. This is a setting in the static context of an XPath
    expression; it has two values, true and false. When the value is set to
    true, the semantics of function calls and certain other operations are
    adjusted to give a greater degree of backwards compatibility between XPath
    2.0 and XPath 1.0.
   
XSLT element
   
    An XSLT element is an element in the XSLT namespace whose syntax and
    semantics are defined in this specification.
   
XSLT instruction
   
    An XSLT instruction is an XSLT element whose syntax summary in this
    specification contains the annotation <!-- category: instruction -->.
   
XSLT namespace
   
    The XSLT namespace has the URI http://www.w3.org/1999/XSL/Transform. It is
    used to identify elements, attributes, and other names that have a special
    meaning defined in this specification.
   
alias
   
    A stylesheet can use the xsl:namespace-alias element to declare that a 
    literal namespace URI is being used as an alias for a target namespace URI
    .
   
arity
   
    The arity of a stylesheet function is the number of xsl:param elements in
    the function definition.
   
atomize
   
    The term atomization is defined in Section 2.4.2 Atomization^XP. It is a
    process that takes as input a sequence of nodes and atomic values, and
    returns a sequence of atomic values, in which the nodes are replaced by
    their typed values as defined in [Data Model].
   
attribute set
   
    The xsl:attribute-set element defines a named attribute set: that is, a
    collection of attribute definitions that can be used repeatedly on
    different constructed elements.
   
attribute value template
   
    In an attribute that is designated as an attribute value template, such as
    an attribute of a literal result element, an expression can be used by
    surrounding the expression with curly brackets ({})
   
backwards compatibility feature
   
    A processor that claims conformance with the backwards compatibility
    feature must support the processing of stylesheet instructions and XPath
    expressions with backwards compatible behavior, as defined in 3.8
    Backwards-Compatible Processing.
   
backwards compatible behavior
   
    An element enables backwards-compatible behavior for itself, its
    attributes, its descendants and their attributes if it has an [xsl:]
    version attribute (see 3.5 Standard Attributes) whose value is less than
    2.0.
   
base output URI
   
    The base output URI is a URI to be used as the base URI when resolving a
    relative URI allocated to a final result tree. If the transformation
    generates more than one final result tree, then typically each one will be
    allocated a URI relative to this base URI.
   
basic XSLT processor
   
    A basic XSLT processor is an XSLT processor that implements all the
    mandatory requirements of this specification with the exception of certain
    explicitly-identified constructs related to schema processing.
   
character map
   
    A character map allows a specific character appearing in a text or
    attribute node in the final result tree to be substituted by a specified
    string of characters during serialization.
   
circularity
   
    A circularity is said to exist if a construct such as a global variable,
    an attribute set, or a key is defined in terms of itself. For example, if
    the expression or sequence constructor specifying the value of a global
    variable X references a global variable Y, then the value for Y must be
    computed before the value of X. A circularity exists if it is impossible
    to do this for all global variable definitions.
   
collation
   
    Facilities in XSLT 2.0 and XPath 2.0 that require strings to be ordered
    rely on the concept of a named collation. A collation is a set of rules
    that determine whether two strings are equal, and if not, which of them is
    to be sorted before the other.
   
context item
   
    The context item is the item currently being processed. An item (see [Data
    Model]) is either an atomic value (such as an integer, date, or string),
    or a node. The context item is initially set to the initial context node
    supplied when the transformation is invoked (see 2.3 Initiating a
    Transformation). It changes whenever instructions such as 
    xsl:apply-templates and xsl:for-each are used to process a sequence of
    items; each item in such a sequence becomes the context item while that
    item is being processed.
   
context node
   
    If the context item is a node (as distinct from an atomic value such as an
    integer), then it is also referred to as the context node. The context
    node is not an independent variable, it changes whenever the context item
    changes. When the context item is an atomic value, there is no context
    node.
   
context position
   
    The context position is the position of the context item within the
    sequence of items currently being processed. It changes whenever the
    context item changes. When an instruction such as xsl:apply-templates or 
    xsl:for-each is used to process a sequence of items, the first item in the
    sequence is processed with a context position of 1, the second item with a
    context position of 2, and so on.
   
context size
   
    The context size is the number of items in the sequence of items currently
    being processed. It changes whenever instructions such as 
    xsl:apply-templates and xsl:for-each are used to process a sequence of
    items; during the processing of each one of those items, the context size
    is set to the count of the number of items in the sequence (or
    equivalently, the position of the last item in the sequence).
   
core function
   
    The term core function means a function that is specified in [Functions
    and Operators] and that is in the standard function namespace.
   
current captured substrings
   
    While the xsl:matching-substring instruction is active, a set of current
    captured substrings is available, corresponding to the parenthesized
    sub-expressions of the regular expression.
   
current group
   
    The evaluation context for XPath expressions includes a component called
    the current group, which is a sequence. The current group is the
    collection of related items that are processed collectively in one
    iteration of the xsl:for-each-group element.
   
current grouping key
   
    The evaluation context for XPath expressions includes a component called
    the current grouping key, which is an atomic value. The current grouping
    key is the grouping key shared in common by all the items within the 
    current group.
   
current mode
   
    At any point in the processing of a stylesheet, there is a current mode.
    When the transformation is initiated, the current mode is the default mode
    , unless a different initial mode has been supplied, as described in 2.3
    Initiating a Transformation. Whenever an xsl:apply-templates instruction
    is evaluated, the current mode becomes the mode selected by this
    instruction.
   
current template rule
   
    At any point in the processing of a stylesheet, there may be a current
    template rule. Whenever a template rule is chosen as a result of
    evaluating xsl:apply-templates, xsl:apply-imports, or xsl:next-match, the
    template rule becomes the current template rule for the evaluation of the
    rule's sequence constructor. When an xsl:for-each, xsl:for-each-group, or 
    xsl:analyze-string instruction is evaluated, or when evaluating a sequence
    constructor contained in an xsl:sort or xsl:key element, or when a 
    stylesheet function is called (see 10.3 Stylesheet Functions), the current
    template rule becomes null for the evaluation of that instruction or
    function.
   
date formatting function
   
    The three functions format-date, format-time, and format-dateTime are
    referred to collectively as the date formatting functions.
   
decimal format
   
    All the xsl:decimal-format declarations in a stylesheet that share the
    same name are grouped into a named decimal format; those that have no name
    are grouped into a single unnamed decimal format.
   
declaration
   
    Top-level elements fall into two categories: declarations, and
    user-defined data elements. Top-level elements whose names are in the XSLT
    namespace are declarations. Top-level elements in any other namespace are 
    user-defined data elements (see 3.6.2 User-defined Data Elements)
   
declaration order
   
    The declarations within a stylesheet level have a total ordering known as 
    declaration order. The order of declarations within a stylesheet level is
    the same as the document order that would result if each stylesheet module
    were inserted textually in place of the xsl:include element that
    references it.
   
default collation
   
    In this specification the term default collation means the collation that
    is used by XPath operators such as eq and lt appearing in XPath
    expressions within the stylesheet.
   
default mode
   
    There is always a default mode available. The default mode is an unnamed 
    mode, and it is used when no mode attribute is specified on an 
    xsl:apply-templates instruction.
   
default priority
   
    If no priority attribute is specified on the xsl:template element, a 
    default priority is computed, based on the syntax of the pattern supplied
    in the match attribute.
   
defining element
   
    A string in the form of a lexical QName may occur as the value of an
    attribute node in a stylesheet module, or within an XPath expression
    contained in such an attribute node, or as the result of evaluating an
    XPath expression contained in such an attribute node. The element
    containing this attribute node is referred to as the defining element of
    the QName.
   
deprecated
   
    Some constructs defined in this specification are described as being 
    deprecated. The use of this term implies that stylesheet authors should
    not use the construct, and that the construct may be removed in a later
    version of this specification.
   
dynamic error
   
    An error that is not detected until a source document is being transformed
    is referred to as a dynamic error.
   
effective value
   
    The result of evaluating an attribute value template is referred to as the
    effective value of the attribute.
   
embedded stylesheet module
   
    An embedded stylesheet module is a stylesheet module that is embedded
    within another XML document, typically the source document that is being
    transformed.
   
expanded-QName
   
    An expanded-QName contains a pair of values, namely a local name and an
    optional namespace URI. It may also contain a namespace prefix. Two
    expanded-QNames are equal if the namespace URIs are the same (or both
    absent) and the local names are the same. The prefix plays no part in the
    comparison, but is used only if the expanded-QName needs to be converted
    back to a string.
   
expression
   
    Within this specification, the term XPath expression, or simply expression
    , means a string that matches the production Expr^ XP defined in [XPath
    2.0].
   
extension attribute
   
    An element from the XSLT namespace may have any attribute not from the
    XSLT namespace, provided that the expanded-QName (see [XPath 2.0]) of the
    attribute has a non-null namespace URI. These attributes are referred to
    as extension attributes.
   
extension function
   
    An extension function is a function that is available for use within an
    XPath expression, other than a core function defined in [Functions and
    Operators], an additional function defined in this XSLT specification, a
    constructor function named after an atomic type, or a stylesheet function
    defined using an xsl:function declaration.
   
extension instruction
   
    An extension instruction is an element within a sequence constructor that
    is in a namespace (not the XSLT namespace) designated as an extension
    namespace.
   
extension namespace
   
    The extension instruction mechanism allows namespaces to be designated as 
    extension namespaces. When a namespace is designated as an extension
    namespace and an element with a name from that namespace occurs in a 
    sequence constructor, then the element is treated as an instruction rather
    than as a literal result element.
   
final output state
   
    The first of the two output states is called final output state. This
    state applies when instructions are writing to a final result tree.
   
final result tree
   
    A final result tree is a result tree that forms part of the final output
    of a transformation. Once created, the contents of a final result tree are
    not accessible within the stylesheet itself.
   
focus
   
    When a sequence constructor is evaluated, the processor keeps track of
    which items are being processed by means of a set of implicit variables
    referred to collectively as the focus.
   
forwards-compatible behavior
   
    An element enables forwards-compatible behavior for itself, its
    attributes, its descendants and their attributes if it has an [xsl:]
    version attribute (see 3.5 Standard Attributes) whose value is greater
    than 2.0.
   
function conversion rules
   
    Except where otherwise indicated, the actual value of an expression is
    converted to the required type using the function conversion rules. These
    are the rules defined in [XPath 2.0] for converting the supplied argument
    of a function call to the required type of that argument, as defined in
    the function signature. The relevant rules are those that apply when XPath
    1.0 compatibility mode is set to false.
   
function parameter
   
    An xsl:param element may appear as a child of an xsl:function element,
    before any non-xsl:param children of that element. Such a parameter is
    known as a function parameter. A function parameter is a local variable
    with the additional property that its value can be set when the function
    is called, using a function call in an XPath expression.
   
global variable
   
    A top-level variable-binding element declares a global variable that is
    visible everywhere (except where it is shadowed by another binding).
   
group
   
    The xsl:for-each-group instruction allocates the items in an input
    sequence into groups of items (that is, it establishes a collection of
    sequences) based either on common values of a grouping key, or on a 
    pattern that the initial or final node in a group must match.
   
grouping key
   
    If either of the group-by attribute or group-adjacent attributes is
    present, then grouping keys are calculated for each item in the population
    . The grouping keys are the items in the sequence obtained by evaluating
    the expression contained in the group-by attribute or group-adjacent
    attribute, atomizing the result, and then casting an xs:untypedAtomic
    value to xs:string.
   
implementation
   
    A specific product that performs the functions of an XSLT processor is
    referred to as an implementation
   
implementation-defined
   
    In this specification, the term implementation-defined refers to a feature
    where the implementation is allowed some flexibility, and where the
    choices made by the implementation must be described in documentation that
    accompanies any conformance claim.
   
implementation-dependent
   
    The term implementation-dependent refers to a feature where the behavior 
    may vary from one implementation to another, and where the vendor is not
    expected to provide a full specification of the behavior.
   
import precedence
   
    A declaration D in the stylesheet is defined to have lower import
    precedence than another declaration E if the stylesheet level containing D
    would be visited before the stylesheet level containing E in a post-order
    traversal of the import tree (that is, a traversal of the import tree in
    which a stylesheet level is visited after its children). Two declarations
    within the same stylesheet level have the same import precedence.
   
import tree
   
    The stylesheet levels making up a stylesheet are treated as forming an 
    import tree. In the import tree, each stylesheet level has one child for
    each xsl:import declaration that it contains.
   
in-scope schema component
   
    The schema components that may be referenced by name in a stylesheet are
    referred to as the in-scope schema components. This set is the same
    throughout all the modules of a stylesheet.
   
initial context node
   
    A node that acts as the initial context node for the transformation. This
    node is accessible within the stylesheet as the initial value of the XPath
    expressions . (dot) and self::node(), as described in 5.4.3.1 Maintaining
    Position: the Focus
   
initial item
   
    For each group, the item within the group that is first in population
    order is known as the initial item of the group.
   
initial sequence
   
    The sequence to be sorted is referred to as the initial sequence.
   
initial template
   
    The transformation is performed by evaluating an initial template. If a 
    named template is supplied when the transformation is initiated, then this
    is the initial template; otherwise, the initial template is the template
    rule selected according to the rules of the xsl:apply-templates
    instruction for processing the initial context node in the initial mode.
   
instruction
   
    An instruction is either an XSLT instruction or an extension instruction.
   
key
   
    A key is defined as a set of xsl:key declarations in the stylesheet that
    share the same name.
   
key specifier
   
    The expression in the use attribute and the sequence constructor within an
    xsl:key declaration are referred to collectively as the key specifier. The
    key specifier determines the values that may be used to find a node using
    this key.
   
lexical QName
   
    A lexical QName is a string representing a QName in the form (NCName ":")?
    NCName, that is, a local name optionally preceded by a namespace prefix.
   
literal namespace URI
   
    A namespace URI in the stylesheet tree that is being used to specify a
    namespace URI in the result tree is called a literal namespace URI.
   
literal result element
   
    In a sequence constructor, an element in the stylesheet that does not
    belong to the XSLT namespace and that is not an extension instruction (see
    18.2 Extension Instructions) is classified as a literal result element.
   
local variable
   
    As well as being allowed as declaration elements, the xsl:variable element
    is also allowed in sequence constructors. Such a variable is known as a 
    local variable.
   
mode
   
    Modes allow a node in a source tree to be processed multiple times, each
    time producing a different result. They also allow different sets of 
    template rules to be active when processing different trees, for example
    when processing documents loaded using the document function (see 16.1
    Multiple Source Documents) or when processing temporary trees.
   
named template
   
    Templates can be invoked by name. An xsl:template element with a name
    attribute defines a named template.
   
namespace fixup
   
    The rules for the individual XSLT instructions that construct a result
    tree (see 11 Creating Nodes and Sequences) prescribe some of the
    situations in which namespace nodes are written to the tree. These rules,
    however, are not sufficient to ensure that the prescribed constraints are
    always satisfied. The XSLT processor must therefore add additional
    namespace nodes to satisfy these constraints. This process is referred to
    as namespace fixup.
   
non-recoverable dynamic error
   
    A dynamic error that is not recoverable is referred to as a 
    non-recoverable dynamic error. When a non-recoverable dynamic error
    occurs, the processor must signal the error, and the transformation fails.
   
optional recovery action
   
    If an implementation chooses to recover from a recoverable dynamic error,
    it must take the optional recovery action defined for that error condition
    in this specification.
   
order of first appearance
   
    There is an ordering among groups referred to as the order of first
    appearance. A group G is defined to precede a group H in order of first
    appearance if the initial item of G precedes the initial item of H in
    population order. If two groups G and H have the same initial item
    (because the item is in both groups) then G precedes H if the grouping key
    of G precedes the grouping key of H in the sequence that results from
    evaluating the group-by expression of this initial item.
   
output definition
   
    All the xsl:output declarations in a stylesheet that share the same name
    are grouped into a named output definition; those that have no name are
    grouped into a single unnamed output definition.
   
output state
   
    Each instruction in the stylesheet is evaluated in one of two possible 
    output states: final output state or temporary output state
   
parameter
   
    The xsl:param element declares a parameter, which may be a stylesheet
    parameter, a template parameter, or a function parameter. A parameter is a
    variable with the additional property that its value can be set by the
    caller when the stylesheet, the template, or the function is invoked.
   
pattern
   
    A pattern specifies a set of conditions on a node. A node that satisfies
    the conditions matches the pattern; a node that does not satisfy the
    conditions does not match the pattern. The syntax for patterns is a subset
    of the syntax for expressions.
   
picture string
   
    The formatting of a number is controlled by a picture string. The picture
    string is a sequence of characters, in which the characters assigned to
    the variables decimal-separator-sign, grouping-sign, zero-digit-sign,
    digit-sign and pattern-separator-sign are classified as active characters,
    and all other characters (including the percent-sign and per-mille-sign)
    are classified as passive characters.
   
place marker
   
    The xsl:number instruction performs two tasks: firstly, determining a 
    place marker (this is a sequence of integers, to allow for hierarchic
    numbering schemes such as 1.12.2 or 3(c)ii), and secondly, formatting the
    place marker for output as a text node in the result sequence.
   
population
   
    The sequence of items to be grouped, which is referred to as the 
    population, is determined by evaluating the XPath expression contained in
    the select attribute.
   
population order
   
    The population is treated as a sequence; the order of items in this
    sequence is referred to as population order
   
principal stylesheet module
   
    A stylesheet may consist of several stylesheet modules, contained in
    different XML documents. For a given transformation, one of these
    functions as the principal stylesheet module. The complete stylesheet is
    assembled by finding the stylesheet modules referenced directly or
    indirectly from the principal stylesheet module using xsl:include and 
    xsl:import elements: see 3.10.2 Stylesheet Inclusion and 3.10.3 Stylesheet
    Import.
   
processing order
   
    There is another ordering among groups referred to as processing order. If
    group R precedes group S in processing order, then in the result sequence
    returned by the xsl:for-each-group instruction the items generated by
    processing group R will precede the items generated by processing group S.
   
processor
   
    The software responsible for transforming source trees into result trees
    using an XSLT stylesheet is referred to as the processor. This is
    sometimes expanded to XSLT processor to avoid any confusion with other
    processors, for example an XML processor.
   
recoverable error
   
    Some dynamic errors are classed as recoverable errors. When a recoverable
    error occurs, this specification allows the processor either to signal the
    error (by reporting the error condition and terminating execution) or to
    take a defined recovery action and continue processing.
   
required type
   
    The context within a stylesheet where an XPath expression appears may
    specify the required type of the expression. The required type indicates
    the type of the value that the expression is expected to return.
   
reserved namespace
   
    The XSLT namespace, together with certain other namespaces recognized by
    an XSLT processor, are classified as reserved namespaces and must be used
    only as specified in this and related specifications.
   
result tree
   
    The term result tree is used to refer to any tree constructed by 
    instructions in the stylesheet. A result tree is either a final result
    tree or a temporary tree.
   
schema component
   
    Type definitions and element and attribute declarations are referred to
    collectively as schema components.
   
schema instance namespace
   
    The schema instance namespace http://www.w3.org/2001/XMLSchema-instance is
    used as defined in [XML Schema Part 1]
   
schema namespace
   
    The schema namespace http://www.w3.org/2001/XMLSchema is used as defined
    in [XML Schema Part 1]
   
schema-aware XSLT processor
   
    A schema-aware XSLT processor is an XSLT processor that implements all the
    mandatory requirements of this specification, including those features
    that a basic XSLT processor signals as an error. The mandatory
    requirements of this specification are taken to include the mandatory
    requirements of XPath 2.0, as described in [XPath 2.0]. A requirement is
    mandatory unless the specification includes wording (such as the use of
    the words should or may) that clearly indicates that it is optional.
   
sequence constructor
   
    A sequence constructor is a sequence of zero or more sibling nodes in the 
    stylesheet that can be evaluated to return a sequence of nodes and atomic
    values. The way that the resulting sequence is used depends on the
    containing instruction.
   
serialization
   
    A frequent requirement is to output a final result tree as an XML document
    (or in other formats such as HTML). This process is referred to as 
    serialization.
   
serialization error
   
    If a transformation has successfully produced a final result tree, it is
    still possible that errors may occur in serializing the result tree. For
    example, it may be impossible to serialize the result tree using the
    encoding selected by the user. Such an error is referred to as a 
    serialization error.
   
serialization feature
   
    A processor that claims conformance with the serialization feature must
    support the conversion of a final result tree to a sequence of octets
    following the rules defined in 20 Serialization.
   
shadows
   
    A binding shadows another binding if the binding occurs at a point where
    the other binding is visible, and the bindings have the same name.
   
simplified stylesheet module
   
    A simplified stylesheet module is a tree, or part of a tree, consisting of
    a literal result element together with its descendant nodes and associated
    attributes and namespaces. This element is not itself in the XSLT
    namespace, but it must have an xsl:version attribute, which implies that
    it must have a namespace node that declares a binding for the XSLT
    namespace. For further details see 3.7 Simplified Stylesheet Modules.
   
singleton focus
   
    A singleton focus based on a node N has the context item (and therefore
    the context node) set to N, and the context position and context size both
    set to 1 (one).
   
sort key component
   
    Within a sort key specification, each xsl:sort element defines one sort
    key component.
   
sort key specification
   
    A sort key specification is a sequence of one or more adjacent xsl:sort
    elements which together define rules for sorting the items in an input
    sequence to form a sorted sequence.
   
sort key value
   
    For each item in the initial sequence, a value is computed for each sort
    key component within the sort key specification. The value computed for an
    item by using the Nth sort key component is referred to as the Nth sort
    key value of that item.
   
sorted sequence
   
    The sequence after sorting as defined by the xsl:sort elements is referred
    to as the sorted sequence.
   
source tree
   
    The term source tree means any tree provided as input to the
    transformation. This includes the document containing the initial context
    node if any, documents containing nodes supplied as the values of 
    stylesheet parameters, documents obtained from the results of functions
    such as document, doc^ FO, and collection^FO, and documents returned by
    extension functions or extension instructions. In the context of a
    particular XSLT instruction, the term source tree means any tree provided
    as input to that instruction; this may be a source tree of the
    transformation as a whole, or it may be a temporary tree produced during
    the course of the transformation.
   
stable
   
    A sort key specification is said to be stable if its first xsl:sort
    element has no stable attribute, or has a stable attribute whose effective
    value is yes.
   
standalone stylesheet module
   
    A standalone stylesheet module is a stylesheet module that comprises the
    whole of an XML document.
   
standard attributes
   
    There are a number of standard attributes that may appear on any XSLT
    element: specifically version, exclude-result-prefixes,
    extension-element-prefixes, xpath-default-namespace, default-collation,
    and use-when.
   
standard function namespace
   
    The standard function namespace http://www.w3.org/2005/xpath-functions is
    used for functions in the function library defined in [Functions and
    Operators] and standard functions defined in this specification.
   
standard stylesheet module
   
    A standard stylesheet module is a tree, or part of a tree, consisting of
    an xsl:stylesheet or xsl:transform element (see 3.6 Stylesheet Element)
    together with its descendant nodes and associated attributes and
    namespaces.
   
static error
   
    An error that is detected by examining a stylesheet before execution
    starts (that is, before the source document and values of stylesheet
    parameters are available) is referred to as a static error.
   
string value
   
    The term string value is defined in Section 5.13 string-value Accessor^DM.
    Every node has a string value. For example, the string value of an element
    is the concatenation of the string values of all its descendant text
    nodes.
   
stylesheet
   
    A transformation in the XSLT language is expressed in the form of a 
    stylesheet, whose syntax is well-formed XML [XML 1.0] conforming to the
    Namespaces in XML Recommendation [Namespaces in XML 1.0].
   
stylesheet function
   
    An xsl:function declaration declares the name, parameters, and
    implementation of a stylesheet function that can be called from any XPath 
    expression within the stylesheet.
   
stylesheet level
   
    A stylesheet level is a collection of stylesheet modules connected using 
    xsl:include declarations: specifically, two stylesheet modules A and B are
    part of the same stylesheet level if one of them includes the other by
    means of an xsl:include declaration, or if there is a third stylesheet
    module C that is in the same stylesheet level as both A and B.
   
stylesheet module
   
    A stylesheet consists of one or more stylesheet modules, each one forming
    all or part of an XML document.
   
stylesheet parameter
   
    A top-level xsl:param element declares a stylesheet parameter. A
    stylesheet parameter is a global variable with the additional property
    that its value can be supplied by the caller when a transformation is
    initiated.
   
supplied value
   
    The value of the variable is computed using the expression given in the
    select attribute or the contained sequence constructor, as described in 
    9.3 Values of Variables and Parameters. This value is referred to as the 
    supplied value of the variable.
   
target namespace URI
   
    The namespace URI that is to be used in the result tree as a substitute
    for a literal namespace URI is called the target namespace URI.
   
template
   
    An xsl:template declaration defines a template, which contains a sequence
    constructor for creating nodes and/or atomic values. A template can serve
    either as a template rule, invoked by matching nodes against a pattern, or
    as a named template, invoked explicitly by name. It is also possible for
    the same template to serve in both capacities.
   
template parameter
   
    An xsl:param element may appear as a child of an xsl:template element,
    before any non-xsl:param children of that element. Such a parameter is
    known as a template parameter. A template parameter is a local variable
    with the additional property that its value can be set when the template
    is called, using any of the instructions xsl:call-template, 
    xsl:apply-templates, xsl:apply-imports, or xsl:next-match.
   
template rule
   
    A stylesheet contains a set of template rules (see 6 Template Rules). A
    template rule has three parts: a pattern that is matched against nodes, a
    (possibly empty) set of template parameters, and a sequence constructor
    that is evaluated to produce a sequence of items.
   
temporary output state
   
    The second of the two output states is called temporary output state. This
    state applies when instructions are writing to a temporary tree or any
    other non-final destination.
   
temporary tree
   
    The term temporary tree means any tree that is neither a source tree nor a
    final result tree.
   
top-level
   
    An element occurring as a child of an xsl:stylesheet element is called a 
    top-level element.
   
tunnel parameter
   
    A parameter passed to a template may be defined as a tunnel parameter.
    Tunnel parameters have the property that they are automatically passed on
    by the called template to any further templates that it calls, and so on
    recursively.
   
type annotation
   
    The term type annotation is used in this specification to refer to the
    value returned by the dm:type-name accessor of a node: see Section 5.14
    type-name Accessor^DM.
   
type errors
   
    Certain errors are classified as type errors. A type error occurs when the
    value supplied as input to an operation is of the wrong type for that
    operation, for example when an integer is supplied to an operation that
    expects a node.
   
typed value
   
    The term typed value is defined in Section 5.15 typed-value Accessor^DM.
    Every node except an element defined in the schema with element-only
    content has a typed value. For example, the typed value of an attribute of
    type xs:IDREFS is a sequence of zero or more xs:IDREF values.
   
user-defined data element
   
    In addition to declarations, the xsl:stylesheet element may contain any
    element not from the XSLT namespace, provided that the expanded-QName of
    the element has a non-null namespace URI. Such elements are referred to as
    user-defined data elements.
   
value
   
    A variable is a binding between a name and a value. The value of a
    variable is any sequence (of nodes and/or atomic values), as defined in 
    [Data Model].
   
variable
   
    The xsl:variable element declares a variable, which may be a global
    variable or a local variable.
   
variable-binding element
   
    The two elements xsl:variable and xsl:param are referred to as 
    variable-binding elements
   
whitespace text node
   
    A whitespace text node is a text node whose content consists entirely of
    whitespace characters (that is, #x09, #x0A, #x0D, or #x20).
   
D Element Syntax Summary (Non-Normative)

The syntax of each XSLT element is summarized below, together with the context
in the stylesheet where the element may appear. Some elements (specifically,
instructions) are allowed as a child of any element that is allowed to contain
a sequence constructor. These elements are:

  * Literal result elements
  * Extension instructions, if so defined

xsl:analyze-string

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:analyze-string                                                  
           select = expression                                                
           regex = { string }                                                 
           flags? = { string }>                                               
           <!-- Content: (xsl:matching-substring?, xsl:non-matching-substring 
         ?, xsl:fallback*) -->                                                
         </xsl:analyze-string>                                                
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:apply-imports

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:apply-imports>                                                  
           <!-- Content: xsl:with-param* -->                                  
         </xsl:apply-imports>                                                 
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:apply-templates

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:apply-templates                                                 
           select? = expression                                               
           mode? = token>                                                     
           <!-- Content: (xsl:sort | xsl:with-param)* -->                     
         </xsl:apply-templates>                                               
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:attribute

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:attribute                                                       
           name = { qname }                                                   
           namespace? = { uri-reference }                                     
           select? = expression                                               
           separator? = { string }                                            
           type? = qname                                                      
           validation? = "strict" | "lax" | "preserve" | "strip">             
           <!-- Content: sequence-constructor -->                             
         </xsl:attribute>                                                     
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:attribute-set                                                
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:attribute-set

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:attribute-set                                                   
           name = qname                                                       
           use-attribute-sets? = qnames>                                      
           <!-- Content: xsl:attribute* -->                                   
         </xsl:attribute-set>                                                 
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:call-template

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:call-template                                                   
           name = qname>                                                      
           <!-- Content: xsl:with-param* -->                                  
         </xsl:call-template>                                                 
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:character-map

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:character-map                                                   
           name = qname                                                       
           use-character-maps? = qnames>                                      
           <!-- Content: (xsl:output-character*) -->                          
         </xsl:character-map>                                                 
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:choose

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:choose>                                                         
           <!-- Content: (xsl:when+, xsl:otherwise?) -->                      
         </xsl:choose>                                                        
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:comment

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:comment                                                         
           select? = expression>                                              
           <!-- Content: sequence-constructor -->                             
         </xsl:comment>                                                       
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:copy

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:copy                                                            
           copy-namespaces? = "yes" | "no"                                    
           inherit-namespaces? = "yes" | "no"                                 
           use-attribute-sets? = qnames                                       
           type? = qname                                                      
           validation? = "strict" | "lax" | "preserve" | "strip">             
           <!-- Content: sequence-constructor -->                             
         </xsl:copy>                                                          
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:copy-of

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:copy-of                                                         
           select = expression                                                
           copy-namespaces? = "yes" | "no"                                    
           type? = qname                                                      
           validation? = "strict" | "lax" | "preserve" | "strip" />           
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:decimal-format

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:decimal-format                                                  
           name? = qname                                                      
           decimal-separator? = char                                          
           grouping-separator? = char                                         
           infinity? = string                                                 
           minus-sign? = char                                                 
           NaN? = string                                                      
           percent? = char                                                    
           per-mille? = char                                                  
           zero-digit? = char                                                 
           digit? = char                                                      
           pattern-separator? = char />                                       
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:document

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:document                                                        
           validation? = "strict" | "lax" | "preserve" | "strip"              
           type? = qname>                                                     
           <!-- Content: sequence-constructor -->                             
         </xsl:document>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:element

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:element                                                         
           name = { qname }                                                   
           namespace? = { uri-reference }                                     
           inherit-namespaces? = "yes" | "no"                                 
           use-attribute-sets? = qnames                                       
           type? = qname                                                      
           validation? = "strict" | "lax" | "preserve" | "strip">             
           <!-- Content: sequence-constructor -->                             
         </xsl:element>                                                       
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:fallback

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:fallback>                                                       
           <!-- Content: sequence-constructor -->                             
         </xsl:fallback>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:for-each

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:for-each                                                        
           select = expression>                                               
           <!-- Content: (xsl:sort*, sequence-constructor) -->                
         </xsl:for-each>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:for-each-group

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:for-each-group                                                  
           select = expression                                                
           group-by? = expression                                             
           group-adjacent? = expression                                       
           group-starting-with? = pattern                                     
           group-ending-with? = pattern                                       
           collation? = { uri }>                                              
           <!-- Content: (xsl:sort*, sequence-constructor) -->                
         </xsl:for-each-group>                                                
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:function

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:function                                                        
           name = qname                                                       
           as? = sequence-type                                                
           override? = "yes" | "no">                                          
           <!-- Content: (xsl:param*, sequence-constructor) -->               
         </xsl:function>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:if

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:if                                                              
           test = expression>                                                 
           <!-- Content: sequence-constructor -->                             
         </xsl:if>                                                            
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:import

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:import                                                          
           href = uri-reference />                                            
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:import-schema

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:import-schema                                                   
           namespace? = uri-reference                                         
           schema-location? = uri-reference>                                  
           <!-- Content: xs:schema? -->                                       
         </xsl:import-schema>                                                 
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:include

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:include                                                         
           href = uri-reference />                                            
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:key

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:key                                                             
           name = qname                                                       
           match = pattern                                                    
           use? = expression                                                  
           collation? = uri>                                                  
           <!-- Content: sequence-constructor -->                             
         </xsl:key>                                                           
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:matching-substring

         Model:                                                               
                                                                              
         <xsl:matching-substring>                                             
           <!-- Content: sequence-constructor -->                             
         </xsl:matching-substring>                                            
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:analyze-string                                               

xsl:message

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:message                                                         
           select? = expression                                               
           terminate? = { "yes" | "no" }>                                     
           <!-- Content: sequence-constructor -->                             
         </xsl:message>                                                       
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       
           * xsl:function                                                     

xsl:namespace

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:namespace                                                       
           name = { ncname }                                                  
           select? = expression>                                              
           <!-- Content: sequence-constructor -->                             
         </xsl:namespace>                                                     
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:namespace-alias

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:namespace-alias                                                 
           stylesheet-prefix = prefix | "#default"                            
           result-prefix = prefix | "#default" />                             
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:next-match

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:next-match>                                                     
           <!-- Content: (xsl:with-param | xsl:fallback)* -->                 
         </xsl:next-match>                                                    
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:non-matching-substring

         Model:                                                               
                                                                              
         <xsl:non-matching-substring>                                         
           <!-- Content: sequence-constructor -->                             
         </xsl:non-matching-substring>                                        
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:analyze-string                                               

xsl:number

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:number                                                          
           value? = expression                                                
           select? = expression                                               
           level? = "single" | "multiple" | "any"                             
           count? = pattern                                                   
           from? = pattern                                                    
           format? = { string }                                               
           lang? = { nmtoken }                                                
           letter-value? = { "alphabetic" | "traditional" }                   
           ordinal? = { string }                                              
           grouping-separator? = { char }                                     
           grouping-size? = { number } />                                     
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:otherwise

         Model:                                                               
                                                                              
         <xsl:otherwise>                                                      
           <!-- Content: sequence-constructor -->                             
         </xsl:otherwise>                                                     
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:choose                                                       

xsl:output

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:output                                                          
           name? = qname                                                      
           method? = "xml" | "html" | "xhtml" | "text" | qname-but-not-ncname 
           byte-order-mark? = "yes" | "no"                                    
           cdata-section-elements? = qnames                                   
           doctype-public? = string                                           
           doctype-system? = string                                           
           encoding? = string                                                 
           escape-uri-attributes? = "yes" | "no"                              
           include-content-type? = "yes" | "no"                               
           indent? = "yes" | "no"                                             
           media-type? = string                                               
           normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" |            
         "fully-normalized" | "none" | nmtoken                                
           omit-xml-declaration? = "yes" | "no"                               
           standalone? = "yes" | "no" | "omit"                                
           undeclare-prefixes? = "yes" | "no"                                 
           use-character-maps? = qnames                                       
           version? = nmtoken />                                              
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:output-character

         Model:                                                               
                                                                              
         <xsl:output-character                                                
           character = char                                                   
           string = string />                                                 
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:character-map                                                

xsl:param

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:param                                                           
           name = qname                                                       
           select? = expression                                               
           as? = sequence-type                                                
           required? = "yes" | "no"                                           
           tunnel? = "yes" | "no">                                            
           <!-- Content: sequence-constructor -->                             
         </xsl:param>                                                         
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    
           * xsl:function                                                     
           * xsl:template                                                     

xsl:perform-sort

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:perform-sort                                                    
           select? = expression>                                              
           <!-- Content: (xsl:sort+, sequence-constructor) -->                
         </xsl:perform-sort>                                                  
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:preserve-space

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:preserve-space                                                  
           elements = tokens />                                               
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:processing-instruction

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:processing-instruction                                          
           name = { ncname }                                                  
           select? = expression>                                              
           <!-- Content: sequence-constructor -->                             
         </xsl:processing-instruction>                                        
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:result-document

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:result-document                                                 
           format? = { qname }                                                
           href? = { uri-reference }                                          
           validation? = "strict" | "lax" | "preserve" | "strip"              
           type? = qname                                                      
           method? = { "xml" | "html" | "xhtml" | "text" |                    
         qname-but-not-ncname }                                               
           byte-order-mark? = { "yes" | "no" }                                
           cdata-section-elements? = { qnames }                               
           doctype-public? = { string }                                       
           doctype-system? = { string }                                       
           encoding? = { string }                                             
           escape-uri-attributes? = { "yes" | "no" }                          
           include-content-type? = { "yes" | "no" }                           
           indent? = { "yes" | "no" }                                         
           media-type? = { string }                                           
           normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" |          
         "fully-normalized" | "none" | nmtoken }                              
           omit-xml-declaration? = { "yes" | "no" }                           
           standalone? = { "yes" | "no" | "omit" }                            
           undeclare-prefixes? = { "yes" | "no" }                             
           use-character-maps? = qnames                                       
           output-version? = { nmtoken }>                                     
           <!-- Content: sequence-constructor -->                             
         </xsl:result-document>                                               
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:sequence

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:sequence                                                        
           select = expression>                                               
           <!-- Content: xsl:fallback* -->                                    
         </xsl:sequence>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:sort

         Model:                                                               
                                                                              
         <xsl:sort                                                            
           select? = expression                                               
           lang? = { nmtoken }                                                
           order? = { "ascending" | "descending" }                            
           collation? = { uri }                                               
           stable? = { "yes" | "no" }                                         
           case-order? = { "upper-first" | "lower-first" }                    
           data-type? = { "text" | "number" | qname-but-not-ncname }>         
           <!-- Content: sequence-constructor -->                             
         </xsl:sort>                                                          
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:apply-templates                                              
           * xsl:for-each                                                     
           * xsl:for-each-group                                               
           * xsl:perform-sort                                                 

xsl:strip-space

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:strip-space                                                     
           elements = tokens />                                               
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:stylesheet

         Model:                                                               
                                                                              
         <xsl:stylesheet                                                      
           id? = id                                                           
           extension-element-prefixes? = tokens                               
           exclude-result-prefixes? = tokens                                  
           version = number                                                   
           xpath-default-namespace? = uri                                     
           default-validation? = "preserve" | "strip"                         
           default-collation? = uri-list                                      
           input-type-annotations? = "preserve" | "strip" | "unspecified">    
           <!-- Content: (xsl:import*, other-declarations) -->                
         </xsl:stylesheet>                                                    
                                                                              
         Permitted parent elements:                                           
                                                                              
           * None                                                             

xsl:template

         Category: declaration                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:template                                                        
           match? = pattern                                                   
           name? = qname                                                      
           priority? = number                                                 
           mode? = tokens                                                     
           as? = sequence-type>                                               
           <!-- Content: (xsl:param*, sequence-constructor) -->               
         </xsl:template>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    

xsl:text

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:text                                                            
           [disable-output-escaping]? = "yes" | "no">                         
           <!-- Content: #PCDATA -->                                          
         </xsl:text>                                                          
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:transform

         Model:                                                               
                                                                              
         <xsl:transform                                                       
           id? = id                                                           
           extension-element-prefixes? = tokens                               
           exclude-result-prefixes? = tokens                                  
           version = number                                                   
           xpath-default-namespace? = uri                                     
           default-validation? = "preserve" | "strip"                         
           default-collation? = uri-list                                      
           input-type-annotations? = "preserve" | "strip" | "unspecified">    
           <!-- Content: (xsl:import*, other-declarations) -->                
         </xsl:transform>                                                     
                                                                              
         Permitted parent elements:                                           
                                                                              
           * None                                                             

xsl:value-of

         Category: instruction                                                
                                                                              
         Model:                                                               
                                                                              
         <xsl:value-of                                                        
           select? = expression                                               
           separator? = { string }                                            
           [disable-output-escaping]? = "yes" | "no">                         
           <!-- Content: sequence-constructor -->                             
         </xsl:value-of>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:variable

         Category: declaration instruction                                    
                                                                              
         Model:                                                               
                                                                              
         <xsl:variable                                                        
           name = qname                                                       
           select? = expression                                               
           as? = sequence-type>                                               
           <!-- Content: sequence-constructor -->                             
         </xsl:variable>                                                      
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:stylesheet                                                   
           * xsl:transform                                                    
           * xsl:function                                                     
           * any XSLT element whose content model is sequence constructor     
           * any literal result element                                       

xsl:when

         Model:                                                               
                                                                              
         <xsl:when                                                            
           test = expression>                                                 
           <!-- Content: sequence-constructor -->                             
         </xsl:when>                                                          
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:choose                                                       

xsl:with-param

         Model:                                                               
                                                                              
         <xsl:with-param                                                      
           name = qname                                                       
           select? = expression                                               
           as? = sequence-type                                                
           tunnel? = "yes" | "no">                                            
           <!-- Content: sequence-constructor -->                             
         </xsl:with-param>                                                    
                                                                              
         Permitted parent elements:                                           
                                                                              
           * xsl:apply-templates                                              
           * xsl:apply-imports                                                
           * xsl:call-template                                                
           * xsl:next-match                                                   

E Summary of Error Conditions (Non-Normative)

This appendix provides a summary of error conditions that a processor may
signal. This list is not exhaustive or definitive. The errors are numbered for
ease of reference, but there is no implication that an implementation must
signal errors using these error codes, or that applications can test for these
codes. Moreover, implementations are not required to signal errors using the
descriptive text used here.

Static errors

ERR XTSE0010
   
    A static error is signaled if an XSLT-defined element is used in a context
    where it is not permitted, if a required attribute is omitted, or if the
    content of the element does not correspond to the content that is allowed
    for the element.
   
ERR XTSE0020
   
    It is a static error if an attribute (other than an attribute written
    using curly brackets in a position where an attribute value template is
    permitted) contains a value that is not one of the permitted values for
    that attribute.
   
ERR XTSE0080
   
    It is a static error to use a reserved namespace in the name of a named
    template, a mode, an attribute set, a key, a decimal-format, a variable or
    parameter, a stylesheet function, a named output definition, or a 
    character map.
   
ERR XTSE0090
   
    It is a static error for an element from the XSLT namespace to have an
    attribute whose namespace is either null (that is, an attribute with an
    unprefixed name) or the XSLT namespace, other than attributes defined for
    the element in this document.
   
ERR XTSE0110
   
    The value of the version attribute must be a number: specifically, it must
    be a a valid instance of the type xs:decimal as defined in [XML Schema
    Part 2].
   
ERR XTSE0120
   
    An xsl:stylesheet element must not have any text node children.
   
ERR XTSE0125
   
    It is a static error if the value of an [xsl:]default-collation attribute,
    after resolving against the base URI, contains no URI that the
    implementation recognizes as a collation URI.
   
ERR XTSE0130
   
    It is a static error if the xsl:stylesheet element has a child element
    whose name has a null namespace URI.
   
ERR XTSE0150
   
    A literal result element that is used as the outermost element of a
    simplified stylesheet module must have an xsl:version attribute.
   
ERR XTSE0165
   
    It is a static error if the processor is not able to retrieve the resource
    identified by the URI reference [ in the href attribute of xsl:include or 
    xsl:import] , or if the resource that is retrieved does not contain a
    stylesheet module conforming to this specification.
   
ERR XTSE0170
   
    An xsl:include element must be a top-level element.
   
ERR XTSE0180
   
    It is a static error if a stylesheet module directly or indirectly
    includes itself.
   
ERR XTSE0190
   
    An xsl:import element must be a top-level element.
   
ERR XTSE0200
   
    The xsl:import element children must precede all other element children of
    an xsl:stylesheet element, including any xsl:include element children and
    any user-defined data elements.
   
ERR XTSE0210
   
    It is a static error if a stylesheet module directly or indirectly imports
    itself.
   
ERR XTSE0215
   
    It is a static error if an xsl:import-schema element that contains an
    xs:schema element has a schema-location attribute, or if it has a
    namespace attribute that conflicts with the target namespace of the
    contained schema.
   
ERR XTSE0220
   
    It is a static error if the synthetic schema document does not satisfy the
    constraints described in [XML Schema Part 1] (section 5.1, Errors in
    Schema Construction and Structure). This includes, without loss of
    generality, conflicts such as multiple definitions of the same name.
   
ERR XTSE0260
   
    Within an XSLT element that is required to be empty, any content other
    than comments or processing instructions, including any whitespace text
    node preserved using the xml:space="preserve" attribute, is a static error
    .
   
ERR XTSE0265
   
    It is a static error if there is a stylesheet module in the stylesheet
    that specifies input-type-annotations="strip" and another stylesheet
    module that specifies input-type-annotations="preserve".
   
ERR XTSE0280
   
    In the case of a prefixed QName used as the value of an attribute in the 
    stylesheet, or appearing within an XPath expression in the stylesheet, it
    is a static error if the defining element has no namespace node whose name
    matches the prefix of the QName.
   
ERR XTSE0340
   
    Where an attribute is defined to contain a pattern, it is a static error
    if the pattern does not match the production Pattern.
   
ERR XTSE0350
   
    It is a static error if an unescaped left curly bracket appears in a fixed
    part of an attribute value template without a matching right curly
    bracket.
   
ERR XTSE0370
   
    It is a static error if an unescaped right curly bracket occurs in a fixed
    part of an attribute value template.
   
ERR XTSE0500
   
    An xsl:template element must have either a match attribute or a name
    attribute, or both. An xsl:template element that has no match attribute 
    must have no mode attribute and no priority attribute.
   
ERR XTSE0530
   
    The value of this attribute [the priority attribute of the xsl:template
    element] must conform to the rules for the xs:decimal type defined in [XML
    Schema Part 2]. Negative values are permitted..
   
ERR XTSE0550
   
    It is a static error if the list [of modes in the mode attribute of 
    xsl:template] is empty, if the same token is included more than once in
    the list, if the list contains an invalid token, or if the token #all
    appears together with any other value.
   
ERR XTSE0580
   
    It is a static error if two parameters of a template or of a stylesheet
    function have the same name.
   
ERR XTSE0620
   
    It is a static error if a variable-binding element has a select attribute
    and has non-empty content.
   
ERR XTSE0630
   
    It is a static error if a stylesheet contains more than one binding of a
    global variable with the same name and same import precedence, unless it
    also contains another binding with the same name and higher import
    precedence.
   
ERR XTSE0650
   
    It is a static error if a stylesheet contains an xsl:call-template
    instruction whose name attribute does not match the name attribute of any 
    xsl:template in the stylesheet.
   
ERR XTSE0660
   
    It is a static error if a stylesheet contains more than one template with
    the same name and the same import precedence, unless it also contains a 
    template with the same name and higher import precedence.
   
ERR XTSE0670
   
    It is a static error if a single xsl:call-template, xsl:apply-templates, 
    xsl:apply-imports, or xsl:next-match element contains two or more 
    xsl:with-param elements with matching name attributes.
   
ERR XTSE0680
   
    In the case of xsl:call-template, it is a static error to pass a 
    non-tunnel parameter named x to a template that does not have a template
    parameter named x, unless backwards compatible behavior is enabled for the
    xsl:call-template instruction.
   
ERR XTSE0690
   
    It is a static error if a template that is invoked using xsl:call-template
    declares a template parameter specifying required="yes" and not specifying
    tunnel="yes", if no value for this parameter is supplied by the calling
    instruction.
   
ERR XTSE0710
   
    It is a static error if the value of the use-attribute-sets attribute of
    an xsl:copy, xsl:element, or xsl:attribute-set element, or the
    xsl:use-attribute-sets attribute of a literal result element, is not a 
    whitespace-separated sequence of QNames, or if it contains a QName that
    does not match the name attribute of any xsl:attribute-set declaration in
    the stylesheet.
   
ERR XTSE0720
   
    It is a static error if an xsl:attribute-set element directly or
    indirectly references itself via the names contained in the
    use-attribute-sets attribute.
   
ERR XTSE0740
   
    A stylesheet function must have a prefixed name, to remove any risk of a
    clash with a function in the default function namespace. It is a static
    error if the name has no prefix.
   
ERR XTSE0760
   
    Because arguments to a stylesheet function call must all be specified, the
    xsl:param elements within an xsl:function element must not specify a
    default value: this means they must be empty, and must not have a select
    attribute.
   
ERR XTSE0770
   
    It is a static error for a stylesheet to contain two or more functions
    with the same expanded-QName, the same arity, and the same import
    precedence, unless there is another function with the same expanded-QName
    and arity, and a higher import precedence.
   
ERR XTSE0805
   
    It is a static error if an attribute on a literal result element is in the
    XSLT namespace, unless it is one of the attributes explicitly defined in
    this specification.
   
ERR XTSE0808
   
    It is a static error if a namespace prefix is used within the [xsl:]
    exclude-result-prefixes attribute and there is no namespace binding in
    scope for that prefix.
   
ERR XTSE0809
   
    It is a static error if the value #default is used within the [xsl:]
    exclude-result-prefixes attribute and the parent element of the [xsl:]
    exclude-result-prefixes attribute has no default namespace.
   
ERR XTSE0810
   
    It is a static error if there is more than one such declaration [more than
    one xsl:namespace-alias declaration] with the same literal namespace URI
    and the same import precedence and different values for the target
    namespace URI, unless there is also an xsl:namespace-alias declaration
    with the same literal namespace URI and a higher import precedence.
   
ERR XTSE0812
   
    It is a static error if a value other than #default is specified for
    either the stylesheet-prefix or the result-prefix attributes of the 
    xsl:namespace-alias element when there is no in-scope binding for that
    namespace prefix.
   
ERR XTSE0840
   
    It is a static error if the select attribute of the xsl:attribute element
    is present unless the element has empty content.
   
ERR XTSE0870
   
    It is a static error if the select attribute of the xsl:value-of element
    is present when the content of the element is non-empty, or if the select
    attribute is absent when the content is empty.
   
ERR XTSE0880
   
    It is a static error if the select attribute of the 
    xsl:processing-instruction element is present unless the element has empty
    content.
   
ERR XTSE0910
   
    It is a static error if the select attribute of the xsl:namespace element
    is present when the element has content other than one or more 
    xsl:fallback instructions, or if the select attribute is absent when the
    element has empty content.
   
ERR XTSE0940
   
    It is a static error if the select attribute of the xsl:comment element is
    present unless the element has empty content.
   
ERR XTTE0950
   
    It is a type error to use the xsl:copy or xsl:copy-of instruction to copy
    a node that has namespace-sensitive content if the copy-namespaces
    attribute has the value no and its explicit or implicit validation
    attribute has the value preserve. It is also a type error if either of
    these instructions (with validation="preserve") is used to copy an
    attribute having namespace-sensitive content, unless the parent element is
    also copied. A node has namespace-sensitive content if its typed value
    contains an item of type xs:QName or xs:NOTATION or a type derived
    therefrom. The reason this is an error is because the validity of the
    content depends on the namespace context being preserved.
   
ERR XTSE0975
   
    It is a static error if the value attribute of xsl:number is present
    unless the select, level, count, and from attributes are all absent.
   
ERR XTSE1015
   
    It is a static error if an xsl:sort element with a select attribute has
    non-empty content.
   
ERR XTSE1017
   
    It is a static error if an xsl:sort element other than the first in a
    sequence of sibling xsl:sort elements has a stable attribute.
   
ERR XTSE1040
   
    It is a static error if an xsl:perform-sort instruction with a select
    attribute has any content other than xsl:sort and xsl:fallback
    instructions.
   
ERR XTSE1060
   
    It is a static error if the current-group function is used within a 
    pattern.
   
ERR XTSE1070
   
    It is a static error if the current-grouping-key function is used within a
    pattern.
   
ERR XTSE1080
   
    These four attributes [the group-by, group-adjacent, group-starting-with,
    and group-ending-with attributes of xsl:for-each-group ] are mutually
    exclusive: it is a static error if none of these four attributes is
    present, or if more than one of them is present.
   
ERR XTSE1090
   
    It is an error to specify the collation attribute if neither the group-by
    attribute nor group-adjacent attribute is specified.
   
ERR XTSE1130
   
    It is a static error if the xsl:analyze-string instruction contains
    neither an xsl:matching-substring nor an xsl:non-matching-substring
    element.
   
ERR XTSE1205
   
    It is a static error if an xsl:key declaration has a use attribute and has
    non-empty content, or if it has empty content and no use attribute.
   
ERR XTSE1210
   
    It is a static error if the xsl:key declaration has a collation attribute
    whose value (after resolving against the base URI) is not a URI recognized
    by the implementation as referring to a collation.
   
ERR XTSE1220
   
    It is a static error if there are several xsl:key declarations in the 
    stylesheet with the same key name and different effective collations. Two
    collations are the same if their URIs are equal under the rules for
    comparing xs:anyURI values, or if the implementation can determine that
    they are different URIs referring to the same collation.
   
ERR XTSE1290
   
    It is a static error if a named or unnamed decimal format contains two
    conflicting values for the same attribute in different xsl:decimal-format
    declarations having the same import precedence, unless there is another
    definition of the same attribute with higher import precedence.
   
ERR XTSE1295
   
    It is a static error if the character specified in the zero-digit
    attribute is not a digit or is a digit that does not have the numeric
    value zero.
   
ERR XTSE1300
   
    It is a static error if, for any named or unnamed decimal format, the
    variables representing characters used in a picture string do not each
    have distinct values. These variables are decimal-separator-sign,
    grouping-sign, percent-sign, per-mille-sign, digit-zero-sign, digit-sign,
    and pattern-separator-sign.
   
ERR XTSE1430
   
    It is a static error if there is no namespace bound to the prefix on the
    element bearing the [xsl:]extension-element-prefixes attribute or, when #
    default is specified, if there is no default namespace.
   
ERR XTSE1505
   
    It is a static error if both the [xsl:]type and [xsl:]validation
    attributes are present on the xsl:element, xsl:attribute, xsl:copy, 
    xsl:copy-of, xsl:document, or xsl:result-document instructions, or on a 
    literal result element.
   
ERR XTSE1520
   
    It is a static error if the value of the type attribute of an xsl:element,
    xsl:attribute, xsl:copy, xsl:copy-of, xsl:document, or xsl:result-document
    instruction, or the xsl:type attribute of a literal result element, is not
    a valid QName, or if it uses a prefix that is not defined in an in-scope
    namespace declaration, or if the QName is not the name of a type
    definition included in the in-scope schema components for the stylesheet.
   
ERR XTSE1530
   
    It is a static error if the value of the type attribute of an 
    xsl:attribute instruction refers to a complex type definition
   
ERR XTSE1560
   
    It is a static error if two xsl:output declarations within an output
    definition specify explicit values for the same attribute (other than
    cdata-section-elements and use-character-maps), with the values of the
    attributes being not equal, unless there is another xsl:output declaration
    within the same output definition that has higher import precedence and
    that specifies an explicit value for the same attribute.
   
ERR XTSE1570
   
    The value [of the method attribute on xsl:output ] must (if present) be a
    valid QName. If the QName does not have a prefix, then it identifies a
    method specified in [XSLT and XQuery Serialization] and must be one of
    xml, html, xhtml, or text.
   
ERR XTSE1580
   
    It is a static error if the stylesheet contains two or more character maps
    with the same name and the same import precedence, unless it also contains
    another character map with the same name and higher import precedence.
   
ERR XTSE1590
   
    It is a static error if a name in the use-character-maps attribute of the 
    xsl:output or xsl:character-map elements does not match the name attribute
    of any xsl:character-map in the stylesheet.
   
ERR XTSE1600
   
    It is a static error if a character map references itself, directly or
    indirectly, via a name in the use-character-maps attribute.
   
ERR XTSE1650
   
    A basic XSLT processor must signal a static error if the stylesheet
    includes an xsl:import-schema declaration.
   
ERR XTSE1660
   
    A basic XSLT processor must signal a static error if the stylesheet
    includes an [xsl:]type attribute, or an [xsl:]validation or
    default-validation attribute with a value other than strip.
   
Type errors

ERR XTTE0505
   
    It is a type error if the result of evaluating the sequence constructor
    cannot be converted to the required type.
   
ERR XTTE0510
   
    It is a type error if an xsl:apply-templates instruction with no select
    attribute is evaluated when the context item is not a node.
   
ERR XTTE0520
   
    It is a type error if the sequence returned by the select expression [of 
    xsl:apply-templates] contains an item that is not a node.
   
ERR XTTE0570
   
    It is a type error if the supplied value of a variable cannot be converted
    to the required type.
   
ERR XTTE0590
   
    It is a type error if the conversion of the supplied value of a parameter
    to its required type fails.
   
ERR XTTE0600
   
    If a default value is given explicitly, that is, if there is either a
    select attribute or a non-empty sequence constructor, then it is a type
    error if the default value cannot be converted to the required type, using
    the function conversion rules.
   
ERR XTTE0780
   
    If the as attribute [of xsl:function ] is specified, then the result
    evaluated by the sequence constructor (see 5.7 Sequence Constructors) is
    converted to the required type, using the function conversion rules. It is
    a type error if this conversion fails.
   
ERR XTTE0790
   
    If the value of a parameter to a stylesheet function cannot be converted
    to the required type, a type error is signaled.
   
ERR XTTE0990
   
    It is a type error if the xsl:number instruction is evaluated, with no
    value or select attribute, when the context item is not a node.
   
ERR XTTE1000
   
    It is a type error if the result of evaluating the select attribute of the
    xsl:number instruction is anything other than a single node.
   
ERR XTTE1020
   
    If any sort key value, after atomization and any type conversion required
    by the data-type attribute, is a sequence containing more than one item,
    then the effect depends on whether the xsl:sort element is evaluated with 
    backwards compatible behavior. With backwards compatible behavior, the
    effective sort key value is the first item in the sequence. In other
    cases, this is a type error.
   
ERR XTTE1100
   
    It is a type error if the grouping key evaluated using the group-adjacent
    attribute is an empty sequence, or a sequence containing more than one
    item.
   
ERR XTTE1120
   
    When the group-starting-with or group-ending-with attribute [of the 
    xsl:for-each-group instruction] is used, it is a type error if the result
    of evaluating the select expression contains an item that is not a node.
   
ERR XTTE1510
   
    If the validation attribute of an xsl:element, xsl:attribute, xsl:copy, 
    xsl:copy-of, or xsl:result-document instruction, or the xsl:validation
    attribute of a literal result element, has the effective value strict, and
    schema validity assessment concludes that the validity of the element or
    attribute is invalid or unknown, a type error occurs. As with other type
    errors, the error may be signaled statically if it can be detected
    statically.
   
ERR XTTE1512
   
    If the validation attribute of an xsl:element, xsl:attribute, xsl:copy, 
    xsl:copy-of, or xsl:result-document instruction, or the xsl:validation
    attribute of a literal result element, has the effective value strict, and
    there is no matching top-level declaration in the schema, then a type
    error occurs. As with other type errors, the error may be signaled
    statically if it can be detected statically.
   
ERR XTTE1515
   
    If the validation attribute of an xsl:element, xsl:attribute, xsl:copy, 
    xsl:copy-of, or xsl:result-document instruction, or the xsl:validation
    attribute of a literal result element, has the effective value lax, and
    schema validity assessment concludes that the element or attribute is
    invalid, a type error occurs. As with other type errors, the error may be
    signaled statically if it can be detected statically.
   
ERR XTTE1540
   
    It is a type error if an [xsl:]type attribute is defined for a constructed
    element or attribute, and the outcome of schema validity assessment
    against that type is that the validity property of that element or
    attribute information item is other than valid.
   
ERR XTTE1545
   
    A type error occurs if a type or validation attribute is defined
    (explicitly or implicitly) for an instruction that constructs a new
    attribute node, if the effect of this is to cause the attribute value to
    be validated against a type that is derived from, or constructed by list
    or union from, the primitive types xs:QName or xs:NOTATION.
   
ERR XTTE1550
   
    A type error occurs [when a document node is validated] unless the
    children of the document node comprise exactly one element node, no text
    nodes, and zero or more comment and processing instruction nodes, in any
    order.
   
ERR XTTE1555
   
    It is a type error if, when validating a document node, document-level
    constraints are not satisfied. These constraints include identity
    constraints (xs:unique, xs:key, and xs:keyref) and ID/IDREF constraints.
   
Dynamic errors

ERR XTDE0030
   
    It is a non-recoverable dynamic error if the effective value of an
    attribute written using curly brackets, in a position where an attribute
    value template is permitted, is a value that is not one of the permitted
    values for that attribute. If the processor is able to detect the error
    statically (for example, when any XPath expressions within the curly
    brackets can be evaluated statically), then the processor may optionally
    signal this as a static error.
   
ERR XTDE0040
   
    It is a non-recoverable dynamic error if the invocation of the stylesheet
    specifies a template name that does not match the expanded-QName of a
    named template defined in the stylesheet.
   
ERR XTDE0045
   
    It is a non-recoverable dynamic error if the invocation of the stylesheet
    specifies an initial mode (other than the default mode) that does not
    match the expanded-QName in the mode attribute of any template defined in
    the stylesheet.
   
ERR XTDE0047
   
    It is a non-recoverable dynamic error if the invocation of the stylesheet
    specifies both an initial mode and an initial template.
   
ERR XTDE0050
   
    It is a non-recoverable dynamic error if the stylesheet that is invoked
    declares a visible stylesheet parameter with required="yes" and no value
    for this parameter is supplied during the invocation of the stylesheet. A
    stylesheet parameter is visible if it is not masked by another global
    variable or parameter with the same name and higher import precedence.
   
ERR XTDE0060
   
    It is a non-recoverable dynamic error if the initial template defines a 
    template parameter that specifies required="yes".
   
ERR XTDE0160
   
    If an implementation does not support backwards-compatible behavior, then
    it is a non-recoverable dynamic error if any element is evaluated that
    enables backwards-compatible behavior.
   
ERR XTRE0270
   
    It is a recoverable dynamic error if this [the process of finding an 
    xsl:strip-space or xsl:preserve-space declaration to match an element in
    the source document] leaves more than one match, unless all the matched
    declarations are equivalent (that is, they are all xsl:strip-space or they
    are all xsl:preserve-space).
        Action: The optional recovery action is to select, from the matches
    that are left, the one that occurs last in declaration order.
   
ERR XTDE0290
   
    Where the result of evaluating an XPath expression (or an attribute value
    template) is required to be a lexical QName, then unless otherwise
    specified it is a non-recoverable dynamic error if the defining element
    has no namespace node whose name matches the prefix of the lexical QName. 
    This error may be signaled as a static error if the value of the
    expression can be determined statically.
   
ERR XTDE0410
   
    It is a non-recoverable dynamic error if the result sequence used to
    construct the content of an element node contains a namespace node or
    attribute node that is preceded in the sequence by a node that is neither
    a namespace node nor an attribute node.
   
ERR XTDE0420
   
    It is a non-recoverable dynamic error if the result sequence used to
    construct the content of a document node contains a namespace node or
    attribute node.
   
ERR XTDE0430
   
    It is a non-recoverable dynamic error if the result sequence contains two
    or more namespace nodes having the same name but different string values
    (that is, namespace nodes that map the same prefix to different namespace
    URIs).
   
ERR XTDE0440
   
    It is a non-recoverable dynamic error if the result sequence contains a
    namespace node with no name and the element node being constructed has a
    null namespace URI (that is, it is an error to define a default namespace
    when the element is in no namespace).
   
ERR XTDE0485
   
    It is a non-recoverable dynamic error if namespace fixup is performed on
    an element that contains among the typed values of the element and its
    attributes two values of type xs:QName or xs:NOTATION containing
    conflicting namespace prefixes, that is, two values that use the same
    prefix to refer to different namespace URIs.
   
ERR XTRE0540
   
    It is a recoverable dynamic error if the conflict resolution algorithm for
    template rules leaves more than one matching template rule.
        Action: The optional recovery action is to select, from the matching
    template rules that are left, the one that occurs last in declaration
    order.
   
ERR XTDE0560
   
    It is a non-recoverable dynamic error if xsl:apply-imports or 
    xsl:next-match is evaluated when the current template rule is null.
   
ERR XTDE0610
   
    If an optional parameter has no select attribute and has an empty sequence
    constructor, and if there is an as attribute, then the default value of
    the parameter is an empty sequence. If the empty sequence is not a valid
    instance of the required type defined in the as attribute, then the
    parameter is treated as a required parameter, which means that it is a 
    non-recoverable dynamic error if the caller supplies no value for the
    parameter.
   
ERR XTDE0640
   
    In general, a circularity in a stylesheet is a non-recoverable dynamic
    error.
   
ERR XTDE0700
   
    In other cases, [with xsl:apply-templates, xsl:apply-imports, and 
    xsl:next-match, or xsl:call-template with tunnel parameters] it is a 
    non-recoverable dynamic error if the template that is invoked declares a 
    template parameter with required="yes" and no value for this parameter is
    supplied by the calling instruction.
   
ERR XTRE0795
   
    It is a recoverable dynamic error if the name of a constructed attribute
    is xml:space and the value is not either default or preserve.
        Action: The optional recovery action is to construct the attribute
    with the value as requested.
   
ERR XTDE0820
   
    It is a non-recoverable dynamic error if the effective value of the name
    attribute [of the xsl:element instruction] is not a lexical QName.
   
ERR XTDE0830
   
    In the case of an xsl:element instruction with no namespace attribute, it
    is a non-recoverable dynamic error if the effective value of the name
    attribute is a QName whose prefix is not declared in an in-scope namespace
    declaration for the xsl:element instruction.
   
ERR XTDE0835
   
    It is a non-recoverable dynamic error if the effective value of the
    namespace attribute [of the xsl:element instruction] is not in the lexical
    space of the xs:anyURI data type.
   
ERR XTDE0850
   
    It is a non-recoverable dynamic error if the effective value of the name
    attribute [of an xsl:attribute instruction] is not a lexical QName.
   
ERR XTDE0855
   
    In the case of an xsl:attribute instruction with no namespace attribute,
    it is a non-recoverable dynamic error if the effective value of the name
    attribute is the string xmlns.
   
ERR XTDE0860
   
    In the case of an xsl:attribute instruction with no namespace attribute,
    it is a non-recoverable dynamic error if the effective value of the name
    attribute is a lexical QName whose prefix is not declared in an in-scope
    namespace declaration for the xsl:attribute instruction.
   
ERR XTDE0865
   
    It is a non-recoverable dynamic error if the effective value of the
    namespace attribute [of the xsl:attribute instruction] is not in the
    lexical space of the xs:anyURI data type.
   
ERR XTDE0890
   
    It is a non-recoverable dynamic error if the effective value of the name
    attribute [of the xsl:processing-instruction instruction] is not both an 
    NCName^ Names and a PITarget^ XML.
   
ERR XTDE0905
   
    It is a non-recoverable dynamic error if the string value of the new
    namespace node [created using xsl:namespace] is not valid in the lexical
    space of the data type xs:anyURI. [see ERR XTDE0835]
   
ERR XTDE0920
   
    It is a non-recoverable dynamic error if the effective value of the name
    attribute [of the xsl:namespace instruction] is neither a zero-length
    string nor an NCName^ Names, or if it is xmlns.
   
ERR XTDE0925
   
    It is a non-recoverable dynamic error if the xsl:namespace instruction
    generates a namespace node whose name is xml and whose string value is not
    http://www.w3.org/XML/1998/namespace, or a namespace node whose string
    value is http://www.w3.org/XML/1998/namespace and whose name is not xml.
   
ERR XTDE0930
   
    It is a non-recoverable dynamic error if evaluating the select attribute
    or the contained sequence constructor of an xsl:namespace instruction
    results in a zero-length string.
   
ERR XTDE0980
   
    It is a non-recoverable dynamic error if any undiscarded item in the
    atomized sequence supplied as the value of the value attribute of 
    xsl:number cannot be converted to an integer, or if the resulting integer
    is less than 0 (zero).
   
ERR XTDE1030
   
    It is a non-recoverable dynamic error if, for any sort key component, the
    set of sort key values evaluated for all the items in the initial sequence
    , after any type conversion requested, contains a pair of ordinary values
    for which the result of the XPath lt operator is an error.
   
ERR XTDE1035
   
    It is a non-recoverable dynamic error if the collation attribute of 
    xsl:sort (after resolving against the base URI) is not a URI that is
    recognized by the implementation as referring to a collation.
   
ERR XTDE1110
   
    It is a non-recoverable dynamic error if the collation URI specified to 
    xsl:for-each-group (after resolving against the base URI) is a collation
    that is not recognized by the implementation. (For notes, [see ERR
    XTDE1035].)
   
ERR XTDE1140
   
    It is a non-recoverable dynamic error if the effective value of the regex
    attribute [of the xsl:analyze-string instruction] does not conform to the 
    required syntax for regular expressions, as specified in [Functions and
    Operators]. If the regular expression is known statically (for example, if
    the attribute does not contain any expressions enclosed in curly brackets)
    then the processor may signal the error as a static error.
   
ERR XTDE1145
   
    It is a non-recoverable dynamic error if the effective value of the flags
    attribute [of the xsl:analyze-string instruction] has a value other than
    the values defined in [Functions and Operators]. If the value of the
    attribute is known statically (for example, if the attribute does not
    contain any expressions enclosed in curly brackets) then the processor may
    signal the error as a static error.
   
ERR XTDE1150
   
    It is a non-recoverable dynamic error if the effective value of the regex
    attribute [of the xsl:analyze-string instruction] is a regular expression
    that matches a zero-length string: or more specifically, if the regular
    expression $r and flags $f are such that matches("", $r, $f) returns true.
    If the regular expression is known statically (for example, if the
    attribute does not contain any expressions enclosed in curly brackets)
    then the processor may signal the error as a static error.
   
ERR XTRE1160
   
    When a URI reference [supplied to the document function] contains a
    fragment identifier, it is a recoverable dynamic error if the media type
    is not one that is recognized by the processor, or if the fragment
    identifier does not conform to the rules for fragment identifiers for that
    media type, or if the fragment identifier selects something other than a
    sequence of nodes (for example, if it selects a range of characters within
    a text node).
        Action: The optional recovery action is to ignore the fragment
    identifier and return the document node.
   
ERR XTDE1170
   
    It is a non-recoverable dynamic error if a URI [supplied in the first
    argument to the unparsed-text function] contains a fragment identifier, or
    if it cannot be used to retrieve a resource containing text.
   
ERR XTDE1190
   
    It is a non-recoverable dynamic error if a resource [retrieved using the 
    unparsed-text function] contains octets that cannot be decoded into
    Unicode characters using the specified encoding, or if the resulting
    characters are not permitted XML characters. This includes the case where
    the processor does not support the requested encoding.
   
ERR XTDE1200
   
    It is a non-recoverable dynamic error if the second argument of the 
    unparsed-text function is omitted and the processor cannot infer the
    encoding using external information and the encoding is not UTF-8.
   
ERR XTDE1260
   
    It is a non-recoverable dynamic error if the value [of the first argument
    to the key function] is not a valid QName, or if there is no namespace
    declaration in scope for the prefix of the QName, or if the name obtained
    by expanding the QName is not the same as the expanded name of any xsl:key
    declaration in the stylesheet. If the processor is able to detect the
    error statically (for example, when the argument is supplied as a string
    literal), then the processor may optionally signal this as a static error.
   
ERR XTDE1270
   
    It is a non-recoverable dynamic error to call the key function with two
    arguments if there is no context node, or if the root of the tree
    containing the context node is not a document node; or to call the
    function with three arguments if the root of the tree containing the node
    supplied in the third argument is not a document node.
   
ERR XTDE1280
   
    It is a non-recoverable dynamic error if the name specified as the
    $decimal-format-name argument [ to the format-number function] is not a
    valid QName, or if its prefix has not been declared in an in-scope
    namespace declaration, or if the stylesheet does not contain a declaration
    of a decimal-format with a matching expanded-QName. If the processor is
    able to detect the error statically (for example, when the argument is
    supplied as a string literal), then the processor may optionally signal
    this as a static error.
   
ERR XTDE1310
   
    The picture string [supplied to the format-number function] must conform
    to the following rules. [ See full specification.] It is a non-recoverable
    dynamic error if the picture string does not satisfy these rules.
   
ERR XTDE1340
   
    It is a non-recoverable dynamic error if the syntax of the picture [used
    for date/time formatting] is incorrect.
   
ERR XTDE1350
   
    It is a non-recoverable dynamic error if a component specifier within the
    picture [used for date/time formatting] refers to components that are not
    available in the given type of $value, for example if the picture supplied
    to the format-time refers to the year, month, or day component.
   
ERR XTDE1360
   
    If the current function is evaluated within an expression that is
    evaluated when the context item is undefined, a non-recoverable dynamic
    error occurs.
   
ERR XTDE1370
   
    It is a non-recoverable dynamic error if the unparsed-entity-uri function
    is called when there is no context node, or when the root of the tree
    containing the context node is not a document node.
   
ERR XTDE1380
   
    It is a non-recoverable dynamic error if the unparsed-entity-public-id
    function is called when there is no context node, or when the root of the
    tree containing the context node is not a document node.
   
ERR XTDE1390
   
    It is a non-recoverable dynamic error if the value [supplied as the
    $property-name argument to the system-property function] is not a valid
    QName, or if there is no namespace declaration in scope for the prefix of
    the QName. If the processor is able to detect the error statically (for
    example, when the argument is supplied as a string literal), then the
    processor may optionally signal this as a static error.
   
ERR XTMM9000
   
    When a transformation is terminated by use of xsl:message terminate="yes",
    the effect is the same as when a non-recoverable dynamic error occurs
    during the transformation.
   
ERR XTDE1400
   
    It is a non-recoverable dynamic error if the argument [passed to the 
    function-available function] does not evaluate to a string that is a valid
    QName, or if there is no namespace declaration in scope for the prefix of
    the QName. If the processor is able to detect the error statically (for
    example, when the argument is supplied as a string literal), then the
    processor may optionally signal this as a static error.
   
ERR XTDE1420
   
    It is a non-recoverable dynamic error if the arguments supplied to a call
    on an extension function do not satisfy the rules defined for that
    particular extension function, or if the extension function reports an
    error, or if the result of the extension function cannot be converted to
    an XPath value.
   
ERR XTDE1425
   
    When backwards compatible behavior is enabled, it is a non-recoverable
    dynamic error to evaluate an extension function call if no implementation
    of the extension function is available.
   
ERR XTDE1428
   
    It is a non-recoverable dynamic error if the argument [passed to the 
    type-available function] does not evaluate to a string that is a valid 
    QName, or if there is no namespace declaration in scope for the prefix of
    the QName. If the processor is able to detect the error statically (for
    example, when the argument is supplied as a string literal), then the
    processor may optionally signal this as a static error.
   
ERR XTDE1440
   
    It is a non-recoverable dynamic error if the argument [passed to the 
    element-available function] does not evaluate to a string that is a valid 
    QName, or if there is no namespace declaration in scope for the prefix of
    the QName. If the processor is able to detect the error statically (for
    example, when the argument is supplied as a string literal), then the
    processor may optionally signal this as a static error.
   
ERR XTDE1450
   
    When a processor performs fallback for an extension instruction that is
    not recognized, if the instruction element has one or more xsl:fallback
    children, then the content of each of the xsl:fallback children must be
    evaluated; it is a non-recoverable dynamic error if it has no xsl:fallback
    children.
   
ERR XTDE1460
   
    It is a non-recoverable dynamic error if the effective value of the format
    attribute [of an xsl:result-document element] is not a valid lexical QName
    , or if it does not match the expanded-QName of an output definition in
    the stylesheet. If the processor is able to detect the error statically
    (for example, when the format attribute contains no curly brackets), then
    the processor may optionally signal this as a static error.
   
ERR XTDE1480
   
    It is a non-recoverable dynamic error to evaluate the xsl:result-document
    instruction in temporary output state.
   
ERR XTDE1490
   
    It is a non-recoverable dynamic error for a transformation to generate two
    or more final result trees with the same URI.
   
ERR XTRE1495
   
    It is a recoverable dynamic error for a transformation to generate two or
    more final result trees with URIs that identify the same physical
    resource. The optional recovery action is implementation-dependent, since
    it may be impossible for the processor to detect the error.
   
ERR XTRE1500
   
    It is a recoverable dynamic error for a stylesheet to write to an external
    resource and read from the same resource during a single transformation,
    whether or not the same URI is used to access the resource in both cases.
        Action: The optional recovery action is implementation-dependent:
    implementations are not required to detect the error condition. Note that
    if the error is not detected, it is undefined whether the document that is
    read from the resource reflects its state before or after the result tree
    is written.
   
ERR XTRE1620
   
    It is a recoverable dynamic error if an xsl:value-of or xsl:text
    instruction specifies that output escaping is to be disabled and the
    implementation does not support this.
        Action: The optional recovery action is to ignore the
    disable-output-escaping attribute.
   
ERR XTRE1630
   
    It is a recoverable dynamic error if an xsl:value-of or xsl:text
    instruction specifies that output escaping is to be disabled when writing
    to a final result tree that is not being serialized.
        Action: The optional recovery action is to ignore the
    disable-output-escaping attribute.
   
ERR XTDE1665
   
    A basic XSLT processor must raise a non-recoverable dynamic error if the
    input to the processor includes a node with a type annotation other than 
    xs:untyped or xs:untypedAtomic, or an atomic value of a type other than
    those which a basic XSLT processor supports.
   
F Checklist of Implementation-Defined Features (Non-Normative)

This appendix provides a summary of XSLT language features whose effect is
explicitly implementation-defined. The conformance rules (see 21 Conformance)
require vendors to provide documentation that explains how these choices have
been exercised.

 1. The way in which an XSLT processor is invoked, and the way in which values
    are supplied for the source document, starting node, stylesheet parameters
    , and base output URI, are implementation-defined. (See 2.3 Initiating a
    Transformation)
   
 2. The mechanisms for creating new extension instructions and extension
    functions are implementation-defined. (See 2.7 Extensibility)
   
 3. Where the specification provides a choice between signaling a dynamic
    error or recovering, the decision that is made (but not the recovery
    action itself) is implementation-defined. (See 2.9 Error Handling)
   
 4. It is implementation-defined whether type errors are signaled statically.
    (See 2.9 Error Handling)
   
 5. The set of namespaces that are specially recognized by the implementation
    (for example, for user-defined data elements, and extension attributes) is
    implementation-defined. (See 3.6.2 User-defined Data Elements)
   
 6. The effect of user-defined data elements whose name is in a namespace
    recognized by the implementation is implementation-defined. (See 3.6.2
    User-defined Data Elements)
   
 7. It is implementation-defined whether an XSLT 2.0 processor supports
    backwards-compatible behavior. (See 3.8 Backwards-Compatible Processing)
   
 8. It is implementation-defined what forms of URI reference are acceptable in
    the href attribute of the xsl:include and xsl:import elements, for
    example, the URI schemes that may be used, the forms of fragment
    identifier that may be used, and the media types that are supported. (See 
    3.10.1 Locating Stylesheet Modules)
   
 9. An implementation may define mechanisms, above and beyond 
    xsl:import-schema that allow schema components such as type definitions to
    be made available within a stylesheet. (See 3.13 Built-in Types)
   
10. It is implementation-defined which versions of XML and XML Namespaces (1.0
    and/or 1.1) are supported. (See 4.1 XML Versions)
   
11. Limits on the value space of primitive data types, where not fixed by [XML
    Schema Part 2], are implementation-defined. (See 4.6 Limits)
   
12. The implicit timezone for a transformation is implementation-defined. (See
    5.4.3.2 Other components of the XPath Dynamic Context)
   
13. If an xml:id attribute that has not been subjected to attribute value
    normalization is copied from a source tree to a result tree, it is
    implementation-defined whether attribute value normalization will be
    applied during the copy process. (See 11.9.1 Shallow Copy)
   
14. The numbering sequences supported by the xsl:number instructions, beyond
    those defined in this specification, are implementation-defined. (See 12.3
    Number to String Conversion Attributes)
   
15. There may be implementation-defined upper bounds on the numbers that can
    be formatted by xsl:number using any particular numbering sequence. (See 
    12.3 Number to String Conversion Attributes)
   
16. The set of languages for which numbering is supported by xsl:number, and
    the method of choosing a default language, are implementation-defined.
    (See 12.3 Number to String Conversion Attributes)
   
17. If the data-type attribute of the xsl:sort element has a value other than
    text or number, the effect is implementation-defined. (See 13.1.2
    Comparing Sort Key Values)
   
18. The facilities for defining collations and allocating URIs to identify
    them are implementation-defined. (See 13.1.3 Sorting Using Collations)
   
19. The algorithm used by xsl:sort to locate a collation, given the values of
    the lang and case-order attributes, is implementation-defined. (See 13.1.3
    Sorting Using Collations)
   
20. The set of media types recognized by the processor, for the purpose of
    interpreting fragment identifiers in URI references passed to the document
    function, is implementation-defined. (See 16.1 Multiple Source Documents)
   
21. The set of encodings recognized by the unparsed-text function, other than
    utf-8 and utf-16, is implementation-defined. (See 16.2 Reading Text Files)
   
22. If no encoding is specified on a call to the unparsed-text function, the
    processor may use implementation-defined heuristics to determine the
    likely encoding. (See 16.2 Reading Text Files)
   
23. The set of languages, calendars, and countries that are supported in the 
    date formatting functions is implementation-defined. If any of these
    arguments is omitted or set to an empty sequence, the default is
    implementation-defined. (See 16.5.2 The Language, Calendar, and Country
    Arguments)
   
24. The choice of the names and abbreviations used in any given language for
    calendar units such as days of the week and months of the year is 
    implementation-defined. (See 16.5.2 The Language, Calendar, and Country
    Arguments)
   
25. The values returned by the system-property function, and the names of the
    additional properties that are recognized, are implementation-defined.
    (See 16.6.5 system-property)
   
26. The destination and formatting of messages written using the xsl:message
    instruction are implementation-defined. (See 17 Messages)
   
27. The effect of an extension function returning a string containing
    characters that are not legal in XML is implementation-defined. (See 
    18.1.2 Calling Extension Functions)
   
28. The way in which external objects are represented in the type system is
    implementation-defined. (See 18.1.3 External Objects)
   
29. The way in which a final result tree is delivered to an application is
    implementation-defined. (See 19 Final Result Trees)
   
30. Implementations may provide additional mechanisms allowing users to define
    the way in which final result trees are processed. (See 19.1 Creating
    Final Result Trees)
   
31. If serialization is supported, then the location to which a final result
    tree is serialized is implementation-defined, subject to the constraint
    that relative URIs used to reference one tree from another remain valid.
    (See 20 Serialization)
   
32. The default value of the encoding attribute of the xsl:output element is
    implementation-defined. (See 20 Serialization)
   
33. It is implementation-defined which versions of XML, HTML, and XHTML are
    supported in the version attribute of the xsl:output declaration. (See 20
    Serialization)
   
34. The default value of the byte-order-mark serialization parameter is
    implementation-defined in the case of UTF-8 encoding. (See 20
    Serialization)
   
35. It is implementation-defined whether, and under what circumstances,
    disabling output escaping is supported. (See 20.2 Disabling Output
    Escaping)
   
G Schema for XSLT Stylesheets (Non-Normative)

The following schema describes the structure of an XSLT stylesheet module. It
does not define all the constraints that apply to a stylesheet (for example,
it does not attempt to define a data type that precisely represents attributes
containing XPath expressions). However, every valid stylesheet module conforms
to this schema, unless it contains elements that invoke 
forwards-compatible-behavior.

A copy of this schema is available at 
http://www.w3.org/2007/schema-for-xslt20.xsd

<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<xs:annotation>
  <xs:documentation>
  
    This is a schema for XSLT 2.0 stylesheets.
    
    It defines all the elements that appear in the XSLT namespace; it also
    provides hooks that allow the inclusion of user-defined literal result elements,
    extension instructions, and top-level data elements.
    
    The schema is derived (with kind permission) from a schema for XSLT 1.0 stylesheets
    produced by Asir S Vedamuthu of WebMethods Inc.
    
    This schema is available for use under the conditions of the W3C Software License
    published at http://www.w3.org/Consortium/Legal/copyright-software-19980720
    
    The schema is organized as follows:
    
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
    PART B: definitions of individual XSLT elements
    PART C: definitions for literal result elements
    PART D: definitions of simple types used in attribute definitions
    
    This schema does not attempt to define all the constraints that apply to a valid
    XSLT 2.0 stylesheet module. It is the intention that all valid stylesheet modules 
    should conform to this schema; however, the schema is non-normative and in the event 
    of any conflict, the text of the Recommendation takes precedence.

    This schema does not implement the special rules that apply when a stylesheet
    has sections that use forwards-compatible-mode. In this mode, setting version="3.0"
    allows elements from the XSLT namespace to be used that are not defined in XSLT 2.0.

    Simplified stylesheets (those with a literal result element as the outermost element)
    will validate against this schema only if validation starts in lax mode.
    
    This version is dated 2005-02-11
    Authors: Michael H Kay, Saxonica Limited
             Jeni Tennison, Jeni Tennison Consulting Ltd.
    
  </xs:documentation>
</xs:annotation>   
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
 
<!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
-->
      
<xs:import namespace="http://www.w3.org/XML/1998/namespace" 
  schemaLocation="http://www.w3.org/2001/xml.xsd"/>

<!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported
-->
  
<xs:import namespace="http://www.w3.org/2001/XMLSchema"
                  schemaLocation="http://www.w3.org/2001/XMLSchema.xsd"/>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<xs:annotation>
  <xs:documentation>
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
  </xs:documentation>
</xs:annotation>   
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<xs:complexType name="generic-element-type" mixed="true">
  <xs:attribute name="default-collation" type="xsl:uri-list"/>
  <xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/>
  <xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/>
  <xs:attribute name="use-when" type="xsl:expression"/>
  <xs:attribute name="xpath-default-namespace" type="xs:anyURI"/>
  <xs:anyAttribute namespace="##other" processContents="lax"/>
</xs:complexType>

<xs:complexType name="versioned-element-type" mixed="true">
  <xs:complexContent>
    <xs:extension base="xsl:generic-element-type">    
      <xs:attribute name="version" type="xs:decimal" use="optional"/>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

<xs:complexType name="element-only-versioned-element-type" mixed="false">
  <xs:complexContent>
    <xs:restriction base="xsl:versioned-element-type">
      <xs:anyAttribute namespace="##other" processContents="lax"/>
    </xs:restriction>
  </xs:complexContent>
</xs:complexType>

<xs:complexType name="sequence-constructor">
  <xs:complexContent mixed="true">
    <xs:extension base="xsl:versioned-element-type">    
      <xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/>
    </xs:extension>
  </xs:complexContent>
</xs:complexType>

<xs:group name="sequence-constructor-group">
  <xs:choice>
    <xs:element ref="xsl:variable"/>
    <xs:element ref="xsl:instruction"/>
    <xs:group ref="xsl:result-elements"/>
  </xs:choice>
</xs:group>

<xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/>

<xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<xs:annotation>
  <xs:documentation>
    PART B: definitions of individual XSLT elements    
    Elements are listed in alphabetical order.    
  </xs:documentation>
</xs:annotation>   
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<xs:element name="analyze-string" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:matching-substring" minOccurs="0"/>
          <xs:element ref="xsl:non-matching-substring" minOccurs="0"/>
          <xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="select" type="xsl:expression" use="required"/>
        <xs:attribute name="regex" type="xsl:avt" use="required"/>
        <xs:attribute name="flags" type="xsl:avt" default=""/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="apply-imports" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="apply-templates" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="xsl:sort"/>
          <xs:element ref="xsl:with-param"/>
        </xs:choice>
        <xs:attribute name="select" type="xsl:expression" default="child::node()"/>
        <xs:attribute name="mode" type="xsl:mode"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="attribute" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:avt" use="required"/>
        <xs:attribute name="namespace" type="xsl:avt"/>
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="separator" type="xsl:avt"/>   
        <xs:attribute name="type" type="xsl:QName"/>
        <xs:attribute name="validation" type="xsl:validation-type"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>        

<xs:element name="attribute-set" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="xsl:attribute"/>
        </xs:sequence>
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="call-template" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xsl:QName" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="character-map" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="use-character-maps" type="xsl:QNames" default=""/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="choose" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:when" maxOccurs="unbounded"/>
          <xs:element ref="xsl:otherwise" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="comment" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="select" type="xsl:expression"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="copy" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/>
        <xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/>
        <xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/>
        <xs:attribute name="type" type="xsl:QName"/>
        <xs:attribute name="validation" type="xsl:validation-type"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="copy-of" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:attribute name="select" type="xsl:expression" use="required"/>
        <xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/>
        <xs:attribute name="type" type="xsl:QName"/>
        <xs:attribute name="validation" type="xsl:validation-type"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="decimal-format" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:attribute name="name" type="xsl:QName"/>
        <xs:attribute name="decimal-separator" type="xsl:char" default="."/>
        <xs:attribute name="grouping-separator" type="xsl:char" default=","/>
        <xs:attribute name="infinity" type="xs:string" default="Infinity"/>
        <xs:attribute name="minus-sign" type="xsl:char" default="-"/>
        <xs:attribute name="NaN" type="xs:string" default="NaN"/>
        <xs:attribute name="percent" type="xsl:char" default="%"/>
        <xs:attribute name="per-mille" type="xsl:char" default="&#x2030;"/>
        <xs:attribute name="zero-digit" type="xsl:char" default="0"/>
        <xs:attribute name="digit" type="xsl:char" default="#"/>
        <xs:attribute name="pattern-separator" type="xsl:char" default=";"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="element" substitutionGroup="xsl:instruction">
  <xs:complexType mixed="true">
    <xs:complexContent>
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:avt" use="required"/>
        <xs:attribute name="namespace" type="xsl:avt"/>
        <xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/>
        <xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/>
        <xs:attribute name="type" type="xsl:QName"/>
        <xs:attribute name="validation" type="xsl:validation-type"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/>

<xs:element name="for-each" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/>
          <xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="select" type="xsl:expression" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="for-each-group" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/>
          <xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="select" type="xsl:expression" use="required"/>
        <xs:attribute name="group-by" type="xsl:expression"/>
        <xs:attribute name="group-adjacent" type="xsl:expression"/>            
        <xs:attribute name="group-starting-with" type="xsl:pattern"/>            
        <xs:attribute name="group-ending-with" type="xsl:pattern"/>            
        <xs:attribute name="collation" type="xs:anyURI"/>            
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="function" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/>
          <xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="override" type="xsl:yes-or-no" default="yes"/>
        <xs:attribute name="as" type="xsl:sequence-type" default="item()*"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="if" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="test" type="xsl:expression" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="import">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:attribute name="href" type="xs:anyURI" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="import-schema" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:sequence>
          <xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute name="namespace" type="xs:anyURI"/>
        <xs:attribute name="schema-location" type="xs:anyURI"/>                  
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="include" substitutionGroup="xsl:declaration">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="xsl:element-only-versioned-element-type">
          <xs:attribute name="href" type="xs:anyURI" use="required"/>
        </xs:extension>
      </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="key" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="match" type="xsl:pattern" use="required"/>
        <xs:attribute name="use" type="xsl:expression"/>
        <xs:attribute name="collation" type="xs:anyURI"/>               
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="matching-substring" type="xsl:sequence-constructor"/>

<xs:element name="message" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="terminate" type="xsl:avt" default="no"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="namespace" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:avt" use="required"/>
        <xs:attribute name="select" type="xsl:expression"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="namespace-alias" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default" use="required"/>
        <xs:attribute name="result-prefix" type="xsl:prefix-or-default" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="next-match" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="xsl:with-param"/>
          <xs:element ref="xsl:fallback"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="non-matching-substring" type="xsl:sequence-constructor"/>

<xs:element name="number" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:attribute name="value" type="xsl:expression"/>
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="level" type="xsl:level" default="single"/>
        <xs:attribute name="count" type="xsl:pattern"/>
        <xs:attribute name="from" type="xsl:pattern"/>
        <xs:attribute name="format" type="xsl:avt" default="1"/>
        <xs:attribute name="lang" type="xsl:avt"/>
        <xs:attribute name="letter-value" type="xsl:avt"/>
        <xs:attribute name="ordinal" type="xsl:avt"/>        
        <xs:attribute name="grouping-separator" type="xsl:avt"/>
        <xs:attribute name="grouping-size" type="xsl:avt"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="otherwise" type="xsl:sequence-constructor"/>

<xs:element name="output" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:generic-element-type">
        <xs:attribute name="name" type="xsl:QName"/>
        <xs:attribute name="method" type="xsl:method"/>
        <xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/>
        <xs:attribute name="cdata-section-elements" type="xsl:QNames"/>
        <xs:attribute name="doctype-public" type="xs:string"/>
        <xs:attribute name="doctype-system" type="xs:string"/>
        <xs:attribute name="encoding" type="xs:string"/>
        <xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/>
        <xs:attribute name="include-content-type" type="xsl:yes-or-no"/>
        <xs:attribute name="indent" type="xsl:yes-or-no"/>
        <xs:attribute name="media-type" type="xs:string"/>
        <xs:attribute name="normalization-form" type="xs:NMTOKEN"/>
        <xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/>
        <xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/>
        <xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/>
        <xs:attribute name="use-character-maps" type="xsl:QNames"/>
        <xs:attribute name="version" type="xs:NMTOKEN"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="output-character">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:attribute name="character" type="xsl:char" use="required"/>
        <xs:attribute name="string" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="param">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="as" type="xsl:sequence-type"/>
        <xs:attribute name="required" type="xsl:yes-or-no"/>
        <xs:attribute name="tunnel" type="xsl:yes-or-no"/>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="perform-sort" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/>
          <xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="select" type="xsl:expression"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="preserve-space" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:attribute name="elements" type="xsl:nametests" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="processing-instruction" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:avt" use="required"/>
        <xs:attribute name="select" type="xsl:expression"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="result-document" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="format" type="xsl:avt"/>
        <xs:attribute name="href" type="xsl:avt"/>
        <xs:attribute name="type" type="xsl:QName"/>
        <xs:attribute name="validation" type="xsl:validation-type"/>
        <xs:attribute name="method" type="xsl:avt"/>
        <xs:attribute name="byte-order-mark" type="xsl:avt"/>
        <xs:attribute name="cdata-section-elements" type="xsl:avt"/>
        <xs:attribute name="doctype-public" type="xsl:avt"/>
        <xs:attribute name="doctype-system" type="xsl:avt"/>
        <xs:attribute name="encoding" type="xsl:avt"/>
        <xs:attribute name="escape-uri-attributes" type="xsl:avt"/>
        <xs:attribute name="include-content-type" type="xsl:avt"/>
        <xs:attribute name="indent" type="xsl:avt"/>
        <xs:attribute name="media-type" type="xsl:avt"/>
        <xs:attribute name="normalization-form" type="xsl:avt"/>
        <xs:attribute name="omit-xml-declaration" type="xsl:avt"/>
        <xs:attribute name="standalone" type="xsl:avt"/>
        <xs:attribute name="undeclare-prefixes" type="xsl:avt"/>
        <xs:attribute name="use-character-maps" type="xsl:QNames"/>
        <xs:attribute name="output-version" type="xsl:avt"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="sequence" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="as" type="xsl:sequence-type"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="sort">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="select" type="xsl:expression"/>  
        <xs:attribute name="lang" type="xsl:avt"/>        
        <xs:attribute name="data-type" type="xsl:avt" default="text"/>        
        <xs:attribute name="order" type="xsl:avt" default="ascending"/>        
        <xs:attribute name="case-order" type="xsl:avt"/>
        <xs:attribute name="collation" type="xsl:avt"/>
        <xs:attribute name="stable" type="xsl:yes-or-no"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="strip-space" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:element-only-versioned-element-type">
        <xs:attribute name="elements" type="xsl:nametests" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="stylesheet" substitutionGroup="xsl:transform"/>

<xs:element name="template" substitutionGroup="xsl:declaration">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:versioned-element-type">
        <xs:sequence>
          <xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/>
          <xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="match" type="xsl:pattern"/>
        <xs:attribute name="priority" type="xs:decimal"/>
        <xs:attribute name="mode" type="xsl:modes"/>
        <xs:attribute name="name" type="xsl:QName"/>
        <xs:attribute name="as" type="xsl:sequence-type" default="item()*"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:complexType name="text-element-base-type">
  <xs:simpleContent>
    <xs:restriction base="xsl:versioned-element-type">
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
      <xs:anyAttribute namespace="##other" processContents="lax"/>
    </xs:restriction>
  </xs:simpleContent>
</xs:complexType>

<xs:element name="text" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:simpleContent>
      <xs:extension base="xsl:text-element-base-type">
        <xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
</xs:element>

<xs:complexType name="transform-element-base-type">
  <xs:complexContent>
    <xs:restriction base="xsl:element-only-versioned-element-type">
      <xs:attribute name="version" type="xs:decimal" use="required"/>
      <xs:anyAttribute namespace="##other" processContents="lax"/>
    </xs:restriction>
  </xs:complexContent>
</xs:complexType>

<xs:element name="transform">
  <xs:complexType>
    <xs:complexContent>
      <xs:extension base="xsl:transform-element-base-type">
        <xs:sequence>
          <xs:element ref="xsl:import" minOccurs="0" maxOccurs="unbounded"/>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="xsl:declaration"/>
            <xs:element ref="xsl:variable"/>
            <xs:element ref="xsl:param"/>              
            <xs:any namespace="##other" processContents="lax"/> <!-- weaker than XSLT 1.0 -->
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/>
        <xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type" default="unspecified"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="value-of" substitutionGroup="xsl:instruction">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="separator" type="xsl:avt"/>            
        <xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="variable">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="select" type="xsl:expression" use="optional"/>
        <xs:attribute name="as" type="xsl:sequence-type" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="when">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="test" type="xsl:expression" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<xs:element name="with-param">
  <xs:complexType>
    <xs:complexContent mixed="true">
      <xs:extension base="xsl:sequence-constructor">
        <xs:attribute name="name" type="xsl:QName" use="required"/>
        <xs:attribute name="select" type="xsl:expression"/>
        <xs:attribute name="as" type="xsl:sequence-type"/>
        <xs:attribute name="tunnel" type="xsl:yes-or-no"/>   
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:element>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<xs:annotation>
  <xs:documentation>
    PART C: definition of literal result elements
    
    There are three ways to define the literal result elements
    permissible in a stylesheet.
    
    (a) do nothing. This allows any element to be used as a literal
        result element, provided it is not in the XSLT namespace
    
    (b) declare all permitted literal result elements as members
        of the xsl:literal-result-element substitution group
        
    (c) redefine the model group xsl:result-elements to accommodate
        all permitted literal result elements.
        
    Literal result elements are allowed to take certain attributes
    in the XSLT namespace. These are defined in the attribute group
    literal-result-element-attributes, which can be included in the
    definition of any literal result element.
    
  </xs:documentation>
</xs:annotation>   
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<xs:element name="literal-result-element" abstract="true" type="xs:anyType"/>

<xs:attributeGroup name="literal-result-element-attributes">
  <xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/>
  <xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/>
  <xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/>
  <xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/>    
  <xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/>
  <xs:attribute name="use-attribute-sets" form="qualified" type="xsl:QNames" default=""/>
  <xs:attribute name="use-when" form="qualified" type="xsl:expression"/>
  <xs:attribute name="version" form="qualified" type="xs:decimal"/>
  <xs:attribute name="type" form="qualified" type="xsl:QName"/>
  <xs:attribute name="validation" form="qualified" type="xsl:validation-type"/>
</xs:attributeGroup>

<xs:group name="result-elements">
  <xs:choice>
    <xs:element ref="xsl:literal-result-element"/>
    <xs:any namespace="##other" processContents="lax"/>
    <xs:any namespace="##local" processContents="lax"/>
  </xs:choice>
</xs:group>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<xs:annotation>
  <xs:documentation>
    PART D: definitions of simple types used in stylesheet attributes 
  </xs:documentation>
</xs:annotation>   
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<xs:simpleType name="avt">
  <xs:annotation>
    <xs:documentation>
      This type is used for all attributes that allow an attribute value template.
      The general rules for the syntax of attribute value templates, and the specific
      rules for each such attribute, are described in the XSLT 2.0 Recommendation.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string"/>
</xs:simpleType>

<xs:simpleType name="char">
  <xs:annotation>
    <xs:documentation>
      A string containing exactly one character.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
    <xs:length value="1"/>
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="expression">
  <xs:annotation>
    <xs:documentation>
      An XPath 2.0 expression.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:token">
    <xs:pattern value=".+"/>
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="input-type-annotations-type">
  <xs:annotation>
    <xs:documentation>
      Describes how type annotations in source documents are handled.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:token">
    <xs:enumeration value="preserve"/>
    <xs:enumeration value="strip"/>   
    <xs:enumeration value="unspecified"/>        
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="level">
  <xs:annotation>
    <xs:documentation>
      The level attribute of xsl:number: 
      one of single, multiple, or any.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:NCName">
    <xs:enumeration value="single"/>
    <xs:enumeration value="multiple"/>
    <xs:enumeration value="any"/>
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="mode">
  <xs:annotation>
    <xs:documentation>
      The mode attribute of xsl:apply-templates: 
      either a QName, or #current, or #default.
    </xs:documentation>
  </xs:annotation>
  <xs:union memberTypes="xsl:QName">
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="#default"/>
        <xs:enumeration value="#current"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:union>
</xs:simpleType>

<xs:simpleType name="modes">
  <xs:annotation>
    <xs:documentation>
      The mode attribute of xsl:template: 
      either a list, each member being either a QName or #default;
      or the value #all
    </xs:documentation>
  </xs:annotation>
  <xs:union>
    <xs:simpleType>
      <xs:list>
        <xs:simpleType>
          <xs:union memberTypes="xsl:QName">
            <xs:simpleType>
              <xs:restriction base="xs:token">
                <xs:enumeration value="#default"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:union>
        </xs:simpleType>
      </xs:list>
    </xs:simpleType>
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="#all"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:union>
</xs:simpleType>

<xs:simpleType name="nametests">
  <xs:annotation>
    <xs:documentation>
      A list of NameTests, as defined in the XPath 2.0 Recommendation.
      Each NameTest is either a QName, or "*", or "prefix:*", or "*:localname"
    </xs:documentation>
  </xs:annotation>
  <xs:list>
    <xs:simpleType>
      <xs:union memberTypes="xsl:QName">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="*"/>
          </xs:restriction>
        </xs:simpleType>
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:pattern value="\i\c*:\*"/>
            <xs:pattern value="\*:\i\c*"/>            
          </xs:restriction>
        </xs:simpleType>
      </xs:union>
    </xs:simpleType>
  </xs:list>
</xs:simpleType>

<xs:simpleType name="prefixes">
  <xs:list itemType="xs:NCName"/>
</xs:simpleType>

<xs:simpleType name="prefix-list-or-all">
  <xs:union memberTypes="xsl:prefix-list">
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="#all"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:union>
</xs:simpleType>
      
<xs:simpleType name="prefix-list">
  <xs:list itemType="xsl:prefix-or-default"/>
</xs:simpleType>

<xs:simpleType name="method">
  <xs:annotation>
    <xs:documentation>
      The method attribute of xsl:output:
      Either one of the recognized names "xml", "xhtml", "html", "text",
      or a QName that must include a prefix.
    </xs:documentation>
  </xs:annotation>
  <xs:union>
    <xs:simpleType>
      <xs:restriction base="xs:NCName">
        <xs:enumeration value="xml"/>
        <xs:enumeration value="xhtml"/>
        <xs:enumeration value="html"/>
        <xs:enumeration value="text"/>
      </xs:restriction>
    </xs:simpleType>
    <xs:simpleType>
      <xs:restriction base="xsl:QName">
        <xs:pattern value="\c*:\c*"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:union>
</xs:simpleType>

<xs:simpleType name="pattern">
  <xs:annotation>
    <xs:documentation>
      A match pattern as defined in the XSLT 2.0 Recommendation.
      The syntax for patterns is a restricted form of the syntax for
      XPath 2.0 expressions.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xsl:expression"/>
</xs:simpleType>

<xs:simpleType name="prefix-or-default">
  <xs:annotation>
    <xs:documentation>
      Either a namespace prefix, or #default.
      Used in the xsl:namespace-alias element.
    </xs:documentation>
  </xs:annotation>
  <xs:union memberTypes="xs:NCName">
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="#default"/>
      </xs:restriction>
    </xs:simpleType>
  </xs:union>
</xs:simpleType>

<xs:simpleType name="QNames">
  <xs:annotation>
    <xs:documentation>
      A list of QNames.
      Used in the [xsl:]use-attribute-sets attribute of various elements,
      and in the cdata-section-elements attribute of xsl:output
    </xs:documentation>
  </xs:annotation>
  <xs:list itemType="xsl:QName"/>          
</xs:simpleType>

<xs:simpleType name="QName">
  <xs:annotation>
    <xs:documentation>
      A QName.
      This schema does not use the built-in type xs:QName, but rather defines its own
      QName type. Although xs:QName would define the correct validation on these attributes,
      a schema processor would expand unprefixed QNames incorrectly when constructing the PSVI,
      because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be in
      the default namespace, which is not the correct assumption for XSLT.
      The data type is defined as a restriction of the built-in type Name, restricted
      so that it can only contain one colon which must not be the first or last character.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:Name">
    <xs:pattern value="([^:]+:)?[^:]+"/>      
  </xs:restriction>        
</xs:simpleType>

<xs:simpleType name="sequence-type">
  <xs:annotation>
    <xs:documentation>
      The description of a data type, conforming to the
      SequenceType production defined in the XPath 2.0 Recommendation
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:token">
    <xs:pattern value=".+"/>      
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="uri-list">
  <xs:list itemType="xs:anyURI"/>
</xs:simpleType>

<xs:simpleType name="validation-strip-or-preserve">
  <xs:annotation>
    <xs:documentation>
      Describes different ways of type-annotating an element or attribute.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xsl:validation-type">
    <xs:enumeration value="preserve"/>
    <xs:enumeration value="strip"/>    
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="validation-type">
  <xs:annotation>
    <xs:documentation>
      Describes different ways of type-annotating an element or attribute.
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:token">
    <xs:enumeration value="strict"/>
    <xs:enumeration value="lax"/>
    <xs:enumeration value="preserve"/>
    <xs:enumeration value="strip"/>    
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="yes-or-no">
  <xs:annotation>
    <xs:documentation>
      One of the values "yes" or "no".
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:token">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="yes-or-no-or-omit">
  <xs:annotation>
    <xs:documentation>
      One of the values "yes" or "no" or "omit".
    </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:token">
    <xs:enumeration value="yes"/>
    <xs:enumeration value="no"/>
    <xs:enumeration value="omit"/>
  </xs:restriction>
</xs:simpleType>

</xs:schema>
*** n3								     :src:n3:
**** ttl
*** w3-rec								:doc:
#+begin_src elisp
(w3m-find-file index w3-rec)
#+end_src

*** unsorted
**** integrated security is often better than afterthoguth	    :defense:
Captured [2014-05-30 Fri 13:14]
  Title: Backdoor in Call Monitoring, Surveillance Gear
  Date: Wed, 28 May 2014 14:40:59 PDT
  Feed: Krebs on Security
  Link: http://krebsonsecurity.co[...]toring-surveillance-gear/
  
  If your company's core business is making software designed to help
  first responders and police record and intercept phone calls, it's
  probably a good idea to ensure the product isn't so full of security
  holes that it allows trivial access by unauthorized users.
  Unfortunately, even companies working in this sensitive space fall
  victim to the classic blunder that eventually turns most software into
  Swiss Cheese: Trying to bolt on security only after the product has
  shipped.

**** reification						  :rdf:debug:
     WN: The noun reification has 2 senses (no senses from
     tagged texts)
***** 1. hypostatization, hypostatisation, reification 
      -- (regarding something abstract as a material thing)
***** 2. depersonalization, depersonalisation, reification 
      -- (representing a human being as a physical thing
      deprived of personal qualities or individuality;
      "according to Marx, treating labor as a commodity
      exemplified the reification of the individual")
**** virtualisation and network-attached storage			:rdf:
**** ubiquitous and organic error correction			  :rdf:debug:
     Are error correcting algorithms and heuristics organic to
     our observations?  Are they built into the math we use to
     describe reality, automatically and without conscious
     purpose? Do these error correcting algorithms enhance or
     obscure our vision?  Do they need revision themselves, in
     a sort of recursive way? Do our corrections require
     corrections? Who watches the watchers?
**** interface								:rdf:
***** Appearance 

      * Themes (aka Workspace) (Widget Style, Desktop
       	theme, Cursor theme) 

      * Style (Window decoration, Splash screen, Gtk) 

      * Colors 

      * Font 

      * Emoticons 

      (Remark: Jens Reuterberg proposed some kind of
      mega theme at the KDE forum, which sounds pretty
      nice. But all topics need some categories to
      keep the navigation consistent. Another point
      for discussion is where Widget Style belongs to:
      Theme or Style? Again, we should take care of
      balancing the structure.)

***** Workspace 

      * Window behavior (Desktop effects, Screen
       	Edges, Launch Feedback, Task switcher, KWin
       	Scripts, Window Rules) 

      * Notification (Applications, System Bell) 

      * Shortcuts and Gestures (Custom, Standard,
       	Global) 

      * Activities 

      (Remark: Can’t we just drop the beep support
      (aka System Bell)? Who owns and want to use an
      in-built speaker instead of jingles?)

***** Personalization 

      * Account Details (Password, Path, Wallet) 

      * Regional Settings (aka Locale)
       	(Country/Region, Language, Spell Checker) 

      * Standard Programs (Default Applications, File
       	Association, Desktop Search) 

      * Accessibility 

***** Networking 

      * (Network) Settings (Proxy, Preferences,
       	Certificates (aka SSL Preferences), +Network
       	Manager) 

      * Connectivity (Accounts aka (PIM) Personal
       	Information, Instant Messaging and VoIP,
       	Social Desktop, Web Shortcuts) 

      * Sharing 

      (Remark: Network Manager settings should get an
      own KCM, which is being in preparation right
      now. Secondly, it is questionable if PIM
      accounts should have a central configuration
      since it’s applied in Kontact only. And,
      apparently from the study results too, the
      organization of web shortcuts is difficult and
      could be improved by another wording.)

***** Hardware 

      * Input Devices (including Keyboard, Mouse,
       	Touchpad, Joystick, Remote Control, Camera) 

      * Display and Monitor (including Gamma) 

      * Removable Devices 

      * Printers 

      * Multimedia 

      * Device Actions 

      * Power management 

***** Software 

  * Bodega 

  * Adobe Flash Player 

  (Remark: Apparently, Bodega is just an idea for
  future improvements. The topic could be extended
  by the distribution specific software
  management.)

Based on this list we will outline an idea how to
get both simple access to a module and the full
set of features without introducing a further
navigation. Join the discussion at the KDE forum!
**** XDM instance syn value						:rdf:
      
     The term XDM instance is used, synonymously with the term value, to
     denote an unconstrained sequence of nodes and/or atomic values in the
     data model.

***** literal
      
      A literal is a direct syntactic representation of an atomic value.

***** thus
     
      A literal is a direct syntactic representation
      of an atomic XDM instance.

      literal == XDM instance == sequence
**** NO DUTY == Fish-Eye Door-Good-Mark-Y		      :defense:debug:
***** TODO NO DUTY rules nd-rules				  :src:debug:
    How would this look in prolog|xslt|xpath|spin|sparql?
#+begin_src *pseudocode*

(defn test for duty
(no-duty (seq (concat ((Line) (Intense Hand)) 
                      ((Out) (Out)) 
                      ((Door-Good-Mark-Y)))
         )))
#+end_src
#+begin_src n3
:no-duty :disjoint :evangelism .
#+end_src
#+begin_src *pseudocode*
test for (task|todo), 
     if none, ignore
     test for duty
test for duty, 
     if none, reject (task|todo)
#+end_src
**** fundamental limits on signal processing				:rdf:
**** error-correction							:rdf:
***** debug

debug is an interactive autoloaded Lisp function.

(debug &rest DEBUGGER-ARGS)

Enter debugger.  `c' returns from the debugger.
Arguments are mainly for use when this is called from the internals
of the evaluator.

You may call with no args, or you may pass nil as the first arg and
any other args you like.  In that case, the list of args after the
first will be printed into the backtrace buffer.
**** relay channel							:rdf:
**** information rate is the average entropy per symbol.		:rdf:
**** org-yaz-ac-predict[org]-complete mode?			  :rdf:elisp:
**** information theory is based on probability theory and statistics.	:rdf:
:information-theory owl:subproperty ( :probability-theory :statistics ) .
:logarithmic-base owl:subproperty ( :bit :nat :hartley ) .
:logarithmic-base :def """The choice of logarithmic base in the following formulae determines
 the unit of information entropy that is used. The most common unit of
 information is the bit, based on the binary logarithm. Other units
 include the nat, which is based on the natural logarithm, and the
 hartley, which is based on the common logarithm.""" .

**** arithmetization of analysis					:rdf:
***** axiomatize analysis using properties of the natural numbers
****** (ε, δ)-definition of limit
****** continuous functions
******* infinitesimals
***** Real numbers as cuts of rational numbers
***** Real and natural numbers have different cardinalities
***** (set-theory) (formal-logic)
***** Search for proofs of consistency
****** Result of discovery of paradoxes in informal set theory
****** 23 Hilbert problems
******* Continuum hypothesis (proof consistency of elementary arithmetic)
******** Respectively
******* produce a method that could decide 
       	whether a multivariate polynomial equation over the integers has
       	a solution
***** a procedure that would decide, 
      given a formalized mathematical statement, 
      whether the statement is true or false.
***** a proof that every set could be well-ordered
***** axiom of choice
****** challenged by discovered paradoxes in naive set theory
******* collection of all ordinal numbers cannot form a set
***** axioms for set theory
***** axiom of replacement
***** limitation of size
**** type-theory (principia-mathematica)				:rdf:
***** urelements
****** not needed
**** forcing used to establish independent results in set theory	:rdf:
**** first-order logic cannot control the cardinalities of infinite structures :rdf:
**** first-order formalizations of set theory have countable modes	:rdf:
**** completeness theorem						:rdf:
 completeness theorem, which establishes a correspondence between
 syntax and semantics in first-order logic

compactness theorem, demonstrating the finitary nature of first-order
logical consequence
incompleteness (in a different meaning of the word) of all
sufficiently strong, effective first-order theories
severe limitations on axiomatic foundations
a consistency proof of any sufficiently strong, effective axiom system
cannot be obtained in the system itself, if the system is consistent,
nor in any weaker system
consistency of arithmetic using a finitistic system together with a
principle of transfinite induction. Gentzen's result introduced the
ideas of cut elimination and proof-theoretic ordinals, which became
key tools in proof theory
consistency of classical arithmetic to that of intutitionistic
arithmetic in higher types
 bijection, injection, and surjection
tudy of computability came to be known as recursion theory
recursive definitions of functions
Turing machines
computable function 
robust enough to admit numerous independent characterizations
oncepts of relative computability
arithmetical hierarchy.
higher-order functionals
At its core, mathematical logic deals with mathematical concepts
expressed using formal logical systems
considering only expressions in a fixed formal language
propositional logic and first-order logic
second-order logic
infinitary logic
intuitionistic logic
First-order logic is a particular formal system of logic. Its syntax
involves only finite expressions as well-formed formulas, while its
semantics are characterized by the limitation of all quantifiers to a
fixed domain of discourse.
Impossible for a set of first-order axioms to characterize the natural
numbers, the real numbers, or any other infinite structure up to
isomorphism
equivalence between semantic and syntactic definitions of logical
consequence in first-order logic
lemma
a set of sentences has a model if and only if every finite subset has
a model
an inconsistent set of formulas must have a finite inconsistent subset
The completeness and compactness theorems allow for sophisticated
analysis of logical consequence in first-order logic and the
development of model theory, and they are a key reason for the
prominence of first-order logic in mathematics.
The first incompleteness theorem states that for any sufficiently
strong, effectively given logical system there exists a statement
which is true but not provable within that system.
or any sufficiently strong, effectively given logical system there
exists a statement which is true but not provable within that system
any sufficiently strong, consistent, effective first-order theory has
models that are not elementarily equivalent
no sufficiently strong, consistent, effective axiom system for
arithmetic can prove its own consistency
allow for formulas to provide an infinite amount of information
include a portion of set theory directly in their semantics
quantifiers may only be nested to finite depths
but formulas may have finite or countably infinite conjunctions and
disjunctions within them
(x=0) :disjoint (x=1) :disjoint (x=2) :disjoint ...
Higher-order logics allow for quantification not only of elements of
the domain of discourse, but subsets of the domain of discourse, sets
of such subsets, and other objects of higher type
rather than having a separate domain for each higher-type quantifier
to range over, the quantifiers instead range over all objects of the
appropriate type
higher-order logics are more expressive, allowing complete
axiomatizations of structures such as the natural numbers, they do not
satisfy analogues of the completeness and compactness theorems from
first-order logic
less amenable to proof-theoretic analysis
Another type of logics are fixed-point logics that allow inductive
definitions, like one writes for primitive recursive functions
constructive information can be recovered from intuitionistic proofs
describing a cumulative hierarchy of sets
objects such as the set of all sets at the cost of restrictions on its
set-existence axioms
axiom of choice
continuum hypothesis
given a collection of nonempty sets there is a single set C that
contains exactly one element from each set in the collection
large cardinals
determinacy
Here a theory is a set of formulas in a particular formal logic and
signature, while a model is a structure that gives a concrete
interpretation of the theory
Model theory is closely related to universal algebra and algebraic
geometry, although the methods of model theory focus more on logical
considerations than those fields
The set of all models of a particular theory is called an elementary
class; classical model theory seeks to determine the properties of
models in a particular elementary class, or determine whether certain
classes of structures form elementary classes.
The method of quantifier elimination can be used to show that
definable sets in particular theories cannot be too complicated
Tarski (1948) established quantifier elimination for real-closed
fields, a result which also shows the theory of the field of real
numbers is decidable. (He also noted that his methods were equally
applicable to algebraically closed fields of arbitrary
characteristic.) A modern subfield developing from this is concerned
with o-minimal structures.
quantifier elimination for real-closed fields
if a first-order theory in a countable language is categorical in some
uncountable cardinality, i.e. all models of this cardinality are
isomorphic, then it is categorical in all uncountable cardinalities.

**** trivial grammar problem					  :rdf:debug:
     "a complete theory with less than continuum many nonisomorphic
     countable models can have only countably many"
**** robust canonical class of computable functions		  :rdf:debug:
     a robust, canonical class of computable functions with numerous
     independent, equivalent characterizations using Turing machines, λ
     calculus, and other systems lattice of recursively enumerable sets
     Generalized recursion theory extends the ideas of recursion theory to
     computations that are no longer necessarily finite study of
     computability in higher types hyperarithmetical theory and α-recursion
     theory unsolvability of the halting problem, a result with far-ranging
     implications in both recursion theory and computer science Proof
     theory and constructive mathematics Computer science also contributes
     to mathematics by developing techniques for the automatic checking or
     even finding of proofs, such as automated theorem proving and logic
     programming.  automated-theorem-proving logic-programming The area
     directors, together with the IETF Chair, form the Internet Engineering
     Steering Group (IESG), which is responsible for the overall operation
     of the IETF.  The IETF is formally a part of the Internet Society.
**** "rough consensus and running code"			    :civil:rdf:debug:

Jari Arkko (2013– )[10] See also

    GADS Task Force
    Internet Architecture Board
    Internet Engineering Steering Group
    Internet Research Task Force
    Internet standard
    Request for Comments
    Standardization

http://ietf.org/

**** parsing expression grammar
 In computer science, a parsing expression grammar, or PEG, is a type
of analytic formal grammar, i.e. it describes a formal language in
terms of a set of rules for recognizing strings in the language. The
formalism was introduced by Bryan Ford in 2004[1] and is closely
related to the family of top-down parsing languages introduced in the
early 1970s. Syntactically, PEGs also look similar to context-free
grammars (CFGs), but they have a different interpretation: the choice
operator selects the first match in PEG, while it is ambiguous in
CFG. This is closer to how string recognition tends to be done in
practice, e.g. by a recursive descent parser.
It is conjectured that there exist context-free languages that cannot
be parsed by a PEG, but this is not yet proven.
The fundamental difference between context-free grammars and parsing
expression grammars is that the PEG's choice operator is ordered

there is more to creation than design

The following parsing expression grammar describes the classic non-context-free language \{ a^n b^n c^n : n \ge 1 \} :

S ← &(A 'c') 'a'+ B !('a'/'b'/'c')
A ← 'a' A? 'b'
B ← 'b' B? 'c'

The following recursive rule matches standard C-style if/then/else statements in such a way that the optional "else" clause always binds to the innermost "if", because of the implicit prioritization of the '/' operator. (In a context-free grammar, this construct yields the classic dangling else ambiguity.)

S ← 'if' C 'then' S 'else' S / 'if' C 'then' S
The parsing expression foo &(bar) matches and consumes the text "foo"
but only if it is followed by the text "bar". The parsing expression
foo !(bar) matches the text "foo" but only if it is not followed by
the text "bar". The expression !(a+ b) a matches a single "a" but only
if it is not part of an arbitrarily long sequence of a's followed by a
b.
Any parsing expression grammar can be converted directly into a
recursive descent parser
It is possible to obtain better performance for any parsing expression
grammar by converting its recursive descent parser into a packrat
parser, which always runs in linear time, at the cost of substantially
greater storage space requirements

A packrat parser[3] is a form of parser similar to a recursive descent
parser in construction, except that during the parsing process it
memoizes the intermediate results of all invocations of the mutually
recursive parsing functions, ensuring that each parsing function is
only invoked at most once at a given input position. Because of this
memoization, a packrat parser has the ability to parse many
context-free grammars and any parsing expression grammar (including
some that do not represent context-free languages) in linear time

**** quantification:						  :rdf:debug:
     A quantifier after a token (such as a character) or group specifies
     how often that preceding element is allowed to occur. The most
     common quantifiers are the question mark ?, the asterisk *
     (derived from the Kleene star), and the plus sign + (Kleene plus).

       ? 	The question mark indicates there is zero or one of the preceding element. For example, colou?r matches both "color" and "colour".
       * 	The asterisk indicates there is zero or more of the preceding element. For example, ab*c matches "ac", "abc", "abbc", "abbbc", and so on.
       + 	The plus sign indicates there is one or more of the preceding element. For example, ab+c matches "abc", "abbc", "abbbc", and so on, but not "ac".
***** SeeAlso quantifier elimination
   "eliminate specifications of preceding element occurance"
   "dont ask how many times you have to repeat yourself"
These constructions can be combined to form arbitrarily complex
   expressions, much like one can construct arithmetical expressions
   from numbers and the operations +, −, ×, and ÷
For example, H(ae?|ä)ndel and H(a|ae|ä)ndel are both valid patterns
   which match the same strings as the earlier example, H(ä|ae?)ndel.

Regular expressions describe regular languages in formal language
theory. They have the same expressive power as regular grammars.

Given a finite alphabet Σ, the following constants are defined as regular expressions:

    (empty set) ∅ denoting the set ∅.
    (empty string) ε denoting the set containing only the "empty" string, which has no characters at all.
    (literal character) a in Σ denoting the set containing only the character a.

Given regular expressions R and S, the following operations over them are defined to produce regular expressions:

    (concatenation) RS denotes the set of strings that can be obtained by concatenating a string in R and a string in S. For example {"ab", "c"}{"d", "ef"} = {"abd", "abef", "cd", "cef"}.
    (alternation) R | S denotes the set union of sets described by R and S. For example, if R describes {"ab", "c"} and S describes {"ab", "d", "ef"}, expression R | S describes {"ab", "c", "d", "ef"}.
    (Kleene star) R* denotes the smallest superset of set described by R that contains ε and is closed under string concatenation. This is the set of all strings that can be made by concatenating any finite number (including zero) of strings from set described by R. For example, {"0","1"}* is the set of all finite binary strings (including the empty string), and {"ab", "c"}* = {ε, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "abcab", ... }.

To avoid parentheses it is assumed that the Kleene star has the
highest priority, then concatenation and then alternation. If there is
no ambiguity then parentheses may be omitted. For example, (ab)c can
be written as abc, and a|(b(c*)) can be written as a|bc*. Many
textbooks use the symbols ∪, +, or ∨ for alternation instead of the
vertical bar.

egular expressions in this sense can express the regular languages,
exactly the class of languages accepted by deterministic finite
automata.

ome classes of regular languages can only be described by
deterministic finite automata whose size grows exponentially in the
size of the shortest equivalent regular expressions. 

uckily, there is a simple mapping from regular expressions to the more general nondeterministic finite automata (NFAs) that does not lead to such a blowup in size; for this reason NFAs are often used as alternative representations of regular languages. NFAs are a simple variation of the type-3 grammars of the Chomsky hierarchy.[16]

Finally, it is worth noting that many real-world "regular expression"
engines implement features that cannot be described by the regular
expressions in the sense of formal language theory ... 

The oldest and fastest relies on a result in formal language theory
that allows every nondeterministic finite automaton (NFA) to be
transformed into a deterministic finite automaton (DFA).

An alternative approach is to simulate the NFA directly, essentially
building each DFA state on demand and then discarding it at the next
step. This keeps the DFA implicit and avoids the exponential
construction cost, but running cost rises to O(m n).

The explicit approach is called the DFA algorithm and the implicit
approach the NFA algorithm. 

 Regular expression Denial of Service

In Arabic scripts, insensitivity to initial, medial, final, and
isolated position may be desired.
**** replete								:rdf:
dict replete
4 definitions found

From The Collaborative International Dictionary of English v.0.48 [gcide]:

  Replete \Re*plete"\, v. t.
     To fill completely, or to satiety. [R.]
     [1913 Webster]

From The Collaborative International Dictionary of English v.0.48 [gcide]:

  Replete \Re*plete"\ (r?-pl?t"), a. [L. repletus, p. p. of
     replere to fill again, fill up; pref. re- re- + plere to
     fill, akin to plenus full: cf. F. replet corpulent. See
     {Plenty}, {Replenish}.]
     Filled again; completely filled; full; charged; abounding.
     "His words replete with guile." --Milton.
     [1913 Webster]
  
           When he of wine was replet at his feast. --Chaucer.
     [1913 Webster]
  
           In heads replete with thoughts of other men. --Cowper.
     [1913 Webster]

From WordNet (r) 3.0 (2006) [wn]:

  replete
      adj 1: filled to satisfaction with food or drink; "a full
             stomach" [syn: {full}, {replete(p)}]
      2: (followed by `with')deeply filled or permeated; "imbued with
         the spirit of the Reformation"; "words instinct with love";
         "it is replete with misery" [syn: {instinct(p)},
         {replete(p)}]
      v 1: fill to satisfaction; "I am sated" [syn: {satiate}, {sate},
           {replete}, {fill}]

From Moby Thesaurus II by Grady Ward, 1.0 [moby-thesaurus]:

  115 Moby Thesaurus words for "replete":
     SRO, abounding, abundant, affluent, all-sufficing, allayed, ample,
     aplenty, awash, bottomless, bounteous, bountiful, brimful,
     brimming, bulging, bursting, capacity, chock-full, chuck-full,
     cloyed, congested, copious, cram-full, crammed, crowded, diffuse,
     disgusted, effuse, engorged, epidemic, exhaustless, extravagant,
     exuberant, farci, fat, fed-up, fertile, filled, flush, full,
     full of, full to bursting, galore, generous, glutted, gorged,
     in plenty, in quantity, inexhaustible, jaded, jam-packed, jammed,
     lavish, liberal, loaded, luxuriant, many, maximal, much, numerous,
     opulent, overfed, overflowing, overfull, overgorged, oversaturated,
     overstuffed, packed, packed like sardines, plenary, plenitudinous,
     plenteous, plentiful, plenty, prevailing, prevalent, prodigal,
     productive, profuse, profusive, rampant, ready to burst,
     replication, rich, rife, riotous, round, running over, sated,
     satiated, satisfied, saturated, sick of, slaked, soaked,
     standing room only, stuffed, superabundant, supersaturated,
     surfeited, swarming, swollen, teeming, thronged, tired of, topful,
     wealthy, well-found, well-furnished, well-provided, well-stocked,
     wholesale, with a bellyful, with a snootful, with enough of
  
In formal language theory, a grammar (when the context is not given,
often called a formal grammar for clarity) is a set of production
rules for strings in a formal language.

The rules describe how to form strings from the language's alphabet
that are valid according to the language's syntax.

A grammar does not describe the meaning of the strings or what can be
done with them in whatever context—only their form.

Formal language theory, the discipline which studies formal grammars
and languages, is a branch of applied mathematics.

**** automata theory is a recognizer theory				:rdf:

One of the interesting results of automata theory is that it is not
possible to design a recognizer for certain formal languages.

**** (N,E,P,S) (rewriting-system) (phrase-structure-grammar)		:rdf:
The operation of a grammar can be defined in terms of relations on strings:

    Given a grammar G = (N, \Sigma, P, S), the binary relation \Rightarrow_G (pronounced as "G derives in one step") on strings in (\Sigma \cup N)^{*} is defined by:

x \Rightarrow_G y \mbox{ iff } \exists u, v, p, q \in (\Sigma \cup N)^*: (x = upv) \wedge (p \rightarrow q \in P) \wedge (y = uqv)

    the relation {\Rightarrow_G}^* (pronounced as G derives in zero or more steps) is defined as the reflexive transitive closure of \Rightarrow_G
    a sentential form is a member of (\Sigma \cup N)^* that can be derived in a finite number of steps from the start symbol S; that is, a sentential form is a member of \{ w \in (\Sigma \cup N)^* \mid S {\Rightarrow_G}^* w \}. A sentential form that contains no nonterminal symbols (i.e. is a member of \Sigma^*) is called a sentence.[5]
    the language of G, denoted as \boldsymbol{L}(G), is defined as all those sentences that can be derived in a finite number of steps from the start symbol S; that is, the set \{ w \in \Sigma^* \mid S {\Rightarrow_G}^* w \}.

Note that the grammar G = (N, \Sigma, P, S) is effectively the
semi-Thue system (N \cup \Sigma, P), rewriting strings in exactly the
same way; the only difference is in that we distinguish specific
nonterminal symbols which must be rewritten in rewrite rules, and are
only interested in rewritings from the designated start symbol S to
strings without nonterminal symbols.

hough there is a tremendous body of literature on parsing algorithms,
most of these algorithms assume that the language to be parsed is
initially described by means of a generative formal grammar, and that
the goal is to transform this generative grammar into a working
parser. Strictly speaking, a generative grammar does not in any way
correspond to the algorithm used to parse a language, and various
algorithms have different restrictions on the form of production rules
that are considered well-formed.

a generative grammar refers to a particular approach to the study of
syntax.

A generative grammar of a language attempts to give a set of rules
that will correctly predict which combinations of words will form
grammatical sentences.

transformational grammar, and this term is still used as a general
term that includes his subsequent theories

Chomsky has argued that many of the properties of a generative grammar
arise from an "innate" universal grammar. 
Proponents of generative grammar have argued that most grammar is not
the result of communicative function and is not simply learned from
the environment (see the poverty of the stimulus argument). In this
respect, generative grammar takes a point of view different from
cognitive grammar, functional, and behaviorist theories

The rules of a generative grammar typically function as an algorithm
to predict grammaticality as a discrete (yes-or-no) result. In this
respect, it differs from stochastic grammar, which considers
grammaticality as a probabilistic variable.

some work in generative grammar (e.g. recent work by Joan Bresnan)
uses stochastic versions of optimality theory


An alternative model of syntax based on the idea that notions like
Subject, Direct Object, and Indirect Object play a primary role in
grammar.

Essentially, the tree model works something like this example, in which S is a sentence, D is a determiner, N a noun, V a verb, NP a noun phrase and VP a verb phrase:

Basic english syntax tree.svg

The resulting sentence could be The dog ate the bone. Such a tree diagram is also called a phrase marker. They can be represented more conveniently in text form, (though the result is less easy to read); in this format the above sentence would be rendered as:
[S [NP [D The ] [N dog ] ] [VP [V ate ] [NP [D the ] [N bone ] ] ] ]

When generative grammar was first proposed, it was widely hailed as a
way of formalizing the implicit set of rules a person "knows" when
they know their native language and produce grammatical utterances in
it (grammaticality intuitions). However Chomsky has repeatedly
rejected that interpretation; according to him, the grammar of a
language is a statement of what it is that a person has to know in
order to recognize an utterance as grammatical, but not a hypothesis
about the processes involved in either understanding or producing
language.

Generative grammar has been used to a limited extent in music theory
and analysis since the 1980s.[4][5] The most well-known approaches
were developed by Mark Steedman[6] as well as Fred Lerdahl and Ray
Jackendoff,[7] who formalised and extended ideas from Schenkerian
analysis.[8] More recently, such early generative approaches to music
were further developed and extended by several scholars

See also

    Formal grammar
    Phrase structure rules
    Cognitive linguistics
    Parsing
    Linguistic competence

a system which "makes infinite use of finite means"

**** sample grammar							:rdf:

/* Input Tokens. */
   <identifier>   => lookup();   // Lookup & store in symbol table.
   <integer>      => lookup();   // Lookup & store in symbol table. 
/* Operator precedence. */
   { '==' '!=' }  <<              // Lowest priority.    
   { '+'  '-'  }  <<         
   { '*'  '/'  }  <<              // Highest priority.
/* Productions. */
   Goal     -> Program... <eof>                        *> goal_()  emit ("\t\tSTART\n"     ,,"\t\tEOF\n")          
   Program  -> 'program' <identifier> '{' Stmt... '}'  *> program_(2) emit ("\t\tPROGRAM %s\n",,"\t\tEND PROGRAM %s\n")
   Stmt     -> Assignment
            -> IfThen
            -> IfElse
            -> IfThenElse
   Assignment  ~> Target '=' Exp ';'                   *> assign_()  emit (          ,,"\t\tSTORE\n")         
   IfThen      -> 'if' RelExp Then 'endif'             *> if_()      emit ("if&0:\n" ,,"endif&0:\n" )
   IfElse      -> 'if' RelExp Else 'endif'             *> if_()      emit ("if&0:\n" ,,"endif&0:\n" )
   IfThenElse  -> 'if' RelExp Then2 Else2 'endif'      *> if_()      emit ("if&0:\n" ,,"endif&0:\n" )              
   Target      -> <identifier>                         *> target_(1) emit (          ,,"\t\tLADR %s\n")
   RelExp   -> Exp '==' Exp                            *> eq_(2) emit (          ,,"\t\tEQ\n" ) 
            -> Exp '!=' Exp                            *> ne_(2) emit (          ,,"\t\tNE\n" ) 
   Exp      -> Primary    
            -> Exp '+' Exp                             *> add_(2) emit (          ,,"\t\tADD\n") 
            -> Exp '-' Exp                             *> sub_(2) emit (          ,,"\t\tSUB\n") 
            -> Exp '*' Exp                             *> mul_(2) emit (          ,,"\t\tMUL\n") 
            -> Exp '/' Exp                             *> div_(2) emit (          ,,"\t\tDIV\n") 
   Primary  -> <identifier>                            *> id_(1) emit (          ,,"\t\tLOAD %s\n")
            -> <integer>                               *> int_(1) emit (          ,,"\t\tLOAD %s\n")
            -> '(' Exp ')'  
   Then     -> 'then' Stmt...                          *> then_()  emit ("\t\tBR NZ endif&1\nthen&1:\n",,)
   Else     -> 'else' Stmt...                          *> else_()  emit ("\t\tBR Z endif&1\nelse&1:\n" ,,)
   Then2    -> 'then' Stmt...                          *> then_()  emit ("\t\tBR NZ else&1\nthen&1:\n" ,,)
   Else2    -> 'else' Stmt...                          *> else_()  emit ("\t\tBR endif&1\nelse&1:\n"   ,,)
/* End of Grammar. */

***** LRSTAR 
      An LR(1)/LR(k) parser generator that reads TBNF grammar
      notation.
***** DCG definite clause grammar
A definite clause grammar (DCG) is a way of expressing grammar, either
for natural or formal languages, in a logic programming language such
as Prolog. It is closely related to the concept of attribute grammars
/ affix grammars from which Prolog was originally developed

***** a set of definite clauses in first-order logic
***** a simple grammar
sentence --> noun_phrase, verb_phrase.
 noun_phrase --> det, noun.
 verb_phrase --> verb, noun_phrase.
 det --> [the].
 det --> [a].
 noun --> [cat].
 noun --> [bat].
 verb --> [eats].

This generates sentences such as "the cat eats the bat", "a bat eats
the cat". One can generate all of the valid expressions in the
language generated by this grammar at a Prolog interpreter by typing
sentence(X,[])
****** test valid sentence 
Similarly, one can test whether a sentence is valid in the language by
typing something like sentence([the,bat,eats,the,bat],[]).
DCG notation is just syntactic sugar for normal definite clauses in Prolog. For example, the previous example could be translated into the following:

 sentence(S1,S3) :- noun_phrase(S1,S2), verb_phrase(S2,S3).
 noun_phrase(S1,S3) :- det(S1,S2), noun(S2,S3).
 verb_phrase(S1,S3) :- verb(S1,S2), noun_phrase(S2,S3).
 det([the|X], X).
 det([a|X], X).
 noun([cat|X], X).
 noun([bat|X], X).
 verb([eats|X], X).
***** pure prolog
In pure Prolog, normal DCG rules with no extra arguments on the
functors, such as the previous example, can only express context-free
grammars; there is only one argument on the left side of the
production. However, context-sensitive grammars can also be expressed
with DCGs, by providing extra arguments, such as in the following
example:

 s --> a(N), b(N), c(N).
 a(0) --> [].
 a(M) --> [a], a(N), {M is N + 1}.
 b(0) --> [].
 b(M) --> [b], b(N), {M is N + 1}.
 c(0) --> [].
 c(M) --> [c], c(N), {M is N + 1}.
****** a set of DCG rules
This set of DCG rules describes the grammar which generates the
language that consists of strings of the form a^{n}b^{n}c^{n}.

 s --> symbols(Sem,a), symbols(Sem,b), symbols(Sem,c).
 symbols(end,_) --> [].
 symbols(s(Sem),S) --> [S], symbols(Sem,S).
****** another set of DCG rules
This set of DCG rules describes the grammar which generates the
language that consists of strings of the form a^{n}b^{n}c^{n}, by
structurally representing n[citation needed]
***** the main practical use of DCG
The main practical use of a DCG is to parse sentences of the given
grammar, i.e. to construct a parse tree. 
****** extra arguments
This can be done by providing "extra arguments" to the functors in the
DCG, like in the following rules:

 sentence(s(NP,VP)) --> noun_phrase(NP), verb_phrase(VP).
 noun_phrase(np(D,N)) --> det(D), noun(N).
 verb_phrase(vp(V,NP)) --> verb(V), noun_phrase(NP).
 det(d(the)) --> [the].
 det(d(a)) --> [a].
 noun(n(bat)) --> [bat].
 noun(n(cat)) --> [cat].
 verb(v(eats)) --> [eats].
****** query the interpreter
One can now query the interpreter to yield a parse tree of any given sentence:
 ?- sentence(Parse_tree, [the,bat,eats,a,cat], []).
 Parse_tree = s(np(d(the),n(bat)),vp(v(eats),np(d(a),n(cat)))) ? ;
****** DCTG definite clause translation grammars
Another extension, called definite clause translation grammars (DCTGs)
was described by in 1984. DCTG notation looks very similar to DCG
notation; the major difference is that one uses ::= instead of --> in
the rules. It was devised to handle grammatical attributes
conveniently. The translation of DCTGs into normal Prolog clauses
is like that of DCGs, but 3 arguments are added instead of 2.
**** pseudocode								:rdf:
Pseudocode is an informal high-level description of the operating
principle of a computer program or other algorithm.
***** specific algorithms and translations
A programmer who needs to implement a specific algorithm, especially
an unfamiliar one, will often start with a pseudocode description, and
then "translate" that description into the target programming language
and modify it to interact correctly with the rest of the
program. Programmers may also start a project by sketching out the
code in pseudocode on paper before writing it in its actual language,
as a top-down structuring approach, with a stepwise refinement.
***** codeblocks
Function calls and blocks of code, such as code contained within a
loop, are often replaced by a one-line natural language sentence.
***** numerical computation
In numerical computation, pseudocode often consists of mathematical
notation, typically from set and matrix theory, mixed with the control
structures of a conventional programming language, and perhaps also
natural language descriptions
**** metalanguage					       :metalanguage:
Broadly, any metalanguage is language or symbols used when language
itself is being discussed or examined. 
***** logic and linguistics
In logic and linguistics, a metalanguage is a language used to make
statements about statements in another language (the object
language). Expressions in a metalanguage are often distinguished from
those in an object language by the use of italics, quotation marks, or
writing on a separate line.
***** embedded, ordered and nested 
There is a variety of recognized metalanguages, including embedded,
ordered, and nested (or, hierarchical).
***** noun, verb and word are examples of metalanguage
words such as noun, verb, or even word describe features and concepts
pertaining to the English language itself
***** ordered metalanguage
An ordered metalanguage is analogous to ordered logic. An example of
an ordered metalanguage is the construction of one metalanguage to
discuss an object language, followed by the creation of another
metalanguage to discuss the first, etc.
***** nested metalanguage
A nested (or, hierarchical) metalanguage is similar to an ordered
metalanguage in that each level represents a greater degree of
abstraction. However, a nested metalanguage differs from an ordered
one in that each level includes the one below. The paradigmatic
example of a nested metalanguage comes from the Linnean taxonomic
system in biology. Each level in the system incorporates the one below
it. The language used to discuss genus is also used to discuss
species; the one used to discuss orders is also used to discuss
genera, etc., up to kingdoms.
***** metatheory
A metatheory is a theory whose subject matter is some other theory (a
theory about a theory). Statements made in the metatheory about the
theory are called metatheorems. A metatheorem is a true statement
about a formal system expressed in a metalanguage. Unlike theorems
proved within a given formal system, a metatheorem is proved within a
metatheory, and may reference concepts that are present in the
metatheory but not the object theory. 
**** EBNF for Lisp					     :rdf:lisp:debug:
     s_expression ::= atomic_symbol | "(" s_expression "." s_expression ")" 
                                       list                                  
             list ::= "(" s_expression* ")"
    atomic_symbol ::= letter atom_part
       	atom_part ::= empty | letter atom_part
                              number atom_part
           letter ::= "a" | "b" | " ..." | "z"
           number ::= "1" | "2" | " ..." | "9" 
**** languages form the terrain of computing		     :rdf:lisp:debug:
    Programming languages, protocol specifications, query languages, file
    formats, pattern languages, memory layouts, formal languages, config
    files, mark-up languages, formatting languages and meta-languages
    shape the way we compute.
***** AT: So, what shapes languages?
***** RR: Grammars do. 
**** perl::rdf stuff
**** TODO sort
      sort sawfish quicksort swordfish syntax 
      sort not
      (don't sort)
      (sort senses of 'not')
      (sort meanings of 'not', by syntax)
**** develop a parser/sorter (for rewards) 
       	for meanings of the term 'not'
       	according to  
       	(*grammatical-rules*) (*syntax*)
**** unicity distance							:rdf:
***** Based on the redundancy of plaintext.
      Attempts to give a minimum amount of ciphertext necessary to
      ensure decipherability.

**** aptitude search parser - installed
i A libxrd-parser-perl              - parse XRD and host-meta files into RDF::Tr
i A libhtml-html5-parser-perl       - parse HTML reliably 
i A librdf-rdfa-parser-perl         - flexible RDFa parser       
i A libxml-parser-perl              - Perl module for parsing XML files  

some sample 


* "Languages and Machines"
** intro
*** Church-Turing thesis
*** Turing machines
*** analysis of effective computation

**** deterministic finite automata
     
     src blocks are an easy derivation of this

***** properties
      read-once
      state and input symbol determine instruction to execute

***** application examples
      switching circuits
      lexical analysis of programming languages

** language definition and effective computation 
   "Language definition and computibility are not two unrelated topics
   that fall under the broad heading of computer science theory, but
   rather are inextricably intertwined. the computations of a machine
   can be used to recognize a language; an input string is accepted by
   the machine if the computation initiated with the string indicates
   it's syntactic correctness. Thus each machine has an associated
   language, the set of strings accepted by the machine. The
   computational capabilities of each family of abstract machines is
   characterized by the languages accepted by the machines in the
   family. With this in mind, we begin our investigations into the
   related topics of language definition and effective computation."
   -- T. Sudkamp, "Languages and Machines"   

** foundations
*** intro
**** theoretical computer science
     explores 
     the capabilities and limitations 
     of algorithmic problem solving

**** formal language theory
     provides the foundation 
     for the definition 
     of programming languages
     and compiler design
     
***** roots
      linguistics
      mathematical logic
      computer science

**** abstract machines
     are built to recognize
     the syntactic properties
     of languages
     and to compute functions

**** the relationship between 
     the grammatical generation of languages 
     and the recognition of languages
     by automata
     is a central theme
     of "Languages and Machines"

***** grammars were developed
      to provide a mechanism
      for describing
      natural (spoken and written) languages
      and have become the primary tool
      for the formal specification
      of programming languages

**** set-theoretic definition of language
     sufficiently broad to include
     both natural and formal languages
     but generality is gained
     at the expense
     of not providing a technique
     for mechanically generating
     the strings of the language

***** to overcome this shortcoming
      recursive definitions
      and set operations
      are used to give 
      finite specifications
      of languages

**** development of the regular sets
     a family of languages
     that arises 
     in automata theory
     formal language theory
     switching circuits
     and neural networks
     
*** mathematical preliminaries
**** set-theory
**** cartesian product, relations and functions
**** equivalence relations
**** countable and uncountable sets
**** recursive definitions
**** mathematical induction
     
     Establishing the relationships between the elements of sets and
     operations on the sets requires the capability of constructing
     proofs to verify the hypothesized properties.
     
     It is impossible to prove that a property holds for every member
     in an infinite set by considering each element individually. 

     The principle of mathematical induction gives sufficient
     conditions for proving that a property holds for every element in
     a recursively defined set. 

     Induction uses the family of nested sets generated by the
     recursive process to extend a property from the basis to the
     entire set.

***** principle of mathematical induction

      Let x be a set defined by recursion from the basis
      X(subscript 0) and let X(subscript 0...i,...) be the sequence of
      sets generated by the recursive process.

      Also let P be a property defined on the elements of X.

      If it can be shown that
      
      i) P holds for each element in X(subscript 0),
      
      ii) whenever P holds for every element in the sets X(subscript
      0...i,...), P also holds for every element in X(subscript (i +
      1)),

      then, by the principle of mathematical induction, P holds for
      every element in X.

      The soundness of the principle of mathematical induction can be
      intuitively exhibited using the sequence of sets constructed by
      a recursive definition. 

      Shading the circle X(subscript i) indicates that P holds for
      every element of X(subscript i).

      The first condition requires that the interior set be
      shaded. 

      Condition (ii) states that the shading can be extended from any
      circle to the next concentric circle. 

      (Fig. 1.3) illustrates how this process eventually shades the
      entire set X.

      Figure 1.3 Principle of mathematical induction.

      The justification for the principle of mathematical induction
      should be clear from the preceeding argument. 

      Another justification can be obtained by assuming that
      conditions (i) and (ii) are satisfied but P is not true for
      every element in X.

      If P does not hold for all elements of X, then there is at least
      one set X(subscript i) for which P does not universally hold.

      Let X(subscript j) be the first such set.

      Since condition (i) asserts that P holds for all elements of
      X(subscript 0), j cannot be zero.

      Now P holds for all elements of X(subscript j-1) by our choice
      of j.

      Condition (ii) then requires that P hold for all elements in
      X(subscript j).

      This implies that there is no first set in the sequence for
      which the property P fails.

      Consequently, P must be true for all the X(subscript i)'s, and
      therefore for X.

      An inductive proof consists of three distinct steps. 

      The first step is proving that the property P holds for each
      element of a basis set. 

      This corresponds to establishing condition (i) in the definition
      of the principle of mathematical induction. 

      The second step is the statement of the inductive
      hypothesis. 

      The inductive hypothesis is the assumption that the property P
      holds for every element in the sets X(subscript 0...n). 

      The inductive step then proves, using the inductive hypothesis,
      that P can be extended to each element in X(subscript (n +
      1)). 

      Completing the inductive stepsatisfies the requirement of the
      principle of mathematical induction. 

      Thus, it can be concluded that P is true for all elements of X.

**** directed graphs
*** languages
**** strings and languages
**** finite specification of languages
**** regular set and expressions
** context-free grammars and parsing
*** context-free grammars
**** context-free grammars and languages
**** examples of grammars and languages
**** regular grammars
**** grammars and languages revisited
**** a context-free grammar for pascl
**** arithmetic expressions
*** parsing: an introduction
**** leftmost derivations and ambiguity
**** the graph of a grammar
**** a breadth-first top-down parser
**** a depth-first top-down parser
**** bottom-up parsing
**** a depth-first bottom-up parser
*** normal forms
**** elimination of lambda rules
**** elimination of chain rules
**** useless symbols
**** Chomsky normal form
**** removal of direct left recursion
**** Greibach normal form
** automata and languages
*** finite automata
**** a finite state machine
**** deterministic finite automata
**** state diagrams and examples
**** nondeterministic finite automata
**** lambda transitions
**** removing nondeterminism
**** dfa minimization
*** regular languages and sets
**** finite automata and regular sets
**** expression graphs
**** regular grammars and finite automata
**** closure properties of regular languages
**** a nonregular language
**** the pumping lemma for regular languages
**** the Myhill-Nerode Theorem
*** pushdown automata and context-free languages
**** pushdown automata
**** variations on the pda theme
**** pushdown automata and context-free languages
**** the pumping lemma for context-free languages
**** closure properties of context-free languages
**** a two-stack automaton
*** Turing machines
**** the standard Turing machine
**** Turing machines as language acceptors
**** alternative acceptance criteria
**** multitrack machines
**** two-way tape machines
**** multitape machines
**** nondeterministic Turing machines
**** Turing machines as language enumerators
*** the Chomsky hierarchy
**** unrestricted grammars
**** context-sensitive grammars
**** linear-bounded automata
**** the Chomsky hierarchy
** decidability and computability
*** decidability
**** decision problems
**** the Church-Turing thesis
**** the halting problem for Turing machines
**** a universal machine
**** reducibility
**** Rice's theorem
**** an unsolvable word problem
**** the post correspondence problem
**** undecidable problems in context-free grammars
*** numeric computation
**** computation of functions
**** numeric computation
**** sequential operation of Turing machines
**** composition of functions
**** toward a programming language
*** mu-recursive functions
**** primitive recursive functions
**** some primitive recursive functions
**** bounded operators
**** division functions
**** Godel numbering and course-of-value recursion
**** computable partial functions
**** Turing computability and mu-recursive functions
**** the Church-Turing thesis revisited
** computational complexity
*** time complexity of a Turing machine
**** linear speedup
**** rates of growth
**** complexity and Turing machine variations
**** properties of time complexity
**** nondeterministic complexity
**** space complexity
*** tractibility and NP-complete problems
**** tractible and intractible decision problems
**** the class NP
**** P = NP?
**** the satisfiability problem
**** additional NP-complete problems
**** derivative complexity classes
** deterministic parsing
*** LL(k) grammars
**** lookahead in context-free grammars
**** FIRST, FOLLOW and lookahead sets
**** strong LL(k) grammars
**** construction of FIRST(k) sets
**** construction of FOLLOW(k) sets
**** a strong LL(1) grammar
**** a strong LL(k) parser
**** LL(k) grammars
*** LR(k) grammars
**** LR(0) contexts
**** an LR(0) parser
**** the LR(0) machine
**** acceptance by the LR(0) machine
**** LR(1) grammars
** index of notation
** the greek alphabet
** Backus-Naur definition of pascal
** subject index
